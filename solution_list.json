[{"id":695,"unique_name":"missing-string","title":"缺少的字符串","description":"给出两个字符串，你需要找到缺少的字符串","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : a given string\n     * @param : another given string\n     * @return: An array of missing string\n     */\n    public List<String> missingString(String str1, String str2) {\n        // Write your code here\n        List<String> res = new ArrayList<>();\n        if (str1.length() > str2.length()) {\n            String temp = str1;\n            str1 = str2;\n            str2 = temp;\n        }\n        \n        String[] arr1 = str1.split(\" \");\n        String[] arr2 = str2.split(\" \");\n        Set<String> set = new HashSet<>();\n        \n        for (String str : arr1) {\n            set.add(str);\n        }\n        \n        for (String str : arr2) {\n            if (!set.contains(str)) {\n                res.add(str);\n            }\n        }\n        \n        return res;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: : a given string\n    @param: : another given string\n    @return: An array of missing string\n    \"\"\"\n\n    def missingString(self, str1, str2):\n        result = []\n        dict = set(str2.split())\n        \n        for word in str1.split():\n            if word not in dict:\n                result.append(word)\n                \n        return result"}]},{"id":703,"unique_name":"decode-string","title":"解码字符串","description":null,"solutions":[{"language":"python","code":"class Solution(object):\n    def stack_pop(self, stack):\n        tmp = \"\"\n        while stack:\n            if stack[-1].isdigit():\n                break\n            tmp = stack.pop() + tmp\n        return tmp\n        \n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        num = 0\n        stack = []\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append(str(num))\n                num = 0\n            elif c == \"]\": \n                tmp = self.stack_pop(stack)\n                times = int(stack.pop())\n                \n                string = \"\"\n                for i in xrange(times):\n                    string += tmp\n                stack.append(string)\n            else:\n                stack.append(c)\n        \n        return self.stack_pop(stack)"}]},{"id":767,"unique_name":"partition-labels","title":"字符串分割","description":null,"solutions":[{"language":"java","code":"class Solution {\n    public List<Integer> partitionLabels(String S) {\n        int[] last = new int[26];\n        for (int i = 0; i < S.length(); ++i)\n            last[S.charAt(i) - 'a'] = i;\n        \n        int right = 0, left = 0;\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < S.length(); ++i) {\n            right = Math.max(right, last[S.charAt(i) - 'a']);\n            if (i == right) {\n                ans.add(i - left + 1);\n                left = i + 1;\n            }\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    vector<int> partitionLabels(string S) {\n        int last[26];\n        for (int i = 0; i < S.length(); ++i)\n            last[S[i] - 'a'] = i;\n        \n        int right = 0, left = 0;\n        vector<int> ans;\n        for (int i = 0; i < S.length(); ++i) {\n            right = max(right, last[S[i] - 'a']);\n            if(i == right) {\n                ans.push_back(i - left + 1);\n                left = i + 1;\n            }\n        }\n        return ans;\n    }\n};"},{"language":"python","code":"class Solution(object):\n    def partitionLabels(self, S):\n        last = {c: i for i, c in enumerate(S)}\n        right = left = 0\n        ans = []\n        for i, c in enumerate(S):\n            right = max(right, last[c])\n            if i == right:\n                ans.append(i - left + 1)\n                left = i + 1\n            \n        return ans"}]},{"id":762,"unique_name":"john-s-backyard-garden","title":"约翰的后花园","description":"约翰想在他家后面的空地上建一个后花园，现在有两种砖，一种`3` dm的高度，`7` dm的高度。约翰想围成`x` dm的墙。如果约翰能做到，输出YES，否则输出NO。","solutions":[{"language":"java","code":"public class Solution {\n\tpublic String isBuild(int x) {\n\t\tint [] dp = new int[10001];\n\t\tfor(int i = 0; i <= 1000; i++) {\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tdp[0] = 1;\n\t\tfor(int i = 3; i <= x; i++) {\n\t\t\tif(dp[i - 3] == 1) {\n\t\t\t\tdp[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 7; i <= x; i++) {\n\t\t\tif(dp[i - 7] == 1) {\n\t\t\t\tdp[i] = 1;\n\t\t\t}\n\t\t}\n\t\treturn dp[x] == 1 ? \"YES\" : \"NO\";\n\t}\n}"},{"language":"cpp","code":"class Solution {\npublic:\n\tstring isBuild(int x) {\n\t\tint dp[1001];\n\t\tfor(int i = 0; i <= 1000; i++) {\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tdp[0] = 1;\n\t\tfor(int i = 3; i <= x; i++) {\n\t\t\tif(dp[i - 3]) {\n\t\t\t\tdp[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 7; i <= x; i++) {\n\t\t\tif(dp[i - 7]) {\n\t\t\t\tdp[i] = 1;\n\t\t\t}\n\t\t}\n\t\treturn dp[x] ? \"YES\" : \"NO\";\n\t}\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param x: the wall's height\n    @return: YES or NO\n    \"\"\"\n    def isBuild(self,x):\n        dp = [0 for i in range(1001)]\n        for i in range(0,1001):\n            dp[i] = 0\n        dp[0] = 1\n        for i in range(3, x + 1):\n            if dp[i - 3] == 1:\n                dp[i] = 1\n        for i in range(7, x + 1):\n            if dp[i - 7] == 1:\n                dp[i] = 1\n        if dp [x] == 1:\n            return \"YES\"\n        else:\n            return \"NO\""}]},{"id":776,"unique_name":"implement-stack-using-queues","title":"用队列实现栈","description":null,"solutions":[{"language":"cpp","code":"class MyStack {\n    \nprivate:\n    queue<int> q;\n    \npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        queue<int> tempQ;\n        while(!q.empty()) {               //注意：如果某个队列或者容器循环只涉及入或者出，而非出入均衡，那么就不要使用for循环\n            tempQ.push(q.front());\n            q.pop();\n        }\n        q.push(x);\n        while(!tempQ.empty()) {\n            q.push(tempQ.front());\n            tempQ.pop();\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int topElment = q.front();\n        q.pop();\n        return topElment;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return q.front();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q.empty();\n    }\n};"}]},{"id":732,"unique_name":"count-different-palindromic-subsequences","title":"计数回文子序列","description":"给出一个字符串 `S`, 计算字符串 S 中不同非空回文子序列的数量, 返回这个数对 `10^9 + 7` 取模后得结果.\n字符串 S 的子序列可以通过删去 `S` 中 `0` 个或多个字符得到. 一个序列如果是回文的, 那么它逆序后与原序列相等.\n两个序列 `A[1]`, `A[2]`, ...  `B[1]`, `B[2]`, ... 如果存在 `A[i]` != `B[i]`, 那么这两个序列是不同的.","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param str: a string S\n     * @return: the number of different non-empty palindromic subsequences in S\n     */\n    public int countPalindSubseq(String str) {\n        if(str == null || str.isEmpty()) return 0;\n        int n = str.length();\n        int[][] dp = new int[n][n];\n        for(int len=1;len<=n;len++){\n            for(int i=0;i+len-1 < n;i++){\n                int j = i+len-1;\n                if(i == j){\n                    dp[i][j] = 1;\n                }\n                else if(str.charAt(i)!=str.charAt(j)){\n                    dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1];\n                }\n                else{\n                    int left = i+1;\n                    int right = j-1;\n                    while(left <= right && str.charAt(left) != str.charAt(i)) left++;\n                    while(left <= right && str.charAt(right) != str.charAt(i)) right--;\n                    if(left == right){\n                        dp[i][j] = dp[i+1][j-1]*2 + 1;\n                    }\n                    else if(left > right){\n                        dp[i][j] = dp[i+1][j-1]*2 + 2;\n                    }\n                    else{\n                        dp[i][j] = dp[i+1][j-1]*2 - dp[left+1][right-1];\n                    }\n                }\n                if(dp[i][j] < 0){\n                    //overflow\n                    dp[i][j] += 1000000007;\n                }else{\n                    dp[i][j] %= 1000000007;\n                }\n            }\n        }\n        return dp[0][n-1];\n    }\n}"}]},{"id":712,"unique_name":"friend-circles","title":"朋友圈","description":null,"solutions":[{"language":"python","code":"class UnionFind:\n    def __init__(self, n):\n        self.father = {}\n\n        for i in xrange(n):\n            self.father[i] = i\n\n    def compressed_find(self, x):\n        ancestor = self.father[x]\n\n        while ancestor != self.father[ancestor]:\n            ancestor = self.father[ancestor]\n\n        while x != self.father[x]:\n            next = self.father[x]\n            self.father[x] = ancestor\n            x = next\n\n        return ancestor\n\n    def union(self, x, y):\n        fa_x = self.compressed_find(x)\n        fa_y = self.compressed_find(y)\n\n        if fa_x != fa_y:\n            self.father[fa_y] = fa_x\n\nclass Solution(object):\n    def findCircleNum(self, M):\n        \"\"\"\n        :type M: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not M or not M[0]:\n            return 0\n\n        n = len(M)\n\n        uf = UnionFind(n)\n\n        for i in xrange(n):\n            for j in xrange(n):\n                if M[i][j] == 1:\n                    uf.union(i, j)\n\n        res = set()\n        for i in xrange(n):\n            for j in xrange(n):\n                if M[i][j] == 1:\n                    uf.compressed_find(j)\n                    res.add(uf.father[j])\n        return len(res)"}]},{"id":713,"unique_name":"max-area-of-island","title":"岛的最大面积","description":null,"solutions":[{"language":"python","code":"class Solution(object):\n    def maxAreaOfIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n, m = len(grid), len(grid[0])\n        \n        mx = 0\n        for i in xrange(n):\n            for j in xrange(m):\n                if grid[i][j]:\n                    mx = max(mx, self.dfs(grid, i, j))\n        return mx\n        \n    def dfs(self, grid, i, j):\n        n, m = len(grid), len(grid[0])\n        \n        if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 0:\n            return 0\n        \n        grid[i][j] = 0\n        return 1 + self.dfs(grid, i - 1, j) + self.dfs(grid, i + 1, j) + self.dfs(grid, i, j - 1) + self.dfs(grid, i, j + 1)"}]},{"id":785,"unique_name":"maximum-association-set","title":"最大关联集合","description":"亚麻卖书，每本书都有与其关联性很强的书，给出ListA与ListB，表示`ListA[i]`与`ListB[i]`有关联，输出互相关联的最大集合。(输出任意顺序)，题目保证只有一个最大的集合。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param ListA: The relation between ListB's books\n     * @param ListB: The relation between ListA's books\n     * @return: The answer\n     */\n    int find(int x, int[] f) {\n        if (x != f[x]) {\n            f[x] = find(f[x], f);\n        }\n        return f[x];\n    }\n    public List<String> maximumAssociationSet(String[] ListA, String[] ListB) {\n        // Write your code here\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\n        HashMap<Integer, String> name = new HashMap<Integer, String>();\n        int n = 0;\n        for (int i = 0; i < ListA.length; i++) {\n            if (!hashMap.containsKey(ListA[i])) {\n                hashMap.put(ListA[i], n);\n                name.put(n, ListA[i]);\n                n++;\n            }\n            if (!hashMap.containsKey(ListB[i])) {\n                hashMap.put(ListB[i], n);\n                name.put(n, ListB[i]);\n                n++;\n            }\n        }\n        int[] f = new int[n];\n        for (int i = 0; i < n; i++) {\n            f[i] = i;\n        }\n        for (int i = 0; i < ListA.length; i++) {\n            int fa = find(hashMap.get(ListA[i]), f);\n            int fb = find(hashMap.get(ListB[i]), f);\n            if (fa != fb) {\n                f[fa] = fb;\n            }\n        }\n        int[] sum = new int[n];\n        int v = 0, idx = 0;\n        for (int i = 0; i < n; i++) {\n            f[i] = find(i, f);\n            sum[f[i]]++;\n            if (sum[f[i]] > v) {\n                v = sum[f[i]];\n                idx = f[i];\n            }\n        }\n        List<String> res = new LinkedList<String>();\n        for (int i = 0; i < n; i++) {\n            if (f[i] == idx) {\n                res.add(name.get(i));\n            }\n        }\n        return res;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param ListA: The relation between ListB's books\n     * @param ListB: The relation between ListA's books\n     * @return: The answer\n     */\n    int father[5001];\n    \n    int find(int x) {\n        if (father[x] == x) {\n            return x;\n        }\n        return father[x] = find(father[x]);\n    }\n    \n    vector<string> maximumAssociationSet(vector<string> &ListA, vector<string> &ListB) {\n        // Write your code here\n        int count = 0;\n        vector<string> ans;\n        map<string, int> hash;\n        map<int, string> rehash;\n        for(string i: ListA) {\n            if(hash.find(i) == hash.end()) {\n                hash[i] = count;\n                rehash[count] = i;\n                count++;\n            }\n        }\n        \n        for(string i: ListB) {\n            if(hash.find(i) == hash.end()) {\n                hash[i] = count;\n                rehash[count] = i;\n                count++;\n            }\n        }\n        \n        for(int i = 0; i < count; i++) {\n            father[i] = i;\n        }\n        \n        for(int i = 0; i < ListA.size(); i++) {\n            int a = hash[ListA[i]];\n            int b = hash[ListB[i]];\n            int fa = find(a);\n            int fb = find(b);\n            if(fa != fb) {\n                father[fa] = fb;\n            }\n        }\n        \n        int sum[5001], Maxid = 0, value = 0;\n        for(int i = 0; i < count; i++) {\n            sum[i] = 0;\n        }\n       \n        for(int i = 0; i < count; i++) {\n            int fx = find(i);\n            sum[fx]++;\n            \n            if(sum[fx] > value) {\n                Maxid = fx;\n                value = sum[fx];\n            }\n        }\n        \n        for(int i = 0; i < count; i++) {\n            if(father[i] == Maxid) {\n                ans.push_back(rehash[i]);\n            }\n        }\n        return ans;\n    }\n};"},{"language":"python","code":"class Solution:\n    def maximumAssociationSet(self, ListA, ListB):\n        fa = range(0,5009)\n        cnt = [1] * 5009\n        strlist = [\"\"]\n        def gf(u):\n            if fa[u] != u:\n                fa[u] = gf(fa[u])\n            return fa[u]\n        dict = {}\n        tot = 0\n        for i in range(0,len(ListA)):\n            a, b = 0, 0\n            if ListA[i] not in dict:\n                tot += 1\n                dict[ListA[i]] = tot\n                strlist.append(ListA[i])\n            a = dict[ListA[i]]\n            if ListB[i] not in dict:\n                tot += 1\n                dict[ListB[i]] = tot\n                strlist.append(ListB[i])\n            b = dict[ListB[i]]\n            x, y = gf(a), gf(b)\n            if x != y:\n                fa[y] = x\n                cnt[x] += cnt[y]\n        ans = []\n        k, flag = 0, 0\n        for i in range (0,5000):\n            if k < cnt[gf(i)]:\n                k = cnt[gf(i)]\n                flag = gf(i)\n        for i in range(0,5000):\n            if gf(i) == flag:\n                ans.append(strlist[i])\n        return ans"}]},{"id":705,"unique_name":"longest-increasing-path-in-a-matrix","title":"矩阵中最长的递增路径","description":null,"solutions":[{"language":"python","code":"class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n        \n        res = 0\n        n, m = len(matrix), len(matrix[0])\n        \n        # dp[i][j]表示从(i, j)点出发获得的Longest Increasing Path\n        dp = [[0 for j in xrange(m)] for i in xrange(n)] \n        \n        for i in xrange(n):\n            for j in xrange(m):\n                res = max(res, self.dfs(matrix, Point(i, j), dp))\n        return res\n        \n    def dfs(self, matrix, point, dp):  \n        n, m = len(matrix), len(matrix[0])\n        \n        if dp[point.x][point.y] != 0:\n            return dp[point.x][point.y]\n        \n        for dx, dy in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n            x = point.x + dx\n            y = point.y + dy\n\n            if x < 0 or x >= n:\n                continue\n\n            if y < 0 or y >= m:\n                continue\n            \n            if matrix[x][y] <= matrix[point.x][point.y]:\n                continue\n                \n            # 从四周选一个最长的path\n            dp[point.x][point.y] = max(dp[point.x][point.y], self.dfs(matrix, Point(x, y), dp))\n            \n        dp[point.x][point.y] += 1  # 再加上当前点\n        \n        return dp[point.x][point.y]"}]},{"id":761,"unique_name":"rogue-knight-sven","title":"流浪剑客斯温","description":"在物质位面“现实”中，有`n+1`个星球，分别为星球0，星球1，……，星球n。\n\n每一个星球都有一个传送门，通过传送门可以直接到达目标星球而不经过其他的星球。\n\n不过传送门有两个缺点。\n\n第一，从星球i通过传送门只能到达编号比`i`大，且与`i`的差不超过`limit`的星球。\n\n第二，通过传送门到达星球`j`，需要`cost[j]`个金币。\n\n现在，流浪剑客斯温到达星球`0`后身上有`m`个金币，请问他有多少种方法通过传送门到达星球`n`？\n","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param n: the max identifier of planet.\n     * @param m: gold coins that Sven has.\n     * @param limit: the max difference.\n     * @param cost: the number of gold coins that reaching the planet j through the portal costs.\n     * @return: return the number of ways he can reach the planet n through the portal.\n     */\n    public long getNumberOfWays(int n, int m, int limit, int[] cost) {\n        // \n        long[][] dp = new long[n + 1][m + 1];\n        for (int i = 0; i < m; i++) {\n            dp[0][i] = 0;\n        }\n        dp[0][m] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                dp[i][j] = 0;\n                for (int t = Math.max(0, i - limit); t <= i - 1; t++) {\n                    if (j + cost[i] <= m) {\n                        dp[i][j] += dp[t][j + cost[i]];\n                    }\n                }\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i <= m; i++) {\n            ans += dp[n][i];\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n: the max identifier of planet.\n     * @param m: gold coins that Sven has.\n     * @param limit: the max difference.\n     * @param cost: the number of gold coins that reaching the planet j through the portal costs.\n     * @return: return the number of ways he can reach the planet n through the portal.\n     */\n    long long getNumberOfWays(int n, int m, int limit, vector<int> &cost) {\n        // \n        long long dp[n + 1][m + 1];\n        for (int i = 0; i < m; i++) {\n            dp[0][i] = 0;\n        }\n        dp[0][m] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                dp[i][j] = 0;\n                for (int t = max(0, i - limit); t <= i - 1; t++) {\n                    if (j + cost[i] <= m) {\n                        dp[i][j] += dp[t][j + cost[i]];\n                    }\n                }\n            }\n        }\n        long long ans = 0;\n        for (int i = 0; i <= m; i++) {\n            ans += dp[n][i];\n        }\n        return ans;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param n: the max identifier of planet.\n    @param m: gold coins that Sven has.\n    @param limit: the max difference.\n    @param cost: the number of gold coins that reaching the planet j through the portal costs.\n    @return: return the number of ways he can reach the planet n through the portal.\n    \"\"\"\n    def getNumberOfWays(self, n, m, limit, cost):\n        # \n        dp = [[0 for i in range(m + 1)] for i in range(n + 1)]\n        dp[0][m] = 1\n        for i in range(n + 1):\n            for j in range(m + 1):\n                for t in range(max(0, i - limit), i):\n                    if j + cost[i] <= m:\n                        dp[i][j] += dp[t][j + cost[i]]\n        ans = 0;\n        for i in range(m + 1):\n            ans += dp[n][i]\n        return ans;"}]},{"id":768,"unique_name":"partition-to-k-equal-sum-subsets","title":"K个子集和相等","description":null,"solutions":[{"language":"java","code":"class Solution {\n    boolean search(int used, int todo, boolean[] visit, int[] nums, int target) {\n        if (todo == 0) {\n            return true;\n        }\n        \n        if (!visit[used]) {\n            visit[used] = true;\n            int remain = (todo - 1) % target + 1;\n            for (int i = 0; i < nums.length; i++) {\n                if ((((used >> i) & 1) == 0) && nums[i] <= remain) {\n                    if (search(used | (1<<i), todo - nums[i], visit, nums, target)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        int sum = Arrays.stream(nums).sum();\n        if (sum % k > 0) {\n            return false;\n        }\n        boolean[] visit = new boolean[1 << nums.length];\n        return search(0, sum, visit, nums, sum / k);\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    bool search(int used, int todo, vector<bool> & visit, vector<int>& nums, int target) {\n        if (!todo) {\n            return true;\n        }\n        \n        if (!visit[used]) {\n            visit[used] = true;\n            int remain = (todo - 1) % target + 1;\n            for(int i = 0; i < nums.size(); i++) {\n                if ((((used >> i) & 1) == 0) && nums[i] <= remain) {\n                    if (search(used | (1<<i), todo - nums[i], visit, nums, target)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int sum = 0;\n        for (auto num : nums) {\n            sum += num;\n        }\n        if (sum % k) {\n            return false;\n        }\n        vector<bool> visit(1 << nums.size(), false);\n        return search(0, sum, visit, nums, sum / k);\n    }\n};"},{"language":"python","code":"class Solution(object):\n    def canPartitionKSubsets(self, nums, k):\n        target, rem = divmod(sum(nums), k)\n        if rem: return False\n\n        def search(groups):\n            if not nums: return True\n            v = nums.pop()\n            for i, group in enumerate(groups):\n                if group + v <= target: # and (i == 0 or group != groups[i - 1]):\n                    groups[i] += v\n                    if search(groups): return True\n                    groups[i] -= v\n                if not group: break\n            nums.append(v)\n            return False\n\n        nums.sort()\n        if nums[-1] > target: return False\n        while nums and nums[-1] == target:\n            nums.pop()\n            k -= 1\n\n        return search([0] * k)"}]},{"id":784,"unique_name":"my-calendar-i","title":"日程表I","description":null,"solutions":[{"language":"java","code":"class MyCalendar {\n    TreeMap<Integer, Integer> calendar;\n\n    MyCalendar() {\n        calendar = new TreeMap();\n    }\n\n    public boolean book(int start, int end) {\n        Integer previous = calendar.floorKey(start), next = calendar.ceilingKey(start);\n        if ((previous == null || calendar.get(previous) <= start) && (next == null || end <= next)) {\n            calendar.put(start, end);\n            return true;\n        }\n        return false;\n    }\n}\n\n/**\n * Your MyCalendar object will be instantiated and called as such:\n * MyCalendar obj = new MyCalendar();\n * boolean param_1 = obj.book(start,end);\n */"},{"language":"cpp","code":"class Node {\npublic:\n    Node(int start, int end) {\n        this->start = start;\n        this->end = end;\n        this->left = this->right = NULL;\n    }\n    \n    bool insert(Node * node) {\n        if (node->start >= this->end) {\n            if (!this->right) {\n                this->right = node;\n                return true;\n            }\n            return this->right->insert(node);\n        } else if (node->end <= this->start) {\n            if (!this->left) {\n                this->left = node;\n                return true;\n            }\n            return this->left->insert(node);\n        } else {\n            return false;\n        }\n    }\n\nprivate:\n    int start, end;\n    Node * left, * right;\n};\n\nclass MyCalendar {\npublic:\n    MyCalendar() {\n        this->root = NULL;\n    }\n    \n    bool book(int start, int end) {\n        if (this->root) {\n            return this->root->insert(new Node(start, end));\n        } \n        this->root = new Node(start, end);\n        return true;\n    }\n\nprivate:\n    Node * root;\n};\n\n/**\n * Your MyCalendar object will be instantiated and called as such:\n * MyCalendar obj = new MyCalendar();\n * bool param_1 = obj.book(start,end);\n */"},{"language":"python","code":"class Node:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n        self.left = self.right = None\n\n    def insert(self, node):\n        if node.start >= self.end:\n            if not self.right:\n                self.right = node\n                return True\n            return self.right.insert(node)\n        elif node.end <= self.start:\n            if not self.left:\n                self.left = node\n                return True\n            return self.left.insert(node)\n        else:\n            return False\n\nclass MyCalendar(object):\n    def __init__(self):\n        self.root = None\n\n    def book(self, start, end):\n        if self.root is None:\n            self.root = Node(start, end)\n            return True\n        return self.root.insert(Node(start, end))\n\n\n# Your MyCalendar object will be instantiated and called as such:\n# obj = MyCalendar()\n# param_1 = obj.book(start,end)"}]},{"id":692,"unique_name":"first-unique-number-in-stream","title":"数据流中第一个唯一的数字","description":"给一个连续的数据流,写一个函数返回终止数字到达时的第一个唯一数字（包括终止数字）,如果在终止数字前无唯一数字或者找不到这个终止数字, 返回 `-1`.","solutions":[{"language":"java","code":"public int firstUniqueNumber(int[] nums, int number) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        Map<Integer, Boolean> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, !map.containsKey(num));\n            if (num == number) {\n                break;\n            }\n        }\n        if (!map.containsKey(number)) {\n            return -1;\n        }\n        for (int num : nums) {\n            if (num == number) {\n                break;\n            }\n            if (map.get(num)) {\n                return num;\n            }\n        }\n        return -1;\n    }"}]},{"id":769,"unique_name":"and-and-or","title":"与或和","description":"给 `n` 个非负整数，请你求出*最大或和*，*最小或和*，*最大与和*，*最小与和*这四个数之*和*。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param n: \n     * @param nums: \n     * @return: return the sum of maximum OR sum, minimum OR sum, maximum AND sum, minimum AND sum.\n     */\n    public long getSum(int n, int[] nums) {\n        // write your code here\n        int maxOrSum = nums[0], maxAndSum = nums[0];\n        int minOrSum = nums[0], minAndSum = nums[0];\n        for (int i = 1; i < n; i++) {\n            maxOrSum |= nums[i];\n            maxAndSum = Math.max(maxAndSum, nums[i]);\n            minOrSum = Math.min(minOrSum, nums[i]);\n            minAndSum &= nums[i];\n        }\n        return (long)maxOrSum + maxAndSum + minOrSum + minAndSum;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n: \n     * @param nums: \n     * @return: return the sum of maximum OR sum, minimum OR sum, maximum AND sum, minimum AND sum.\n     */\n    long long getSum(int n, vector<int> &nums) {\n        // \n        int maxOrSum = nums[0], maxAndSum = nums[0];\n        int minOrSum = nums[0], minAndSum = nums[0];\n        for (int i = 1; i < n; i++) {\n            maxOrSum |= nums[i];\n            maxAndSum = max(maxAndSum, nums[i]);\n            minOrSum = min(minOrSum, nums[i]);\n            minAndSum &= nums[i];\n        }\n        return (long long)maxOrSum + maxAndSum + minOrSum + minAndSum;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param n: \n    @param nums: \n    @return: return the sum of maximum OR sum, minimum OR sum, maximum AND sum, minimum AND sum.\n    \"\"\"\n    def getSum(self, n, nums):\n        # write your code here\n        maxOrSum = nums[0]\n        maxAndSum = nums[0]\n        minOrSum = nums[0]\n        minAndSum = nums[0]\n        for i in range(1, n):\n            maxOrSum |= nums[i]\n            maxAndSum = max(maxAndSum, nums[i])\n            minOrSum = min(minOrSum, nums[i])\n            minAndSum &= nums[i]\n        return maxOrSum + maxAndSum + minOrSum + minAndSum"}]},{"id":741,"unique_name":"course-schedule-iii","title":"课程表 III","description":"这里有 `n` 门不同的线上课程, 编号为 `1` 到 `n`. 每一节课都有持续时间(课程长度) `t` 和 在第 `d` 天关闭. 课程应连续持续 `t` 天，必须在第`d `天或之前完成, 你将从第一天开始.\n给出 `n` 门线上课程用 `pairs (t, d)` 来表示, 你的任务是找到可以上的最大数量的课程数.","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : duration and close day of each course\n     * @return: the maximal number of courses that can be taken\n     */\n    public int scheduleCourse(int[][] courses) {\n        // write your code here\n        if (courses == null || courses.length == 0) {\n            return 0;\n        }\n        Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a);\n        int time = 0;\n        for (int i = 0; i < courses.length; i++) {\n            if (time + courses[i][0] <= courses[i][1]) {\n                time += courses[i][0];\n                queue.offer(courses[i][0]);\n            }\n            else if (!queue.isEmpty() && courses[i][0] < queue.peek()) {\n                time += courses[i][0] - queue.poll();\n                queue.offer(courses[i][0]);\n            }\n        }\n        return queue.size();\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param : duration and close day of each course\n     * @return: the maximal number of courses that can be taken\n     */\n    int scheduleCourse(vector<vector<int>> &courses) {\n        // write your code here\n        sort(courses.begin(), courses.end(), \n            [](const vector<int> &a, const vector<int> &b) {\n               return a[1] < b[1]; \n            });\n    \tpriority_queue<int, vector<int>> queue;\n    \tint time = 0;\n    \tfor (int i = 0; i < courses.size(); i++) {\n    \t    if (time + courses[i][0] <= courses[i][1]) {\n    \t        time += courses[i][0];\n    \t        queue.push(courses[i][0]);\n    \t    }\n    \t    else if (!queue.empty() && courses[i][0] < queue.top()) {\n    \t        time += courses[i][0] - queue.top();\n    \t        queue.pop();\n    \t        queue.push(courses[i][0]);\n    \t    }\n    \t}\n    \treturn queue.size();\n    }\n};"},{"language":"python","code":"import heapq\n\nclass Solution:\n    \"\"\"\n    @param: : duration and close day of each course\n    @return: the maximal number of courses that can be taken\n    \"\"\"\n\n    def scheduleCourse(self, courses):\n        # write your code here\n        if courses == None or len(courses) == 0:\n            return 0\n        courses.sort(key = lambda x : x[1])\n        queue = []\n        time = 0\n        for i in xrange(len(courses)):\n            if time + courses[i][0] <= courses[i][1]:\n                time += courses[i][0]\n                heapq.heappush(queue, -courses[i][0])\n            elif queue and courses[i][0] < (-queue[0]):\n                time += courses[i][0] - (-queue[0])\n                heapq.heapreplace(queue, -courses[i][0])\n        return len(queue)"}]},{"id":709,"unique_name":"two-sum-bst-edtion","title":"两数之和 - BST版本","description":"给一棵二叉搜索树以及一个整数 `n`, 在树中找到和为 `n` 的两个数字","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : the root of tree\n     * @param : the target sum\n     * @return: two numbers from tree which sum is n\n     */\n    public int[] twoSum(TreeNode root, int n) {\n    \tif (root == null) return null;\n    \tint[] res = new int[2];\n    \tif (root.left == null && root.right == null) return res;\n        // left most node\n    \tTreeNode l = getMinimum(root);\n        // right most node\n    \tTreeNode r = getMaximum(root);\n    \tint sum = 0;\n    \twhile (l.val < r.val) {\n    \t\tsum = l.val + r.val;\n    \t\tif (sum < n) {\n    \t\t\tl = getSuccessor(root, l);\n    \t\t} else if (sum > n) {\n    \t\t\tr = getPredecessor(root, r);\n    \t\t} else {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \t\n    \tres[0] = l.val;\n    \tres[1] = r.val;\n    \treturn res;\n    }\n\n    private TreeNode getPredecessor(TreeNode root, TreeNode n) {\n    \tif (n == null) return null;\n    \tif (n.left != null) {\n    \t\treturn getMaximum(n.left);\n    \t}\n    \tif (root == n) {\n    \t\treturn null;\n    \t}\n    \tTreeNode p = null;\n    \tTreeNode cur = root;\n    \twhile (cur != null) {\n    \t\tif (cur.val > n.val) {\n    \t\t\tcur = cur.left;\n    \t\t} else if (cur.val < n.val) {\n    \t\t\tp = cur;\n    \t\t\tcur = cur.right;\n    \t\t} else {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \treturn p;\n    }\n\n    private TreeNode getSuccessor(TreeNode root, TreeNode n) {\n    \tif (n == null) return null;\n    \tif (n.right != null) {\n    \t\treturn getMinimum(n.right);\n    \t}\n    \tif (root == n) {\n    \t\treturn null;\n    \t}\n    \tTreeNode p = null;\n    \tTreeNode cur = root;\n    \twhile (cur != null) {\n    \t\tif (cur.val > n.val) {\n    \t\t\tp = cur;\n    \t\t\tcur = cur.left;\n    \t\t} else if (cur.val < n.val) {\n    \t\t\tcur = cur.right;\n    \t\t} else {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \treturn p;\n    }\n    \n    private TreeNode getMinimum(TreeNode root) {\n    \tTreeNode p = root;\n    \twhile (p.left != null) {\n    \t\tp = p.left;\n    \t}\n    \treturn p;\n    }\n\n    private TreeNode getMaximum(TreeNode root) {\n    \tTreeNode p = root;\n    \twhile (p.right != null) {\n    \t\tp = p.right;\n    \t}\n    \treturn p;\n    }\n}"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\n    \"\"\"\n    @param: : the root of tree\n    @param: : the target sum\n    @return: two numbers from tree which sum is n\n    \"\"\"\n\n    def twoSum(self, root, n):\n        if not root: return \n        traverse = [root]; visit = set()\n        for node in traverse:\n            if n - node.val in visit:\n                return [node.val, n - node.val]\n            visit.add(node.val)\n            if node.left: traverse.append(node.left)\n            if node.right: traverse.append(node.right)"}]},{"id":786,"unique_name":"buy-fruits","title":"买水果","description":"小明要帮公司买水果，给了一个codeList，里面装的是他买的水果，给了一个shoppingCart,里面装的是target水果，目标是检查codelist里的水果顺序是否和shoppingCart里的顺序匹配。注意的是只有codelist中的所有链表的item之后加起来小于等于shoppingcart里item之和才可能返回`1`，另外在codelist中有可能出现item时\"anything\"，它可以和任意的水果匹配。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param codeList: The codeList\n     * @param shoppingCart: The shoppingCart\n     * @return: The answer\n     */\n    public int buyFruits(List<List<String>> codeList, List<String> shoppingCart) {\n        // Write your code here\n        List<String> list = new ArrayList<String>();\n        \n        for(List<String> i: codeList) {\n            for(String j: i) {\n                list.add(j);\n            }\n        }\n        if(list.size() > shoppingCart.size()) {\n            return 0;\n        }\n        for(int i = 0; i + list.size() <= shoppingCart.size(); i++) {\n            for(int j = 0; j < list.size(); j++) {\n                if(list.get(j).equals(\"anything\")) {\n                    if(j == list.size() - 1) {\n                        return 1;\n                    }\n                    continue;\n                }\n                if(!list.get(j).equals(shoppingCart.get(i + j))) {\n                    break;\n                }\n                if(j == list.size() - 1) {\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param codeList: The codeList\n     * @param shoppingCart: The shoppingCart\n     * @return: The answer\n     */\n    int buyFruits(vector<vector<string>> &codeList, vector<string> &shoppingCart) {\n        // Write your code here\n        vector<string>list;\n        for(vector<string> i: codeList) {\n            for(string j: i) {\n                list.push_back(j);\n            }\n        }\n        if(list.size() > shoppingCart.size()) {\n            return 0;\n        }\n        for(int i = 0; i + list.size() <= shoppingCart.size(); i++) {\n            for(int j = 0; j < list.size(); j++) {\n                if(list[j] == \"anything\") {\n                    if(j == list.size() - 1) {\n                        return 1;\n                    }\n                    continue;\n                }\n                if(list[j] != shoppingCart[i + j]) {\n                    break;\n                }\n                if(j == list.size() - 1) {\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param codeList: The codeList\n    @param shoppingCart: The shoppingCart\n    @return: The answer\n    \"\"\"\n    def buyFruits(self, codeList, shoppingCart):\n        # Write your code here\n        sumCodeList = 0\n        for itemList in codeList:\n            sumCodeList += len(itemList)\n        sumShoppingCart = len(shoppingCart)\n        if sumCodeList > sumShoppingCart:\n            return 0\n        for i in range(sumShoppingCart - sumCodeList + 1):\n            idx = 0\n            for itemList in codeList:\n                for j in itemList:\n                    if j == shoppingCart[i + idx] or j == 'anything':\n                        idx += 1\n                    else:\n                        idx = -1\n                        break\n                if idx == -1:\n                    break\n            if idx == sumCodeList:\n                return 1\n        return 0"}]},{"id":714,"unique_name":"01-matrix","title":"01矩阵","description":null,"solutions":[{"language":"python","code":"class Solution(object):\n    def updateMatrix(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return []\n        \n        n, m = len(matrix), len(matrix[0])\n        \n        queue = []\n        for i in xrange(n):\n            for j in xrange(m):\n                # 将所有的0当做起始点\n                if matrix[i][j] == 0:\n                    queue.append((i, j))\n                else:\n                    matrix[i][j] = n + m  # 曼哈顿距离在一个矩阵中的最大值（不严格，反正比最大值大就行）\n        \n        while queue:\n            point = queue.pop(0)\n            \n            for dx, dy in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                x = dx + point[0]\n                y = dy + point[1]\n                \n                if x < 0 or x >= n or y < 0 or y >= m:\n                    continue\n                \n                # 当前是洼地，四周比它高\n                if matrix[point[0]][point[1]] < matrix[x][y]:\n                    matrix[x][y] = matrix[point[0]][point[1]] + 1\n                    queue.append((x, y))\n        return matrix"}]},{"id":754,"unique_name":"number-of-corner-rectangles","title":"矩形个数","description":null,"solutions":[{"language":"java","code":"class Solution {\n    public int countCornerRectangles(int[][] grid) {\n        List<List<Integer>> rows = new ArrayList();\n        int N = 0;\n        for (int r = 0; r < grid.length; ++r) {\n            rows.add(new ArrayList());\n            for (int c = 0; c < grid[r].length; ++c)\n                if (grid[r][c] == 1) {\n                    rows.get(r).add(c);\n                    N++;\n                }\n        }\n\n        int sqrtN = (int) Math.sqrt(N);\n        int ans = 0;\n        Map<Integer, Integer> count = new HashMap();\n\n        for (int r = 0; r < grid.length; ++r) {\n            if (rows.get(r).size() >= sqrtN) {\n                Set<Integer> target = new HashSet(rows.get(r));\n\n                for (int r2 = 0; r2 < grid.length; ++r2) {\n                    if (r2 <= r && rows.get(r2).size() >= sqrtN)\n                        continue;\n                    int found = 0;\n                    for (int c2: rows.get(r2))\n                        if (target.contains(c2))\n                            found++;\n                    ans += found * (found - 1) / 2;\n                }\n            } else {\n                for (int i1 = 0; i1 < rows.get(r).size(); ++i1) {\n                    int c1 = rows.get(r).get(i1);\n                    for (int i2 = i1 + 1; i2 < rows.get(r).size(); ++i2) {\n                        int c2 = rows.get(r).get(i2);\n                        int ct = count.getOrDefault(200*c1 + c2, 0);\n                        ans += ct;\n                        count.put(200*c1 + c2, ct + 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    int countCornerRectangles(vector<vector<int>>& grid) {\n        vector<vector<int>> rows;\n        int N = 0;\n        for (int r = 0; r < grid.size(); ++r) {\n            rows.push_back(vector<int>());\n            for (int c = 0; c < grid[r].size(); ++c) \n                if (grid[r][c]) {\n                    rows[r].push_back(c);\n                    N++;\n                }\n        }\n        int sqrtN = (int) pow(N, 0.5);\n        int ans = 0;\n        unordered_map<int, int> count;\n        \n        for (int r = 0; r < grid.size(); ++r) {\n            if (rows[r].size() >= sqrtN) {\n                set<int> target(rows[r].begin(), rows[r].end());\n                \n                for (int r2 = 0; r2 < grid.size(); ++r2) {\n                    if (r2 <= r && rows[r2].size() >= sqrtN)\n                        continue;\n                    int found = 0;\n                    for (int c2: rows[r2])\n                        if (target.find(c2) != target.end())\n                            found++;\n                    ans += found * (found - 1) / 2;\n                }\n            } else {\n                for (int i1 = 0; i1 < rows[r].size(); ++i1) {\n                    int c1 = rows[r][i1];\n                    for (int i2 = i1 + 1; i2 < rows[r].size(); ++i2) {\n                        int c2 = rows[r][i2];\n                        int order = 200 * c1 + c2;\n                        if (count.find(order) == count.end()) {\n                            count[order] = 0;\n                        }\n                        ans += count[order]++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};"},{"language":"python","code":"class Solution(object):\n    def countCornerRectangles(self, grid):\n        rows = [[c for c, val in enumerate(row) if val]\n                for row in grid]\n        N = sum(sum(row) for row in grid)\n        SQRTN = int(N**.5)\n\n        ans = 0\n        count = collections.Counter()\n        for r, row in enumerate(rows):\n            if len(row) >= SQRTN:\n                target = set(row)\n                for r2, row2 in enumerate(rows):\n                    if r2 <= r and len(row2) >= SQRTN:\n                        continue\n                    found = sum(1 for c2 in row2 if c2 in target)\n                    ans += found * (found - 1) / 2\n            else:\n                for pair in itertools.combinations(row, 2):\n                    ans += count[pair]\n                    count[pair] += 1\n\n        return ans"}]},{"id":736,"unique_name":"replace-with-greatest-from-right","title":"替换为右侧最大值","description":"给一整数数组, 用当前元素之后数组中的最大元素来替换当前元素(右侧的最大元素). 因为最后一个元素的右边没有元素了, 所以用 `-1` 来替换这个值. 举个例子, 如果数组为 `[16,17,4,3,5,2]`, 那么它就需要修改为 `[17,5,5,5,2,-1]`.","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : An array of integers.\n     * @return: nothing\n     * O(n) time, O(1) space\n     */\n    public void arrayReplaceWithGreatestFromRight(int[] nums) {\n        // Write your code here.\n        int max = nums[nums.length - 1];\n        for(int i = nums.length - 2; i >= 0; i--){\n            int old = nums[i];\n            nums[i] = max;\n            max = Math.max(old,max);\n        }\n        nums[nums.length - 1] = -1;\n    }\n}"}]},{"id":777,"unique_name":"global-and-local-inversions","title":"全局和局部逆序","description":null,"solutions":[{"language":"java","code":"class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        for(int i = 2, max_value = 0; i < A.length; ++i) {\n            max_value = Math.max(max_value, A[i - 2]);\n            if(A[i] < max_value) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    bool isIdealPermutation(vector<int>& A) {\n        for (int i = 2, max_value = 0; i < A.size(); ++i) {\n            max_value = max(max_value, A[i - 2]);\n            if (max_value > A[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"},{"language":"python","code":"class Solution:\n    def isIdealPermutation(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        max_value = 0\n        for i in range(2, len(A)):\n            max_value = max(A[i - 2], max_value)\n            if max_value > A[i]:\n                return False\n        return True"}]},{"id":749,"unique_name":"cutting-a-rod","title":"杆子分割","description":"给一个 `n` 英寸长的杆子和一个包含所有小于 `n` 的尺寸的价格. 确定通过切割杆并销售碎片可获得的最大值.例如，如果棒的长度为8，并且不同长度部件的值如下，则最大可获得值为 `22`(通过切割两段长度 `2` 和 `6` )","solutions":[]},{"id":788,"unique_name":"palindrome-number-ii","title":"回文数 II","description":"判断一个非负整数 `n` 的二进制表示是否为回文数","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param n: non-negative integer n.\n     * @return: return whether a binary representation of a non-negative integer n is a palindrome.\n     */\n    public boolean isPalindrome(int n) {\n        // write code here.\n        int[] bin = new int[32];\n        int len = 0;\n        do {\n            bin[len++] = n & 1;\n            n >>= 1;\n        } while (n > 0);\n        for (int i = 0; i < len / 2; i++) {\n            if (bin[i] != bin[len - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n: non-negative integer n.\n     * @return: return whether a binary representation of a non-negative integer n is a palindrome.\n     */\n    bool isPalindrome(int n) {\n        // write code here.\n        int bin[32];\n        int len = 0;\n        do {\n            bin[len++] = n & 1;\n            n >>= 1;\n        } while (n > 0);\n        for (int i = 0; i < len / 2; i++) {\n            if (bin[i] != bin[len - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param n: non-negative integer n.\n    @return: return whether a binary representation of a non-negative integer n is a palindrome.\n    \"\"\"\n    def isPalindrome(self, n):\n        # write code here.\n        num = bin(n)[2:]\n        for i in range(len(num)):\n            if num[i] != num[-i - 1]:\n                return False\n        return True"}]},{"id":763,"unique_name":"john-s-business","title":"约翰的生意","description":"在一条数轴上，有n个城市，编号从`0 ~ n – 1` , 约翰打算在这n个城市做点生意，他对Armani的一批货物感兴趣，每个城市对于这批货物都有一个价格`prices[i]`。对于城市`x`,约翰可从城市编号为`[x - k, x + k]`购买货物，然后卖到城市x,问约翰在*每个*城市*最多*能赚到多少钱？","solutions":[{"language":"java","code":"public class Solution {\n\t\n\t\n\tpublic class SegmentTreeNode {\n        public int start, end;\n        public int min;\n        public SegmentTreeNode left, right;\n        public SegmentTreeNode(int start, int end, int min) {\n              this.start = start;\n              this.end = end;\n              this.min = min;\n              this.left = this.right = null;\n        }\n\t }\n\t\n\t public SegmentTreeNode build(int start, int end, int[] A) {\n\t\tif(start > end) {\n\t\t    return null;\n\t\t}\n\t\t//叶节点\n\t\tif(start == end) {\n\t\t    return new SegmentTreeNode(start, end, A[start]);\n\t\t}\n\t\t//递归构建子树\n\t\tint mid = (start + end) / 2;\n\t\tSegmentTreeNode root = new SegmentTreeNode(start, end, Integer.MAX_VALUE);\n\t\troot.left = build(start, mid, A);\n\t\troot.right = build(mid + 1, end, A);\n\t\t//更新该节点信息\n\t\tif(root.left != null) {\n\t\t    root.min = Math.min(root.min, root.left.min);\n\t\t}\n\t\tif(root.right != null) {\n\t\t\troot.min = Math.min(root.min, root.right.min);\n\t\t}\n\t\treturn root;\n\t }\n\t \n\t public int query(SegmentTreeNode root, int start, int end) {\n\t\tif(start <= root.start && root.end <= end) {\n\t\t    return root.min;\n\t\t}\n\t\tint mid = (root.start + root.end) / 2;\n\t\tint ans = Integer.MAX_VALUE;\n\t\t//包括左区间\n\t\tif(start <= mid) {\n\t\t\tans = Math.min(ans, query(root.left, start, end));\n\t\t}\n\t\t//包括右区间\n\t\tif(end > mid) {\n\t\t\tans = Math.min(ans, query(root.right, start, end));\n\t\t}\n\t\treturn ans;\n\t }\n\t \n\t public int [] business(int [] A, int k) {\n\t\t int [] ans = new int [A.length];\n\t\t \n\t\t SegmentTreeNode root = build(0, A.length - 1, A);\n\t\t for(int i = 0; i < A.length; i++) {\n\t\t\t\tint l = i - k;\n\t\t\t\tint r = i + k;\n\t\t\t\tif(l < 0) {\n\t\t\t\t\tl = 0;\n\t\t\t\t}\n\t\t\t\tif(r > A.length - 1) {\n\t\t\t\t\tr = A.length - 1;\n\t\t\t\t}\n\t\t\t\tint value = A[i] - query(root, l, r);\n\t\t\t\tans[i] = value;\n\t\t\t}\n\t\t \n\t\t return ans;\n\t }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n\n\tclass SegmentTreeNode {\n\tpublic:\n\t\tint start, end, min;\n\t\tSegmentTreeNode *left, *right;\n\t\tSegmentTreeNode(int start, int end, int min) {\n\t\t\tthis->start = start;\n\t\t\tthis->end = end;\n\t\t\tthis->min = min;\n\t\t\tthis->left = this->right = NULL;\n\t\t}\n\t};\n\t\n\tSegmentTreeNode *build(int start, int end, vector<int> &A) {\n\t\tif(start > end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif(start == end) {\n\t\t\treturn new SegmentTreeNode(start, end, A[start]);\n\t\t}\n\t\tint mid = (start + end) / 2;\n\t\tSegmentTreeNode *root = new SegmentTreeNode(start, end, INT_MAX);\n\t\tif(start <= mid) {\n\t\t\troot->left = build(start, mid, A);\n\t\t}\n\t\tif(end > mid) {\n\t\t\troot->right = build(mid + 1, end, A);\n\t\t}\n\t\tif(root->left != NULL) {\n\t\t\troot->min = min(root->min, root->left->min);\n\t\t}\n\t\tif(root->right != NULL) {\n\t\t\troot->min = min(root->min, root->right->min);\n\t\t}\n\t\treturn root;\n\t}\n\t\n\tint query(SegmentTreeNode *root, int start, int end) {\n\t\tif(start <= root->start && root->end <= end) {\n\t\t\treturn root->min;\n\t\t}\n\t\tint mid = (root->start + root->end) / 2;\n\t\tint ans = INT_MAX;\n\t\tif(start <= mid && root->left != NULL) {\n\t\t\tans = min(ans, query(root->left, start, end));\n\t\t}\n\t\tif(end > mid && root->right != NULL) {\n\t\t\tans = min(ans, query(root->right, start, end));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\tvector<int> business(vector<int> &A,int k) {\n\t\tSegmentTreeNode *root;\n\t\troot = build(0,A.size() - 1, A);\n\t\tvector<int> ans;\n\t\tfor(int i = 0; i < A.size(); i++) {\n\t\t\tint l = i - k;\n\t\t\tint r = i + k;\n\t\t\tif(l < 0) {\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t\tif(r > A.size() - 1) {\n\t\t\t\tr = A.size() - 1;\n\t\t\t}\n\t\t\tint value = A[i] - query(root, l, r);\n\t\t\tans.push_back(value);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n};"},{"language":"python","code":"class Solution:\n    \n    class SegmentTreeNode:\n        def __init__(self, start, end, min):\n            self.start, self.end, self.min = start, end, min\n            self.left, self.right = None, None\n    \n    def buildTree(self, start, end, A):\n        if start > end:\n            return None\n\n        node = self.SegmentTreeNode(start, end, A[start])\n        if start == end:\n            return node\n\n        mid = (start + end) / 2\n        node.left = self.buildTree(start, mid, A)\n        node.right = self.buildTree(mid + 1, end, A)\n        if node.left is not None and node.left.min < node.min:\n            node.min = node.left.min\n        if node.right is not None and node.right.min < node.min:\n            node.min = node.right.min\n        return node\n    \n    def query(self, root, start, end):\n        if root.start > end or root.end < start:\n            return 0xffffff\n    \n        if start <= root.start and root.end <= end:\n            return root.min\n        \n        ans = 0xffffff\n        \n        if root.left is not None:\n            ans = min(ans, self.query(root.left, start, end))\n        \n        if root.right is not None:\n            ans = min(ans, self.query(root.right, start, end))\n        \n        \n        return ans\n    \n  \n    \"\"\"\n    @param A: The prices [i]\n    @param k: \n    @return: The ans array\n    \"\"\"\n    def business(self, A, k):\n        root = self.buildTree(0, len(A)-1, A)\n        ans = []\n        for i in range(len(A)):\n            l = i - k\n            r = i + k\n            if l < 0:\n                l = 0\n            if r > len(A) - 1:\n                r = len(A) - 1\n            tmp = A[i] - self.query(root, l, r)\n            ans.append(tmp)\n        return ans"}]},{"id":746,"unique_name":"maximum-subarray-vi","title":"最大子数组VI","description":"给出一个整数数组，找出异或值最大的子数组。\n什么是异或:https://en.wikipedia.org/wiki/Exclusive_or","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : the array\n     * @return: the max xor sum of the subarray in a given array\n     */\n    class TrieNode{\n        public int label;\n        public TrieNode[] children;\n        TrieNode(int label){\n            this.label = label;\n            this.children = new TrieNode[2];\n        }\n    }\n    public int maxXorSubarray(int[] nums) {\n        if(nums == null || nums.length == 0) return 0;\n        int max = 0;\n        int pre_xor = 0;\n        TrieNode root = new TrieNode(0);\n        //根据j同学的提示，这里应该insert 0做初始化。\n        insert(root, 0);\n        for(int i=0;i<nums.length;i++){\n            pre_xor ^= nums[i];\n            insert(root, pre_xor);\n            max = Math.max(max, searchAndFindMax(root, pre_xor));\n        }\n        return max;\n    }\n    \n    private void insert(TrieNode root, int num){\n        TrieNode cur = root;\n        for(int i=31;i>=0;i--){\n            int bit = num >> i & 1;\n            if(cur.children[bit] == null){\n                cur.children[bit] = new TrieNode(bit);\n            }\n            cur = cur.children[bit];\n        }\n    }\n    \n    private int searchAndFindMax(TrieNode root, int num){\n        TrieNode cur = root;\n        int res = 0;\n        for(int i=31;i>=0;i--){\n            int bit = num >> i & 1;\n            if(cur.children[1-bit] != null){\n                res |= 1 << i;\n                cur = cur.children[1-bit];\n            }else{\n                cur = cur.children[bit];\n            }\n        }\n        return res;\n    }\n}"}]},{"id":753,"unique_name":"number-of-atoms","title":"原子计数","description":null,"solutions":[{"language":"java","code":"import java.util.regex.*;\n\nclass Solution {\n    public String countOfAtoms(String formula) {\n        Matcher matcher = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\").matcher(formula);\n        Stack<Map<String, Integer>> stack = new Stack();\n        // TreeMap内部实现红黑是，HashMap内部实现哈希表\n        stack.push(new TreeMap());\n\n        while (matcher.find()) {\n            String match = matcher.group();\n            if (match.equals(\"(\")) {\n                stack.push(new TreeMap());\n            } else if (match.startsWith(\")\")) {\n                Map<String, Integer> top = stack.pop();\n                int multiplicity = match.length() > 1 ? Integer.parseInt(match.substring(1, match.length())) : 1;\n                for (String name: top.keySet()) {\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * multiplicity);\n                }\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                int multiplicity = i < match.length() ? Integer.parseInt(match.substring(i, match.length())) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            final int count = stack.peek().get(name);\n            if (count > 1) ans.append(String.valueOf(count));\n        }\n        return ans.toString();\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    string countOfAtoms(string formula)\n    {\n        regex re = regex( \"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\" );\n        stack<map<string, int>>    stack;\n        map<string, int> init_map;\n        stack.push(init_map);\n        smatch matcher;\n        while (regex_search(formula, matcher, re)) {\n            string match = matcher.str();\n            if (match == \"(\") {\n                map<string, int> new_map;\n                stack.push(new_map);\n            } else if (match.at(0) == ')') {\n                map<string, int> top = stack.top();\n                stack.pop();\n                // 使用stringstream做类型转换\n                stringstream ss;\n                ss << match.substr(1, match.length());\n                int i;\n                ss >> i;\n                int multiplicity = match.length() > 1 ? i : 1;\n                for (map<string, int>::iterator it = top.begin(); it != top.end(); it++) {\n                    stack.top()[it->first] += top[it->first] * multiplicity;\n                }\n            } else  {\n                int i = 1;\n                while (i < match.length() && (match.at( i ) >= 'a' && match.at( i ) <= 'z')) {\n                    i++;\n                }\n                string name = match.substr(0, i);\n                stringstream ss;\n                ss << match.substr( i, match.length() );\n                int j;\n                ss >> j;\n                int multiplicity = i < match.length() ? j : 1;\n                stack.top()[name] += multiplicity;\n            }\n            formula = matcher.suffix().str();\n        }\n        map<string, int> top = stack.top();\n        map<string, int>::iterator    it;\n        string result = \"\";\n        for (it = top.begin(); it != top.end(); it++)\n        {\n            result += it->first;\n            if (it->second > 1)\n            {\n                stringstream ss;\n                ss << it->second;\n                result += ss.str();\n            }\n        }\n        return(result);\n    }\n};"},{"language":"python","code":"# python的这个版本体现了Counter和正则表达式的灵活特性，十分值得推荐\nclass Solution(object):\n    def countOfAtoms(self, formula):\n        parse = re.findall(r\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\", formula)\n        stack = [collections.Counter()]\n        for name, m1, left_open, right_open, m2 in parse:\n            if name:\n              stack[-1][name] += int(m1 or 1)\n            if left_open:\n              stack.append(collections.Counter())\n            if right_open:\n                top = stack.pop()\n                for k in top:\n                  stack[-1][k] += top[k] * int(m2 or 1)\n\n        return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                       for name in sorted(stack[-1]))"}]},{"id":747,"unique_name":"boolean-parenthesization","title":"布尔括号","description":"给一带有下列符号的布尔表达式.\n```\nSymbols\n    'T' ---> true \n    'F' ---> false \n```\n以及填充在两个符号间的运算符\n```\nOperators\n    &   ---> boolean AND (位与)\n    |   ---> boolean OR (位或)\n    ^   ---> boolean XOR (异或)\n```\n计算在表达式的基础上添加括号使式子为真的方法数.\n输入的形式为两个数组, 一个为按顺序给出的符号集(T 和 F), 另一个为运算符(&,|和^)","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param symb: the array of symbols\n     * @param oper: the array of operators\n     * @return: the number of ways\n     */\n    public int countParenth(char[] symb, char[] oper) {\n        if(symb == null || symb.length == 0 || oper == null || oper.length == 0) return 0;\n        int n = symb.length;\n        int[][] T = new int[n][n];\n        int[][] F = new int[n][n];\n        for(int i=0;i<n;i++){\n            if(symb[i] == 'T'){\n                T[i][i] = 1;\n            }else{\n                F[i][i] = 1;\n            }\n        }\n        \n        for(int j=0;j<n;j++){\n            for(int i=j-1;i>=0;i--){\n                T[i][j] = 0;\n                F[i][j] = 0;\n                for(int k=i;k<j;k++){\n                    switch(oper[k]) {\n                        case '&':\n                            T[i][j] += T[i][k]*T[k+1][j];\n                            F[i][j] += (T[i][k] + F[i][k]) * (T[k+1][j] + F[k+1][j]) - T[i][k] * T[k+1][j];\n                            break;\n                        case '|':\n                            T[i][j] += (T[i][k] + F[i][k]) * (T[k+1][j] + F[k+1][j]) - F[i][k] * F[k+1][j];\n                            F[i][j] += F[i][k]*F[k+1][j];\n                            break;\n                        case '^':\n                            T[i][j] += T[i][k]*F[k+1][j] + F[i][k]*T[k+1][j];\n                            F[i][j] += T[i][k]*T[k+1][j] + F[i][k]*F[k+1][j];\n                            break;\n                    }\n                }\n            }\n        }\n        return T[0][n-1];\n    }\n}"}]},{"id":755,"unique_name":"lc-763-partition-labels","title":"LC 763. 分区标签","description":null,"solutions":[{"language":"java","code":"class Solution {\n    /**\n     * @param S\n     * @return\n     */\n    public List<Integer> partitionLabels(String S) {\n        if (S == null) {\n            return new LinkedList<>();\n        }\n\n        // core logic\n        HashMap<Character, Pair> lookup = new HashMap<>();\n        for (int i = 0; i < S.length(); i++) {\n            if (lookup.containsKey(S.charAt(i))) {\n                lookup.get(S.charAt(i)).end = i;\n            } else {\n                lookup.put(S.charAt(i), new Pair(i, i));\n            }\n        }\n\n        LinkedList<Integer> ends = new LinkedList<>();\n        for (int i = 0; i < S.length(); ) {\n            int end = Math.max(i, lookup.get(S.charAt(i)).end);\n            while (i < end) {\n                i++;\n                end = Math.max(end, lookup.get(S.charAt(i)).end);\n            }\n            ends.add(end + 1);\n            i++;\n        }\n        LinkedList<Integer> results = new LinkedList<>();\n        results.add(ends.get(0));\n        for (int i = 1; i < ends.size(); i++) {\n            results.add(ends.get(i) - ends.get(i - 1));\n        }\n        return results;\n    }\n\n    private class Pair {\n        int start;\n        int end;\n\n        public Pair(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" +\n                    \"start=\" + start +\n                    \", end=\" + end +\n                    '}';\n        }\n    }\n}"}]},{"id":757,"unique_name":"lc-764-largest-plus-sign","title":"LC 764. 最大的加号","description":null,"solutions":[{"language":"java","code":"class Solution {\n    /**\n     * @param N\n     * @param mines\n     * @return\n     */\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        // filter abnormal cases\n        if (mines == null || mines.length == 0) {\n            return (N + 1) / 2;\n        }\n\n        // core logic\n        int m = mines.length;\n        int[][] matrix = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                matrix[i][j] = 1;\n            }\n        }\n        for (int[] mine : mines) {\n            matrix[mine[0]][mine[1]] = 0;\n        }\n\n        int[][] dpUp = new int[N][N];\n        int[][] dpDown = new int[N][N];\n        int[][] dpLeft = new int[N][N];\n        int[][] dpRight = new int[N][N];\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (matrix[i - 1][j] == 0) {\n                    dpUp[i][j] = 0;\n                } else {\n                    dpUp[i][j] = dpUp[i - 1][j] + 1;\n                }\n            }\n        }\n        for (int i = N - 2; i >= 0; i--) {\n            for (int j = 0; j < N; j++) {\n                if (matrix[i + 1][j] == 0) {\n                    dpDown[i][j] = 0;\n                } else {\n                    dpDown[i][j] = dpDown[i + 1][j] + 1;\n                }\n            }\n        }\n        //left\n        for (int j = 1; j < N; j++) {\n            for (int i = 0; i < N; i++) {\n                if (matrix[i][j - 1] == 0) {\n                    dpLeft[i][j] = 0;\n                } else {\n                    dpLeft[i][j] = dpLeft[i][j - 1] + 1;\n                }\n            }\n        }\n        //right\n        for (int j = N - 2; j >= 0; j--) {\n            for (int i = 0; i < N; i++) {\n                if (matrix[i][j + 1] == 0) {\n                    dpRight[i][j] = 0;\n                } else {\n                    dpRight[i][j] = dpRight[i][j + 1] + 1;\n                }\n            }\n        }\n        // Final Scan\n        int maxK = 0;\n        for (int i = 1; i < N - 1; i++) {\n            for (int j = 1; j < N - 1; j++) {\n                if (matrix[i][j] == 1) {\n                    maxK = Math.max(maxK, 1 + Math.min(Math.min(dpUp[i][j], dpDown[i][j]), Math.min(dpLeft[i][j], dpRight[i][j])));\n                }\n            }\n        }\n        if (maxK < 1) {\n            for (int i = 0; i < N; i++) {\n                if (matrix[i][0] == 1 || matrix[i][N - 1] == 1) {\n                    maxK = 1;\n                    return maxK;\n                }\n            }\n            for (int j = 1; j < N - 1; j++) {\n                if (matrix[0][j] == 1 || matrix[N - 1][j] == 1) {\n                    maxK = 1;\n                    return maxK;\n                }\n            }\n        }\n\n        // return the final result\n        return maxK;\n    }\n}"}]},{"id":718,"unique_name":"array-partition-i","title":"数组分割 I","description":null,"solutions":[{"language":"java","code":"class Solution {\n\tpublic int arrayPairSum(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < nums.length; i += 2) {\n\t\t\tres += nums[i];\n\t\t}\n\t\treturn res;\n\t}\n}"}]},{"id":756,"unique_name":"maximum-product-of-three-numbers","title":"三个数字乘积最大值","description":null,"solutions":[{"language":"python","code":"class Solution(object):\n    def maximumProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums or len(nums)==0:\n            return 0\n        nums.sort()\n        res1 = nums[-1]*nums[-2]*nums[-3]\n        res2 = nums[0]*nums[1]*nums[-1]\n        return max(res1, res2)"}]},{"id":740,"unique_name":"guess-number-higher-or-lower-ii","title":"猜数字大小II","description":null,"solutions":[{"language":"python","code":"import sys\n\n# version 1: bottom up\nclass Solution(object):\n    def getMoneyAmount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for j in xrange(n + 1)] for i in xrange(n + 1)]\n\n        # 如果只有一个数字，那么不用猜，cost为0\n        for i in xrange(n + 1):\n            dp[i][i] = 0\n\n        for i in xrange(n - 1, 0, -1):\n            for j in xrange(i + 1, n + 1):\n                min_cost = sys.maxint\n                for k in xrange(i, j):\n                    min_cost = min(min_cost, k + max(dp[i][k - 1], dp[k + 1][j]))\n                dp[i][j] = min_cost\n        return dp[1][n]\n    \n    \n# version 2 : top down + memoization\nclass Solution(object):\n    def getMoneyAmount(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0 for j in xrange(n)] for i in xrange(n)]\n        return self.getMinCost(0, n - 1, dp)\n    \n    def getMinCost(self, start, end, dp):\n        if start >= end:\n            return 0\n        \n        if dp[start][end] != 0:\n            return dp[start][end]\n        \n        min_cost = sys.maxint\n        for k in xrange(start, end + 1):\n            # 因为给定数字是 [1, n]，这里有一个 index off by one 的问题，因此k + 1\n            min_cost = min(min_cost, k + 1 + \n                                        max(self.getMinCost(start, k - 1, dp), self.getMinCost(k + 1, end, dp)))\n        dp[start][end] = min_cost\n        \n        return dp[start][end]"}]},{"id":690,"unique_name":"word-break-iii","title":"单词拆分 III","description":"给出一个单词表和一条去掉所有空格的句子，根据给出的单词表添加空格, 返回可以构成的句子的数量, 保证构成的句子中所有的单词都可以在单词表中找到.","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : A string\n     * @param : A set of word\n     * @return: the number of possible sentences.\n     */\n    private int ans = 0;\n    \n    public int wordBreak3(String s, Set<String> dict) {\n        int n = s.length();\n        String lowerS = s.toLowerCase();\n        \n        Set<String> lowerDict = new HashSet<String>();\n        for(String str : dict) {\n            lowerDict.add(str.toLowerCase());\n        }\n        \n        wordBreakhelper(lowerS, lowerDict, 0, n);\n        return ans;\n    }\n\n    public void wordBreakhelper(String s,\n                                Set<String> dict,\n                                int start,\n                                int len) {\n        if (start == len) {\n            ans++;\n        }\n        \n        for(int i = start; i < len; i++) {\n            String substr = s.substring(start, i + 1);\n            if (dict.contains(substr)) {\n               wordBreakhelper(s, dict, i + 1, len);\n            }\n        }\n    }\n}"}]},{"id":704,"unique_name":"sliding-window-unique-elements-sum","title":"滑动窗口内唯一元素数量和","description":"给一个数组和一个滑动窗口的大小, 求每一个窗口内唯一元素的个数和","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : the given array\n     * @param : the window size\n     * @return: the sum of the count of unique elements in each window\n     */\n    public int slidingWindowUniqueElementsSum(int[] nums, int k) {\n        // write your code here\n        if(nums == null || nums.length == 0){\n            return 0;\n        }\n        \n        int i = 0;\n        int j = 0;\n        Map<Integer, Integer> freq = new HashMap<>();\n        int count = 0;\n        int res = 0;\n        \n        for(i = 0; i < nums.length; i++){\n            while(j < nums.length && count < k){\n                if(!freq.containsKey(nums[j])){\n                    freq.put(nums[j], 1);\n                } else {\n                    int occ = freq.get(nums[j]);\n                    occ += 1;\n                    freq.put(nums[j], occ);\n                }\n                count++;\n                j++;\n            }\n            \n            if(j <= nums.length){\n                for(Integer key : freq.keySet()){\n                    if(freq.get(key) == 1){\n                        res += 1;\n                    }\n                }\n                \n                freq.put(nums[i], freq.get(nums[i]) - 1);\n                count--;\n                \n                // When reach nums.length, no need to continue since all the\n                // numbers have been included\n                if(j == nums.length){\n                    break;\n                }\n            }\n        }\n        \n        return res;\n    }\n};"},{"language":"python","code":"from collections import Counter\nclass Solution:\n    \n    count, keylist = 0, []\n    def Add(self, value):\n        self.count += 1\n        self.keylist.append(value)\n        \n    def Remove(self, value):\n        self.count -= 1\n        self.keylist.remove(value)\n\n    def slidingWindowUniqueElementsSum(self, nums, k):\n        res = 0\n        if len(nums) <= k:\n            d = Counter(nums)\n            for key in d:\n                if d[key] == 1:\n                    res += 1\n        else:\n            dic = Counter(nums[:k])\n            for key in dic:\n                if dic[key] == 1:\n                    self.Add(key)\n            start, end = 0, k - 1\n            res += self.count\n            while end + 1 < len(nums):\n                v, u = nums[start], nums[end + 1]\n                dic[v] -= 1\n                if dic[v] == 0 and v in self.keylist:\n                    del dic[v]\n                    self.Remove(v)\n                if u not in dic and u not in self.keylist:\n                    dic[u] = 0\n                    self.Add(u)\n                dic[u] += 1\n                if dic[u] == 2 and u in self.keylist:\n                    self.Remove(u)\n                if v in dic and dic[v] == 1 and v not in self.keylist:\n                    self.Add(v)\n                res += self.count\n                start += 1\n                end += 1\n        return res"}]},{"id":694,"unique_name":"split-string","title":"分割字符串","description":"给一个字符串,你可以选择在一个字符或两个相邻字符之后拆分字符串,使字符串由仅一个字符或两个字符组成,输出所有可能的结果","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : a string to be split\n     * @return: all possible split string array\n     */\n    public List<List<String>> splitString(String s) {\n        // write your code here\n        List<List<String>> results = new ArrayList<>();\n        if (s == null) {\n            return results;\n        } else if (s.length() == 0) {\n            results.add(new ArrayList<>());\n            return results;\n        }\n        \n        dfsHelper(results, new ArrayList<>(), 0, s);\n        \n        return results;\n    }\n    \n    private void dfsHelper(List<List<String>> results,\n                           List<String> result,\n                           int index,\n                           String s) {\n        if (index == s.length()) {\n            results.add(new ArrayList<>(result));\n            return;\n        }\n        \n        for (int i = index; i < index + 2 && i < s.length(); i++) {\n            String substring = s.substring(index, i + 1);\n            result.add(substring);\n            dfsHelper(results, result, i + 1, s);\n            result.remove(result.size() - 1);\n        }\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param : a string to be split\n     * @return: all possible split string array\n     */\n    vector<vector<string>> splitString(string& s) {\n        // write your code here\n        vector<string>tmp;\n        splitString(s,0,tmp);\n        return ans;\n    }\n    void splitString(string & s,int pos,vector<string>&tmp){\n        string str;\n        if(pos == s.size()){\n            if(tmp.size() != 1)\n                ans.push_back(tmp);\n            return;\n        }\n        for(int i = pos;i<s.size();i++){\n            str.push_back(s[i]);\n            if(str.size()>2)break;\n            tmp.push_back(str);\n            splitString(s,i+1,tmp);\n            tmp.pop_back();\n        }\n    }\nprivate:\n    vector<vector<string>>ans;\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: : a string to be split\n    @return: all possible split string array\n    \"\"\"\n    def splitString(self, s):\n        # write your code here\n        self.res, candidate, self.s = [], [], s\n        if s is None: return self.res\n        self.helper(candidate, 0)\n        return self.res\n\n    def helper(self, candidate, index):\n    \tif index == len(self.s):\n    \t\tself.res.append(candidate)\n    \t\treturn \n    \ti = index \n    \twhile i < min(index + 2, len(self.s)):\n    \t\tself.helper(candidate + [self.s[index: i + 1]], i + 1)\n    \t\ti = i + 1"}]},{"id":770,"unique_name":"minimum-risk-path","title":"最小危险值路径","description":"地图上有 `m` 条无向边，每条边 (x, y, w) 表示位置 `x` 到位置 `y` 的权值为 `w`。从位置 `0` 到 位置 `n` 可能有多条路径。我们定义一条路径的危险值为这条路径中所有的边的最大权值。\n\n请问从位置 `0` 到 位置 `n` 所有路径中最小的危险值为多少？\n","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param n: maximum index of position.\n     * @param m: the number of undirected edges.\n     * @param x: \n     * @param y: \n     * @param w: \n     * @return: return the minimum risk value.\n     */\n    public class Edge {\n        int to, w;\n        Edge(int to, int w) {\n            this.to = to;\n            this.w = w;\n        }\n    }\n    public int dfs(int now, int target, int val, int res, boolean[] vis, List[] g) {\n        if (now == target) {\n            return val;\n        }\n        if (val >= res) {\n            return Integer.MAX_VALUE;\n        }\n        vis[now] = true;\n        for (int i = 0; i < g[now].size(); i++) {\n            Edge edge = (Edge)g[now].get(i);\n            if (vis[edge.to]) {\n                continue;\n            }\n            res = Math.min(res, dfs(edge.to, target, Math.max(val, edge.w), res, vis, g));\n        }\n        vis[now] = false;\n        return res;\n    }\n    public int getMinRiskValue(int n, int m, int[] x, int[] y, int[] w) {\n        // Write your code here\n        boolean[] vis = new boolean[n + 1];\n        for (int i = 0; i < n + 1; i++) {\n            vis[i] = false;\n        }\n        ArrayList[] g = new ArrayList[n + 1];\n        for (int i = 0; i < n + 1; i++) {\n            g[i] = new ArrayList<Edge>();\n        }\n        for (int i = 0; i < m; i++) {\n            g[x[i]].add(new Edge(y[i], w[i]));\n            g[y[i]].add(new Edge(x[i], w[i]));\n        }\n        return dfs(0, n, 0, Integer.MAX_VALUE, vis, g);\n    }\n}"},{"language":"cpp","code":"// version 1 kruskal\nclass Solution {\npublic:\n    /**\n     * @param n: maximum index of position.\n     * @param m: the number of undirected edges.\n     * @param x: \n     * @param y: \n     * @param w: \n     * @return: return the minimum risk value.\n     */\n    struct Edge {\n      int x, y, w;  \n    };\n    int findFather(int x, int f[]) {\n        if (x != f[x]) {\n            f[x] = findFather(f[x], f);\n        }\n        return f[x];\n    }\n    int getMinRiskValue(int n, int m, vector<int> &x, vector<int> &y, vector<int> &w) {\n        // \n        int ans;\n        int f[n + 1];\n        Edge edges[m];\n        for (int i = 0; i <= n; i++) {\n            f[i] = i;\n        }\n        for (int i = 0; i < m; i++) {\n            edges[i] = Edge{x[i], y[i], w[i]};\n        }\n        sort(edges, edges + m, [](const Edge &edge1, const Edge &edge2) {\n            return edge1.w < edge2.w;\n        });\n        for (int i = 0; i < m; i++) {\n            int a = edges[i].x, b = edges[i].y, c = edges[i].w;\n            int fa = findFather(a, f), fb = findFather(b, f);\n            if (fa != fb) {\n                int f0 = findFather(0, f), fn = findFather(n, f);\n                if (fa < fb) {\n                    swap(fa, fb);\n                }\n                if (f0 < fn) {\n                    swap(f0, fn);\n                }\n                f[fa] = fb;\n                if (f0 == fa && fn == fb) {\n                    ans = c;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n// version 2 dfs + pruning\nclass Solution {\npublic:\n    /**\n     * @param n: maximum index of position.\n     * @param m: the number of undirected edges.\n     * @param x: \n     * @param y: \n     * @param w: \n     * @return: return the minimum risk value.\n     */\n    void dfs(int now, int target, int val, int &res, bool vis[], vector<pair<int, int> > g[]) {\n        if (now == target) {\n            res = min(res, val);\n        }\n        // pruning\n        if (val >= res) {\n             return;\n        }\n        vis[now] = true;\n        for (int i = 0; i < g[now].size(); i++) {\n            int to = g[now][i].first;\n            if (vis[to]) continue;\n            dfs(to, target, max(val, g[now][i].second), res, vis, g);\n        }\n        vis[now] = false;\n    }\n    int getMinRiskValue(int n, int m, vector<int> &x, vector<int> &y, vector<int> &w) {\n        // \n        int res = INT_MAX;\n        bool vis[n + 1];\n        for (int i = 0; i < n + 1; i++) {\n            vis[i] = false;\n        }\n        vector<pair<int, int> > g[n + 1];\n        for (int i = 0; i < m; i++) {\n            g[x[i]].push_back(make_pair(y[i], w[i]));\n            g[y[i]].push_back(make_pair(x[i], w[i]));\n        }\n        dfs(0, n, 0, res, vis, g);\n        return res;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param n: maximum index of position.\n    @param m: the number of undirected edges.\n    @param x: \n    @param y: \n    @param w: \n    @return: return the minimum risk value.\n    \"\"\"\n    def __init__(self):\n        self.v = [[] for x in range(0, 1010)]\n        self.w = [[] for x in range(0, 1010)]\n        self.vis = [0 for _ in range(0, 1010)]\n        self.res = 1000000000\n    \n    def addedge(self, x, y, z):\n        self.v[x].append(y)\n        self.w[x].append(z)\n        \n    def helper(self, x, value, n):\n        if x == n:\n            return value\n        if value >= self.res:\n            return 1000000000\n        self.vis[x] = 1\n        temp = 1000000000\n        for i in range(0, len(self.v[x])):\n            if self.vis[self.v[x][i]] == 1:\n                continue\n            temp = min(temp, self.helper(self.v[x][i], max(value, self.w[x][i]), n))\n            self.res = min(temp, self.res)\n        self.vis[x] = 0\n        return temp\n    \n    def getMinRiskValue(self, n, m, x, y, w):\n        # Write your code here\n        for i in range(0, m):\n            self.addedge(x[i], y[i], w[i])\n            self.addedge(y[i], x[i], w[i])\n        return self.helper(0, 0, n)"}]},{"id":780,"unique_name":"parser","title":"符号串生成器","description":"符号串生成器由两部分组成，开始符号和生成规则集合，\n比如对于以下符号串生成器，\n开始符合：'S'，生成规则集合：[\"S -> abc\", \"S -> aA\", \"A -> b\", \"A -> c\"]\n那么，\n符号串 abc 可以被生成，因为 S -> abc。\n符号串 ab 可以被生成，因为 S -> aA -> ab。\n符号串 ac 可以被生成，因为 S -> aA -> ac。\n现在，给你一个符号串生成器，一个符号串，若该符号串可以被生成返回 True，否则返回 False。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param generator: Generating set of rules.\n     * @param startSymbol: Start symbol.\n     * @param symbolString: Symbol string.\n     * @return: Return true if the symbol string can be generated, otherwise return false.\n     */\n    public boolean canBeGenerated(String[] generator, char startSymbol, String symbolString) {\n        // Write your code here.\n        Map<Character, List<String> >map = new HashMap<Character, List<String> >();\n        for(int i = 0;i < generator.length; i++) {\n            Character start = generator[i].charAt(0);\n            String tostring = generator[i].substring(5);\n            if(map.get(start) == null) {\n                map.put(start, new ArrayList<String>());\n            }\n            map.get(start).add(tostring);\n        }\n        String x = String.valueOf(startSymbol);\n        System.out.println(symbolString);\n        return dfs(map, x, symbolString);\n    }\n    \n    public boolean dfs(Map<Character, List<String> >map, String x, String symbolString) {\n        if(x.length() > symbolString.length()) {\n            return false;\n        }\n        if(x.equals(symbolString)) {\n            return true;\n        }\n        for(int i = 0; i < x.length(); i++) {\n            if(x.charAt(i) >= 'A' && x.charAt(i) <= 'Z') {\n                for(String j : map.get(x.charAt(i))) {\n                    String tmp = new String();\n                    if(i > 0) {\n                        tmp = x.substring(0, i);\n                    }\n                    tmp += j;\n                    if(i + 1 < x.length()) {\n                        tmp = tmp + x.substring(i + 1);\n                    }\n                    boolean ans = dfs(map, tmp, symbolString);\n                    if(ans == true) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}"},{"language":"cpp","code":"// with left factoring\nclass Solution {\npublic:\n    /**\n     * @param generator: Generating set of rules.\n     * @param startSymbol: Start symbol.\n     * @param symbolString: Symbol string.\n     * @return: Return true if the symbol string can be generated, otherwise return false.\n     */\n        \n    int chrToCode(char c) {\n        return c - 'A';\n    }\n    vector<int> stringToVector(string s) {\n        vector<int> res(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            res[i] = chrToCode(s[i]);\n        }\n        return res;\n    }\n    bool nonTerminal(int idx) {\n        if (idx == chrToCode('~')) {\n            return false;\n        } else if (idx >= chrToCode('a') && idx <= chrToCode('z')) {\n            return false;\n        }\n        return true;\n    }\n    void removeLeftCommonFactor(vector<vector<vector<int>>> &sym) {\n        for (int i = 0; i < sym.size(); i++) {\n            if (sym[i].size() == 0) {\n                continue;\n            }\n            vector<vector<int>> vis[sym.size()];\n            for (int j = 0; j < sym[i].size(); j++) {\n                vis[sym[i][j][0]].push_back(sym[i][j]);\n            }\n            sym[i].clear();\n            int tmpSymSize = sym.size();\n            for (int j = 0; j < tmpSymSize; j++) {\n                if (vis[j].size() == 0) {\n                    continue;\n                } else if (vis[j].size() == 1) {\n                    sym[i].push_back(vis[j][0]);\n                    continue;\n                }\n                int comMaxSize = vis[j][0].size();\n                int comSize = 1;\n                for (int k = 1; k < vis[j].size(); k++) {\n                    comMaxSize = min(comMaxSize, int(vis[j][k].size()));\n                }\n                for (int k = 1; k < comMaxSize; k++) {\n                    bool hasCom = true;\n                    for (int t = 1; t < vis[j].size(); t++) {\n                        if (vis[j][t][k] != vis[j][0][k]) {\n                            hasCom = false;\n                            break;\n                        }\n                    }\n                    if (!hasCom) {\n                        break;\n                    }\n                    comSize++;\n                }\n                vector<int> ins;\n                for (int k = 0; k < comSize; k++) {\n                    ins.push_back(vis[j][0][k]);\n                }\n                ins.push_back(sym.size());\n                sym[i].push_back(ins);\n                for (int k = 0; k < vis[j].size(); k++) {\n                    vis[j][k].erase(vis[j][k].begin(), vis[j][k].begin() + comSize);\n                    if (vis[j][k].size() == 0) {\n                        vis[j][k].push_back(chrToCode('~'));\n                    }\n                }\n                sym.push_back(vis[j]);\n            }\n        }\n    }\n    vector<int> subVector(vector<int> &v, int start) {\n        vector<int> res;\n        for (int i = start; i < v.size(); i++) {\n            res.push_back(v[i]);\n        }\n        return res;\n    }\n    vector<int> mergeVector(vector<int> &a, vector<int> &b) {\n        vector<int> res;\n        for (int i = 0; i < a.size(); i++) {\n            res.push_back(a[i]);\n        }\n        for (int i = 0; i < b.size(); i++) {\n            res.push_back(b[i]);\n        }\n        return res;\n    }\n    bool isMatched(vector<int> &symbolVector, int pos, vector<int> left, vector<vector<vector<int>>> &sym) {\n        if (left.size() == 0) {\n            if (pos == symbolVector.size()) {\n                return true;\n            }\n            return false;\n        } else if (pos < symbolVector.size() && left[0] == symbolVector[pos]) {\n            if (isMatched(symbolVector, pos + 1, subVector(left, 1), sym)) {\n                return true;\n            }\n        } else if (left[0] == chrToCode('~')) {\n            if (isMatched(symbolVector, pos, subVector(left, 1), sym)) {\n                return true;\n            }\n        } else if (nonTerminal(left[0])) {\n            int idx = left[0];\n            vector<int> tmpLeft = subVector(left, 1);\n            for (int i = 0; i < sym[idx].size(); i++) {\n                if (isMatched(symbolVector, pos, mergeVector(sym[idx][i], tmpLeft), sym)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    bool canBeGenerated(vector<string> &generator, char startSymbol, string &symbolString) {\n        vector<vector<vector<int>>> sym(128);\n        for (int i = 0; i < generator.size(); i++) {\n            sym[chrToCode(generator[i][0])].push_back(stringToVector(generator[i].substr(5)));\n        }\n        removeLeftCommonFactor(sym);\n        int idx = chrToCode(startSymbol);\n        vector<int> symbolVector = stringToVector(symbolString);\n        for (int i = 0; i < sym[idx].size(); i++) {\n            if (isMatched(symbolVector, 0, sym[idx][i], sym)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n// without left factoring\nclass Solution {\npublic:\n    /**\n     * @param generator: Generating set of rules.\n     * @param startSymbol: Start symbol.\n     * @param symbolString: Symbol string.\n     * @return: Return true if the symbol string can be generated, otherwise return false.\n     */\n    int getIdx(char c) {\n        return c - 'A';\n    }\n    bool nonTerminal(char c) {\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isMatched(string &s, int pos, string gen, vector<string> sym[]) {\n        if (pos == s.length()) {\n            if (gen.length() == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (gen.length() == 0) {\n                return false;\n            } else if (nonTerminal(gen[0])) {\n                int idx = getIdx(gen[0]);\n                for (int i = 0; i < sym[idx].size(); i++) {\n                    if (isMatched(s, pos, sym[idx][i] + gen.substr(1), sym)) {\n                        return true;\n                    }\n                }\n            } else if (gen[0] == s[pos]) {\n                if (isMatched(s, pos + 1, gen.substr(1), sym)) {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        }\n        return false;\n    }\n    bool canBeGenerated(vector<string> &generator, char startSymbol, string &symbolString) {\n        vector<string> sym[26];\n        for (int i = 0; i < generator.size(); i++) {\n            sym[getIdx(generator[i][0])].push_back(generator[i].substr(5));\n        }\n        int idx = getIdx(startSymbol);\n        for (int i = 0; i < sym[idx].size(); i++) {\n            if (isMatched(symbolString, 0, sym[idx][i], sym)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param generator: Generating set of rules.\n    @param startSymbol: Start symbol.\n    @param symbolString: Symbol string.\n    @return: Return true if the symbol string can be generated, otherwise return false.\n    \"\"\"\n    def getIdx(self, c):\n        return ord(c) - ord('A')\n        \n        \n    def nonTerminal(self, c):\n        return ord(c) >= ord('A') and ord(c) <= ord('Z')\n        \n        \n    def isMatched(self, s, pos, gen, sym):\n        if pos == len(s):\n            if len(gen) == 0:\n                return True\n            else:\n                return False\n        else:\n            if len(gen) == 0:\n                return False\n            elif self.nonTerminal(gen[0]):\n                idx = self.getIdx(gen[0])\n                for i in sym[idx]:\n                    if self.isMatched(s, pos, i + gen[1:], sym):\n                        return True\n            elif gen[0] == s[pos]:\n                if self.isMatched(s, pos + 1, gen[1:], sym):\n                    return True\n            else:\n                return False\n        return False\n        \n        \n    def canBeGenerated(self, generator, startSymbol, symbolString):\n        # Write your code here.\n        sym = [[] for i in range(26)]\n        for i in generator:\n            sym[self.getIdx(i[0])].append(i[5:])\n        idx = self.getIdx(startSymbol)\n        for i in sym[idx]:\n            if self.isMatched(symbolString, 0, i, sym):\n                return True\n        return False"}]},{"id":787,"unique_name":"movie-network","title":"影际网络","description":"给一些movie（编号从`0`开始）的rating和他们的联系关系，联系关系可以传递(`a`和`b`有联系，`b`和`c`有联系，`a`和`c`也认为有联系)。给出每个movie的直接联系list。再给定一个movie编号为`S`，找到和`S`相联系的movie中的rating最高的`K`个movie（当与S相联系的movie少于`K`个时，输出所有。输出答案时可以按照任意次序，注意联系movie并不包括`S`。）","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param rating: the rating of the movies\n     * @param G: the realtionship of movies\n     * @param S: the begin movie\n     * @param K: top K rating \n     * @return: the top k largest rating moive which contact with S\n     */\n    public class Pair {\n        public int rating;\n        public int index;\n        public Pair(int rating, int index) {\n            this.rating = rating;\n            this.index = index;\n        }\n\n    }\n    \n    public static Comparator<Pair> idComparator = new Comparator<Pair>(){\n        @Override\n        public int compare(Pair c1, Pair c2) {\n            return c2.rating - c1.rating;\n        }  \n    };\n    public void dfs(int[] rating, int[][] G,int x, int S, Queue<Pair> pq, boolean[] visit) {\n        if(visit[x] == true) {\n            return;\n        }\n        visit[x] = true;\n        if(x != S) {\n            pq.add(new Pair(rating[x], x));\n        }\n        for(int i = 0; i < G[x].length; i++) {\n            dfs(rating, G, G[x][i], S, pq, visit);\n        }\n    }\n    \n     \n    public int[] topKMovie(int[] rating, int[][] G, int S, int K) {\n        // Write your code here\n        Queue<Pair> pq =  new PriorityQueue<Pair>(K,idComparator);\n        boolean[] visit = new boolean[rating.length];\n        dfs(rating, G, S, S, pq, visit);\n        int[] ans = new int[K];\n        for(int i = 0; i < K; i++) {\n            if(!pq.isEmpty()) {\n                Pair top = pq.poll();\n                ans[i] = top.index;\n            }\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    class node {\n    public:\n        int rating;\n        int id;\n        bool operator < (const node &B) const {\n            return rating > B.rating;\n        }\n        node(int a, int b): rating(a),id(b){}\n    };\n    priority_queue<node>Q;\n    map<int ,bool> visit;\n    vector<int> topKMovie(vector<int> &rating, vector<vector<int>> G, int S, int K) {\n        vector<int> ans;\n        dfs(S, K, rating, G, S);\n        while(!Q.empty()) {\n            ans.push_back(Q.top().id);\n            Q.pop();\n        }\n        sort(ans.begin(),ans.end());\n        return ans;\n    }\n\n    void dfs(int u, int limit, vector<int> &rating, vector<vector<int>> &G, int S) {\n        visit[u] = true;\n        if(u != S){\n            if(Q.size() < limit || (rating[u] > Q.top().rating)) {\n                if(Q.size() == limit) {\n                    Q.pop();\n                }\n                Q.push(node(rating[u],u));\n            }\n        }\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            if(visit[v] == false) {\n                dfs(v, limit, rating, G, S);\n            }\n        }\n    }\n};"},{"language":"python","code":"import Queue\nclass Solution:\n    \"\"\"\n    @param rating: the rating of the movies\n    @param G: the realtionship of movies\n    @param S: the begin movie\n    @param K: top K rating \n    @return: the top k largest rating moive which contact with S\n    \"\"\"\n    def __init__(self):\n        self.visit = {}\n        self.Q = Queue.PriorityQueue() \n    class node :\n        def __init__(self, rating, id):\n            self.id = id\n            self.rating = rating\n        def __cmp__(self, other):\n            return self.rating > other.rating\n    def dfs(self, u, limit, rating, G, S):\n        self.visit[u] = 1\n        First = self.node(0,0)\n        if self.Q.qsize() != 0:\n            First = self.Q.get()\n            self.Q.put(First)\n        if u != S:\n            if self.Q.qsize() < limit or rating[u] > First.rating:\n                if self.Q.qsize() == limit:\n                    self.Q.get()\n                self.Q.put(self.node(rating[u],u))\n        for i in G[u]:\n            if i not in self.visit:\n                self.dfs(i, limit, rating, G, S)\n        \n    def topKMovie(self, rating, G, S, K):\n        \n        # Write your code here\n        ans = []\n        self.dfs(S, K, rating, G, S)\n        while self.Q.empty() is False:\n            ans.append(self.Q.get().id)\n        return ans"}]},{"id":798,"unique_name":"time-intersection","title":"时间交集","description":"目前有两个用户的有序在线时间序列，每一个区间记录了该用户的登录时间点`x`和离线时间点`y`，请找出这两个用户同时在线的时间段，输出的时间段请从小到大排序。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param seqA: The seqA\n     * @param seqB: The seqB\n     * @return: The answer\n     */\n    public List<Interval> timeIntersection(List<Interval> seqA, List<Interval> seqB) {\n        // Write your code here\n        int [] visit = new int[1000001];\n        for(int i = 0; i < 1000001; i++) {\n            visit[i] = 0;\n        }\n        for(int i = 0; i < seqA.size(); i++) {\n            for(int j = seqA.get(i).start; j <= seqA.get(i).end; j++) {\n                visit[j] ++;\n            }\n        }\n        for(int i = 0; i < seqB.size(); i++) {\n            for(int j = seqB.get(i).start; j <= seqB.get(i).end; j++) {\n                visit[j] ++;\n            }\n        }\n        List<Interval> ans = new ArrayList<>();\n        for(int i = 0; i < 1000001; i++) {\n            if(visit[i] >= 2) {\n                int x = i;\n                int y = i;\n                while(y + 1 < 1000001 && visit[y + 1] >= 2) {\n                    y++;\n                }\n                ans.add(new Interval(x, y));\n                i = y + 1;\n            }\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param seqA: The seqA\n     * @param seqB: The seqB\n     * @return: The answer\n     */\n    vector<Interval> timeIntersection(vector<Interval> &seqA, vector<Interval> &seqB) {\n        // Write your code here\n        int *visit = new int[1000001];\n        for(int i = 0; i < 1000001; i++) {\n            visit[i] = 0;\n        }\n        for(int i = 0; i < seqA.size(); i++) {\n            for(int j = seqA[i].start; j <= seqA[i].end; j++) {\n                visit[j] ++;\n            }\n        }\n        for(int i = 0; i < seqB.size(); i++) {\n            for(int j = seqB[i].start; j <= seqB[i].end; j++) {\n                visit[j] ++;\n            }\n        }\n        vector<Interval> ans;\n        for(int i = 0; i < 1000001; i++) {\n            if(visit[i] >= 2) {\n                int x = i;\n                int y = i;\n                while(y + 1 < 1000001 && visit[y + 1] >= 2) {\n                    y++;\n                }\n                ans.push_back(Interval(x,y));\n                i = y + 1;\n            }\n        }\n        return ans;\n    }\n};"},{"language":"python","code":"class Solution:\n\n    def timeIntersection(self, seqA, seqB):\n        # Write your code here\n        visit = [0] * 1000001\n        for i in seqA:\n            for j in range(i.start, i.end + 1):\n                visit[j] += 1\n        for i in seqB:\n            for j in range(i.start, i.end + 1):\n                visit[j] += 1\n        ans = []\n        i = 0\n        while i < 1000001:\n            if visit[i] == 2:\n                temp = Interval(0, 0)\n                temp.start = i\n                for j in range(i, 1000001):\n                    if visit[j] !=2 :\n                        temp.end = j - 1\n                        break\n                ans.append(temp)\n                i = temp.end\n            i += 1\n       \n        return ans"}]},{"id":799,"unique_name":"rectangle","title":"矩形","description":"给出一个set，问能不能找到四个点组成平行于坐标轴的矩形，如果能输出YES,否则输出NO。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param pointSet: The point set\n     * @return: The answer\n     */\n    long hash(int x, int y) {\n       return (long)x * 10000000 + y;\n    }\n     \n    public String rectangle(Point[] pointSet) {\n        // Write your code here\n        Set<Long> hashtable = new HashSet<Long>();\n        for(int i = 0; i < pointSet.length; i++) {\n            hashtable.add(hash(pointSet[i].x, pointSet[i].y));\n        }\n        for(int i = 0; i < pointSet.length; i++) {\n            for(int j = 0; j < pointSet.length; j++) {\n                if(pointSet[i].x < pointSet[j].x && pointSet[i].y < pointSet[j].y) {\n                    long temp1 = hash(pointSet[i].x, pointSet[j].y);\n                    long temp2 = hash(pointSet[j].x, pointSet[i].y);\n                    if(hashtable.contains(temp1) && hashtable.contains(temp2)) {\n                        return \"YES\";\n                    }\n                }\n            }\n        }\n        return \"NO\";\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param pointSet: The point set\n     * @return: The answer\n     */\n    string rectangle(vector<Point> &pointSet) {\n        // Write your code here\n        map<pair<int,int> , int> hash;\n    \tfor(auto it: pointSet) {\n    \t\thash[make_pair(it.x, it.y)] = 1;\n    \t}\n    \tfor(int i = 0; i < pointSet.size(); i++) {\n    \t\tfor(int j = 0; j < pointSet.size(); j++) {\n    \t\t\tif(pointSet[i].x < pointSet[j].x && pointSet[i].y < pointSet[j].y) {\n    \t\t\t\tpair<int,int> temp1 = make_pair(pointSet[i].x, pointSet[j].y);\n    \t\t\t\tpair<int,int> temp2 = make_pair(pointSet[j].x, pointSet[i].y);\n    \t\t\t\tif(hash[temp1] && hash[temp2]) {\n    \t\t\t\t\treturn \"YES\";\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn \"NO\";\n    }\n};"},{"language":"python","code":"class Solution:\n    def rectangle(self, pointSet):\n        def cmp(a, b):\n            return a.x < b.x\n        def Hash(p):\n            return p.x * 10000007 + p.y\n        pointSet.sort(cmp)\n        dic = {}\n        for i in pointSet:\n            dic[Hash(i)] = 1\n        a = Point()\n        b = Point()\n        i,j = 0,0\n        n = len(pointSet)\n        while(i < n):\n            j = i + 1\n            while(j < n):\n                if pointSet[i].x < pointSet[j].x and pointSet[i].y < pointSet[j].y:\n                    a.x,a.y = pointSet[i].x,pointSet[j].y\n                    b.x,b.y = pointSet[j].x,pointSet[i].y\n                    if Hash(a) in dic and Hash(b) in dic:\n                        return \"YES\"\n                j += 1\n            i += 1\n        return \"NO\""}]},{"id":800,"unique_name":"word-sorting","title":"单词排序","description":"给一个新的字母表，如{c,b,a,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}，根据新的字母表排序字符串数组。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param alphabet: the new alphabet\n     * @param words: the original string array\n     * @return: the string array after sorting\n     */\n    public String[] wordSort(char[] alphabet, String[] words) {\n        // Write your code here\n        char []Into = new char[1000];\n        char []Outto = new char[1000];\n        for(int i = 0; i < alphabet.length; i++) {\n            Into[(int)alphabet[i]] = (char)('a' + i);\n            Outto['a' + i] = alphabet[i];\n        }\n        for(int i = 0; i < words.length; i++) {\n            String temp = new String();\n            for(int j = 0; j < words[i].length(); j++) {\n                temp += Into[(int)words[i].charAt(j)];\n            }\n            words[i] = temp;\n        }\n        Arrays.sort(words);\n        for(int i = 0; i < words.length; i++) {\n            String temp = new String();\n            for(int j = 0; j < words[i].length(); j++) {\n                temp += Outto[(int)words[i].charAt(j)];\n            }\n             words[i] = temp;\n        }\n        return words;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param alphabet: the new alphabet\n     * @param words: the original string array\n     * @return: the string array after sorting\n     */\n    vector<string> wordSort(string &alphabet, vector<string> &words) {\n        // Write your code here\n        char Into[500],Outto[500];\n        for(int i = 0; i < alphabet.length(); i++) {\n            Into[alphabet[i]] = 'a' + i;\n            Outto['a' + i] = alphabet[i];\n        }\n        for(int i = 0; i < words.size(); i++) {\n            for(int j = 0; j < words[i].length(); j++) {\n                words[i][j] = Into[words[i][j]];\n            }\n        }\n        sort(words.begin(),words.end());\n        for(int i = 0; i < words.size(); i++) {\n            for(int j = 0; j < words[i].length(); j++) {\n                words[i][j] = Outto[words[i][j]];\n            }\n        }\n        return words;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param alphabet: the new alphabet\n    @param words: the original string array\n    @return: the string array after sorting\n    \"\"\"\n    def wordSort(self, alphabet, words):\n        Rank = {}\n        def Cmp(a, b):\n            for i in range(0, min(len(a), len(b))):\n                if Rank[a[i]] < Rank[b[i]]:\n                    return -1\n                elif Rank[a[i]] > Rank[b[i]]:\n                    return 1\n            if(len(a) > len(b)):\n                return 1\n            else:\n                return -1\n        cnt = 0\n        for i in alphabet:\n            Rank[i] = cnt\n            cnt += 1\n        words.sort(Cmp)\n        \n        return words"}]},{"id":801,"unique_name":"subset-with-target","title":"限制条件子集","description":"给一个数组，给定一个target，求满足以下条件的子集个数：\n条件：子集中的最小值+最大值小于给定target。 \n","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param nums: the array\n     * @param target: the target\n     * @return: the number of subsets which meet the following conditions\n     */\n    public long subsetWithTarget(int[] nums, int target) {\n        // Write you code here\n        Arrays.sort(nums);\n        long ans = 0;\n        for(int i = 0; i < nums.length; i++) {\n            int j = i;\n            while(j + 1 < nums.length && nums[i] + nums[j + 1] < target) {\n                j++;\n            }\n            if(nums[i] + nums[j] < target) {\n                ans += ((long)1<<(j - i)) ;\n            }\n            \n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param nums: the array\n     * @param target: the target\n     * @return: the number of subsets which meet the following conditions\n     */\n    long long subsetWithTarget(vector<int> &nums, int target) {\n        // Write you code here\n        sort(nums.begin(),nums.end());\n        long long ans = 0;\n        for(int i = 0; i < nums.size(); i++) {\n            long long p = 1;\n            if(nums[i] + nums[i] < target)\n                ans++;\n            for(int j = i + 1; j < nums.size();j++) {\n                if (nums[i] + nums[j] >= target)\n                    break;\n                ans += p;\n                p = p * 2;\n            }\n        }\n        return ans;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param nums: the array\n    @param target: the target\n    @return: the number of subsets which meet the following conditions\n    \"\"\"\n    def subsetWithTarget(self, nums, target):\n        # Write you code here\n        nums.sort()\n        ans = 0\n        for i in range(0, len(nums)):\n            j = i\n            while(j + 1 < len(nums) and nums[i] + nums[j+1] < target):\n                j += 1\n            if (nums[i] + nums[j] < target):\n                ans = ans + (1<<(j - i))\n        return ans"}]},{"id":488,"unique_name":"russian-doll-envelopes","title":"俄罗斯套娃信封","description":"给一定数量的信封，带有整数对 `(w, h)` 分别代表信封宽度和高度。一个信封的宽高均大于另一个信封时可以放下另一个信封。\n求最大的信封嵌套层数。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param envelopes a number of envelopes with widths and heights\r\n     * @return the maximum number of envelopes\r\n     */\r\n    public int maxEnvelopes(int[][] envelopes) {\r\n        // Write your code here\r\n        if(envelopes == null || envelopes.length == 0 \r\n            || envelopes[0] == null || envelopes[0].length != 2)\r\n            return 0;\r\n        Arrays.sort(envelopes, new Comparator<int[]>(){\r\n            public int compare(int[] arr1, int[] arr2){\r\n                if(arr1[0] == arr2[0])\r\n                    return arr2[1] - arr1[1];\r\n                else\r\n                    return arr1[0] - arr2[0];\r\n            } \r\n        });\r\n        int dp[] = new int[envelopes.length];\r\n        int len = 0;\r\n        for(int[] envelope : envelopes){\r\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\r\n                if(index < 0)\r\n                    index = -index - 1;\r\n            dp[index] = envelope[1];\r\n            if (index == len)\r\n                len++;\r\n        }\r\n        return len;\r\n    }\r\n}"},{"language":"cpp","code":"bool cmp(const pair<int,int>&x, const pair<int, int>&y) {\r\n  return x.first != y.first ? x.first < y.first : x.second > y.second;\r\n}\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param envelopes a number of envelopes with widths and heights\r\n     * @return the maximum number of envelopes\r\n     */\r\n    int maxEnvelopes(vector<pair<int, int>>& envelopes) {\r\n        // Write your code here\r\n        int n = envelopes.size();\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n    \r\n        sort(envelopes.begin(), envelopes.end(), cmp);\r\n        vector<int> dp(n), height(n+1, INT_MAX);\r\n        for (int i = 0; i < n; i++) {\r\n            int k = lower_bound(height.begin(), height.end(), envelopes[i].second) - height.begin() ;\r\n            dp[i] = k;\r\n            height[k] = envelopes[i].second;\r\n        }\r\n    \r\n        int ans = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            ans = max(ans, dp[i]);\r\n        }\r\n        return ans + 1;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[][]} envelopes a number of envelopes with widths and heights\r\n    # @return {int} the maximum number of envelopes\r\n    def maxEnvelopes(self, envelopes):\r\n        # Write your code here\r\n        height = [a[1] for a in sorted(envelopes, key = lambda x: (x[0], -x[1]))]\r\n        dp, length = [0] * len(height), 0\r\n\r\n        import bisect\r\n        for h in height:\r\n            i = bisect.bisect_left(dp, h, 0, length)\r\n            dp[i] = h\r\n            if i == length:\r\n                length += 1\r\n        return length"}]},{"id":88,"unique_name":"multiply-strings","title":"大整数乘法","description":"以字符串的形式给定两个非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积。","solutions":[{"language":"java","code":"public class Solution {\r\n    public String multiply(String num1, String num2) {\r\n        if (num1 == null || num2 == null) {\r\n            return null;\r\n        }\r\n        \r\n        int len1 = num1.length(), len2 = num2.length();\r\n        int len3 = len1 + len2;\r\n        int i, j, product, carry;\r\n\r\n        int[] num3 = new int[len3];\r\n        for (i = len1 - 1; i >= 0; i--) {\r\n            carry = 0;\r\n            for (j = len2 - 1; j >= 0; j--) {\r\n                product = carry + num3[i + j + 1] +\r\n                    Character.getNumericValue(num1.charAt(i)) *\r\n                    Character.getNumericValue(num2.charAt(j));\r\n                num3[i + j + 1] = product % 10;\r\n                carry = product / 10;\r\n            }\r\n            num3[i + j + 1] = carry;\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        i = 0;\r\n\r\n        while (i < len3 - 1 && num3[i] == 0) {\r\n            i++;\r\n        }\r\n\r\n        while (i < len3) {\r\n            sb.append(num3[i++]);\r\n        }\r\n\r\n        return sb.toString();\r\n    }\r\n}\r\n"}]},{"id":528,"unique_name":"walls-and-gates","title":"最近的出口","description":"您将获得一个使用这三个可能值初始化的 m×n 2D 网格。\n`-1` - 墙壁或障碍物。 \n`0` - 门。 \n`INF` - Infinity是一个空房间。我们使用值 `2 ^ 31 - 1 = 2147483647` 来表示INF，您可以假设到门的距离小于 `2147483647`。\n在代表每个空房间的网格中填入到距离最近门的距离。如果不可能到达门口，则应填入 `INF`。","solutions":[{"language":"cpp","code":"// BFS\r\nclass Solution {\r\npublic:\r\n    int dx[4] = {0,1,0,-1};\r\n    int dy[4] = {1,0,-1,0};\r\n    void wallsAndGates(vector<vector<int>>& rooms) {\r\n        queue<pair<int, int>> q;\r\n        for (int i = 0; i < rooms.size(); ++i) {\r\n            for (int j = 0; j < rooms[i].size(); ++j) {\r\n                if (rooms[i][j] == 0) {\r\n                    q.push({i, j});   \r\n                }\r\n            }\r\n        }\r\n        while (!q.empty()) {\r\n            int i = q.front().first, j = q.front().second; q.pop();\r\n            for (int k = 0; k < 4; ++k) {\r\n                int x = i + dx[k], y = j + dy[k];\r\n                if (x < 0 || x >= rooms.size() || y < 0 || y >= rooms[0].size() || rooms[x][y] < rooms[i][j] + 1) {\r\n                    continue;\r\n                }\r\n                rooms[x][y] = rooms[i][j] + 1;\r\n                q.push(make_pair(x, y));\r\n            }\r\n        }\r\n    }\r\n};"}]},{"id":552,"unique_name":"read-n-characters-given-read4-ii-call-multiple-times","title":"从文件中读取字符-多次调用","description":"接口：`int read4(char * buf)`一次从文件中读取 `4` 个字符。\n返回值是实际读取的字符数。 例如，如果文件中只剩下 3 个字符，则返回 3。\n通过使用read4 接口，实现从文件读取 n 个字符的函数`int read(char * buf，int n)`。","solutions":[{"language":"java","code":"/* The read4 API is defined in the parent class Reader4.\r\n      int read4(char[] buf); */\r\n\r\npublic class Solution extends Reader4 {\r\n    private char[] buf4 = new char[4];\r\n    private int buf4Index = 4;\r\n    private int buf4Size = 4;\r\n    \r\n    private boolean readNext(char[] buf, int index) {\r\n        if (buf4Index >= buf4Size) {\r\n            buf4Size = read4(buf4);\r\n            buf4Index = 0;\r\n            if (buf4Size == 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        buf[index] = buf4[buf4Index++];\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @param buf Destination buffer\r\n     * @param n   Maximum number of characters to read\r\n     * @return    The number of characters read\r\n     */\r\n    public int read(char[] buf, int n) {\r\n        for (int i = 0; i < n; i++) {\r\n            if (!readNext(buf, i)) {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return n;\r\n    }\r\n}"},{"language":"cpp","code":"// Forward declaration of the read4 API.\r\nint read4(char *buf);\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param buf Destination buffer\r\n     * @param n   Maximum number of characters to read\r\n     * @return    The number of characters read\r\n     */\r\n    char now[4];\r\n    int cur_pos = 0;\r\n    int total_pos = 0;\r\n    int read(char *buf, int n) {\r\n        for (int i = 0; i < n; i++) {\r\n            if (cur_pos == total_pos) {\r\n                total_pos = read4(now);\r\n                cur_pos = 0;\r\n            }\r\n            if (cur_pos < total_pos) {\r\n                buf[i] = now[cur_pos++];\r\n            } else {\r\n                return i;\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n};"}]},{"id":517,"unique_name":"sparse-matrix-multiplication","title":"稀疏矩阵乘法","description":"给定两个 [稀疏矩阵](https://en.wikipedia.org/wiki/Sparse_matrix) A 和 B，返回AB的结果。\n您可以假设A的列数等于B的行数。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param A a sparse matrix\n     * @param B a sparse matrix\n     * @return the result of A * B\n     */\n    public int[][] multiply(int[][] A, int[][] B) {\n        // Write your code here\n        int n = A.length;\n        int m = A[0].length;\n        int k = B[0].length;\n\n        int[][] C = new int[n][k];\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (A[i][j] != 0)\n                    for (int l = 0; l < k; ++l)\n                        C[i][l] += A[i][j] * B[j][l];\n        return C;\n    }\n}\n\n// version: 高频题班\n//常规做法\npublic class Solution {\n    /**\n     * @param A a sparse matrix\n     * @param B a sparse matrix\n     * @return the result of A * B\n     */\n    public int[][] multiply(int[][] A, int[][] B) {\n        // Write your code here\n        int n = A.length;\n        int m = B[0].length;\n        int t = A[0].length;\n        int[][] C = new int[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                for (int k = 0; k < t; k++) {\n                    C[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n        return C;\n    }\n}\n\n\n\n//改进做法\npublic class Solution {\n    /**\n     * @param A a sparse matrix\n     * @param B a sparse matrix\n     * @return the result of A * B\n     */\n    public int[][] multiply(int[][] A, int[][] B) {\n        // Write your code here\n        int n = A.length;\n        int m = B[0].length;\n        int t = A[0].length;\n        int[][] C = new int[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int k = 0; k < t; k++) {\n                if (A[i][k] == 0) {\n                    continue;\n                }\n                for (int j = 0; j < m; j++) {\n                    C[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n        return C;\n    }\n}\n\n\n//进一步改进\npublic class Solution {\n    /**\n     * @param A a sparse matrix\n     * @param B a sparse matrix\n     * @return the result of A * B\n     */\n    public int[][] multiply(int[][] A, int[][] B) {\n        // Write your code here\n        int n = A.length;\n        int m = B[0].length;\n        int t = A[0].length;\n        int[][] C = new int[n][m];\n\n        List<List<Integer>> col = new ArrayList<>();\n        for (int i = 0; i < t; i++) {\n            col.add(new ArrayList<>());\n            for (int j = 0; j < m; j++) {\n                if (B[i][j] != 0) {\n                    col.get(i).add(j);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int k = 0; k < t; k++) {\n                if (A[i][k] == 0) {\n                    continue;\n                }\n                for (int p = 0; p < col.get(k).size(); p++) {\n                    int j = col.get(k).get(p);\n                    C[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n        return C;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n   \r\n    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\r\n        int na = A.size();\r\n        int ma = A[0].size();\r\n        int mb = B[0].size();\r\n        vector<vector<int>> ans(na, vector<int>(mb, 0));\r\n        for (int i = 0; i < na; i ++) {\r\n           for (int k = 0 ; k < ma; k++) {\r\n              if (A[i][k] != 0) {\r\n                 for (int j = 0; j < mb; j++) {\r\n                    ans[i][j] += (A[i][k] * B[k][j]);    \r\n                  }\r\n              }\r\n           }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n// 超时的常规做法\r\nclass Solution {\r\npublic:\r\n   \r\n    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\r\n        int na = A.size();\r\n        int ma = A[0].size();\r\n        int mb = B[0].size();\r\n        vector<vector<int>> ans(na, vector<int>(mb, 0));\r\n        for (int i = 0; i < na; i ++) {\r\n            for (int j = 0; j < mb; j++) {\r\n                for (int k = 0 ; k < ma; k++) {\r\n                    ans[i][j] += (A[i][k] * B[k][j]);    \r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n//改进版\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param A a sparse matrix\r\n     * @param B a sparse matrix\r\n     * @return the result of A * B\r\n     */\r\n    vector<vector<int> > multiply(vector<vector<int> >& A, vector<vector<int> >& B) {\r\n        // Write your code here\r\n        vector<vector<int> > ans(A.size(), vector<int>(B[0].size(), 0));\r\n        vector<vector<pair<int, int> > > v(B.size());\r\n        for (int i = 0; i < B.size(); i++) { \r\n            for (int j = 0; j < B[i].size(); j++) { \r\n                if (B[i][j] != 0) {\r\n                    v[i].push_back({j, B[i][j]});\r\n                } \r\n            } \r\n        } \r\n        for (int i = 0; i < A.size(); i++) { \r\n            for (int k = 0; k < A[i].size(); k++) { \r\n                if (A[i][k] != 0) { \r\n                    for (int p = 0; p < v[k].size(); p++) {\r\n                        int j = v[k][p].first;\r\n                        int val = v[k][p].second;\r\n                        ans[i][j] += A[i][k] * val;\r\n                    }\r\n                } \r\n            } \r\n        } \r\n        return ans;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[][]} A a sparse matrix\r\n    # @param {int[][]} B a sparse matrix\r\n    # @return {int[][]} the result of A * B\r\n    def multiply(self, A, B):\r\n        # Write your code here\r\n        n = len(A)\r\n        m = len(A[0])\r\n        k = len(B[0])\r\n\r\n        C = [[0 for _ in xrange(k)] for i in xrange(n)]\r\n\r\n        for i in xrange(n):\r\n            for j in xrange(m):\r\n                if A[i][j] != 0:\r\n                    for l in xrange(k):\r\n                        C[i][l] += A[i][j] * B[j][l]\r\n        return C"}]},{"id":548,"unique_name":"binary-tree-vertical-order-traversal","title":"二叉树垂直遍历","description":"给定二叉树，返回其节点值的垂直遍历顺序。 (即逐列从上到下)。\n如果两个节点在同一行和同一列中，则顺序应 **从左到右**。","solutions":[{"language":"java","code":"/**\n * Definition of TreeNode:\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left, right;\n *     public TreeNode(int val) {\n *         this.val = val;\n *         this.left = this.right = null;\n *     }\n * }\n */\npublic class Solution {\n    /**\n     * @param root the root of binary tree\n     * @return the vertical order traversal\n     */\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        // Write your code here\n        List<List<Integer>> results = new ArrayList<>();\n        if (root == null) {\n            return results;\n        }\n        Map<Integer, List<Integer>> map = new TreeMap<Integer, List<Integer>>();\n        Queue<Integer> qCol = new LinkedList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        qCol.offer(0);\n        \n        while(!queue.isEmpty()) {\n            TreeNode curr = queue.poll();\n            int col = qCol.poll();\n            if(!map.containsKey(col)) {\n                map.put(col, new ArrayList<Integer>(Arrays.asList(curr.val)));\n            } else {\n                map.get(col).add(curr.val);\n            }\n            if(curr.left != null) {\n                queue.offer(curr.left);\n                qCol.offer(col - 1);\n            }\n            if(curr.right != null) {\n                queue.offer(curr.right);\n                qCol.offer(col + 1);\n            }\n        }\n        for(int n : map.keySet()) {\n            results.add(map.get(n));\n        }\n        return results;\n    }   \n}\n\n// version: 高频题班\npublic class Solution {\n    /**\n     * @param root the root of binary tree\n     * @return the vertical order traversal\n     */\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        // Write your code here\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) {\n            return ans;\n        }\n\n        Map<Integer, List<Integer>> hash = new HashMap<>();\n        Queue<Integer> qCol = new LinkedList<>();\n        Queue<TreeNode> qNode = new LinkedList<>();\n\n        qCol.offer(0);\n        qNode.offer(root);\n\n        while (!qCol.isEmpty()) {                      // bfs\n            int c = qCol.poll();\n            TreeNode node = qNode.poll();\n\n            hash.putIfAbsent(c, new ArrayList<>());\n            hash.get(c).add(node.val);\n\n            if (node.left != null) {\n                qCol.offer(c - 1);\n                qNode.offer(node.left);\n            }\n            if (node.right != null) {\n                qCol.offer(c + 1);\n                qNode.offer(node.right);\n            }\n        }\n\n        for (int i = Collections.min(hash.keySet()); i <= Collections.max(hash.keySet()); i++) {\n            ans.add(hash.get(i));\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> verticalOrder(TreeNode* root) {\r\n        map<int, vector<int>> mp;\r\n        queue<pair<TreeNode*, int> > q;\r\n        if (root != NULL) {\r\n            q.push(make_pair(root, 0));\r\n        }\r\n        while(!q.empty()) {\r\n            pair<TreeNode*, int> now = q.front(); q.pop();\r\n            mp[now.second].push_back(now.first->val);\r\n            if (now.first->left != NULL) {\r\n                q.push(make_pair(now.first->left, now.second - 1));\r\n            }\r\n            if (now.first->right != NULL) {\r\n                q.push(make_pair(now.first->right, now.second + 1));\r\n            }\r\n        }\r\n        vector<vector<int>> ans;\r\n        for (map<int, vector<int>>::iterator it = mp.begin(); it != mp.end(); it++) {\r\n            ans.push_back(it->second);\r\n        }\r\n        return ans;\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        self.val = val\r\n        self.left, self.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    # @param {TreeNode} root the root of binary tree\r\n    # @return {int[][]} the vertical order traversal\r\n    def verticalOrder(self, root):\r\n        # Write your code here\r\n        results = collections.defaultdict(list)\r\n        import Queue\r\n        queue = Queue.Queue()\r\n        queue.put((root, 0))\r\n        while not queue.empty():\r\n            node, x = queue.get()\r\n            if node:\r\n                results[x].append(node.val)\r\n                queue.put((node.left, x - 1))\r\n                queue.put((node.right, x + 1))\r\n                \r\n        return [results[i] for i in sorted(results)]"}]},{"id":527,"unique_name":"find-the-celebrity","title":"识别名人","description":"假设你和 `n` 个人在一个聚会中(标记为 `0` 到 `n - 1`)，其中可能存在一个名人。名人的定义是所有其他 `n - 1` 人都认识他/她，但他/她不知道任何一个。\n现在你想要找出这个名人是谁或者验证这个名人不存在。你唯一可以做的事情就是提出如下问题：“你好，A，你认识B吗？” 来获取A是否认识B。您需要通过询问尽可能少的问题(以渐近的意义)来找出名人是谁(或验证其不存在)。\n你得到一个辅助函数 `bool know(a，b)`，它会告诉你A是否知道B.实现一个函数 `int findCelebrity(n)`，你的函数应该使 `knows` 的调用次数最少。","solutions":[{"language":"java","code":"// version: 高频题班\r\npublic class Solution extends Relation {\r\n    /**\r\n     * @param n a party with n people\r\n     * @return the celebrity's label or -1\r\n     */\r\n    public int findCelebrity(int n) {\r\n        // Write your code here\r\n        int ans = 0;\r\n        for (int i = 1; i < n; i++) {\r\n            if (knows(ans, i)) {\r\n                ans = i;\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (ans != i && knows(ans, i)) {\r\n                return -1;\r\n            }\r\n            if (ans != i && !knows(i, ans)) {\r\n                return -1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"// Forward declaration of the knows API.\r\nbool knows(int a, int b);\r\n\r\nclass Solution {\r\npublic:\r\n    int findCelebrity(int n) {\r\n        int left = 0;\r\n        int right = n - 1;\r\n        while (left < right) {\r\n            if(knows(left, right)) {\r\n                left ++;\r\n            } else {\r\n                right --;\r\n            }\r\n        }\r\n        for (int i = 0; i < n; i ++) {\r\n            if (i==left || (knows(i, left) && !knows(left, i))) {\r\n                continue;\r\n            } else {\r\n                return -1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n};"}]},{"id":534,"unique_name":"lowest-common-ancestor-iii","title":"最近公共祖先 III","description":"给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先LCA。\r\n\r\n两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。\r\n\r\n返回 `null` 如果两个节点在这棵树上不存在最近公共祖先的话。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\nclass ResultType {\r\n    public boolean a_exist, b_exist;\r\n    public TreeNode node;\r\n    ResultType(boolean a, boolean b, TreeNode n) {\r\n        a_exist = a;\r\n        b_exist = b;\r\n        node = n;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param root The root of the binary tree.\r\n     * @param A and B two nodes\r\n     * @return: Return the LCA of the two nodes.\r\n     */\r\n    public TreeNode lowestCommonAncestor3(TreeNode root, TreeNode A, TreeNode B) {\r\n        // write your code here\r\n        ResultType rt = helper(root, A, B);\r\n        if (rt.a_exist && rt.b_exist)\r\n            return rt.node;\r\n        else\r\n            return null;\r\n    }\r\n\r\n    public ResultType helper(TreeNode root, TreeNode A, TreeNode B) {\r\n        if (root == null)\r\n            return new ResultType(false, false, null);\r\n            \r\n        ResultType left_rt = helper(root.left, A, B);\r\n        ResultType right_rt = helper(root.right, A, B);\r\n        \r\n        boolean a_exist = left_rt.a_exist || right_rt.a_exist || root == A;\r\n        boolean b_exist = left_rt.b_exist || right_rt.b_exist || root == B;\r\n        \r\n        if (root == A || root == B)\r\n            return new ResultType(a_exist, b_exist, root);\r\n\r\n        if (left_rt.node != null && right_rt.node != null)\r\n            return new ResultType(a_exist, b_exist, root);\r\n        if (left_rt.node != null)\r\n            return new ResultType(a_exist, b_exist, left_rt.node);\r\n        if (right_rt.node != null)\r\n            return new ResultType(a_exist, b_exist, right_rt.node);\r\n\r\n        return new ResultType(a_exist, b_exist, null);\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass ResultType {\r\npublic:\r\n    bool a_exist, b_exist;\r\n    TreeNode* node;\r\n    ResultType(bool a, bool b, TreeNode* n) {\r\n        a_exist = a;\r\n        b_exist = b;\r\n        node = n;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: The root of the binary tree.\r\n     * @param A and B: two nodes\r\n     * @return: Return the LCA of the two nodes.\r\n     */\r\n    TreeNode *lowestCommonAncestor3(TreeNode* root, TreeNode* A, TreeNode* B) {\r\n        // write your code here\r\n        ResultType rt = helper(root, A, B);\r\n        if (rt.a_exist && rt.b_exist)\r\n            return rt.node;\r\n        else\r\n            return NULL;\r\n    }\r\n    \r\n    ResultType helper(TreeNode* root, TreeNode* A, TreeNode* B) {\r\n        if (root == NULL)\r\n            return ResultType(false, false, NULL);\r\n            \r\n        ResultType left_rt = helper(root->left, A, B);\r\n        ResultType right_rt = helper(root->right, A, B);\r\n        \r\n        bool a_exist = left_rt.a_exist || right_rt.a_exist || root == A;\r\n        bool b_exist = left_rt.b_exist || right_rt.b_exist || root == B;\r\n        \r\n        if (root == A || root == B)\r\n            return ResultType(a_exist, b_exist, root);\r\n\r\n        if (left_rt.node != NULL && right_rt.node != NULL)\r\n            return ResultType(a_exist, b_exist, root);\r\n        if (left_rt.node != NULL)\r\n            return ResultType(a_exist, b_exist, left_rt.node);\r\n        if (right_rt.node != NULL)\r\n            return ResultType(a_exist, b_exist, right_rt.node);\r\n\r\n        return ResultType(a_exist, b_exist, NULL);\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nimport copy\r\nclass Solution:\r\n    \"\"\"\r\n    @param {TreeNode} root The root of the binary tree.\r\n    @param {TreeNode} A and {TreeNode} B two nodes\r\n    @return Return the LCA of the two nodes.\r\n    \"\"\" \r\n    def lowestCommonAncestor3(self, root, A, B):\r\n        # write your code here\r\n        a, b, lca = self.helper(root, A, B)\r\n        if a and b:\r\n            return lca\r\n        else:\r\n            return None\r\n\r\n    def helper(self, root, A, B):\r\n        if root is None:\r\n            return False, False, None\r\n            \r\n        left_a, left_b, left_node = self.helper(root.left, A, B)\r\n        right_a, right_b, right_node = self.helper(root.right, A, B)\r\n        \r\n        a = left_a or right_a or root == A\r\n        b = left_b or right_b or root == B\r\n        \r\n        if root == A or root == B:\r\n            return a, b, root\r\n\r\n        if left_node is not None and right_node is not None:\r\n            return a, b, root\r\n        if left_node is not None:\r\n            return a, b, left_node\r\n        if right_node is not None:\r\n            return a, b, right_node\r\n\r\n        return a, b, None\r\n"}]},{"id":519,"unique_name":"paint-house-ii","title":"房屋染色 II","description":"这里有`n`个房子在一列直线上，现在我们需要给房屋染色，共有`k`种颜色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小。\n\n费用通过一个`n`x`k` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染颜色`0`的费用，`cost[1][2]`表示房屋`1`染颜色`2`的费用。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param costs n x k cost matrix\r\n     * @return an integer, the minimum cost to paint all houses\r\n     */\r\n    public int minCostII(int[][] costs) {\r\n        int n = costs.length;\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int K = costs[0].length;\r\n        \r\n        int[][] f = new int[2][K];\r\n        int old, now = 0;\r\n        int i, j, k;\r\n        for (k = 0; k < K; ++k) {\r\n            f[now][k] = 0;\r\n        }\r\n        \r\n        for (i = 1; i <= n; ++i) {\r\n            old = now;\r\n            now = 1 - now;\r\n            int min1 = Integer.MAX_VALUE;\r\n            int min2 = Integer.MAX_VALUE;\r\n            for (k = 0; k < K; ++k) {\r\n                if (f[old][k] < min1) {\r\n                    min2 = min1;\r\n                    min1 = f[old][k];\r\n                }\r\n                else {\r\n                    if (f[old][k] < min2) {\r\n                        min2 = f[old][k];\r\n                    }\r\n                }\r\n            }\r\n            \r\n            for (j = 0; j < K; ++j) {\r\n                if (min1 == f[old][j]) {\r\n                    f[now][j] = min2 + costs[i-1][j];   \r\n                }\r\n                else {\r\n                    f[now][j] = min1 + costs[i-1][j];\r\n                }\r\n            }\r\n        }\r\n        \r\n        int res = f[now][0];\r\n        for (k = 0; k < K; ++k) {\r\n            if (f[now][k] < res) {\r\n                res = f[now][k];\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}"},{"language":"cpp","code":"class node {\r\npublic: \r\n    node(){}\r\n    node(int x, int v) {\r\n        id = x;\r\n        value = v;\r\n    }\r\n    int id, value;\r\n};\r\n\r\nbool cmp(const node &a, const node &b)  {\r\n    return a.value < b.value;\r\n}\r\n\r\nclass Solution {\r\npublic:\r\n    \r\n    int minCostII(vector<vector<int>>& costs) {\r\n        if(costs.size() == 0) {\r\n            return 0;\r\n        }\r\n        int n = costs.size();\r\n        int k = costs[0].size();\r\n        int ans[n+1][k];\r\n        memset(ans, 0, sizeof(ans));\r\n        vector<node> now(3), last(3);\r\n        now[0] = node(0, INT_MAX);\r\n        now[1] = node(0, INT_MAX);\r\n            \r\n        for (int i = 1; i <= n; i++) {\r\n            last = now;\r\n            now[0] = node(0, INT_MAX);\r\n            now[1] = node(0, INT_MAX);\r\n            for (int j = 0; j < k ; j++) {\r\n                if(j == last[0].id) {\r\n                    ans[i][j] = ans[i-1][last[1].id] + costs[i-1][j]; \r\n                } else {\r\n                    ans[i][j] = ans[i-1][last[0].id] + costs[i-1][j];\r\n                }\r\n                now[2] = node(j, ans[i][j]);\r\n                sort(now.begin(), now.end(), cmp);\r\n            }\r\n        }\r\n        \r\n        return now[0].value;\r\n    }\r\n};"}]},{"id":323,"unique_name":"graph-valid-tree","title":"图是否是树","description":"给出 `n` 个节点，标号分别从 `0` 到 `n - 1` 并且给出一个 `无向` 边的列表 (给出每条边的两个顶点), 写一个函数去判断这张｀无向｀图是否是一棵树\r\n","solutions":[{"language":"java","code":"// version 1: BFS\r\npublic class Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @param edges a list of undirected edges\r\n     * @return true if it's a valid tree, or false\r\n     */\r\n    public boolean validTree(int n, int[][] edges) {\r\n        if (n == 0) {\r\n            return false;\r\n        }\r\n        \r\n        if (edges.length != n - 1) {\r\n            return false;\r\n        }\r\n        \r\n        Map<Integer, Set<Integer>> graph = initializeGraph(n, edges);\r\n        \r\n        // bfs\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        Set<Integer> hash = new HashSet<>();\r\n        \r\n        queue.offer(0);\r\n        hash.add(0);\r\n        while (!queue.isEmpty()) {\r\n            int node = queue.poll();\r\n            for (Integer neighbor : graph.get(node)) {\r\n                if (hash.contains(neighbor)) {\r\n                    continue;\r\n                }\r\n                hash.add(neighbor);\r\n                queue.offer(neighbor);\r\n            }\r\n        }\r\n        \r\n        return (hash.size() == n);\r\n    }\r\n    \r\n    private Map<Integer, Set<Integer>> initializeGraph(int n, int[][] edges) {\r\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\r\n        for (int i = 0; i < n; i++) {\r\n            graph.put(i, new HashSet<Integer>());\r\n        }\r\n        \r\n        for (int i = 0; i < edges.length; i++) {\r\n            int u = edges[i][0];\r\n            int v = edges[i][1];\r\n            graph.get(u).add(v);\r\n            graph.get(v).add(u);\r\n        }\r\n        \r\n        return graph;\r\n    }\r\n}\r\n\r\n\r\n// version 2: Union Find\r\npublic class Solution {\r\n      class UnionFind{\r\n        HashMap<Integer, Integer> father = new HashMap<Integer, Integer>();\r\n        UnionFind(int n){\r\n            for(int i = 0 ; i < n; i++) {\r\n                father.put(i, i); \r\n            }\r\n        }\r\n        int compressed_find(int x){\r\n            int parent =  father.get(x);\r\n            while(parent!=father.get(parent)) {\r\n                parent = father.get(parent);\r\n            }\r\n            int temp = -1;\r\n            int fa = father.get(x);\r\n            while(fa!=father.get(fa)) {\r\n                temp = father.get(fa);\r\n                father.put(fa, parent) ;\r\n                fa = temp;\r\n            }\r\n            return parent;\r\n                \r\n        }\r\n        \r\n        void union(int x, int y){\r\n            int fa_x = compressed_find(x);\r\n            int fa_y = compressed_find(y);\r\n            if(fa_x != fa_y)\r\n                father.put(fa_x, fa_y);\r\n        }\r\n    }\r\n    /**\r\n     * @param n an integer\r\n     * @param edges a list of undirected edges\r\n     * @return true if it's a valid tree, or false\r\n     */\r\n    public boolean validTree(int n, int[][] edges) {\r\n        // tree should have n nodes with n-1 edges\r\n        if (n - 1 != edges.length) {\r\n            return false;\r\n        }\r\n        \r\n        UnionFind uf = new UnionFind(n);\r\n        \r\n        for (int i = 0; i < edges.length; i++) {\r\n            if (uf.compressed_find(edges[i][0]) == uf.compressed_find(edges[i][1])) {\r\n                return false;\r\n            }\r\n            uf.union(edges[i][0], edges[i][1]);\r\n        }\r\n        return true;\r\n    }\r\n}"},{"language":"cpp","code":"// bfs version\r\nclass Solution {\r\npublic:\r\n    bool validTree(int n, vector<pair<int, int>>& edges) {\r\n        vector<unordered_set<int>> g(n, unordered_set<int>());\r\n        unordered_set<int> v;\r\n        queue<int> q;\r\n        q.push(0);\r\n        v.insert(0);\r\n        for (auto a : edges) {\r\n            g[a.first].insert(a.second);\r\n            g[a.second].insert(a.first);\r\n        }\r\n        while (!q.empty()) {\r\n            int t = q.front(); q.pop();\r\n            for (auto a : g[t]) {\r\n                if (v.find(a) != v.end()) return false;\r\n                v.insert(a);\r\n                q.push(a);\r\n                g[a].erase(t);\r\n            }\r\n        }\r\n        return v.size() == n;\r\n    }\r\n};\r\n\r\n\r\n// union find version\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param n an integer\r\n     * @param edges a list of undirected edges\r\n     * @return true if it's a valid tree, or false\r\n     */\r\n    bool validTree(int n, vector<vector<int>>& edges) {\r\n        // Write your code here\r\n        vector<int> root(n, -1);\r\n        for(int i = 0; i < edges.size(); i++) {\r\n            int root1 = find(root, edges[i][0]);\r\n            int root2 = find(root, edges[i][1]);\r\n            if(root1 == root2)\r\n                return false;\r\n            root[root1] = root2;\r\n        }\r\n        return edges.size() == n - 1;\r\n    }\r\n    int find(vector<int> &root, int e) {\r\n        if(root[e] == -1)\r\n            return e;\r\n        else\r\n            return root[e] = find(root, root[e]);\r\n    }\r\n};"},{"language":"python","code":"// bfs version\r\nclass Solution:\r\n    # @param {int} n an integer\r\n    # @param {int[][]} edges a list of undirected edges\r\n    # @return {boolean} true if it's a valid tree, or false\r\n    def validTree(self, n, edges):\r\n        # Write your code here\r\n        if len(edges) != n - 1:\r\n            return False\r\n\r\n        neighbors = collections.defaultdict(list)\r\n        for u, v in edges:\r\n            neighbors[u].append(v)\r\n            neighbors[v].append(u)\r\n\r\n        visited = {}\r\n        from Queue import Queue\r\n        queue = Queue()\r\n        \r\n        queue.put(0)\r\n        visited[0] = True\r\n        while not queue.empty():\r\n            cur = queue.get()\r\n            visited[cur] = True\r\n            for node in neighbors[cur]:\r\n                if node not in visited:\r\n                    visited[node] = True\r\n                    queue.put(node)\r\n\r\n        return len(visited) == n\r\n\r\n\r\n// union find version\r\nclass Solution:\r\n    # @param {int} n an integer\r\n    # @param {int[][]} edges a list of undirected edges\r\n    # @return {boolean} true if it's a valid tree, or false\r\n    def validTree(self, n, edges):\r\n        # Write your code here\r\n        root = [i for i in range(n)]\r\n        for i in edges:\r\n            root1 = self.find(root, i[0])\r\n            root2 = self.find(root, i[1])\r\n            if root1 == root2:\r\n                return False\r\n            else:\r\n                root[root1] = root2\r\n        return len(edges) == n - 1\r\n        \r\n    def find(self, root, e):\r\n        if root[e] == e:\r\n            return e\r\n        else:\r\n            root[e] = self.find(root, root[e])\r\n            return root[e]"}]},{"id":315,"unique_name":"binary-tree-paths","title":"二叉树的所有路径","description":"给一棵二叉树，找出从根节点到叶子节点的所有路径。","solutions":[{"language":"java","code":"// version 1: Divide Conquer\npublic class Solution {\n    /**\n     * @param root the root of the binary tree\n     * @return all root-to-leaf paths\n     */\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> paths = new ArrayList<>();\n        if (root == null) {\n            return paths;\n        }\n        \n        List<String> leftPaths = binaryTreePaths(root.left);\n        List<String> rightPaths = binaryTreePaths(root.right);\n        for (String path : leftPaths) {\n            paths.add(root.val + \"->\" + path);\n        }\n        for (String path : rightPaths) {\n            paths.add(root.val + \"->\" + path);\n        }\n        \n        // root is a leaf\n        if (paths.size() == 0) {\n            paths.add(\"\" + root.val);\n        }\n        \n        return paths;\n    }\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root the root of the binary tree\r\n     * @return all root-to-leaf paths\r\n     */\r\n    vector<string> binaryTreePaths(TreeNode* root) {\r\n        // Write your code here\r\n        vector<string> path;\r\n        if(root == NULL)\r\n            return path;\r\n        vector<vector<int> > pathv;    \r\n        unordered_map<TreeNode*, bool> visited;\r\n        stack<TreeNode*> stk;\r\n        stk.push(root);\r\n        visited[root] = true;\r\n        if(root->left == NULL && root->right == NULL)\r\n            save(pathv, stk);\r\n        while(!stk.empty())\r\n        {\r\n            TreeNode* top = stk.top();\r\n            if(top->left && visited[top->left] == false)\r\n            {\r\n                stk.push(top->left);\r\n                visited[top->left] = true;\r\n                if(top->left->left == NULL && top->left->right == NULL)\r\n                    save(pathv, stk);\r\n                continue;\r\n            }\r\n            if(top->right && visited[top->right] == false)\r\n            {\r\n                stk.push(top->right);\r\n                visited[top->right] = true;\r\n                if(top->right->left == NULL && top->right->right == NULL)\r\n                    save(pathv, stk);\r\n                continue;\r\n            }\r\n            stk.pop();\r\n        }\r\n        return convert(pathv);\r\n    }\r\n\r\n    void save(vector<vector<int> >& pathv, stack<TreeNode*> stk)\r\n    {\r\n        vector<int> cur;\r\n        while(!stk.empty())\r\n        {\r\n            TreeNode* top = stk.top();\r\n            cur.push_back(top->val);\r\n            stk.pop();\r\n        }\r\n        reverse(cur.begin(), cur.end());\r\n        pathv.push_back(cur);\r\n    }\r\n\r\n    vector<string> convert(vector<vector<int> >& pathv)\r\n    {\r\n        vector<string> path;\r\n        for(int i = 0; i < pathv.size(); i ++)\r\n        {\r\n            string cur;\r\n            cur += to_string(pathv[i][0]);\r\n            for(int j = 1; j < pathv[i].size(); j ++)\r\n            {\r\n                cur += \"->\";\r\n                cur += to_string(pathv[i][j]);\r\n            }\r\n            path.push_back(cur);\r\n        }\r\n        return path;\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        self.val = val\r\n        self.left, self.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    # @param {TreeNode} root the root of the binary tree\r\n    # @return {List[str]} all root-to-leaf paths\r\n    def binaryTreePaths(self, root):\r\n        # Write your code here\r\n        result = []\r\n        if root is None:\r\n            return result\r\n        self.dfs(root, result, [])\r\n        return result\r\n\r\n    def dfs(self, node, result, tmp):\r\n        tmp.append(str(node.val))\r\n        if node.left is None and node.right is None:\r\n            result.append('->'.join(tmp))\r\n            tmp.pop()\r\n            return\r\n\r\n        if node.left:\r\n            self.dfs(node.left, result, tmp);\r\n        \r\n        if node.right:\r\n            self.dfs(node.right, result, tmp)\r\n\r\n        tmp.pop()\r\n"}]},{"id":111,"unique_name":"letter-combinations-of-a-phone-number","title":"电话号码的字母组合","description":"","solutions":[{"language":"java","code":"public class Solution {\r\n    public ArrayList<String> letterCombinations(String digits) {\r\n        ArrayList<String> result = new ArrayList<String>();\r\n\r\n        if (digits == null || digits.equals(\"\")) {\r\n            return result;\r\n        }\r\n\r\n        Map<Character, char[]> map = new HashMap<Character, char[]>();\r\n        map.put('0', new char[] {});\r\n        map.put('1', new char[] {});\r\n        map.put('2', new char[] { 'a', 'b', 'c' });\r\n        map.put('3', new char[] { 'd', 'e', 'f' });\r\n        map.put('4', new char[] { 'g', 'h', 'i' });\r\n        map.put('5', new char[] { 'j', 'k', 'l' });\r\n        map.put('6', new char[] { 'm', 'n', 'o' });\r\n        map.put('7', new char[] { 'p', 'q', 'r', 's' });\r\n        map.put('8', new char[] { 't', 'u', 'v'});\r\n        map.put('9', new char[] { 'w', 'x', 'y', 'z' });\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        helper(map, digits, sb, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    private void helper(Map<Character, char[]> map, String digits, \r\n        StringBuilder sb, ArrayList<String> result) {\r\n        if (sb.length() == digits.length()) {\r\n            result.add(sb.toString());\r\n            return;\r\n        }\r\n\r\n        for (char c : map.get(digits.charAt(sb.length()))) {\r\n            sb.append(c);\r\n            helper(map, digits, sb, result);\r\n            sb.deleteCharAt(sb.length() - 1);\r\n        }\r\n    }\r\n}\r\n\r\n// version: 高频题班\r\n\r\n//  方法1 计状态 \r\npublic class Solution {\r\n    /**\r\n     * @param digits A digital string\r\n     * @return all posible letter combinations\r\n     */\r\n    ArrayList<String> ans = new ArrayList<>();\r\n\r\n    void dfs(int x, int l, String str, String digits, String phone[]) {\r\n        if (x == l) {\r\n            ans.add(str);\r\n            return;\r\n        }\r\n        int d = digits.charAt(x) - '0';\r\n        for (char c : phone[d].toCharArray()) {\r\n            dfs(x + 1, l, str + c, digits, phone);\r\n        }\r\n    }\r\n\r\n    public ArrayList<String> letterCombinations(String digits) {\r\n        // Write your code here\r\n        String phone[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\r\n\r\n        if (digits.length() == 0) {\r\n            return ans;\r\n        }\r\n        dfs(0, digits.length(), \"\", digits, phone);\r\n        return ans;\r\n    }\r\n}\r\n\r\n\r\n// 方法2 计状态\r\npublic class Solution {\r\n    /**\r\n     * @param digits A digital string\r\n     * @return all posible letter combinations\r\n     */\r\n    ArrayList<String> ans = new ArrayList<>();\r\n\r\n    int l;\r\n    String digits;\r\n    static final String phone[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\r\n            \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\r\n\r\n    void dfs(int x, String str) {\r\n        if (x == l) {\r\n            ans.add(str);\r\n            return;\r\n        }\r\n        int d = digits.charAt(x) - '0';\r\n        for (char c : phone[d].toCharArray()) {\r\n            dfs(x + 1, str + c);\r\n        }\r\n    }\r\n\r\n    public ArrayList<String> letterCombinations(String digits) {\r\n        // Write your code here\r\n        this.l = digits.length();\r\n        this.digits = digits;\r\n\r\n        if (digits.length() == 0) {\r\n            return ans;\r\n        }\r\n        dfs(0, \"\");\r\n        return ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    const vector<string> keyboard { \" \", \"\", \"abc\", \"def\", // '0','1','2',...\r\n            \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\r\n\r\n    vector<string> letterCombinations (const string &digits) {\r\n        if (digits == \"\") return {};\r\n        vector<string> result;\r\n        dfs(digits, 0, \"\", result);\r\n        return result;\r\n    }\r\n\r\n    void dfs(const string &digits, size_t cur, string path,\r\n            vector<string> &result) {\r\n        if (cur == digits.size()) {\r\n            result.push_back(path);\r\n            return;\r\n        }\r\n        for (auto c : keyboard[digits[cur] - '0']) {\r\n            dfs(digits, cur + 1, path + c, result);\r\n        }\r\n    }\r\n};\r\n\r\n\r\n// 方法二\r\n\r\nclass Solution {\r\npublic:\r\n  /**\r\n   * @param digits A digital string\r\n   * @return all posible letter combinations\r\n   */\r\n  vector<string> ans;\r\n  \r\n  void dfs(int x, int l, string str, string digits, char phone[][4]) {\r\n    if (x == l) {\r\n      ans.push_back(str);\r\n      return;\r\n    }\r\n    int num = digits[x] - '0';\r\n    for (int i = 0; i < 4; i++) {\r\n      if (phone[num][i]) {\r\n        dfs(x + 1, l, str + phone[num][i], digits, phone);\r\n      }\r\n    }\r\n  }\r\n  vector<string> letterCombinations(string& digits) {\r\n    // Write your code here\r\n    char phone[10][4] = {{' '}, {}, {'a', 'b', 'c'}, {'d', 'e', 'f'}, {'g', 'h', 'i'},\r\n    {'j', 'k', 'l'}, {'m', 'n', 'o'}, {'p', 'q', 'r', 's'}, {'t', 'u', 'v'}, {'w', 'x', 'y', 'z'}};\r\n    \r\n    if (digits.size() == 0) {\r\n      return ans;\r\n    }\r\n    dfs(0, digits.size(), \"\", digits, phone);\r\n    return ans;\r\n  }\r\n};\r\n"},{"language":"python","code":"// version 1\r\nclass Solution:\r\n    # @return a list of strings, [s1, s2]\r\n    def letterCombinations(self, digits):\r\n        def dfs(num, string, res):\r\n            if num == length:\r\n                res.append(string)\r\n                return\r\n            for letter in dict[digits[num]]:\r\n                    dfs(num+1, string+letter, res)\r\n        \r\n        dict = {'2':['a','b','c'],\r\n                '3':['d','e','f'],\r\n                '4':['g','h','i'],\r\n                '5':['j','k','l'],\r\n                '6':['m','n','o'],\r\n                '7':['p','q','r','s'],\r\n                '8':['t','u','v'],\r\n                '9':['w','x','y','z']\r\n                }\r\n        res = []\r\n        length = len(digits)\r\n        if length == 0:\r\n            return res\r\n        dfs(0, '', res)\r\n        return res\r\n// version 2\r\nclass Solution(object):\r\n    '''\r\n    题意：输出电话号码对应的所有可能的字符串\r\n    可以递归或直接模拟\r\n    '''\r\n    def letterCombinations(self, digits):\r\n        chr = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\r\n        res = []\r\n        for i in range(0, len(digits)):\r\n            num = int(digits[i])\r\n            tmp = []\r\n            for j in range(0, len(chr[num])):\r\n                if len(res):\r\n                    for k in range(0, len(res)):\r\n                        tmp.append(res[k] + chr[num][j])\r\n                else:\r\n                    tmp.append(str(chr[num][j]))\r\n            res = copy.copy(tmp)\r\n        return res"}]},{"id":299,"unique_name":"implement-trie","title":"实现 Trie","description":"实现一个 Trie，包含 `insert`, `search`, 和 `startsWith` 这三个方法。","solutions":[{"language":"java","code":"// Version 1: Array of TrieNode\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie trie = new Trie();\n * trie.insert(\"lintcode\");\n * trie.search(\"lint\"); will return false\n * trie.startsWith(\"lint\"); will return true\n */\nclass TrieNode {\n    private TrieNode[] children;\n    public boolean hasWord;\n    \n    // Initialize your data structure here.\n    public TrieNode() {\n        children = new TrieNode[26];\n        hasWord = false;\n    }\n    \n    public void insert(String word, int index) {\n        if (index == word.length()) {\n            this.hasWord = true;\n            return;\n        }\n        \n        int pos = word.charAt(index) - 'a';\n        if (children[pos] == null) {\n            children[pos] = new TrieNode();\n        }\n        children[pos].insert(word, index + 1);\n    }\n    \n    public TrieNode find(String word, int index) {\n        if (index == word.length()) {\n            return this;\n        }\n        \n        int pos = word.charAt(index) - 'a';\n        if (children[pos] == null) {\n            return null;\n        }\n        return children[pos].find(word, index + 1);\n    }\n}\n\npublic class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    public void insert(String word) {\n        root.insert(word, 0);\n    }\n\n    // Returns if the word is in the trie.\n    public boolean search(String word) {\n        TrieNode node = root.find(word, 0);\n        return (node != null && node.hasWord);\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    public boolean startsWith(String prefix) {\n        TrieNode node = root.find(prefix, 0);\n        return node != null;\n    }\n}\n\n// Version 2: HashMap Version, this version will be TLE when you submit on LintCode\n/*\nYour Trie object will be instantiated and called as such:\nTrie trie = new Trie();\ntrie.insert(\"lintcode\");\ntrie.search(\"lint\"); will return false\ntrie.startsWith(\"lint\"); will return true\n*/\nclass TrieNode {\n    // Initialize your data structure here.\n    char c;\n    HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n    boolean hasWord;\n    \n    public TrieNode(){\n        \n    }\n    \n    public TrieNode(char c){\n        this.c = c;\n    }\n}\n\npublic class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    public void insert(String word) {\n        TrieNode cur = root;\n        HashMap<Character, TrieNode> curChildren = root.children;\n        char[] wordArray = word.toCharArray();\n        for(int i = 0; i < wordArray.length; i++){\n            char wc = wordArray[i];\n            if(curChildren.containsKey(wc)){\n                cur = curChildren.get(wc);\n            } else {\n                TrieNode newNode = new TrieNode(wc);\n                curChildren.put(wc, newNode);\n                cur = newNode;\n            }\n            curChildren = cur.children;\n            if(i == wordArray.length - 1){\n                cur.hasWord= true;\n            }\n        }\n    }\n\n    // Returns if the word is in the trie.\n    public boolean search(String word) {\n        if(searchWordNodePos(word) == null){\n            return false;\n        } else if(searchWordNodePos(word).hasWord) \n          return true;\n          else return false;\n    }\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    public boolean startsWith(String prefix) {\n        if(searchWordNodePos(prefix) == null){\n            return false;\n        } else return true;\n    }\n    \n    public TrieNode searchWordNodePos(String s){\n        HashMap<Character, TrieNode> children = root.children;\n        TrieNode cur = null;\n        char[] sArray = s.toCharArray();\n        for(int i = 0; i < sArray.length; i++){\n            char c = sArray[i];\n            if(children.containsKey(c)){\n                cur = children.get(c);\n                children = cur.children;\n            } else{\n                return null;\n            }\n        }\n        return cur;\n    }\n}"},{"language":"cpp","code":"/*\r\nYour Trie object will be instantiated and called as such:\r\nTrie trie;\r\ntrie.insert(\"lintcode\");\r\ntrie.search(\"lint\"); will return false\r\ntrie.startsWith(\"lint\"); will return true\r\n*/\r\nclass TrieNode {\r\npublic:\r\n    // Initialize your data structure here.\r\n    TrieNode() {\r\n        for(int i = 0; i < 26; i++)\r\n            next[i] = NULL;\r\n        isString = false;\r\n    }\r\n    TrieNode *next[26];\r\n    bool isString;\r\n};\r\n \r\nclass Trie {\r\npublic:\r\n    Trie() {\r\n        root = new TrieNode();\r\n    }\r\n \r\n    // Inserts a word into the trie.\r\n    void insert(string word) {\r\n        TrieNode *p = root;\r\n        for(int i = 0; i < word.size(); i++){\r\n            if(p->next[word[i]-'a'] == NULL){\r\n                p->next[word[i]-'a'] = new TrieNode();\r\n            }\r\n            p = p->next[word[i]-'a'];\r\n        }\r\n        p->isString = true;\r\n    }\r\n \r\n    // Returns if the word is in the trie.\r\n    bool search(string word) {\r\n        TrieNode *p = root;\r\n        for(int i = 0; i < word.size(); i++){\r\n            if(p == NULL) return false;\r\n            p = p->next[word[i]-'a'];\r\n        }\r\n        if(p == NULL || p->isString == false) return false;\r\n        return true;\r\n         \r\n    }\r\n \r\n    // Returns if there is any word in the trie\r\n    // that starts with the given prefix.\r\n    bool startsWith(string prefix) {\r\n        TrieNode *p = root;\r\n        for(int i = 0; i < prefix.size(); i++) {\r\n            p = p->next[prefix[i]-'a'];\r\n            if(p == NULL) return false;\r\n        }\r\n        return true;\r\n    }\r\n \r\nprivate:\r\n    TrieNode* root;\r\n};"},{"language":"python","code":"\"\"\"\r\nYour Trie object will be instantiated and called as such:\r\ntrie = Trie()\r\ntrie.insert(\"lintcode\")\r\ntrie.search(\"lint\") will return false\r\ntrie.startsWith(\"lint\") will return true\r\n\"\"\"\r\nclass TrieNode:\r\n  def __init__(self):\r\n    # Initialize your data structure here.\r\n    self.childs = dict()\r\n    self.isWord = False\r\n\r\nclass Trie:\r\n  def __init__(self):\r\n    self.root = TrieNode()\r\n\r\n  # @param {string} word\r\n  # @return {void}\r\n  # Inserts a word into the trie.\r\n  def insert(self, word):\r\n    node = self.root\r\n    for letter in word:\r\n      child = node.childs.get(letter)\r\n      if child is None:\r\n        child = TrieNode()\r\n        node.childs[letter] = child\r\n      node = child\r\n    node.isWord = True\r\n\r\n  # @param {string} word\r\n  # @return {boolean}\r\n  # Returns if the word is in the trie.\r\n  def search(self, word):\r\n    node = self.root\r\n    for letter in word:\r\n      node = node.childs.get(letter)\r\n      if node is None:\r\n        return False\r\n    return node.isWord\r\n\r\n  # @param {string} prefix\r\n  # @return {boolean}\r\n  # Returns if there is any word in the trie\r\n  # that starts with the given prefix.\r\n  def startsWith(self, prefix):\r\n    node = self.root\r\n    for letter in prefix:\r\n      node = node.childs.get(letter)\r\n      if node is None:\r\n        return False\r\n    return True"}]},{"id":264,"unique_name":"maximal-square","title":"最大正方形","description":"在一个二维01矩阵中找到全为1的最大正方形","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param matrix: a matrix of 0 and 1\r\n     * @return: an integer\r\n     */\r\n    public int maxSquare(int[][] matrix) {\r\n        // write your code here\r\n        int ans = 0;\r\n        int n = matrix.length;\r\n        int m;\r\n        if(n > 0)\r\n            m = matrix[0].length;\r\n        else \r\n            return ans;\r\n        int [][]res = new int [n][m];\r\n        for(int i = 0; i < n; i++){\r\n            res[i][0] = matrix[i][0];\r\n            ans = Math.max(res[i][0] , ans);\r\n            for(int j = 1; j < m; j++) {\r\n                if(i > 0) {\r\n                    if(matrix[i][j] > 0) {\r\n                        res[i][j] = Math.min(res[i - 1][j],Math.min(res[i][j-1], res[i-1][j-1])) + 1;\r\n                    } else {\r\n                        res[i][j] = 0;\r\n                    }\r\n                    \r\n                }\r\n                else {\r\n                    res[i][j] = matrix[i][j];\r\n                }\r\n                ans = Math.max(res[i][j], ans);\r\n            }\r\n        }\r\n        return ans*ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param matrix: a matrix of 0 and 1\r\n     * @return: an integer\r\n     */\r\n    int maxSquare(vector<vector<int> > &matrix) {\r\n        // write your code here\r\n        int m = matrix.size(), n = matrix[0].size();\r\n        vector<vector<int> > f(m, vector<int>(n));\r\n        for (int i=0; i<n; ++i) f[0][i] = matrix[0][i];\r\n        for (int i=1; i<m; ++i) f[i][0] = matrix[i][0];\r\n        for (int i=1; i<m; ++i)\r\n            for (int j=1; j<n; ++j) \r\n                if (matrix[i][j]==0) f[i][j] = 0;\r\n                else f[i][j] = 1+min(f[i-1][j], min(f[i-1][j-1], f[i][j-1]));\r\n        int ans = 0;        \r\n        for (int i=0; i<m; ++i)\r\n            for (int j=0; j<n; ++j) ans = max(ans, f[i][j]);\r\n        return ans*ans;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    #param matrix: a matrix of 0 and 1\r\n    #return: an integer\r\n    def maxSquare(self, matrix):\r\n        # write your code here\r\n        m = len(matrix)\r\n        n = len(matrix[0])\r\n        f = []\r\n        for i in xrange(m): f.append([])\r\n        for i in xrange(m):\r\n            for j in xrange(n): f[i].append(0)\r\n        for i in xrange(n): f[0][i] = matrix[0][i]\r\n        for i in xrange(1, m): f[i][0] = matrix[i][0]\r\n        for i in xrange(1, m):\r\n            for j in xrange(1, n): \r\n                if (matrix[i][j]==0): f[i][j] = 0\r\n                else: f[i][j] = 1+min(f[i-1][j], min(f[i-1][j-1], f[i][j-1]))\r\n        ans = 0        \r\n        for i in xrange(m):\r\n            for j in xrange(n): ans = max(ans, f[i][j])\r\n        return ans*ans\r\n"}]},{"id":407,"unique_name":"number-of-islands","title":"岛屿的个数","description":"给一个01矩阵，求不同的岛屿的个数。\r\n\r\n0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。","solutions":[{"language":"java","code":"// version 1: BFS\r\nclass Coordinate {\r\n    int x, y;\r\n    public Coordinate(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param grid a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    public int numIslands(boolean[][] grid) {\r\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int n = grid.length;\r\n        int m = grid[0].length;\r\n        int islands = 0;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                if (grid[i][j]) {\r\n                    markByBFS(grid, i, j);\r\n                    islands++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return islands;\r\n    }\r\n    \r\n    private void markByBFS(boolean[][] grid, int x, int y) {\r\n        // magic numbers!\r\n        int[] directionX = {0, 1, -1, 0};\r\n        int[] directionY = {1, 0, 0, -1};\r\n        \r\n        Queue<Coordinate> queue = new LinkedList<>();\r\n        \r\n        queue.offer(new Coordinate(x, y));\r\n        grid[x][y] = false;\r\n        \r\n        while (!queue.isEmpty()) {\r\n            Coordinate coor = queue.poll();\r\n            for (int i = 0; i < 4; i++) {\r\n                Coordinate adj = new Coordinate(\r\n                    coor.x + directionX[i],\r\n                    coor.y + directionY[i]\r\n                );\r\n                if (!inBound(adj, grid)) {\r\n                    continue;\r\n                }\r\n                if (grid[adj.x][adj.y]) {\r\n                    grid[adj.x][adj.y] = false;\r\n                    queue.offer(adj);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private boolean inBound(Coordinate coor, boolean[][] grid) {\r\n        int n = grid.length;\r\n        int m = grid[0].length;\r\n        \r\n        return coor.x >= 0 && coor.x < n && coor.y >= 0 && coor.y < m;\r\n    }\r\n}\r\n\r\n// version 2: Union Find\r\nclass UnionFind { \r\n\r\n    private int[] father = null;\r\n    private int count;\r\n\r\n    private int find(int x) {\r\n        if (father[x] == x) {\r\n            return x;\r\n        }\r\n        return father[x] = find(father[x]);\r\n    }\r\n\r\n    public UnionFind(int n) {\r\n        // initialize your data structure here.\r\n        father = new int[n];\r\n        for (int i = 0; i < n; ++i) {\r\n            father[i] = i;\r\n        }\r\n    }\r\n\r\n    public void connect(int a, int b) {\r\n        // Write your code here\r\n        int root_a = find(a);\r\n        int root_b = find(b);\r\n        if (root_a != root_b) {\r\n            father[root_a] = root_b;\r\n            count --;\r\n        }\r\n    }\r\n        \r\n    public int query() {\r\n        // Write your code here\r\n        return count;\r\n    }\r\n    \r\n    public void set_count(int total) {\r\n        count = total;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param grid a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    public int numIslands(boolean[][] grid) {\r\n        int count = 0;\r\n        int n = grid.length;\r\n        if (n == 0)\r\n            return 0;\r\n        int m = grid[0].length;\r\n        if (m == 0)\r\n            return 0;\r\n        UnionFind union_find = new UnionFind(n * m);\r\n        \r\n        int total = 0;\r\n        for(int i = 0;i < grid.length; ++i)\r\n            for(int j = 0;j < grid[0].length; ++j)\r\n            if (grid[i][j])\r\n                total ++;\r\n    \r\n        union_find.set_count(total);\r\n        for(int i = 0;i < grid.length; ++i)\r\n            for(int j = 0;j < grid[0].length; ++j)\r\n            if (grid[i][j]) {\r\n                if (i > 0 && grid[i - 1][j]) {\r\n                    union_find.connect(i * m + j, (i - 1) * m + j);\r\n                }\r\n                if (i <  n - 1 && grid[i + 1][j]) {\r\n                    union_find.connect(i * m + j, (i + 1) * m + j);\r\n                }\r\n                if (j > 0 && grid[i][j - 1]) {\r\n                    union_find.connect(i * m + j, i * m + j - 1);\r\n                }\r\n                if (j < m - 1 && grid[i][j + 1]) {\r\n                    union_find.connect(i * m + j, i * m + j + 1);\r\n                }\r\n            }\r\n        return union_find.query();\r\n    }\r\n}\r\n\r\n// version 3: DFS (not recommended)\r\npublic class Solution {\r\n    /**\r\n     * @param grid a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    private int m, n;\r\n    public void dfs(boolean[][] grid, int i, int j) {\r\n        if (i < 0 || i >= m || j < 0 || j >= n) return;\r\n        \r\n        if (grid[i][j]) {\r\n            grid[i][j] = false;\r\n            dfs(grid, i - 1, j);\r\n            dfs(grid, i + 1, j);\r\n            dfs(grid, i, j - 1);\r\n            dfs(grid, i, j + 1);\r\n        }\r\n    }\r\n\r\n    public int numIslands(boolean[][] grid) {\r\n        // Write your code here\r\n        m = grid.length;\r\n        if (m == 0) return 0;\r\n        n = grid[0].length;\r\n        if (n == 0) return 0;\r\n        \r\n        int ans = 0;\r\n        for (int i = 0; i < m; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                if (!grid[i][j]) continue;\r\n                ans++;\r\n                dfs(grid, i, j);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param grid a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    void dfs(vector<vector<bool>> &grid, int x, int y) {\r\n        if (x < 0 || x >= grid.size()) return;\r\n        if (y < 0 || y >= grid[0].size()) return;\r\n        if (!grid[x][y]) return;\r\n        grid[x][y] = false;\r\n        dfs(grid, x + 1, y);\r\n        dfs(grid, x - 1, y);\r\n        dfs(grid, x, y + 1);\r\n        dfs(grid, x, y - 1);\r\n    }\r\n    int numIslands(vector<vector<bool>>& grid) {\r\n        // Write your code here\r\n        if (grid.empty() || grid[0].empty()) return 0;\r\n        int N = grid.size(), M = grid[0].size();\r\n        int cnt = 0;\r\n        for (int i = 0; i < N; ++i) {\r\n            for (int j = 0; j < M; ++j) {\r\n                if (grid[i][j]) {\r\n                    dfs(grid, i, j);\r\n                    ++cnt;\r\n                }\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {boolean[][]} grid a boolean 2D matrix\r\n    # @return {int} an integer\r\n    def numIslands(self, grid):\r\n        # Write your code here\r\n        m = len(grid)\r\n        if m == 0:\r\n            return 0\r\n        n = len(grid[0])\r\n        visit = [[False for i in range(n)]for j in range(m)]\r\n        def check(x, y):\r\n            if x >= 0 and x<m and y>= 0 and y< n and grid[x][y] and visit[x][y] == False:\r\n                return True\r\n        def dfs(x,y):\r\n            nbrow = [1,0,-1,0]\r\n            nbcol = [0,1,0,-1]\r\n            for k in range(4):\r\n                newx = x + nbrow[k]\r\n                newy = y + nbcol[k]\r\n                if check(newx, newy):\r\n                    visit[newx][newy] = True\r\n                    dfs(newx,newy)\r\n        count = 0\r\n        for row in range(m):\r\n            for col in range(n):\r\n                if check(row,col):\r\n                    visit[row][col] = True\r\n                    dfs(row,col)\r\n                    count+=1\r\n        return count\r\n\r\n//bfs\r\nclass Solution:\r\n    # @param {boolean[][]} grid a boolean 2D matrix\r\n    # @return {int} an integer\r\n    def numIslands(self, grid):\r\n        # Write your code here\r\n        m = len(grid)\r\n        if m == 0:\r\n            return 0\r\n        n = len(grid[0])\r\n        visit = [[False for i in range(n)]for j in range(m)]\r\n        def check(x, y):\r\n            if x >= 0 and x<m and y>= 0 and y< n and grid[x][y] and visit[x][y] == False:\r\n                return True\r\n        def bfs(x,y):\r\n            nbrow = [1,0,-1,0]\r\n            nbcol = [0,1,0,-1]\r\n            q=[(x,y)]\r\n            while len(q) > 0:\r\n                x = q[0][0]\r\n                y = q[0][1]\r\n                q.pop(0)\r\n                for k in range(4):\r\n                    newx = x + nbrow[k]\r\n                    newy = y + nbcol[k]\r\n                    if check(newx, newy):\r\n                        visit[newx][newy] = True\r\n                        q.append((newx,newy))\r\n            \r\n        count = 0\r\n        for row in range(m):\r\n            for col in range(n):\r\n                if check(row,col):\r\n                    visit[row][col] = True\r\n                    bfs(row,col)\r\n                    count+=1\r\n        return count"}]},{"id":258,"unique_name":"minimum-size-subarray-sum","title":"和大于S的最小子数组","description":"给定一个由 n 个正整数组成的数组和一个正整数 s ，请找出该数组中满足其和 ≥ s 的最小长度子数组。如果无解，则返回 -1。\n","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: an array of integers\r\n     * @param s: an integer\r\n     * @return: an integer representing the minimum size of subarray\r\n     */\r\n    public int minimumSize(int[] nums, int s) {\r\n        // write your code here\r\n        int j = 0, i = 0;\r\n        int sum =0;\r\n        int ans = Integer.MAX_VALUE;\r\n        for(i = 0; i < nums.length; i++) {\r\n            while(j < nums.length && sum < s) {\r\n                sum += nums[j];\r\n                j ++;\r\n            }\r\n            if(sum >=s) {\r\n                ans = Math.min(ans, j - i);\r\n            }\r\n            sum -= nums[i];\r\n        }\r\n        if(ans == Integer.MAX_VALUE)\r\n            ans = -1;\r\n        return ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: a vector of integers\r\n     * @param s: an integer\r\n     * @return: an integer representing the minimum size of subarray\r\n     */\r\n    int minimumSize(vector<int> &nums, int s) {\r\n        // write your code here\r\n        int n = nums.size();\r\n        if (n==0) return -1;\r\n        int left = 0, right = 0, total = 0, ans = n+1;\r\n        while (right<n) {\r\n            while (right<n && total<s) total += nums[right++];\r\n            if (total<s) break;\r\n            while (left<right && total>=s) total -= nums[left++];\r\n            ans = min(ans, right-left+1);\r\n        }\r\n        if (ans==n+1) return -1;\r\n        else return ans;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n     # @param nums: a list of integers\r\n     # @param s: an integer\r\n     # @return: an integer representing the minimum size of subarray\r\n    def minimumSize(self, nums, s):\r\n        # write your code here\r\n        n = len(nums)\r\n        if n==0: return -1\r\n        left = right = total = 0 \r\n        ans = n+1\r\n        while right<n:\r\n            while right<n and total<s: \r\n                total += nums[right]\r\n                right += 1\r\n            if total<s: break\r\n            while left<right and total>=s:\r\n                total -= nums[left]\r\n                left += 1\r\n            ans = min(ans, right-left+1)\r\n        if ans==n+1: return -1\r\n        else: return ans \r\n"}]},{"id":40,"unique_name":"populating-next-right-pointers-in-each-node-ii","title":"填充每个结点的右结点指针II","description":"<p>给定一棵二叉树：</p><pre>    struct TreeLinkNode {\r\n      TreeLinkNode *left;\r\n      TreeLinkNode *right;\r\n      TreeLinkNode *next;\r\n    }</pre><p>填充每个结点指向其同层右边下一个结点的指针next。如果右边没有下一个结点，则next指针指向NULL。</p><p>初始时，所有的next指针全部指向NULL。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public void connect(TreeLinkNode root) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n\r\n        TreeLinkNode parent = root;\r\n        TreeLinkNode pre;\r\n        TreeLinkNode next;\r\n        while (parent != null) {\r\n            pre = null;\r\n            next = null;\r\n            while (parent != null) {\r\n                if (next == null){\r\n                    next = (parent.left != null) ? parent.left: parent.right;\r\n                }\r\n\r\n                if (parent.left != null){\r\n                    if (pre != null) {\r\n                        pre.next = parent.left;\r\n                        pre = pre.next;\r\n                    } else {\r\n                        pre = parent.left;\r\n                    }\r\n                }\r\n\r\n                if (parent.right != null) {\r\n                    if (pre != null) {\r\n                        pre.next = parent.right;\r\n                        pre = pre.next;\r\n                    } else {\r\n                        pre = parent.right;\r\n                    }\r\n                }\r\n                parent = parent.next;\r\n            }\r\n            parent = next;\r\n        }\r\n    }\r\n}"},{"language":"python","code":"# Definition for binary tree with next pointer.\r\n# class TreeLinkNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def _connect(self, prev, curt):\r\n        if prev is not None:\r\n            prev.next = curt\r\n        \r\n    # @param root, a tree link node\r\n    # @return nothing\r\n    def connect(self, root):\r\n        if root is None:\r\n            return\r\n        \r\n        parent = root\r\n        root.next = None\r\n        while parent is not None:\r\n            last, first = None, None\r\n            while parent is not None:\r\n                for node in [parent.left, parent.right]:\r\n                    if node is None:\r\n                        continue\r\n                    self._connect(last, node)\r\n                    if last is None:\r\n                        first = node\r\n                    last = node\r\n                parent = parent.next\r\n            parent = first"}]},{"id":107,"unique_name":"merge-k-sorted-lists","title":"合并k个排序链表","description":"<p>合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。<br></p>","solutions":[{"language":"java","code":"// version 1: Divide & Conquer\r\n/**\r\n * Definition for ListNode.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int val) {\r\n *         this.val = val;\r\n *         this.next = null;\r\n *     }\r\n * }\r\n */ \r\npublic class Solution {\r\n    /**\r\n     * @param lists: a list of ListNode\r\n     * @return: The head of one sorted list.\r\n     */\r\n    public ListNode mergeKLists(List<ListNode> lists) {\r\n        if (lists.size() == 0) {\r\n            return null;\r\n        }\r\n        return mergeHelper(lists, 0, lists.size() - 1);\r\n    }\r\n    \r\n    private ListNode mergeHelper(List<ListNode> lists, int start, int end) {\r\n        if (start == end) {\r\n            return lists.get(start);\r\n        }\r\n        \r\n        int mid = start + (end - start) / 2;\r\n        ListNode left = mergeHelper(lists, start, mid);\r\n        ListNode right = mergeHelper(lists, mid + 1, end);\r\n        return mergeTwoLists(left, right);\r\n    }\r\n    \r\n    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {\r\n        ListNode dummy = new ListNode(0);\r\n        ListNode tail = dummy;\r\n        while (list1 != null && list2 != null) {\r\n            if (list1.val < list2.val) {\r\n                tail.next = list1;\r\n                tail = list1;\r\n                list1 = list1.next;\r\n            } else {\r\n                tail.next = list2;\r\n                tail = list2;\r\n                list2 = list2.next;\r\n            }\r\n        }\r\n        if (list1 != null) {\r\n            tail.next = list1;\r\n        } else {\r\n            tail.next = list2;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n\r\n// version 2: Heap\r\npublic class Solution {\r\n    private Comparator<ListNode> ListNodeComparator = new Comparator<ListNode>() {\r\n        public int compare(ListNode left, ListNode right) {\r\n            return left.val - right.val;\r\n        }\r\n    };\r\n    \r\n    public ListNode mergeKLists(List<ListNode> lists) {\r\n        if (lists == null || lists.size() == 0) {\r\n            return null;\r\n        }\r\n        \r\n        Queue<ListNode> heap = new PriorityQueue<ListNode>(lists.size(), ListNodeComparator);\r\n        for (int i = 0; i < lists.size(); i++) {\r\n            if (lists.get(i) != null) {\r\n                heap.add(lists.get(i));\r\n            }\r\n        }\r\n        \r\n        ListNode dummy = new ListNode(0);\r\n        ListNode tail = dummy;\r\n        while (!heap.isEmpty()) {\r\n            ListNode head = heap.poll();\r\n            tail.next = head;\r\n            tail = head;\r\n            if (head.next != null) {\r\n                heap.add(head.next);\r\n            }\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n\r\n// Version 3: merge two by two\r\n/**\r\n * Definition for ListNode.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int val) {\r\n *         this.val = val;\r\n *         this.next = null;\r\n *     }\r\n * }\r\n */ \r\npublic class Solution {\r\n    /**\r\n     * @param lists: a list of ListNode\r\n     * @return: The head of one sorted list.\r\n     */\r\n    public ListNode mergeKLists(List<ListNode> lists) {  \r\n        if (lists == null || lists.size() == 0) {\r\n            return null;\r\n        }\r\n        \r\n        while (lists.size() > 1) {\r\n            List<ListNode> new_lists = new ArrayList<ListNode>();\r\n            for (int i = 0; i + 1 < lists.size(); i += 2) {\r\n                ListNode merged_list = merge(lists.get(i), lists.get(i+1));\r\n                new_lists.add(merged_list);\r\n            }\r\n            if (lists.size() % 2 == 1) {\r\n                new_lists.add(lists.get(lists.size() - 1));\r\n            }\r\n            lists = new_lists;\r\n        }\r\n        \r\n        return lists.get(0);\r\n    }\r\n    \r\n    private ListNode merge(ListNode a, ListNode b) {\r\n        ListNode dummy = new ListNode(0);\r\n        ListNode tail = dummy;\r\n        while (a != null && b != null) {\r\n            if (a.val < b.val) {\r\n                tail.next = a;\r\n                a = a.next;\r\n            } else {\r\n                tail.next = b;\r\n                b = b.next;\r\n            }\r\n            tail = tail.next;\r\n        }\r\n        \r\n        if (a != null) {\r\n            tail.next = a;\r\n        } else {\r\n            tail.next = b;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n\r\n\r\n"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param lists: a list of ListNode\r\n     * @return: The head of one sorted list.\r\n     */\r\n    ListNode *mergeKLists(vector<ListNode *> &lists) {\r\n        // write your code here\r\n        ListNode* tmp_node = NULL;\r\n        ListNode* tar_node = NULL;\r\n        ListNode* new_node = NULL;\r\n        ListNode* result = NULL;\r\n        for (int i = 0; i < lists.size(); ++i) {\r\n            tmp_node = lists[i];\r\n            if (NULL == tmp_node) {\r\n                continue;\r\n            }\r\n            if (NULL == result) {\r\n                result = new ListNode(tmp_node->val);\r\n                tmp_node = tmp_node->next;\r\n            } else {\r\n                if (result->val > tmp_node->val) {\r\n                    new_node = new ListNode(tmp_node->val);\r\n                    new_node->next = result;\r\n                    result = new_node;\r\n                    tmp_node = tmp_node->next;\r\n                }\r\n            }\r\n            tar_node = result;\r\n            while (tmp_node != NULL) {\r\n                while (NULL != tar_node->next && tar_node->next->val < tmp_node->val) {\r\n                    tar_node = tar_node->next;\r\n                }\r\n                if (NULL == tar_node->next) {\r\n                    new_node = new ListNode(tmp_node->val);\r\n                    tar_node->next = new_node;\r\n                } else {\r\n                    new_node = new ListNode(tmp_node->val);\r\n                    new_node->next = tar_node->next;\r\n                    tar_node->next = new_node;\r\n                }\r\n                tmp_node = tmp_node->next;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\n\r\n\r\n"},{"language":"python","code":"#version 1\r\nfrom lintcode import ListNode\r\n\r\n\"\"\"\r\nDefinition of ListNode\r\nclass ListNode(object):\r\n\r\n    def __init__(self, val, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param lists: a list of ListNode\r\n    @return: The head of one sorted list.\r\n    \"\"\"\r\n    def mergeKLists(self, lists):\r\n        # write your code here\r\n        self.heap = [[i, lists[i].val] for i in range(len(lists)) if lists[i] != None]\r\n        self.hsize = len(self.heap)\r\n        for i in range(self.hsize - 1, -1, -1):\r\n            self.adjustdown(i)\r\n        nHead = ListNode(0)\r\n        head = nHead\r\n        while self.hsize > 0:\r\n            ind, val = self.heap[0][0], self.heap[0][1]\r\n            head.next = lists[ind]\r\n            head = head.next\r\n            lists[ind] = lists[ind].next\r\n            if lists[ind] is None:\r\n                self.heap[0] = self.heap[self.hsize-1]\r\n                self.hsize = self.hsize - 1\r\n            else:\r\n                self.heap[0] = [ind, lists[ind].val]\r\n            self.adjustdown(0)\r\n        return nHead.next\r\n\r\n    def adjustdown(self, p):\r\n        lc = lambda x: (x + 1) * 2 - 1\r\n        rc = lambda x: (x + 1) * 2\r\n        while True:\r\n            np, pv = p, self.heap[p][1]\r\n            if lc(p) < self.hsize and self.heap[lc(p)][1] < pv:\r\n                np, pv = lc(p), self.heap[lc(p)][1]\r\n            if rc(p) < self.hsize and self.heap[rc(p)][1] < pv:\r\n                np = rc(p)\r\n            if np == p:\r\n                break\r\n            else:\r\n                self.heap[np], self.heap[p] = self.heap[p], self.heap[np]\r\n                p = np\r\n        \r\n        \r\n#version 2\r\nfrom heapq import heappop, heappush\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    @param lists: a list of ListNode\r\n    @return: The head of one sorted list.\r\n    \"\"\"\r\n    def mergeKLists(self, lists):\r\n        if not lists:\r\n            return None\r\n        \r\n        trav = dummy = ListNode(-1)\r\n        heap = []\r\n        for ll in lists:\r\n            if ll:\r\n                self.heappushNode(heap, ll)\r\n                \r\n        while heap:\r\n            node = heappop(heap)[1]\r\n            trav.next = node\r\n            trav = trav.next\r\n            #print(trav.val)\r\n            if trav.next:\r\n                self.heappushNode(heap, trav.next)\r\n                \r\n                    \r\n        return dummy.next\r\n            \r\n    def heappushNode(self, heap, node):\r\n        heappush(heap, (node.val, node))\r\n        \r\n\r\n"}]},{"id":213,"unique_name":"remove-duplicates-from-sorted-array-ii","title":"删除排序数组中的重复数字 II","description":"<p>跟进“删除重复数字”：</p><p>如果可以允许出现两次重复将如何处理？</p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param A: a array of integers\n     * @return : return an integer\n     */\n    public int removeDuplicates(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int index = 0, count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == nums[index]) {\n                if (count < 2) {\n                    nums[++index] = nums[i];\n                    count ++;\n                }\n            } else {\n                nums[++index] = nums[i];\n                count = 1;\n            }\n        }\n        return index + 1;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A: a list of integers\r\n     * @return : return an integer\r\n     */\r\n    int removeDuplicates(vector<int> &nums) {\r\n        // write your code here\r\n        vector <int> B;\r\n        if(nums.size() == 0)\r\n            return 0;\r\n        int before = nums[0] - 1;\r\n        int countb = 0;\r\n        for(int i = 0; i < nums.size(); i++)\r\n        {\r\n            if(before != nums[i])\r\n            {\r\n                 B.push_back(nums[i]);\r\n                 countb = 1;\r\n                 before = nums[i];\r\n            }\r\n            else if(countb < 2 )\r\n            {\r\n                 B.push_back(nums[i]);\r\n                 countb++ ;\r\n                 before = nums[i];\r\n            }\r\n        }\r\n        int len = 0;\r\n        for(int i = 0; i < B.size(); i++)\r\n            nums[len++] = B[i];\r\n        return len;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    # @param A: a list of integers\r\n    # @return an integer\r\n    \"\"\"\r\n    def removeDuplicates(self, A):\r\n        # write your code here\r\n        B = []\r\n        before = None\r\n        countb = 0\r\n        for number in A:\r\n            if(before != number):\r\n                B.append(number)\r\n                before = number\r\n                countb = 1\r\n            elif countb < 2:\r\n                B.append(number)\r\n                countb += 1\r\n        p = 0\r\n        for number in B:\r\n            A[p] = number\r\n            p += 1\r\n        return p\r\n          \r\n"}]},{"id":148,"unique_name":"lowest-common-ancestor","title":"最近公共祖先","description":"<p>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。</p><p>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>","solutions":[{"language":"java","code":"Version : Divide & Conquer\r\n\r\npublic class Solution {\r\n    // 在root为根的二叉树中找A,B的LCA:\r\n    // 如果找到了就返回这个LCA\r\n    // 如果只碰到A，就返回A\r\n    // 如果只碰到B，就返回B\r\n    // 如果都没有，就返回null\r\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {\r\n        if (root == null || root == node1 || root == node2) {\r\n            return root;\r\n        }\r\n        \r\n        // Divide\r\n        TreeNode left = lowestCommonAncestor(root.left, node1, node2);\r\n        TreeNode right = lowestCommonAncestor(root.right, node1, node2);\r\n        \r\n        // Conquer\r\n        if (left != null && right != null) {\r\n            return root;\r\n        } \r\n        if (left != null) {\r\n            return left;\r\n        }\r\n        if (right != null) {\r\n            return right;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: The root of the binary search tree.\r\n     * @param A and B: two nodes in a Binary.\r\n     * @return: Return the least common ancestor(LCA) of the two nodes.\r\n     */\r\n    int Atop, Btop, top;\r\n    TreeNode *a[100000], *b[100000], *ans[100000];\r\n    bool find;\r\n    void inorder(TreeNode *node, TreeNode *A, int flag) { \r\n        if (find==true)\r\n            return;\r\n        if (node == NULL)\r\n            return;\r\n        ans[++top] = node;\r\n        if (A == node) {\r\n            find = true;\r\n            if (flag == 0) {\r\n                Atop = top;\r\n                for (int i = 1; i <= top; ++i)\r\n                    a[i] = ans[i];\r\n            } else {\r\n                Btop = top;\r\n                for (int i = 1; i <= top; ++i)\r\n                    b[i] = ans[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        inorder(node->left, A, flag);\r\n        if (find) return;\r\n            \r\n        inorder(node->right, A, flag);\r\n        if (find) return;\r\n          \r\n        top --;\r\n        \r\n    }\r\n    TreeNode *leastCommonAncestor(TreeNode *root, TreeNode *A, TreeNode *B) {\r\n        // write your code here\r\n        top = 0; find = false;\r\n        inorder(root, A, 0);\r\n\r\n        top = 0; find = false;\r\n        inorder(root, B, 1);\r\n  \r\n        Atop = min(Atop, Btop);\r\n        Btop = Atop;\r\n\r\n        while (a[Atop] != b[Btop]) {\r\n            Atop --;\r\n            Btop --;\r\n        }\r\n        return a[Atop];\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        self.val = val\r\n        self.left, self.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of the binary search tree.\r\n    @param A and B: two nodes in a Binary.\r\n    @return: Return the least common ancestor(LCA) of the two nodes.\r\n    \"\"\" \r\n    def lowestCommonAncestor(self, root, A, B):\r\n        if root is None:\r\n            return None\r\n            \r\n        if root is A or root is B:\r\n            return root\r\n            \r\n        left = self.lowestCommonAncestor(root.left, A, B)\r\n        right = self.lowestCommonAncestor(root.right, A, B)\r\n        \r\n        if left is not None and right is not None:\r\n            return root\r\n        if left is not None:\r\n            return left\r\n        if right is not None:\r\n            return right\r\n        return None\r\n        "}]},{"id":205,"unique_name":"binary-search-tree-iterator","title":"二叉查找树迭代器","description":"设计实现一个带有下列属性的二叉查找树的迭代器：\r\n\r\n- 元素按照递增的顺序被访问（比如中序遍历）\r\n- `next()`和`hasNext()`的询问操作要求**均摊**时间复杂度是O(*1*)","solutions":[{"language":"java","code":"public class BSTIterator {\r\n    private Stack<TreeNode> stack = new Stack<>();\r\n    TreeNode next = null;\r\n    void AddNodeToStack(TreeNode root) {\r\n        while (root != null) {\r\n            stack.push(root);\r\n            root = root.left;\r\n        }\r\n    } \r\n    \r\n    // @param root: The root of binary tree.\r\n    public BSTIterator(TreeNode root) {\r\n        next = root;\r\n    }\r\n\r\n    //@return: True if there has next node, or false\r\n    public boolean hasNext() {\r\n        if (next != null) {\r\n            AddNodeToStack(next);\r\n            next = null;\r\n        }\r\n        return !stack.isEmpty();\r\n    }\r\n    \r\n    //@return: return next node\r\n    public TreeNode next() {\r\n        if (!hasNext()) {\r\n            return null;\r\n        }\r\n        TreeNode cur = stack.pop();\r\n        next = cur.right;\r\n        return cur;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition for binary tree\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass BSTIterator {\r\npublic:\r\n    stack<TreeNode *> myStack;\r\n    TreeNode *current;\r\n    \r\n    BSTIterator(TreeNode *root) {\r\n        while (!myStack.empty()) {\r\n            myStack.pop();\r\n        }\r\n        current = root;\r\n    }\r\n\r\n    /** @return whether we have a next smallest number */\r\n    bool hasNext() {\r\n        return (current != NULL || !myStack.empty());\r\n    }\r\n\r\n    /** @return the next smallest number */\r\n    TreeNode* next() {\r\n        while (current != NULL) {\r\n            myStack.push(current);\r\n            current = current->left;\r\n        }\r\n        current = myStack.top(); myStack.pop();\r\n        TreeNode *nxt = current;\r\n        current = current->right;\r\n        return nxt;\r\n    }\r\n};\r\n\r\n/**\r\n * Your BSTIterator will be called like this:\r\n * BSTIterator i = BSTIterator(root);\r\n * while (i.hasNext()) cout << i.next();\r\n */"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        self.val = val\r\n        self.left, self.right = None, None\r\n\r\nExample of iterate a tree:\r\niterator = BSTIterator(root)\r\nwhile iterator.hasNext():\r\n    node = iterator.next()\r\n    do something for node \r\n\"\"\"\r\nclass BSTIterator:\r\n    #@param root: The root of binary tree.\r\n    def __init__(self, root):\r\n        self.stack = []\r\n        self.curt = root\r\n\r\n    #@return: True if there has next node, or false\r\n    def hasNext(self):\r\n        return self.curt is not None or len(self.stack) > 0\r\n\r\n    #@return: return next node\r\n    def next(self):\r\n        while self.curt is not None:\r\n            self.stack.append(self.curt)\r\n            self.curt = self.curt.left\r\n            \r\n        self.curt = self.stack.pop()\r\n        nxt = self.curt\r\n        self.curt = self.curt.right\r\n        return nxt"}]},{"id":166,"unique_name":"first-bad-version","title":"第一个错误的代码版本","description":"代码库的版本号是从 1 到 *n* 的整数。某一天，有人提交了错误版本的代码，因此造成自身及之后版本的代码在单元测试中均出错。请找出第一个错误的版本号。\r\n\r\n你可以通过 `isBadVersion` 的接口来判断版本号 version 是否在单元测试中出错，具体接口详情和调用方法请见代码的注释部分。","solutions":[{"language":"java","code":"/**\r\n * public class GitRepo {\r\n *     public static boolean isBadVersion(int k);\r\n * }\r\n * you can use GitRepo.isBadVersion(k) to judge whether \r\n * the kth code version is bad or not.\r\n*/\r\nclass Solution {\r\n    /**\r\n     * @param n: An integers.\r\n     * @return: An integer which is the first bad version.\r\n     */\r\n    public int findFirstBadVersion(int n) {\r\n        int start = 1, end = n;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (SVNRepo.isBadVersion(mid)) {\r\n                end = mid;\r\n            } else {\r\n                start = mid;\r\n            }\r\n        }\r\n            \r\n        if (SVNRepo.isBadVersion(start)) {\r\n            return start;\r\n        }\r\n        return end;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"/**\r\n * class SVNRepo {\r\n *     public:\r\n *     static bool isBadVersion(int k);\r\n * }\r\n * you can use SVNRepo::isBadVersion(k) to judge whether \r\n * the kth code version is bad or not.\r\n*/\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param n: An integers.\r\n     * @return: An integer which is the first bad version.\r\n     */\r\n    int findFirstBadVersion(int n) {\r\n        int start = 1, end = n;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (SVNRepo::isBadVersion(mid)) {\r\n                end = mid;\r\n            } else {\r\n                start = mid;\r\n            }\r\n        }\r\n        \r\n        if (SVNRepo::isBadVersion(start)) {\r\n            return start;\r\n        }\r\n        return end;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param n: An integers.\r\n    @return: An integer which is the first bad version.\r\n    \"\"\"\r\n    def findFirstBadVersion(self, n):\r\n        start, end = 1, n\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            if SVNRepo.isBadVersion(mid):\r\n                end = mid\r\n            else:\r\n                start = mid\r\n        if SVNRepo.isBadVersion(start):\r\n            return start\r\n        return end\r\n"}]},{"id":55,"unique_name":"binary-tree-level-order-traversal","title":"二叉树的层次遍历","description":"给出一棵二叉树，返回其节点值的层次遍历（逐层从左往右访问）","solutions":[{"language":"java","code":"// version 1: BFS\r\npublic class Solution {\r\n    public List<List<Integer>> levelOrder(TreeNode root) {\r\n        List result = new ArrayList();\r\n\r\n        if (root == null) {\r\n            return result;\r\n        }\r\n\r\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n        queue.offer(root);\r\n\r\n        while (!queue.isEmpty()) {\r\n            ArrayList<Integer> level = new ArrayList<Integer>();\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode head = queue.poll();\r\n                level.add(head.val);\r\n                if (head.left != null) {\r\n                    queue.offer(head.left);\r\n                }\r\n                if (head.right != null) {\r\n                    queue.offer(head.right);\r\n                }\r\n            }\r\n            result.add(level);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// version 2:  DFS\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: Level order a list of lists of integer\r\n     */\r\n    public List<List<Integer>> levelOrder(TreeNode root) {\r\n        List<List<Integer>> results = new ArrayList<List<Integer>>();\r\n        \r\n        if (root == null) {\r\n            return results;\r\n        }\r\n        \r\n        int maxLevel = 0;\r\n        while (true) {\r\n            List<Integer> level = new ArrayList<Integer>();\r\n            dfs(root, level, 0, maxLevel);\r\n            if (level.size() == 0) {\r\n                break;\r\n            }\r\n            \r\n            results.add(level);\r\n            maxLevel++;\r\n        }\r\n        \r\n        return results;\r\n    }\r\n    \r\n    private void dfs(TreeNode root,\r\n                     List<Integer> level,\r\n                     int curtLevel,\r\n                     int maxLevel) {\r\n        if (root == null || curtLevel > maxLevel) {\r\n            return;\r\n        }\r\n        \r\n        if (curtLevel == maxLevel) {\r\n            level.add(root.val);\r\n            return;\r\n        }\r\n        \r\n        dfs(root.left, level, curtLevel + 1, maxLevel);\r\n        dfs(root.right, level, curtLevel + 1, maxLevel);\r\n    }\r\n}\r\n\r\n\r\n// version 3: BFS. two queues\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: Level order a list of lists of integer\r\n     */\r\n    public List<List<Integer>> levelOrder(TreeNode root) {\r\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\r\n        if (root == null) {\r\n            return result;\r\n        }\r\n        \r\n        List<TreeNode> Q1 = new ArrayList<TreeNode>();\r\n        List<TreeNode> Q2 = new ArrayList<TreeNode>();\r\n\r\n        Q1.add(root);\r\n        while (Q1.size() != 0) {\r\n            List<Integer> level = new ArrayList<Integer>();\r\n            Q2.clear();\r\n            for (int i = 0; i < Q1.size(); i++) {\r\n                TreeNode node = Q1.get(i);\r\n                level.add(node.val);\r\n                if (node.left != null) {\r\n                    Q2.add(node.left);\r\n                }\r\n                if (node.right != null) {\r\n                    Q2.add(node.right);\r\n                }\r\n            }\r\n            \r\n            // swap q1 and q2\r\n            List<TreeNode> temp = Q1;\r\n            Q1 = Q2;\r\n            Q2 = temp;\r\n            \r\n            // add to result\r\n            result.add(level);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n// version 4: BFS, queue with dummy node\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: Level order a list of lists of integer\r\n     */\r\n    public List<List<Integer>> levelOrder(TreeNode root) {\r\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\r\n        if (root == null) {\r\n            return result;\r\n        }\r\n        \r\n        Queue<TreeNode> Q = new LinkedList<TreeNode>();\r\n        Q.offer(root);\r\n        Q.offer(null); // dummy node\r\n        \r\n        List<Integer> level = new ArrayList<Integer>();\r\n        while (!Q.isEmpty()) {\r\n            TreeNode node = Q.poll();\r\n            if (node == null) {\r\n                if (level.size() == 0) {\r\n                    break;\r\n                }\r\n                result.add(level);\r\n                level = new ArrayList<Integer>();\r\n                Q.offer(null); // add a new dummy node\r\n                continue;\r\n            }\r\n            \r\n            level.add(node.val);\r\n            if (node.left != null) {\r\n                Q.offer(node.left);\r\n            }\r\n            if (node.right != null) {\r\n                Q.offer(node.right);\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\n \r\n \r\nclass Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: Level order a list of lists of integer\r\n     */\r\npublic:\r\n    vector<vector<int>> levelOrder(TreeNode *root) {\r\n        vector<vector<int>> result;\r\n        if (root == NULL) {\r\n            return result;\r\n        }\r\n        \r\n        queue<TreeNode *> Q;\r\n        Q.push(root);\r\n        while (!Q.empty()) {\r\n            int size = Q.size();\r\n            vector<int> level;\r\n            \r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode *head = Q.front(); Q.pop();\r\n                level.push_back(head->val);\r\n                if (head->left != NULL) {\r\n                    Q.push(head->left);\r\n                }\r\n                if (head->right != NULL) {\r\n                    Q.push(head->right);\r\n                }\r\n            }\r\n            \r\n            result.push_back(level);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"from lintcode import TreeNode\r\n\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: Level order in a list of lists of integers\r\n    \"\"\"\r\n    def levelOrder(self, root):\r\n        # write your code here\r\n        self.results = []\r\n        if not root:\r\n            return self.results\r\n        q = [root]\r\n        while q:\r\n            new_q = []\r\n            self.results.append([n.val for n in q])\r\n            for node in q:\r\n                if node.left:\r\n                    new_q.append(node.left)\r\n                if node.right:\r\n                    new_q.append(node.right)\r\n            q = new_q\r\n        return self.results"}]},{"id":143,"unique_name":"merge-sorted-array","title":"合并排序数组","description":"合并两个排序的整数数组A和B变成一个新的数组。","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * @param A: sorted integer array A which has m elements, \r\n     *           but size of A is m+n\r\n     * @param B: sorted integer array B which has n elements\r\n     * @return: void\r\n     */\r\n    public void mergeSortedArray(int[] A, int m, int[] B, int n) {\r\n        int i = m-1, j = n-1, index = m + n - 1;\r\n        while (i >= 0 && j >= 0) {\r\n            if (A[i] > B[j]) {\r\n                A[index--] = A[i--];\r\n            } else {\r\n                A[index--] = B[j--];\r\n            }\r\n        }\r\n        while (i >= 0) {\r\n            A[index--] = A[i--];\r\n        }\r\n        while (j >= 0) {\r\n            A[index--] = B[j--];\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A: sorted integer array A which has m elements, \r\n     *           but size of A is m+n\r\n     * @param B: sorted integer array B which has n elements\r\n     * @return: void\r\n     */\r\n    void mergeSortedArray(int A[], int m, int B[], int n) {\r\n        int pos = m + n - 1 , i = m - 1 , j = n - 1;\r\n        while (i >= 0 && j >= 0)\r\n            A[pos--] = A[i] > B[j] ? A[i--] : B[j--];\r\n        while (i >= 0)\r\n            A[pos--] = A[i--];\r\n        while (j >= 0)\r\n            A[pos--] = B[j--];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    #@param A: sorted integer array A which has m elements, \r\n    #          but size of A is m+n\r\n    #@param B: sorted integer array B which has n elements\r\n    #@return: void\r\n    def mergeSortedArray(self, A, m, B, n):\r\n        for i in range(n):\r\n            A[i+m] = B[i]\r\n        A.sort()"}]},{"id":97,"unique_name":"search-in-rotated-sorted-array","title":"搜索旋转排序数组","description":"<p><span style=\"line-height: 1.42857143;\">假设有一个排序的</span><span style=\"line-height: 1.42857143;\">按未知的旋转轴旋转的</span><span style=\"line-height: 1.42857143;\">数组(比如，</span><b style=\"line-height: 1.42857143;\"><font color=\"#e76363\">0 1 2 4 5 6 7</font></b><span style=\"line-height: 1.42857143;\"> 可能成为</span><font color=\"#e76363\" style=\"line-height: 1.42857143;\"><b>4 5 6 7 0 1 2</b></font><span style=\"line-height: 1.42857143;\">)。给定一个目标值进行搜索，如果在数组中找到目标值返回数组中的索引位置，否则返回-1。</span></p><p>你可以假设数组中不存在重复的元素。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int search(int[] A, int target) {\r\n        if (A == null || A.length == 0) {\r\n            return -1;\r\n        }\r\n\r\n        int start = 0;\r\n        int end = A.length - 1;\r\n        int mid;\r\n        \r\n        while (start + 1 < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (A[mid] == target) {\r\n                return mid;\r\n            }\r\n            if (A[start] < A[mid]) {\r\n                // situation 1, red line\r\n                if (A[start] <= target && target <= A[mid]) {\r\n                    end = mid;\r\n                } else {\r\n                    start = mid;\r\n                }\r\n            } else {\r\n                // situation 2, green line\r\n                if (A[mid] <= target && target <= A[end]) {\r\n                    start = mid;\r\n                } else {\r\n                    end = mid;\r\n                }\r\n            }\r\n        } // while\r\n        \r\n        if (A[start] == target) {\r\n            return start;\r\n        }\r\n        if (A[end] == target) {\r\n            return end;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <vector>\n\nusing namespace std;\n\nclass Solution {\n    /** \n     * param A : an integer ratated sorted array\n     * param target :  an integer to be searched\n     * return : an integer\n     */\nprivate:\nint find(vector<int> &A, int l, int r, int target) {\n        if (l > r) {\n            return -1;\n        }\n        int idx = -1;\n        if (A[l] <= A[r]) {\n            int left = l, right = r, mid = 0;\n            while (left <= right) {\n                mid = (left + right) >> 1;\n                if (A[mid] == target) {\n                    idx = mid;\n                    break;\n                }\n                else if (A[mid] > target) {\n                    right = mid - 1;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n        }\n        else {\n            int mid = (l + r) >> 1;\n            if (A[mid] == target) {\n                idx = mid;\n            }\n            else {\n                idx = find(A, l, mid - 1, target);\n                idx = idx == -1 ? find(A, mid + 1, r, target) : idx;               \n            }\n        }        \n        return idx;\n}\npublic:\n    int search(vector<int> &A, int target) {\n        // write your code here\n        int n = A.size();\n        return find(A,0,n-1,target);\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param A : a list of integers\n    @param target : an integer to be searched\n    @return : an integer\n    \"\"\"\n    def search(self, A, target):\n        # write your code here\n        l, h = 0, len(A) - 1\n        while (l <= h):\n            m = l + ((h - l) >> 1)\n            if A[m] == target:\n                return m\n            elif (A[m] > A[l] and target < A[m] and target >= A[l]) or (A[m] < A[l] and not (target <= A[h] and target > A[m])):\n                h = m - 1\n            else:\n                l = m + 1\n        return -1"},{"language":"javascript","code":"/**\n * @param A: an integer rotated sorted array\n * @param target: an integer to be searched\n * @return: an integer\n */\nconst search = function (A, target) {\n    if (A === null || A.length === 0) {\n        return -1;\n    }\n    var start = 0;\n    var end = A.length - 1;\n    var mid;\n    while (start + 1 < end) {\n        mid = start + Math.floor((end - start) / 2);\n        if (A[mid] === target) {\n            return mid;\n        }\n        if (A[start] < A[mid]) {\n            if (A[start] <= target && target <= A[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        } else {\n            if (A[mid] <= target && target <= A[end]) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n    }\n    if (A[start] === target) {\n        return start;\n    }\n    if (A[end] === target) {\n        return end;\n    }\n    return -1;\n}"}]},{"id":128,"unique_name":"two-sum","title":"两数之和","description":"给一个整数数组，找到两个数使得他们的和等于一个给定的数 *target*。\n\n你需要实现的函数`twoSum`需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 *n-1*。\n","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param numbers : An array of Integer\n     * @param target : target = numbers[index1] + numbers[index2]\n     * @return : [index1 + 1, index2 + 1] (index1 < index2)\n         numbers=[2, 7, 11, 15],  target=9\n         return [1, 2]\n     */\n    public int[] twoSum(int[] numbers, int target) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n\n        for (int i = 0; i < numbers.length; i++) {\n            if (map.get(numbers[i]) != null) {\n                int[] result = {map.get(numbers[i]), i};\n                return result;\n            }\n            map.put(target - numbers[i], i);\n        }\n        \n        int[] result = {};\n        return result;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // hash[i]表示nums中数值为i的下标\n        unordered_map<int, int> hash;\n        vector<int> result;\n\n        // 一边循环每个数，一边加入hash表。\n        for (int i = 0; i < nums.size(); i++) {\n            if (hash.find(target - nums[i]) != hash.end()) {\n                // target - nums[i]的下标更小，放在前面\n                result.push_back(hash[target - nums[i]]);\n                result.push_back(i);\n                return result;\n            }\n            hash[nums[i]] = i;\n        }\n\n        // 无解的情况\n        result.push_back(-1);\n        result.push_back(-1);\n        return result;\n    }\n};"},{"language":"python","code":"class Solution(object):\n    def twoSum(self, nums, target):\n        #hash用于建立数值到下标的映射\n        hash = {}\n        #循环nums数值，并添加映射\n        for i in range(len(nums)):\n            if target - nums[i] in hash:\n                return [hash[target - nums[i]], i]\n            hash[nums[i]] = i\n        #无解的情况\n        return [-1, -1]"},{"language":"javascript","code":"/**\n * @param numbers: An array of Integer\n * @param target: target = numbers[index1] + numbers[index2]\n * @return: [index1 + 1, index2 + 1] (index1 < index2)\n */\nconst twoSum = function (numbers, target) {\n    var map = []\n    var i;\n    var res;\n    for (i = 0; i < numbers.length; i++) {\n        if (map.hasOwnProperty(numbers[i])) {\n            res = [];\n            res[0] = map[numbers[i]];\n            res[1] = i;\n            return res;\n        }\n        map[target - numbers[i]] = i;\n    }\n    res = [];\n    return res;\n}"}]},{"id":31,"unique_name":"subsets","title":"子集","description":"给定一个含不同整数的集合，返回其所有的子集","solutions":[{"language":"java","code":"// 递归：实现方式，一种实现DFS算法的一种方式\nclass Solution {\n    /**\n     * @param S: A set of numbers.\n     * @return: A list of lists. All valid subsets.\n     */\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n        \n        if (nums == null) {\n            return results;\n        }\n        \n        if (nums.length == 0) {\n            results.add(new ArrayList<Integer>());\n            return results;\n        }\n        \n        Arrays.sort(nums);\n        helper(new ArrayList<Integer>(), nums, 0, results);\n        return results;\n    }\n    \n    \n    // 递归三要素\n    // 1. 递归的定义：在 Nums 中找到所有以 subset 开头的的集合，并放到 results\n    private void helper(ArrayList<Integer> subset,\n                        int[] nums,\n                        int startIndex,\n                        List<List<Integer>> results) {\n        // 2. 递归的拆解\n        // deep copy\n        // results.add(subset);\n        results.add(new ArrayList<Integer>(subset));\n        \n        for (int i = startIndex; i < nums.length; i++) {\n            // [1] -> [1,2]\n            subset.add(nums[i]);\n            // 寻找所有以 [1,2] 开头的集合，并扔到 results\n            helper(subset, nums, i + 1, results);\n            // [1,2] -> [1]  回溯\n            subset.remove(subset.size() - 1);\n        }\n        \n        // 3. 递归的出口\n        // return;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\n private:\r\n    void helper(vector<vector<int> > &results,\r\n                vector<int> &subset,\r\n                vector<int> &nums,\r\n                int start) {\r\n        results.push_back(subset);\r\n        \r\n        for (int i = start; i < nums.size(); i++) {\r\n            subset.push_back(nums[i]);\r\n            helper(results, subset, nums, i + 1);\r\n            subset.pop_back();\r\n        }\r\n    }\r\n    \r\n public:\r\n    vector<vector<int> > subsets(vector<int> &nums) {\r\n        vector<vector<int> > results;\r\n        vector<int> subset;\r\n\r\n        sort(nums.begin(), nums.end());\r\n        helper(results, subset, nums, 0);\r\n\r\n        return results;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    \r\n    def search(self, nums, S, index):\r\n        if index == len(nums):\r\n            self.results.append(S)\r\n            return\r\n        \r\n        self.search(nums, S + [nums[index]], index + 1)\r\n        self.search(nums, S, index + 1)\r\n        \r\n    def subsets(self, nums):\r\n        self.results = []\r\n        self.search(sorted(nums), [], 0)\r\n        return self.results"}]},{"id":102,"unique_name":"implement-strstr","title":"字符串查找","description":"对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 `-1`。","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * Returns a index to the first occurrence of target in source,\r\n     * or -1  if target is not part of source.\r\n     * @param source string to be scanned.\r\n     * @param target string containing the sequence of characters to match.\r\n     */\r\n    public int strStr(String source, String target) {\r\n        if (source == null || target == null) {\r\n            return -1;\r\n        }\r\n        \r\n        for (int i = 0; i < source.length() - target.length() + 1; i++) {\r\n            int j = 0;\r\n            for (j = 0; j < target.length(); j++) {\r\n                if (source.charAt(i + j) != target.charAt(j)) {\r\n                    break;\r\n                }\r\n            }\r\n            // finished loop, target found\r\n            if (j == target.length()) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int strStr(string source, string  target) {\r\n        int i, j, lenh = source.length(), lenn =  target.length();\r\n        if (lenn == 0)  return 0;\r\n        for (i = 0; i <= lenh - lenn; i++) {\r\n            for (j = 0; j < lenn; j++) \r\n                if (source[i + j] !=  target[j]) break;\r\n            // 匹配成功\r\n            if (j == lenn)  return i;\r\n        }\r\n        return -1;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    def strStr(self, source, target):\r\n        if source is None or target is None:\r\n            return -1\r\n        len_s = len(source)\r\n        len_t = len(target)\r\n        for i in range(len_s - len_t + 1):\r\n            j = 0\r\n            while (j < len_t):\r\n                if source[i + j] != target[j]:\r\n                    break\r\n                j += 1\r\n            if j == len_t:\r\n                return i\r\n        return -1"}]},{"id":22,"unique_name":"clone-graph","title":"克隆图","description":"克隆一张无向图，图中的每个节点包含一个 `label` 和一个列表 `neighbors`。\r\n\r\n数据中如何表示一个无向图？[http://www.lintcode.com/help/graph/](http://www.lintcode.com/help/graph/ \"\")\r\n\r\n你的程序需要返回一个经过深度拷贝的新图。这个新图和原图具有同样的结构，并且对新图的任何改动不会对原图造成任何影响。","solutions":[{"language":"java","code":"/**\n * Definition for undirected graph.\n * class UndirectedGraphNode {\n *     int label;\n *     ArrayList<UndirectedGraphNode> neighbors;\n *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n * };\n */\npublic class Solution {\n    /**\n     * @param node: A undirected graph node\n     * @return: A undirected graph node\n     */\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null) {\n            return node;\n        }\n\n        // use bfs algorithm to traverse the graph and get all nodes.\n        ArrayList<UndirectedGraphNode> nodes = getNodes(node);\n        \n        // copy nodes, store the old->new mapping information in a hash map\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> mapping = new HashMap<>();\n        for (UndirectedGraphNode n : nodes) {\n            mapping.put(n, new UndirectedGraphNode(n.label));\n        }\n        \n        // copy neighbors(edges)\n        for (UndirectedGraphNode n : nodes) {\n            UndirectedGraphNode newNode = mapping.get(n);\n            for (UndirectedGraphNode neighbor : n.neighbors) {\n                UndirectedGraphNode newNeighbor = mapping.get(neighbor);\n                newNode.neighbors.add(newNeighbor);\n            }\n        }\n        \n        return mapping.get(node);\n    }\n    \n    private ArrayList<UndirectedGraphNode> getNodes(UndirectedGraphNode node) {\n        Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();\n        HashSet<UndirectedGraphNode> set = new HashSet<>();\n        \n        queue.offer(node);\n        set.add(node);\n        while (!queue.isEmpty()) {\n            UndirectedGraphNode head = queue.poll();\n            for (UndirectedGraphNode neighbor : head.neighbors) {\n                if(!set.contains(neighbor)){\n                    set.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return new ArrayList<UndirectedGraphNode>(set);\n    }\n}"},{"language":"cpp","code":"/**\n * Definition for undirected graph.\n * struct UndirectedGraphNode {\n *     int label;\n *     vector<UndirectedGraphNode *> neighbors;\n *     UndirectedGraphNode(int x) : label(x) {};\n * };\n */\n// BFS 版本的解法\n/**\n * Definition for undirected graph.\n * struct UndirectedGraphNode {\n *     int label;\n *     vector<UndirectedGraphNode *> neighbors;\n *     UndirectedGraphNode(int x) : label(x) {};\n * };\n */\n\n\nclass Solution {\npublic:\n    /*\n     * @param node: A undirected graph node\n     * @return: A undirected graph node\n     */\n    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {\n        if (!node) {\n            return nullptr;\n        }\n        UndirectedGraphNode *p1 = node;\n        UndirectedGraphNode *p2 = new UndirectedGraphNode(node->label);\n        unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> map;\n        queue<UndirectedGraphNode*> q;        \n        q.push(node);\n        map[node] = p2;\n        \n        while(!q.empty()) {\n            p1 = q.front(); p2 = map[p1];\n            q.pop();\n            for(int i=0; i<p1->neighbors.size(); i++) {\n                UndirectedGraphNode *nb = p1->neighbors[i];\n                if(map.count(nb)) {\n                    p2->neighbors.push_back(map[nb]);\n                } else {\n                    UndirectedGraphNode *temp = new UndirectedGraphNode(nb->label);\n                    p2->neighbors.push_back(temp);\n                    map[nb] = temp;\n                    q.push(nb);\n                }\n            }\n        }\n        \n        return map[node];\n    }\n};\n\n// DFS 版本的解法\nclass Solution {\npublic:\n    UndirectedGraphNode *clone(UndirectedGraphNode *node, map<int,UndirectedGraphNode*> &table)\n    {\n        if(node==NULL)\n            return NULL;\n            \n        if(table.find(node->label)!=table.end())\n            return table[node->label];\n        \n        UndirectedGraphNode *newnode=new UndirectedGraphNode(node->label);\n        table[newnode->label]=newnode;\n\n        for(int i=0;i<node->neighbors.size();i++)\n        {\n            UndirectedGraphNode *neighbor=clone(node->neighbors[i],table);\n            newnode->neighbors.push_back(neighbor);\n        }\n        \n        return newnode;\n    }\n    /**\n     * @param node: A undirected graph node\n     * @return: A undirected graph node\n     */\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n        map<int,UndirectedGraphNode*> visitTable;\n        return clone(node,visitTable);\n    }\n};"},{"language":"python","code":"// version 1\r\nclass Solution:\r\n    def cloneGraph(self, node):\r\n        root = node\r\n        if node is None:\r\n            return node\r\n            \r\n        # use bfs algorithm to traverse the graph and get all nodes.\r\n        nodes = self.getNodes(node)\r\n        \r\n        # copy nodes, store the old->new mapping information in a hash map\r\n        mapping = {}\r\n        for node in nodes:\r\n            mapping[node] = UndirectedGraphNode(node.label)\r\n        \r\n        # copy neighbors(edges)\r\n        for node in nodes:\r\n            new_node = mapping[node]\r\n            for neighbor in node.neighbors:\r\n                new_neighbor = mapping[neighbor]\r\n                new_node.neighbors.append(new_neighbor)\r\n        \r\n        return mapping[root]\r\n        \r\n    def getNodes(self, node):\r\n        q = collections.deque([node])\r\n        result = set([node])\r\n        while q:\r\n            head = q.popleft()\r\n            for neighbor in head.neighbors:\r\n                if neighbor not in result:\r\n                    result.add(neighbor)\r\n                    q.append(neighbor)\r\n        return result\r\n\r\n// version 2\r\n# Definition for a undirected graph node\r\n# class UndirectedGraphNode:\r\n#     def __init__(self, x):\r\n#         self.label = x\r\n#         self.neighbors = []\r\nclass Solution:\r\n    # @param node, a undirected graph node\r\n    # @return a undirected graph node\r\n    def __init__(self):\r\n        self.dict = {}\r\n        \r\n    def cloneGraph(self, node):\r\n        if node == None:\r\n            return None\r\n        if node.label in self.dict:\r\n            return self.dict[node.label]\r\n        root = UndirectedGraphNode(node.label)\r\n        self.dict[node.label] = root\r\n        for item in node.neighbors:\r\n            root.neighbors.append(self.cloneGraph(item))\r\n        return root"}]},{"id":105,"unique_name":"reverse-nodes-in-k-group","title":"K组翻转链表","description":"给你一个链表以及一个*k*,将这个链表从头指针开始每*k*个翻转一下。\r\n链表元素个数不是*k*的倍数，最后剩余的不用翻转。","solutions":[{"language":"java","code":"// version 1:\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @param k an integer\r\n     * @return a ListNode\r\n     */\r\n    public ListNode reverseKGroup(ListNode head, int k) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        head = dummy;\r\n        while (true) {\r\n            head = reverseK(head, k);\r\n            if (head == null) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n    \r\n    // head -> n1 -> n2 ... nk -> nk+1\r\n    // =>\r\n    // head -> nk -> nk-1 .. n1 -> nk+1\r\n    // return n1\r\n    public ListNode reverseK(ListNode head, int k) {\r\n        ListNode nk = head;\r\n        for (int i = 0; i < k; i++) {\r\n            if (nk == null) {\r\n                return null;\r\n            }\r\n            nk = nk.next;\r\n        }\r\n        \r\n        if (nk == null) {\r\n            return null;\r\n        }\r\n        \r\n        // reverse        \r\n        ListNode n1 = head.next;\r\n        ListNode nkplus = nk.next; \r\n        \r\n        ListNode prev = null;\r\n        ListNode curt = n1;\r\n        while (curt != nkplus) {\r\n            ListNode temp = curt.next;\r\n            curt.next = prev;\r\n            prev = curt;\r\n            curt = temp;\r\n        }\r\n        \r\n        // connect\r\n        head.next = nk;\r\n        n1.next = nkplus;\r\n        return n1;\r\n    }\r\n}\r\n\r\n// version 2:\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @param k an integer\r\n     * @return a ListNode\r\n     */\r\n    public ListNode reverseKGroup(ListNode head, int k) {\r\n        if (head == null || k <= 1) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        head = dummy;\r\n        while (head.next != null) {\r\n            head = reverseNextK(head, k);\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n    \r\n    // reverse head->n1->..->nk->next..\r\n    // to head->nk->..->n1->next..\r\n    // return n1\r\n    private ListNode reverseNextK(ListNode head, int k) {\r\n        // check there is enought nodes to reverse\r\n        ListNode next = head; // next is not null\r\n        for (int i = 0; i < k; i++) {\r\n            if (next.next == null) {\r\n                return next;\r\n            }\r\n            next = next.next;\r\n        }\r\n        \r\n        // reverse\r\n        ListNode n1 = head.next;\r\n        ListNode prev = head, curt = n1;\r\n        for (int i = 0; i < k; i++) {\r\n            ListNode temp = curt.next;\r\n            curt.next = prev;\r\n            prev = curt;\r\n            curt = temp;\r\n        }\r\n        \r\n        n1.next = curt;\r\n        head.next = prev;\r\n        return n1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"// version 1\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* reverseKGroup(ListNode* head, int k) {\r\n        ListNode *dummy = new ListNode(0);\r\n        dummy->next = head;\r\n        head = dummy;\r\n        while (head->next != NULL) {\r\n            head = reverseKNodes(head, k);\r\n        }\r\n        return dummy->next;\r\n    }\r\n    \r\n    // reverse the next k nodes AFTER head: head->n1->n2..->nk->.. => head->nk->nk-1...->n1->..\r\n    // return n1 (the next head)\r\n    ListNode *reverseKNodes(ListNode *head, int k) {\r\n        ListNode *node = head;\r\n        for (int i = 0; i < k; i++) {\r\n            if (node->next == NULL) {\r\n                return node;\r\n            }\r\n            node = node->next;\r\n        }\r\n        \r\n        ListNode *n1 = head->next;\r\n        ListNode *curt = n1;\r\n        ListNode *next = curt->next;\r\n        for (int i = 0; i < k - 1; i++) {\r\n            if (next == NULL) {\r\n                n1->next = NULL;\r\n                break;\r\n            }\r\n            ListNode *temp = next->next;\r\n            next->next = curt;\r\n            curt = next;\r\n            next = temp;\r\n        }\r\n        head->next = curt;\r\n        n1->next = next;\r\n        return n1;\r\n    }\r\n};\r\n\r\n\r\n// version 2\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    // p1->p1next->...->p2->p2next\r\n    //      |____________|\r\n    //   reverse this part to:\r\n    // p1->p2->.......->p1next->p2next;\r\n    // return p1next;\r\n    ListNode *reverse(ListNode *p1, ListNode *p2) {\r\n        ListNode *p1next = p1->next;\r\n        ListNode *p2next = p2->next;\r\n        ListNode *prev = p2next;\r\n        ListNode *p = p1next; \r\n        \r\n        while (p != p2next) {\r\n            ListNode *temp = p ->next;\r\n            p->next = prev;\r\n            prev = p;\r\n            p = temp;\r\n        }\r\n        p1->next = p2;\r\n        return p1next;\r\n    }\r\n    \r\n    ListNode* reverseKGroup(ListNode* head, int k) {\r\n        if (k == 1) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode *dummy = new ListNode(0);\r\n        dummy->next = head;\r\n        \r\n        ListNode *p1 = dummy, *p2 = dummy;\r\n        \r\n        for (int i = 0; i < k; i++) {\r\n            if (p2 == NULL) {\r\n                break;\r\n            }\r\n            p2 = p2->next;\r\n        }\r\n        if (p2 == NULL) {\r\n            return head;\r\n        }\r\n        \r\n        while (p2 != NULL) {\r\n            p2 = reverse(p1, p2);\r\n            for (int i = 0; i < k; i++) {\r\n                if (p2 == NULL) {\r\n                    break;\r\n                }\r\n                p1 = p1->next;\r\n                p2 = p2->next;\r\n            }\r\n        }\r\n        \r\n        return dummy->next;\r\n    }\r\n};"},{"language":"python","code":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    # @param head, a ListNode\r\n    # @param k, an integer\r\n    # @return a ListNode\r\n    def reverse(self, start, end):\r\n        # Write your code here\r\n        newhead=ListNode(0); newhead.next=start\r\n        while newhead.next!=end:\r\n            tmp=start.next\r\n            start.next=tmp.next\r\n            tmp.next=newhead.next\r\n            newhead.next=tmp\r\n        return [end, start]\r\n    def reverseKGroup(self, head, k):\r\n        if head==None: return None\r\n        nhead=ListNode(0); nhead.next=head; start=nhead\r\n        while start.next:\r\n            end=start\r\n            for i in range(k-1):\r\n                end=end.next\r\n                if end.next==None: return nhead.next\r\n            res=self.reverse(start.next, end.next)\r\n            start.next=res[0]\r\n            start=res[1]\r\n        return nhead.next"}]},{"id":2,"unique_name":"pow-x-n","title":"x的n次幂","description":"实现 pow(x,n)","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param x the base number\n     * @param n the power number\n     * @return the result\n     */\n    public double myPow(double x, int n) {\n        // Write your code here\n        if (n == 0) {\n            return 1;\n        }\n\n        if (n == 1) {\n            return x;\n        }\n\n        boolean isNegative = false;\n        if (n < 0) {\n            isNegative = true;\n        }\n\n        int k = n / 2;\n        int l = n - k * 2;\n        double t1 = myPow(x, Math.abs(k));\n        double t2 = myPow(x, Math.abs(l));\n        if (isNegative) {\n            return 1 / (t1 * t1 * t2);\n        } else {\n            return t1 * t1 * t2;\n        }\n    }\n}\n\n\npublic class Solution {\n    /**\n     * @param x the base number\n     * @param n the power number\n     * @return the result\n     */\n    public double myPow(double x, int n) {\n        // Write your code here\n        boolean isNegative = false;\n        if (n < 0) {\n            x = 1 / x;\n            isNegative = true;\n            n = -(n + 1); // Avoid overflow when n == MIN_VALUE\n        }\n\n        double ans = 1, tmp = x; \n\n        while (n != 0) {\n            if (n % 2 == 1) {\n                ans *= tmp;\n            }\n            tmp *= tmp;\n            n /= 2;\n        }\n        \n        if (isNegative) {\n            ans *= x;\n        }\n        return ans;\n    }\n}\n\n// version: 高频题班\npublic class Solution {\n    /**\n     * @param x the base number\n     * @param n the power number\n     * @return the result\n     */\n    public double myPow(double x, long n) { \n        // Write your code here\n        if (n < 0) {\n            x = 1 / x;\n            n = -n;\n        }\n\n        double ans = 1, tmp = x;\n\n        while (n != 0) {\n            if (n % 2 == 1) {\n                ans *= tmp;\n            }\n            tmp *= tmp;\n            n /= 2;\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param x the base number\r\n     * @param n the power number\r\n     * @return the result\r\n     */\r\n    public:\r\n    double myPow(double x, int n) {\r\n        if (n < 0) return 1.0 / power(x, -n);\r\n        else return power(x, n);\r\n    }\r\nprivate:\r\n    double power(double x, int n) {\r\n        if (n == 0) return 1;\r\n        double v = power(x, n / 2);\r\n        if (n % 2 == 0) return v * v;\r\n        else return v * v * x;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {double} x the base number\r\n    # @param {int} n the power number\r\n    # @return {double} the result\r\n    def myPow(self, x, n):\r\n        # Write your code here\r\n        if n < 0 :\r\n            x = 1 / x\r\n            n = -n\r\n\r\n        ans = 1\r\n        tmp = x\r\n\r\n        while n != 0:\r\n            if n % 2 == 1:\r\n                ans *= tmp\r\n            tmp *= tmp\r\n            n /= 2\r\n        return ans\r\n\r\n"}]},{"id":3,"unique_name":"count-and-say","title":"报数","description":"报数指的是，按照其中的整数的顺序进行报数，然后得到下一个数。如下所示：\r\n\r\n`1, 11, 21, 1211, 111221, ...`\r\n\r\n`1` 读作 `\"one 1\"` -> `11`.\r\n\r\n`11` 读作 `\"two 1s\"` -> `21`.\r\n\r\n`21` 读作 `\"one 2, then one 1\"` -> `1211`.\r\n\r\n给定一个整数 `n`, 返回 第 `n` 个顺序。 ","solutions":[{"language":"java","code":"public class Solution {\r\n    public String countAndSay(int n) {\r\n        String oldString = \"1\";\r\n        while (--n > 0) {\r\n            StringBuilder sb = new StringBuilder();\r\n            char [] oldChars = oldString.toCharArray();\r\n\r\n            for (int i = 0; i < oldChars.length; i++) {\r\n                int count = 1;\r\n                while ((i+1) < oldChars.length && oldChars[i] == oldChars[i+1]) {\r\n                    count++;\r\n                    i++;\r\n                }\r\n                sb.append(String.valueOf(count) + String.valueOf(oldChars[i]));\r\n            }\r\n            oldString = sb.toString();\r\n        }\r\n\r\n        return oldString;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    string int_to_string(int j) {\r\n        stringstream in;\r\n        in << j;\r\n        string temp;\r\n        in >> temp;\r\n        return temp;    \r\n    }\r\n    \r\n    string genate(string s) {\r\n        string now;\r\n        int j = 0;\r\n        for(int i = 0; i < s.size(); i += j) {\r\n            for(j = 0; j + i < s.size(); j++) {\r\n                if(s[i] != s[i+j]) {\r\n                    break;\r\n                } \r\n            }\r\n            now = now + int_to_string(j) + s[i];\r\n        }\r\n        return now;\r\n    }\r\n    \r\n    string countAndSay(int n) {\r\n        string s(\"1\");\r\n        \r\n        while(--n) {\r\n            s = genate(s);\r\n        }\r\n        return s;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @return a string\r\n    def count(self,s):\r\n        t=''; count=0; curr='#'\r\n        for i in s:\r\n            if i!=curr:\r\n                if curr!='#':\r\n                    t+=str(count)+curr\r\n                curr=i\r\n                count=1\r\n            else:\r\n                count+=1\r\n        t+=str(count)+curr\r\n        return t\r\n    def countAndSay(self, n):\r\n        s='1'\r\n        for i in range(2,n+1):\r\n            s=self.count(s)\r\n        return s\r\n"}]},{"id":30,"unique_name":"valid-palindrome","title":"有效回文串","description":"给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean isPalindrome(String s) {\r\n        if (s == null || s.length() == 0) {\r\n            return true;\r\n        }\r\n\r\n        int front = 0;\r\n        int end = s.length() - 1;\r\n        while (front < end) {\r\n            while (front < s.length() && !isvalid(s.charAt(front))){ // nead to check range of a/b\r\n                front++;\r\n            }\r\n\r\n            if (front == s.length()) { // for emtpy string “.,,,”     \r\n                return true; \r\n            }           \r\n\r\n            while (end >= 0 && ! isvalid(s.charAt(end))) { // same here, need to check border of a,b\r\n                end--;\r\n            }\r\n\r\n            if (Character.toLowerCase(s.charAt(front)) != Character.toLowerCase(s.charAt(end))) {\r\n                break;\r\n            } else {\r\n                front++;\r\n                end--;\r\n            }\r\n        }\r\n\r\n        return end <= front; \r\n    }\r\n\r\n    private boolean isvalid (char c) {\r\n        return Character.isLetter(c) || Character.isDigit(c);\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    bool isPalindrome(string s) {\n        transform(s.begin(), s.end(), s.begin(), ::tolower);\n        auto left = s.begin(), right = prev(s.end());\n        while (left < right) {\n            if (!::isalnum(*left))  ++left;\n            else if (!::isalnum(*right)) --right;\n            else if (*left != *right) return false;\n            else{ left++, right--; }\n        }\n        return true;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param {string} s A string\n    # @return {boolean} Whether the string is a valid palindrome\n    def isPalindrome(self, s):\n        start, end = 0, len(s) - 1\n        while start < end:\n            while start < end and not s[start].isalpha() and not s[start].isdigit():\n                start += 1\n            while start < end and not s[end].isalpha() and not s[end].isdigit():\n                end -= 1\n            if start < end and s[start].lower() != s[end].lower():\n                return False\n            start += 1\n            end -= 1\n        return True\n"}]},{"id":67,"unique_name":"add-binary","title":"二进制求和","description":"给定两个二进制字符串，返回他们的和（用二进制表示）。","solutions":[{"language":"java","code":"public class Solution {\r\n    public String addBinary(String a, String b) {\r\n        if(a.length() < b.length()){\r\n            String tmp = a;\r\n            a = b;\r\n            b = tmp;\r\n        }\r\n        \r\n        int pa = a.length()-1;\r\n        int pb = b.length()-1;\r\n        int carries = 0;\r\n        String rst = \"\";\r\n        \r\n        while(pb >= 0){\r\n            int sum = (int)(a.charAt(pa) - '0') + (int)(b.charAt(pb) - '0') + carries;\r\n            rst = String.valueOf(sum % 2) + rst;\r\n            carries = sum / 2;\r\n            pa --;\r\n            pb --;\r\n        }\r\n        \r\n        while(pa >= 0){\r\n            int sum = (int)(a.charAt(pa) - '0') + carries;\r\n            rst = String.valueOf(sum % 2) + rst;\r\n            carries = sum / 2;\r\n            pa --;\r\n        }       \r\n        \r\n        if (carries == 1)\r\n            rst = \"1\" + rst;\r\n        return rst;\r\n    }\r\n}\r\n\r\n\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param a a number\r\n     * @param b a number\r\n     * @return the result\r\n     */\r\n    public String addBinary(String a, String b) {\r\n        // Write your code here\r\n        String ans = \"\";\r\n\r\n        int carry = 0;\r\n        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {\r\n            int sum = carry;\r\n            sum += (i >= 0) ? a.charAt(i) - '0' : 0;\r\n            sum += (j >= 0) ? b.charAt(j) - '0' : 0;\r\n            ans = (sum % 2) + ans;\r\n            carry = sum / 2;\r\n        }\r\n        if (carry != 0) {\r\n            ans = carry + ans;\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    string addBinary(string a, string b) {\r\n        string result;\r\n        const size_t n = a.size() > b.size() ? a.size() : b.size();\r\n        reverse(a.begin(), a.end());\r\n        reverse(b.begin(), b.end());\r\n        int carry = 0;\r\n        for (size_t i = 0; i < n; i++) {\r\n            const int ai = i < a.size() ? a[i] - '0' : 0;\r\n            const int bi = i < b.size() ? b[i] - '0' : 0;\r\n            const int val = (ai + bi + carry) % 2;\r\n            carry = (ai + bi + carry) / 2;\r\n            result.insert(result.begin(), val + '0');\r\n        }\r\n        if (carry == 1) {\r\n            result.insert(result.begin(), '1');\r\n        }\r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {string} a a number\r\n    # @param {string} b a number\r\n    # @return {string} the result\r\n    def addBinary(self, a, b):\r\n        indexa = len(a) - 1\r\n        indexb = len(b) - 1\r\n        carry = 0\r\n        sum = \"\"\r\n        while indexa >= 0 or indexb >= 0:\r\n            x = int(a[indexa]) if indexa >= 0 else 0\r\n            y = int(b[indexb]) if indexb >= 0 else 0\r\n            if (x + y + carry) % 2 == 0:\r\n                sum = '0' + sum\r\n            else:\r\n                sum = '1' + sum\r\n            carry = (x + y + carry) / 2\r\n            indexa, indexb = indexa - 1, indexb - 1\r\n        if carry == 1:\r\n            sum = '1' + sum\r\n        return sum"}]},{"id":82,"unique_name":"anagrams","title":"乱序字符串","description":"<p>给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。</p>","solutions":[{"language":"java","code":"// Based on sort\r\npublic class Solution {\r\n    /**\r\n     * @param strs: A list of strings\r\n     * @return: A list of strings\r\n     */\r\n    public List<String> anagrams(String[] strs) {\r\n        List<String> result = new ArrayList<String>();\r\n        if (strs == null || strs.length == 0) {\r\n            return result;\r\n        }\r\n        Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\r\n        for (int i = 0; i < strs.length; i++) {\r\n            char[] arr = strs[i].toCharArray(); \r\n            Arrays.sort(arr);\r\n            String s = String.valueOf(arr);\r\n            if (!map.containsKey(s)) {\r\n                ArrayList<String> list = new ArrayList<String>();\r\n                map.put(s, list);\r\n            }\r\n            map.get(s).add(strs[i]);\r\n        } \r\n        for (Map.Entry<String, ArrayList<String>> entry : map.entrySet()) {\r\n            if (entry.getValue().size() >= 2) {\r\n                result.addAll(entry.getValue());\r\n            }\r\n        }\r\n        return result;\r\n\t}\r\n}\r\n\r\n\r\n// based on hash\r\npublic class Solution {\r\n    private int getHash(int[] count) {\r\n        int hash = 0;\r\n        int a = 378551;\r\n        int b = 63689;\r\n        for (int num : count) {\r\n            hash = hash * a + num;\r\n            a = a * b;\r\n        }\r\n        return hash;\r\n    }\r\n    \r\n    public ArrayList<String> anagrams(String[] strs) {\r\n        ArrayList<String> result = new ArrayList<String>();\r\n        HashMap<Integer, ArrayList<String>> map = new HashMap<Integer, ArrayList<String>>();\r\n\r\n        for (String str : strs) {\r\n            int[] count = new int[26];\r\n            for (int i = 0; i < str.length(); i++) {\r\n                count[str.charAt(i) - 'a']++;\r\n            }\r\n\r\n            int hash = getHash(count);\r\n            if (!map.containsKey(hash)) {\r\n                map.put(hash, new ArrayList<String>());\r\n            }\r\n\r\n            map.get(hash).add(str);\r\n        }\r\n\r\n        for (ArrayList<String> tmp : map.values()) {\r\n            if (tmp.size() > 1) {\r\n                result.addAll(tmp);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param strs: A list of strings\r\n     * @return: A list of strings\r\n     */\r\n    string getSortedString(string &str) {\r\n        static int count[26];\r\n        for (int i = 0; i < 26; i++) {\r\n            count[i] = 0;\r\n        }\r\n        for (int i = 0; i < str.length(); i++) {\r\n            count[str[i] - 'a']++;\r\n        }\r\n        \r\n        string sorted_str = \"\";\r\n        for (int i = 0; i < 26; i++) {\r\n            for (int j = 0; j < count[i]; j++) {\r\n                sorted_str = sorted_str + (char)('a' + i);\r\n            }\r\n        }\r\n        return sorted_str;\r\n    }\r\n    \r\n    vector<string> anagrams(vector<string> &strs) {\r\n        unordered_map<string, int> hash;\r\n        \r\n        for (int i = 0; i < strs.size(); i++) {\r\n            string str = getSortedString(strs[i]);\r\n            if (hash.find(str) == hash.end()) {\r\n                hash[str] = 1;\r\n            } else {\r\n                hash[str] = hash[str] + 1;\r\n            }\r\n        }\r\n        \r\n        vector<string> result;\r\n        for (int i = 0; i < strs.size(); i++) {\r\n            string str = getSortedString(strs[i]);\r\n            if (hash.find(str) == hash.end()) {\r\n                continue;\r\n            } else {\r\n                if (hash[str] > 1) {\r\n                    result.push_back(strs[i]);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param strs: A list of strings\r\n    # @return: A list of strings\r\n    def anagrams(self, strs):\r\n        # write your code here\r\n        dict = {}\r\n        for word in strs:\r\n            sortedword = ''.join(sorted(word))\r\n            dict[sortedword] = [word] if sortedword not in dict else dict[sortedword] + [word]\r\n        res = []\r\n        for item in dict:\r\n            if len(dict[item]) >= 2:\r\n                res += dict[item]\r\n        return res\r\n"}]},{"id":119,"unique_name":"regular-expression-matching","title":"正则表达式匹配","description":"","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean isMatch(String s, String p) {\r\n        //Java note: s.substring(n) will be \"\" if n == s.length(), but if n > s.length(), index oob error\r\n        \r\n        int i = 0, j = 0;\r\n        //you don't have to construct a state machine for this problem\r\n \r\n        if (s.length() == 0) {\r\n            return checkEmpty(p);\r\n        }\r\n \r\n        if (p.length() == 0) {\r\n            return false;\r\n        }\r\n \r\n        char c1 = s.charAt(0);\r\n        char d1 = p.charAt(0), d2 = '0'; //any init value except '*'for d2 will do\r\n \r\n        if (p.length()>1){\r\n            d2 = p.charAt(1);\r\n        }\r\n \r\n        if (d2 == '*') {\r\n            if (compare(c1, d1)) {\r\n                //fork here: 1. consume the character, and use the same pattern again.\r\n                //2. keep the character, and skip 'd1*' pattern\r\n                 \r\n                //Here is also an opportunity to use DP, but the idea is the same\r\n                return isMatch(s.substring(1), p) || isMatch(s, p.substring(2));\r\n            }\r\n            else {\r\n                return isMatch(s, p.substring(2));\r\n            }\r\n        }\r\n        else {\r\n            if (compare(c1, d1)) {\r\n                return isMatch(s.substring(1), p.substring(1));\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    \r\n    public boolean compare(char c1, char d1){\r\n        return d1 == '.' || c1 == d1;\r\n    }\r\n \r\n    public boolean checkEmpty(String p) {\r\n        if (p.length()%2 != 0) {\r\n            return false;  \r\n        }\r\n \r\n        for (int i = 1; i < p.length(); i+=2) {\r\n            if (p.charAt(i) != '*') {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n    题意： 正则表达式匹配，'.'可以匹配任意字符，'*'可以匹配任意个(可以为0)'*'之前的字符\r\n    不考虑'*'的话，题目变成简单的匹配。考虑'*'，可能产生的情况有匹配0、1、2…个字符\r\n    因此可以使用递归或dp或其他方法解决\r\n    */\r\n    bool isMatch(string s, string p) {\r\n        if (s.length() == 0){\r\n            // s串匹配完合法的情况只有p为空，或是 \"X*X*\"的形式\r\n            if (p.length() & 1) return false;\r\n            else {\r\n                for (int i = 1; i < p.length(); i += 2) {\r\n                    if (p[i] != '*') return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if (p.length() == 0) return false;\r\n        if (p.length() > 1 && p[1] == '*') {\r\n            if (p[0] == '.' || s[0] == p[0]) {\r\n                return isMatch(s.substr(1), p) || isMatch(s, p.substr(2));\r\n            } else return isMatch(s, p.substr(2));\r\n        } else {\r\n            if (p[0] == '.' || s[0] == p[0]) {\r\n                return isMatch(s.substr(1), p.substr(1));\r\n            } else return false;\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param s: A string \r\n    @param p: A string includes \".\" and \"*\"\r\n    @return: A boolean\r\n    \"\"\"\r\n    hash = None\r\n    def isMatch(self, s, p):\r\n        if self.hash is None:\r\n            self.hash = {}\r\n        key = s + p\r\n        if key in self.hash:\r\n            return self.hash[key]\r\n            \r\n        if p == '':\r\n            return s == ''\r\n        if s == '':\r\n            if len(p) % 2 == 1:\r\n                return False\r\n            i = 1\r\n            while i < len(p):\r\n                if p[i] != '*':\r\n                    return False\r\n                i += 2\r\n            return True\r\n        \r\n        if len(p) > 1 and p[1] == '*':\r\n            if p[0] == '.':\r\n                self.hash[key] = self.isMatch(s[1:], p) or self.isMatch(s, p[2:])\r\n            elif p[0] == s[0]:\r\n                self.hash[key] = self.isMatch(s[1:], p) or self.isMatch(s, p[2:])\r\n            else:\r\n                self.hash[key] = self.isMatch(s, p[2:])\r\n        elif p[0] == '.':\r\n            self.hash[key] = self.isMatch(s[1:], p[1:])\r\n        else:\r\n            self.hash[key] = s[0] == p[0] and self.isMatch(s[1:], p[1:])\r\n        \r\n        return self.hash[key]\r\n\r\nclass Solution(object):\r\n    # DP\r\n    def isMatch(self, s, p):\r\n        dp = [[False for i in range(0,len(p) + 1)] for j in range(0, len(s) + 1)]\r\n        dp[0][0] = True\r\n        for i in range(1, len(p) + 1):\r\n            if (p[i - 1] == '*'):\r\n                dp[0][i] = dp[0][i - 2]\r\n        for i in range(1, len(s) + 1):\r\n            for j in range(1, len(p) + 1):\r\n                if p[j - 1] == '*':\r\n                    dp[i][j] = dp[i][j - 2]\r\n                    if s[i - 1] == p[j - 2] or p[j - 2] == '.':\r\n                        dp[i][j] |= dp[i-1][j]\r\n                else:\r\n                    if s[i - 1] == p[j - 1] or p[j - 1] == '.':\r\n                        dp[i][j] = dp[i - 1][j - 1]\r\n    \r\n        return dp[len(s)][len(p)]\r\n\r\n    # 懒癌版\r\n    def isMatch(self, s, p):\r\n        return re.match(p + '$', s) != None"}]},{"id":36,"unique_name":"best-time-to-buy-and-sell-stock","title":"买卖股票的最佳时机","description":"<span style=\"line-height: 1.42857143;\">假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。</span><span style=\"line-height: 1.42857143;\">如果你最多只允许完成一次交易(例如,一次买卖股票),设计一个算法来找出最大利润。</span>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int maxProfit(int[] prices) {\r\n        if (prices == null || prices.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        int min = Integer.MAX_VALUE;  //just remember the smallest price\r\n        int profit = 0;\r\n        for (int i : prices) {\r\n            min = i < min ? i : min;\r\n            profit = (i - min) > profit ? i - min : profit;\r\n        }\r\n\r\n        return profit;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param prices: Given an integer array\n     * @return: Maximum profit\n     */\n    int maxProfit(vector<int> &prices) {\n        // write your code here\n        if (prices.empty()) return 0;\n        int i=prices.size()-1, ans=0, maxp=prices[i];\n        for (--i; i>=0; --i){\n            ans=max(ans, maxp-prices[i]);\n            maxp=max(maxp, prices[i]);\n        }\n        return ans;\n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param prices: Given an integer array\n    @return: Maximum profit\n    \"\"\"\n    def maxProfit(self, prices):\n        # write your code here\n        total = 0\n        low, high = sys.maxint, 0\n        for x in prices:\n            if x - low > total:\n                total = x - low\n            if x < low:\n                low = x\n        return total\n"},{"language":"javascript","code":"/**\n * @param prices: Given an integer array\n * @return: Maximum profit\n */\nconst maxProfit = function (prices) {\n    if (prices === null || prices.length === 0) {\n        return 0;\n    }\n    var min = Number.MAX_VALUE;\n    var profit = 0;\n    var i;\n    for (i = 0; i < prices.length; i++) {\n        min = prices[i] < min ? prices[i] : min;\n        profit = (prices[i] - min) > profit ? prices[i] - min : profit;\n    }\n    return profit;\n}"}]},{"id":57,"unique_name":"sort-colors","title":"颜色分类","description":"给定一个包含红，白，蓝且长度为 n 的数组，将数组元素进行分类使相同颜色的元素相邻，并按照红、白、蓝的顺序进行排序。\r\n\r\n我们可以使用整数 0，1 和 2 分别代表红，白，蓝。\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    public void sortColors(int[] a) {\r\n        if (a == null || a.length <= 1) {\r\n            return;\r\n        }\r\n        \r\n        int pl = 0;\r\n        int pr = a.length - 1;\r\n        int i = 0;\r\n        while (i <= pr) {\r\n            if (a[i] == 0) {\r\n                swap(a, pl, i);\r\n                pl++;\r\n                i++;\r\n            } else if(a[i] == 1) {\r\n                i++;\r\n            } else {\r\n                swap(a, pr, i);\r\n                pr--;\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void swap(int[] a, int i, int j) {\r\n        int tmp = a[i];\r\n        a[i] = a[j];\r\n        a[j] = tmp;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution{\r\npublic:\r\n    /**\r\n     * @param nums: A list of integer which is 0, 1 or 2 \r\n     * @return: nothing\r\n     */    \r\n    void sortColors(vector<int> &nums) {\r\n        int left = 0, right = nums.size() - 1;\r\n        int middle = 0;\r\n        \r\n        // should be <= not <\r\n        while (middle <= right) {\r\n            if (nums[middle] == 0) {\r\n                swap(nums[middle], nums[left]);\r\n                left++;\r\n                middle++;\r\n            } else if (nums[middle] == 1) {\r\n                middle++;\r\n            } else {\r\n                swap(nums[middle], nums[right]);\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    def sort(self, A, flag, index):\r\n        start, end = index, len(A) - 1\r\n        while start <= end:\r\n            while start <= end and A[start] == flag:\r\n                start += 1\r\n            while start <= end and A[end] != flag:\r\n                end -= 1\r\n            if start <= end:\r\n                A[start], A[end] = A[end], A[start]\r\n                start += 1\r\n                end -= 1\r\n        return start\r\n    \r\n    # @param A a list of integers\r\n    # @return nothing, sort in place\r\n    def sortColors(self, A):\r\n        self.sort(A, 1, self.sort(A, 0, 0))"},{"language":"javascript","code":"/**\n * @param nums: A list of integer which is 0, 1 or 2 \n * @return: \n */\nconst sortColors = function (nums) {\n    if (nums === null || nums.length <= 1) {\n        return;\n    }\n    var pl = 0;\n    var pr = nums.length - 1;\n    var i = 0;\n    var tmp;\n    while (i <= pr) {\n        if (nums[i] === 0) {\n            tmp = nums[i];\n            nums[i] = nums[pl];\n            nums[pl] = tmp;\n            pl++;\n            i++;\n        } else if(nums[i] === 1) {\n            i++;\n        } else {\n            tmp = nums[i];\n            nums[i] = nums[pr];\n            nums[pr] = tmp;\n            pr--;\n        }\n    }\n}"}]},{"id":135,"unique_name":"word-search","title":"单词搜索","description":"<p><span style=\"line-height: 1.42857143;\">给出一个二维的字母板和一个单词，寻找字母板网格中是否存在这个单词。</span><br></p><p>单词可以由按顺序的相邻单元的字母组成，其中相邻单元指的是水平或者垂直方向相邻。每个单元中的字母最多只能使用一次。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    // recursion\r\n    public boolean exist(char[][] board, String word) {\r\n        if(board == null || board.length == 0)\r\n            return false;\r\n        if(word.length() == 0)\r\n            return true;\r\n        \r\n        for(int i = 0; i< board.length; i++){\r\n            for(int j=0; j< board[0].length; j++){\r\n                if(board[i][j] == word.charAt(0)){\r\n                    \r\n                    boolean rst = find(board, i, j, word, 0);\r\n                    if(rst)\r\n                        return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    private boolean find(char[][] board, int i, int j, String word, int start){\r\n        if(start == word.length())\r\n            return true;\r\n        \r\n        if (i < 0 || i>= board.length || \r\n     j < 0 || j >= board[0].length || board[i][j] != word.charAt(start)){\r\n            return false;\r\n\t }\r\n        \r\n        board[i][j] = '#'; // should remember to mark it\r\n        boolean rst = find(board, i-1, j, word, start+1) \r\n|| find(board, i, j-1, word, start+1) \r\n|| find(board, i+1, j, word, start+1) \r\n|| find(board, i, j+1, word, start+1);\r\n        board[i][j] = word.charAt(start);\r\n        return rst;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param board: A list of lists of character\r\n     * @param word: A string\r\n     * @return: A boolean\r\n     */\r\n    bool exist(vector<vector<char> > &board, string word) {\r\n        // write your code here\r\n        vector<vector<bool> > mask(board.size(), vector<bool>(board[0].size(), true));\r\n        if (board.size() < 1) return false;\r\n        for (int i = 0; i <board.size(); ++i) {\r\n            for (int j = 0; j < board[0].size(); ++j) {\r\n                if (board[i][j] == word[0] && search(board, word, mask, 0, i, j)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    bool search(vector<vector<char> > &board, string &word, vector<vector<bool> > &mask, int idx, int x, int y) {\r\n        if (word[idx] == board[x][y]) {\r\n            ++idx;\r\n            if (idx == word.length()){\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n        mask[x][y] = false;\r\n        if (y + 1 < board[0].size() && mask[x][y+1] && board[x][y+1] == word[idx]) {\r\n            if (search(board, word, mask, idx, x, y + 1))\r\n                return true;\r\n        }\r\n        if (x + 1 < board.size() && mask[x+1][y] && board[x+1][y] == word[idx]) {\r\n           if (search(board, word, mask, idx, x + 1, y))\r\n                return true;\r\n        }\r\n        if (x - 1 >= 0 && mask[x-1][y] && board[x-1][y] == word[idx]) {\r\n           if (search(board, word, mask, idx, x - 1, y))\r\n                return true;\r\n        }\r\n        if (y - 1 >= 0 && mask[x][y-1] && board[x][y-1] == word[idx]) {\r\n           if (search(board, word, mask, idx, x, y - 1))\r\n                return true;\r\n        }\r\n        mask[x][y] = true;\r\n        return false;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param board, a list of lists of 1 length string\r\n    # @param word, a string\r\n    # @return a boolean\r\n    def exist(self, board, word):\r\n        # write your code here\r\n        # Boundary Condition\r\n        if word == []:\r\n            return True\r\n        m = len(board)\r\n        if m == 0:\r\n            return False\r\n        n = len(board[0])\r\n        if n == 0:\r\n            return False\r\n        # Visited Matrix\r\n        visited = [[False for j in range(n)] for i in range(m)]\r\n        # DFS\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if self.exist2(board, word, visited, i, j):\r\n                    return True\r\n        return False\r\n\r\n    def exist2(self, board, word, visited, row, col):\r\n        if word == '':\r\n            return True\r\n        m, n = len(board), len(board[0])\r\n        if row < 0 or row >= m or col < 0 or col >= n:\r\n            return False\r\n        if board[row][col] == word[0] and not visited[row][col]:\r\n            visited[row][col] = True\r\n            # row - 1, col\r\n            if self.exist2(board, word[1:], visited, row - 1, col) or self.exist2(board, word[1:], visited, row, col - 1) or self.exist2(board, word[1:], visited, row + 1, col) or self.exist2(board, word[1:], visited, row, col + 1):\r\n                return True\r\n            else:\r\n                visited[row][col] = False\r\n        return False"}]},{"id":104,"unique_name":"remove-duplicates-from-sorted-array","title":"删除排序数组中的重复数字","description":"<p>给定一个排序数组，在原数组中删除重复出现的数字，使得每个元素只出现一次，并且返回新的数组的长度。</p><p>不要使用额外的数组空间，必须在原地没有额外空间的条件下完成。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int removeDuplicates(int[] A) {\r\n        if (A == null || A.length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int size = 0;\r\n        for (int i = 0; i < A.length; i++) {\r\n            if (A[i] != A[size]) {\r\n                A[++size] = A[i];\r\n            }\r\n        }\r\n        return size + 1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param A: a list of integers\n     * @return : return an integer\n     */\n    int removeDuplicates(vector<int> &nums) {\n        if (nums.size() == 0) {\n            return 0;\n        }\n        int len = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[len] != nums[i]) {\n                nums[++len] = nums[i];\n            }\n        }\n        return len + 1;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param A: a list of integers\n    @return an integer\n    \"\"\"\n    def removeDuplicates(self, A):\n        # write your code here\n        if A == []:\n            return 0\n        index = 0\n        for i in range(1, len(A)):\n            if A[index] != A[i]:\n                index += 1\n                A[index] = A[i]\n\n        return index + 1"}]},{"id":114,"unique_name":"3sum","title":"三数之和","description":"<p><span style=\"line-height: 30px;\">给出一个有n个整数的数组S，在S中找到三个整数a, b, c，找到所有使得a + b + c = 0的三元组。</span><br></p>","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param nums : Give an array numbers of n integer\n     * @return : Find all unique triplets in the array which gives the sum of zero.\n     */\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n        \n        if (nums == null || nums.length < 3) {\n            return results;\n        }\n        \n        Arrays.sort(nums);\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            // skip duplicate triples with the same first numebr\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n\n            int left = i + 1, right = nums.length - 1;\n            int target = -nums[i];\n            \n            twoSum(nums, left, right, target, results);\n        }\n        \n        return results;\n    }\n    \n    public void twoSum(int[] nums,\n                       int left,\n                       int right,\n                       int target,\n                       List<List<Integer>> results) {\n        while (left < right) {\n            if (nums[left] + nums[right] == target) {\n                ArrayList<Integer> triple = new ArrayList<>();\n                triple.add(-target);\n                triple.add(nums[left]);\n                triple.add(nums[right]);\n                results.add(triple);\n                \n                left++;\n                right--;\n                // skip duplicate pairs with the same left\n                while (left < right && nums[left] == nums[left - 1]) {\n                    left++;\n                }\n                // skip duplicate pairs with the same right\n                while (left < right && nums[right] == nums[right + 1]) {\n                    right--;\n                }\n            } else if (nums[left] + nums[right] < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n}\n\n// 九章硅谷求职算法集训营版本\npublic class Solution {\n    /**\n     * @param nums : Give an array numbers of n integer\n     * @return : Find all unique triplets in the array which gives the sum of zero.\n     */\n    List<List<Integer>> results = new ArrayList<>();\n    \n    public List<List<Integer>> threeSum(int[] A) {\n        \n        if (A == null || A.length < 3) {\n            return results;\n        }\n        \n        Arrays.sort(A);\n        int i;\n        for (i = 2; i < A.length; ++i) {\n            // item3 is always the last in a bunch of duplicates\n            if (i + 1 < A.length && A[i + 1] == A[i]) continue;\n            twoSum(A, i - 1, -A[i]);\n        }\n        \n        return results;\n    }\n    \n    void twoSum(int[] A,\n                int right,\n                int target) {\n        int i, j;\n        j = right;\n        for (i = 0; i <= right; ++i) {\n            // item2 is always the first in a bunch of duplicates\n            if (i > 0 && A[i] == A[i - 1]) continue;\n            \n            while (j > i && A[i] + A[j] > target) {\n                --j;\n            }\n            \n            if (j <= i) {\n                break;\n            }\n            \n            if (A[i] + A[j] == target) {\n                List<Integer> trio = new ArrayList<>();\n                trio.add(A[i]);\n                trio.add(A[j]);\n                trio.add(-target);\n                results.add(trio);\n            }\n        }\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param numbers : Give an array numbers of n integer\r\n     * @return : Find all unique triplets in the array which gives the sum of zero.\r\n     */\r\n    vector<vector<int> > threeSum(vector<int> &nums) {\r\n        vector<vector<int> > result;\r\n        \r\n        sort(nums.begin(), nums.end());\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (i > 0 && nums[i] == nums[i - 1]) {\r\n                continue;\r\n            }\r\n            // two sum;\r\n            int start = i + 1, end = nums.size() - 1;\r\n            int target = -nums[i];\r\n            while (start < end) {\r\n                if (start > i + 1 && nums[start - 1] == nums[start]) {\r\n                    start++;\r\n                    continue;\r\n                }\r\n                if (nums[start] + nums[end] < target) {\r\n                    start++;\r\n                } else if (nums[start] + nums[end] > target) {\r\n                    end--;\r\n                } else {\r\n                    vector<int> triple;\r\n                    triple.push_back(nums[i]);\r\n                    triple.push_back(nums[start]);\r\n                    triple.push_back(nums[end]);\r\n                    result.push_back(triple);\r\n                    start++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution(object):\r\n    '''\r\n        题意：求数列中三个数之和为0的三元组有多少个，需去重\r\n        暴力枚举三个数复杂度为O(N^3)\r\n        先考虑2Sum的做法，假设升序数列a，对于一组解ai,aj, 另一组解ak,al \r\n        必然满足 i<k j>l 或 i>k j<l, 因此我们可以用两个指针，初始时指向数列两端\r\n        指向数之和大于目标值时，右指针向左移使得总和减小，反之左指针向右移\r\n        由此可以用O(N)的复杂度解决2Sum问题，3Sum则枚举第一个数O(N^2)\r\n        使用有序数列的好处是，在枚举和移动指针时值相等的数可以跳过，省去去重部分\r\n    '''\r\n    def threeSum(self, nums):\r\n        nums.sort()\r\n        res = []\r\n        length = len(nums)\r\n        for i in range(0, length - 2):\r\n            if i and nums[i] == nums[i - 1]:\r\n                continue\r\n            target = nums[i] * -1\r\n            left, right = i + 1, length - 1\r\n            while left < right:\r\n                if nums[left] + nums[right] == target:\r\n                    res.append([nums[i], nums[left], nums[right]])\r\n                    right -= 1\r\n                    left += 1\r\n                    while left < right and nums[left] == nums[left - 1]:\r\n                        left += 1\r\n                    while left < right and nums[right] == nums[right + 1]:\r\n                        right -= 1\r\n                elif nums[left] + nums[right] > target:\r\n                    right -= 1\r\n                else:\r\n                    left += 1\r\n        return res"}]},{"id":155,"unique_name":"reverse-linked-list","title":"翻转链表","description":"<p>翻转一个链表</p>","solutions":[{"language":"java","code":"/**\r\n * Definition for ListNode.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int val) {\r\n *         this.val = val;\r\n *         this.next = null;\r\n *     }\r\n * }\r\n */ \r\npublic class Solution {\r\n    /**\r\n     * @param head: The head of linked list.\r\n     * @return: The new head of reversed linked list.\r\n     */\r\n    public ListNode reverse(ListNode head) {\r\n        ListNode prev = null;\r\n        while (head != null) {\r\n            ListNode temp = head.next;\r\n            head.next = prev;\r\n            prev = head;\r\n            head = temp;\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * \r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n * \r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: The first node of linked list.\r\n     * @return: The new head of reversed linked list.\r\n     */\r\n    ListNode *reverse(ListNode *head) {\r\n        ListNode *prev = NULL;\r\n        while (head != NULL) {\r\n            ListNode *temp = head->next;\r\n            head->next = prev;\r\n            prev = head;\r\n            head = temp;\r\n        }\r\n        return prev;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n\r\n    def reverse(self, head):\r\n        curt = None\r\n        while head != None:\r\n            temp = head.next\r\n            head.next = curt\r\n            curt = head\r\n            head = temp\r\n        return curt"}]},{"id":56,"unique_name":"minimum-window-substring","title":"最小子串覆盖","description":"<p>给定一个字符串<span style=\"font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\"><b><font color=\"#e76363\">source</font></b></span>和一个目标字符串<b><font color=\"#e76363\">target</font></b>，在字符串<span style=\"line-height: 1.42857143; color: rgb(231, 99, 99); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: 700;\">source</span><span style=\"line-height: 1.42857143;\">中</span><span style=\"line-height: 1.42857143;\">找到包括所有目标字符串字母的子串。</span></p>","solutions":[{"language":"java","code":"public class Solution {    \n//方法一:\n    int initTargetHash(int []targethash, String Target) {\n        int targetnum =0 ;\n        for (char ch : Target.toCharArray()) {\n            targetnum++;\n            targethash[ch]++;\n        }\n        return targetnum;\n    }\n    boolean valid(int []sourcehash, int []targethash) {\n        \n        for(int i = 0; i < 256; i++) {\n            if(targethash[i] > sourcehash[i])    \n                return false;\n        }\n        return true;\n    }\n    public String minWindow(String Source, String Target) {\n        // queueing the position that matches the char in T\n        int ans = Integer.MAX_VALUE;\n        String minStr = \"\";\n        \n        int[] sourcehash = new int[256];\n        int[] targethash = new int[256];\n        \n        initTargetHash(targethash, Target);\n        int j = 0, i = 0;\n        for(i = 0; i < Source.length(); i++) {\n            while( !valid(sourcehash, targethash) && j < Source.length()  ) {\n                sourcehash[Source.charAt(j)]++;\n                j++;\n            }\n            if(valid(sourcehash, targethash) ){\n                if(ans > j - i ) {\n                    ans = Math.min(ans, j - i );\n                    minStr = Source.substring(i, j );\n                }\n            }\n            sourcehash[Source.charAt(i)]--;\n        }\n        return minStr;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    string minWindow(string s, string t) {\r\n        unordered_map<char, int> mp;\r\n        for (char now : t) {\r\n            mp[now] ++;\r\n        }\r\n        int count = mp.size();\r\n        int j = 0;\r\n        int ans = INT_MAX;\r\n        string res; \r\n        for (int i = 0; i < s.size(); i++) {\r\n            while(count != 0 && j < s.size()) {\r\n                mp[s[j]]--;\r\n                if (mp[s[j]] == 0) {\r\n                    count--;\r\n                }\r\n                j++;\r\n                if (count == 0) {\r\n                    break;\r\n                }\r\n            }\r\n            if (count == 0 && j - i< ans) {\r\n                ans = j - i;\r\n                res = s.substr(i, j - i);\r\n                \r\n            }\r\n            if(mp[s[i]] == 0) {\r\n                count++;\r\n            }\r\n            mp[s[i]]++;\r\n        }\r\n        return res;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param source: A string\r\n    @param target: A string\r\n    @return: A string denote the minimum window\r\n             Return \"\" if there is no such a string\r\n    \"\"\"\r\n    def minWindow(self, source, target):\r\n        if (target == \"\"):\r\n            return \"\"\r\n        S , T = source, target\r\n        d, dt = {}, dict.fromkeys(T, 0)\r\n        for c in T: d[c] = d.get(c, 0) + 1\r\n        pi, pj, cont = 0, 0, 0\r\n        if (source ==\"\" or target ==\"\"):\r\n            return \"\"\r\n        ans = \"\"\r\n        while pj < len(S):\r\n            if S[pj] in dt:\r\n                if dt[S[pj]] < d[S[pj]]:\r\n                    cont += 1\r\n                dt[S[pj]] += 1;\r\n            if cont == len(T):\r\n                while pi < pj:\r\n                    if S[pi] in dt:\r\n                        if dt[S[pi]] == d[S[pi]]:\r\n                            break;\r\n                        dt[S[pi]] -= 1;\r\n                    pi+= 1\r\n                if ans == '' or pj - pi < len(ans):\r\n                    ans = S[pi:pj+1]\r\n                dt[S[pi]] -= 1\r\n                pi += 1\r\n                cont -= 1\r\n            pj += 1\r\n        return ans\r\n"}]},{"id":701,"unique_name":"calculate-maximum-value","title":"计算最大值","description":"给一个字符串类型的数字, 写一个方法去找到最大值, 你可以在任意两个数字间加 `+` 或 `*` ","solutions":[{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param : the given string\n     * @return: the maximum value\n     */\n    int calcMaxValue(string &str) {\n        // write your code here\n        if (str.size() == 0) {\n            return 0;\n        }\n        int res = str[0] -'0';\n \n        // Start traversing the string\n        for (int i = 1; i < str.length(); i++)\n        {\n            if (str[i] == '0' || str[i] == '1' || res <= 1)\n                res += (str[i]-'0');\n            else\n                res *= (str[i]-'0');\n        }\n     \n        return res;\n    }\n};"}]},{"id":764,"unique_name":"group-anagrams","title":"错位词分组","description":"给一字符串数组, 将 错位词(指相同字符不同排列的字符串) 分组","solutions":[{"language":"java","code":"//高频班version\npublic class Solution {\n    /**\n     * @param strs: the given array of strings\n     * @return: The anagrams which have been divided into groups\n     */\n    public List<List<String>> groupAnagrams(String[] strs) {\n        // write your code here\n        Map<String, List<String>> map = new HashMap<>();\n        for (String s : strs) {\n            char[] sc = s.toCharArray();\n            Arrays.sort(sc);\n            String key = String.valueOf(sc);\n            map.putIfAbsent(key, new ArrayList<>());\n            map.get(key).add(s);\n        }\n        return new ArrayList<>(map.values());\n    }\n}"}]},{"id":721,"unique_name":"rotate-bits-left","title":"左旋转二进制位","description":"位旋转 -—— 旋转（或循环移位）是类似于移位的操作, 不同的是一端脱落的那一位会被放回到另一端\n在左旋转中, 左端掉下来的那一位会放在右端\n假设 n 用 8 位二进制来存. 对 n = `11100101` 左旋转 `3` 位, 得到 n = `00101111` (左移3位, 原先的前3位放在末尾).\n如果 n 用 16 位或 32 位二进制来存, 那么对 n (`000…11100101`)左旋转了之后会变成 (`00..0011100101000`).\n在本问题中, 你可以假设 n 是用 `32` 位二进制来存的.","solutions":[{"language":"java","code":"public int leftRotate(int n, int d) {\n    // write code here\n    return (n >>> (32 - d)) + (n << d);\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param : a number\n     * @param : digit needed to be rorated\n     * @return: a number\n     */\n    int leftRotate(int n, int d) {\n        // write code here\n        int left = 0;\n        for (int i = 0; i < d; ++i) {\n            left = left * 2 + n & (1 << (31 - i));\n        }\n        return n << d + left;\n    }\n};"}]},{"id":672,"unique_name":"longest-palindromic-subsequence","title":"最长的回文序列","description":"给一字符串 s, 找出在 s 中的最长回文序列的长度. 你可以假设 s 的最大长度为 `1000`.","solutions":[{"language":"java","code":"// 动态规划专题班非递归版：\r\npublic class Solution {\r\n    public int longestPalindromeSubseq(String s) {\r\n        int n = s.length();\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        if (n == 1) {\r\n            return 1;\r\n        }\r\n        \r\n        int[][] f = new int[n][n];\r\n        int i, j, len;\r\n        for (i = 0; i < n; ++i) {\r\n            f[i][i] = 1;\r\n        }\r\n        for (i = 0; i < n-1; ++i) {\r\n            if (s.charAt(i) == s.charAt(i+1)) {\r\n                f[i][i+1] = 2;\r\n            }\r\n            else {\r\n                f[i][i+1] = 1;\r\n            }\r\n        }\r\n        \r\n        for (len = 3; len <= n; ++len) {\r\n            for (i = 0; i <= n-len; ++i) {\r\n                j = i + len - 1;\r\n                f[i][j] = f[i][j-1];\r\n                if (f[i+1][j] > f[i][j]) {\r\n                    f[i][j] = f[i+1][j];\r\n                }\r\n                if (s.charAt(i) == s.charAt(j) && f[i+1][j-1] + 2 > f[i][j]) {\r\n                    f[i][j] = f[i+1][j-1] + 2;\r\n                }\r\n            }\r\n        }\r\n        \r\n        int res = 0;\r\n        for (i = 0; i < n; ++i) {\r\n            for (j = i; j < n; ++j) {\r\n                if (f[i][j] > res) {\r\n                    res = f[i][j];\r\n                }\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n// 动态规划专题班递归版：\r\npublic class Solution {\r\n    int[][] f = null;\r\n    char[] s = null;\r\n    int res = 0;\r\n\r\n    private void Compute(int i, int j) {\r\n        if (f[i][j] != -1) {\r\n            return;\r\n        }\r\n\r\n        if (i == j) {\r\n            f[i][j] = 1;\r\n            return;\r\n        }\r\n\r\n        if (i + 1 == j) {\r\n            if (s[i] == s[j]) {\r\n                f[i][j] = 2;\r\n            }\r\n            else {\r\n                f[i][j] = 1;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        Compute(i + 1, j);\r\n        Compute(i, j - 1);\r\n        Compute(i + 1, j - 1);\r\n        f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);\r\n        if (s[i] == s[j]) {\r\n            f[i][j] = Math.max(f[i][j], f[i + 1][j - 1] + 2);\r\n        }\r\n    }\r\n\r\n    public int longestPalindromeSubseq(String ss) {\r\n        s = ss.toCharArray();\r\n        int n = s.length;\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        if (n == 1) {\r\n            return 1;\r\n        }\r\n        \r\n        int i, j;\r\n        f = new int[n][n];    \r\n        for (i = 0; i < n; ++i) {\r\n            for (j = i; j < n; ++j) {\r\n                f[i][j] = -1;\r\n            }\r\n        }\r\n        \r\n        Compute(0, n - 1);       \r\n        \r\n        for (i = 0; i < n; ++i) {\r\n            for (j = i; j < n; ++j) {\r\n                res = Math.max(res, f[i][j]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param s the maximum length of s is 1000\r\n     * @return the longest palindromic subsequence's length\r\n     */\r\n    public int longestPalindromeSubseq(String s) {\r\n        // Write your code here\r\n        int length = s.length();\r\n        if (length == 0)\r\n            return 0;\r\n        int[][] dp = new int[length][length];\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            dp[i][i] = 1;\r\n            for (int j = i + 1; j < length; j++) {\r\n                if (s.charAt(i) == s.charAt(j)) {\r\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\r\n                } else {\r\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n        return dp[0][length - 1];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param s the maximum length of s is 1000\r\n     * @return the longest palindromic subsequence's length\r\n     */\r\n    int longestPalindromeSubseq(string& s) {\r\n        // Write your code here\r\n        int length = s.size();\r\n        if (length == 0)\r\n            return 0;\r\n        vector<vector<int>> dp(length, vector<int>(length));\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            dp[i][i] = 1;\r\n            for (int j = i + 1; j < length; j++) {\r\n                if (s[i] == s[j]) {\r\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\r\n                } else {\r\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n        return dp[0][length - 1];\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {string} s the maximum length of s is 1000\r\n    # @return {int} the longest palindromic subsequence's length\r\n    def longestPalindromeSubseq(self, s):\r\n        # Write your code here\r\n        length = len(s)\r\n        if length == 0:\r\n            return 0\r\n        dp = [[0 for _ in xrange(length)] for __ in xrange(length)]\r\n        for i in xrange(length - 1, -1, -1):\r\n            dp[i][i] = 1\r\n            for j in xrange(i + 1, length):\r\n                if s[i] == s[j]:\r\n                    dp[i][j] = dp[i + 1][j - 1] + 2\r\n                else:\r\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\r\n        return dp[0][length - 1]"}]},{"id":463,"unique_name":"house-robber-iii","title":"打劫房屋 III","description":"在上次打劫完一条街道之后和一圈房屋之后，窃贼又发现了一个新的可以打劫的地方，**但这次所有的房子组成的区域比较奇怪，聪明的窃贼考察地形之后，发现这次的地形是一颗二叉树**。与前两次偷窃相似的是每个房子都存放着特定金额的钱。你面临的唯一约束条件是：**相邻的房子装着相互联系的防盗系统，且当相邻的两个房子同一天被打劫时，该系统会自动报警**。\r\n\r\n算一算，如果今晚去打劫，你最多可以得到多少钱，当然在不触动报警装置的情况下。","solutions":[{"language":"java","code":"/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\n//dp[i][0]表示以i为根的子树不偷根节点能获得的最高价值，dp[i][1]表示以i为根的子树偷根节点能获得的最高价值\r\npublic class Solution {\r\n    public int houseRobber3(TreeNode root) {\r\n        int[] ans = dp(root);\r\n        return Math.max(ans[0], ans[1]);\r\n    }\r\n    public int[] dp(TreeNode root) {\r\n        if (root == null) {\r\n            int[] now = new int[]{0, 0};\r\n            return now;\r\n        }\r\n        int[] left = dp(root.left);\r\n        int[] right = dp(root.right);\r\n        int[] now = new int[2];\r\n        now[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\r\n        now[1] = left[0] + right[0] + root.val;\r\n        return now;\r\n    }\r\n}\r\n\r\n// version 2\r\n/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass ResultType {\r\n    public int rob, not_rob;\r\n    public ResultType() { rob = not_rob = 0; }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: The maximum amount of money you can rob tonight\r\n     */\r\n    public int houseRobber3(TreeNode root) {\r\n        // write your code here\r\n        ResultType result = visit(root);\r\n        return Math.max(result.rob, result.not_rob);\r\n    }\r\n    \r\n    public ResultType visit(TreeNode root) {\r\n        ResultType result = new ResultType();\r\n        if (root == null)\r\n            return result;\r\n            \r\n        ResultType left_result = visit(root.left);\r\n        ResultType right_result = visit(root.right);\r\n        \r\n        result.rob = root.val + left_result.not_rob + right_result.not_rob;\r\n        result.not_rob = Math.max(left_result.rob, left_result.not_rob) + \r\n                         Math.max(right_result.rob, right_result.not_rob);\r\n        return result;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * }\r\n */\r\nclass Solution {\r\nprivate:\r\n    void visit(TreeNode* root, int &rob, int &not_rob) {\r\n        rob = not_rob = 0;\r\n        if (root == NULL)\r\n            return;\r\n            \r\n        int left_rob, left_not_rob, right_rob, right_not_rob;\r\n        visit(root->left, left_rob, left_not_rob);\r\n        visit(root->right, right_rob, right_not_rob);\r\n        \r\n        rob = left_not_rob + right_not_rob + root->val;\r\n        not_rob = max(left_rob, left_not_rob) + max(right_rob, right_not_rob);\r\n    }\r\npublic:\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: The maximum amount of money you can rob tonight\r\n     */\r\n    int houseRobber3(TreeNode* root) {\r\n        // write your code here\r\n        int rob, not_rob;\r\n        visit(root, rob, not_rob);\r\n        return max(rob, not_rob);\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        sef.val = val\r\n        self.left, self.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    # @param {TreeNode} root, the root of binary tree.\r\n    # @return {int} The maximum amount of money you can rob tonight\r\n    def houseRobber3(self, root):\r\n        # write your code here\r\n        rob, not_rob = self.visit(root)\r\n        return max(rob, not_rob)\r\n        \r\n    def visit(self, root):\r\n        if root is None:\r\n            return 0, 0\r\n        \r\n        left_rob, left_not_rob = self.visit(root.left)\r\n        right_rob, right_not_rob = self.visit(root.right)\r\n        \r\n        rob = root.val + left_not_rob + right_not_rob\r\n        not_rob = max(left_rob, left_not_rob) + max(right_rob, right_not_rob)\r\n        return rob, not_rob\r\n"}]},{"id":53,"unique_name":"maximum-depth-of-binary-tree","title":"二叉树的最大深度","description":"给定一个二叉树，找出其最大深度。\r\n\r\n二叉树的深度为根节点到最远叶子节点的距离。","solutions":[{"language":"java","code":"// Version 1: Divide Conquer\r\npublic class Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n\r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n}\r\n\r\n// version 2: Traverse\r\n/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: An integer.\r\n     */\r\n    private int depth;\r\n    \r\n    public int maxDepth(TreeNode root) {\r\n        depth = 0;\r\n        helper(root, 1);\r\n        \r\n        return depth;\r\n    }\r\n    \r\n    private void helper(TreeNode node, int curtDepth) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        \r\n        if (curtDepth > depth) {\r\n            depth = curtDepth;\r\n        }\r\n        \r\n        helper(node.left, curtDepth + 1);\r\n        helper(node.right, curtDepth + 1);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: An integer\r\n     */\r\n    int maxDepth(TreeNode *root) {\r\n        if (root == NULL) {\r\n            return 0;\r\n        }\r\n        int left = maxDepth(root->left);\r\n        int right = maxDepth(root->right);\r\n        return left > right ? left + 1 : right + 1;\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: An integer\r\n    \"\"\" \r\n    def maxDepth(self, root):\r\n        if root is None:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n"}]},{"id":121,"unique_name":"string-to-integer-atoi","title":"转换字符串到整数","description":"<p>实现atoi这个函数，将一个字符串转换为整数。如果没有合法的整数，返回0。如果整数超出了32位整数的范围，返回INT_MAX(2147483647)如果是正整数，或者INT_MIN(-2147483648)如果是负整数。</p>","solutions":[{"language":"java","code":"\r\npublic class Solution {\r\n   public int myAtoi(String str) {\r\n        // Start typing your Java solution below\r\n        // DO NOT write main() function\r\n        if(str == null) {\r\n            return 0;\r\n        }\r\n        str = str.trim();\r\n        if (str.length() == 0) {\r\n            return 0;\r\n        }\r\n            \r\n        int sign = 1;\r\n        int index = 0;\r\n    \r\n        if (str.charAt(index) == '+') {\r\n            index++;\r\n        } else if (str.charAt(index) == '-') {\r\n            sign = -1;\r\n            index++;\r\n        }\r\n        long num = 0;\r\n        for (; index < str.length(); index++) {\r\n            if (str.charAt(index) < '0' || str.charAt(index) > '9')\r\n                break;\r\n            num = num * 10 + (str.charAt(index) - '0');\r\n            if (num > Integer.MAX_VALUE ) {\r\n                break;\r\n            }\r\n        }   \r\n        if (num * sign >= Integer.MAX_VALUE) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n        if (num * sign <= Integer.MIN_VALUE) {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n        return (int)num * sign;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    // 字符串转int，注意判断超出Int范围\r\n    int myAtoi(string str) {\r\n        if (str == \"\") return 0;\r\n        // 去首尾空格\r\n        str.erase(0, str.find_first_not_of(' '));\r\n        str.erase(str.find_last_not_of(' ') + 1);\r\n        \r\n        int i = 0, len = str.length(), sign = 1;\r\n        while ( i < len && str[i] == ' ') i++;\r\n        if (i == len) return 0;\r\n        if (str[i] == '+') {\r\n            sign = 1;\r\n            i++;\r\n        } else \r\n            if (str[i] == '-') {\r\n                sign = -1;\r\n                i++;\r\n            }\r\n        // 转换结果可能超出int范围，使用long long作为转换后接收变量的类型\r\n        long long ret = 0;\r\n        for (; i < len; i++) {\r\n            if (str[i] < '0' || str[i] > '9') break;\r\n            ret = ret * 10 + (str[i] - '0');\r\n            if (ret > INT_MAX) break;\r\n        }\r\n        ret *= sign;\r\n        if (ret > INT_MAX) return INT_MAX;\r\n        if (ret < INT_MIN) return INT_MIN;\r\n        return ret;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    # string转int，去首尾空格判读正负号，转换中注意Int范围\r\n    def myAtoi(self, str):\r\n        str = str.strip()\r\n        if str == \"\" :\r\n            return 0\r\n        i = 0\r\n        sign = 1\r\n        ret = 0\r\n        length = len(str)\r\n        MaxInt = (1 << 31) - 1\r\n        if str[i] == '+':\r\n            i += 1\r\n        elif str[i] == '-' :\r\n            i += 1\r\n            sign = -1\r\n        \r\n        for i in range(i, length) :\r\n            if str[i] < '0' or str[i] > '9' :\r\n                break\r\n            ret = ret * 10 + int(str[i])\r\n            if ret > sys.maxint:\r\n                break\r\n        ret *= sign\r\n        if ret >= MaxInt:\r\n            return MaxInt\r\n        if ret < MaxInt * -1 :\r\n            return MaxInt * - 1 - 1 \r\n        return ret"}]},{"id":171,"unique_name":"min-stack","title":"带最小值操作的栈","description":"<p>实现一个带有取最小值min方法的栈，min方法将返回当前栈中的最小值。</p><p>你实现的栈将支持<b><font color=\"#e76363\">push</font></b>，<font color=\"#e76363\"><b>pop</b></font> 和 <font color=\"#e76363\"><b>min</b></font> 操作，所有操作要求都在O(1)时间内完成。</p>","solutions":[{"language":"java","code":"// version 1:\r\npublic class MinStack {\r\n    private Stack<Integer> stack;\r\n    private Stack<Integer> minStack;\r\n    \r\n    public MinStack() {\r\n        stack = new Stack<Integer>();\r\n        minStack = new Stack<Integer>();\r\n    }\r\n\r\n    public void push(int number) {\r\n        stack.push(number);\r\n        if (minStack.isEmpty()) {\r\n            minStack.push(number);\r\n        } else {\r\n            minStack.push(Math.min(number, minStack.peek()));\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        minStack.pop();\r\n        return stack.pop();\r\n    }\r\n\r\n    public int min() {\r\n        return minStack.peek();\r\n    }\r\n}\r\n\r\n// version 2, save more space. but space complexity doesn't change.\r\npublic class MinStack {\r\n    private Stack<Integer> stack;\r\n    private Stack<Integer> minStack;\r\n\r\n    public MinStack() {\r\n        stack = new Stack<Integer>();\r\n        minStack = new Stack<Integer>();\r\n    }\r\n\r\n    public void push(int number) {\r\n        stack.push(number);\r\n        if (minStack.empty() == true)\r\n            minStack.push(number);\r\n        else {\r\n        // 这里考虑的相等的情况也会继续push\r\n        if (minStack.peek() >= number)\r\n            minStack.push(number);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (stack.peek().equals(minStack.peek()) ) \r\n            minStack.pop();\r\n        return stack.pop();\r\n    }\r\n\r\n    public int min() {\r\n        return minStack.peek();\r\n    }\r\n}"},{"language":"cpp","code":"class MinStack {\r\npublic:\r\n    stack<int> stk, minstk;\r\n\r\n    void push(int number) {\r\n        stk.push(number);\r\n        if (minstk.empty() or number <= minstk.top()) {\r\n            minstk.push(number);\r\n        }\r\n    }\r\n\r\n    int pop() {\r\n        int top = stk.top();\r\n        stk.pop();\r\n        if (top == minstk.top()) {\r\n            minstk.pop();\r\n        }\r\n        return top;\r\n    }\r\n\r\n    int min() {\r\n        return minstk.top();\r\n    }\r\n};\r\n"},{"language":"python","code":"class MinStack(object):\r\n\r\n    def __init__(self):\r\n        # do some intialize if necessary\r\n        self.stack = []\r\n        self.minstack = []\r\n\r\n    def push(self, number):\r\n        # write yout code here\r\n        self.stack.append(number)\r\n        if len(self.minstack) == 0 or number <= self.minstack[-1]:\r\n            self.minstack.append(number)\r\n\r\n    def pop(self):\r\n        # pop and return the top item in stack\r\n        if self.stack[-1] == self.minstack[-1]:\r\n            self.minstack.pop()\r\n        return self.stack.pop()\r\n\r\n    def min(self):\r\n        # return the minimum number in stack\r\n        return self.minstack[-1]"}]},{"id":316,"unique_name":"binary-tree-serialization","title":"二叉树的序列化和反序列化","description":"设计一个算法，并编写代码来序列化和反序列化二叉树。将树写入一个文件被称为“序列化”，读取文件后重建同样的二叉树被称为“反序列化”。\r\n\r\n如何反序列化或序列化二叉树是没有限制的，你只需要确保可以将二叉树序列化为一个字符串，并且可以将字符串反序列化为原来的树结构。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    /**\r\n     * This method will be invoked first, you should design your own algorithm \r\n     * to serialize a binary tree which denote by a root node to a string which\r\n     * can be easily deserialized by your own \"deserialize\" method later.\r\n     */\r\n    public String serialize(TreeNode root) {\r\n        if (root == null) {\r\n            return \"{}\";\r\n        }\r\n\r\n        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();\r\n        queue.add(root);\r\n\r\n        for (int i = 0; i < queue.size(); i++) {\r\n            TreeNode node = queue.get(i);\r\n            if (node == null) {\r\n                continue;\r\n            }\r\n            queue.add(node.left);\r\n            queue.add(node.right);\r\n        }\r\n\r\n        while (queue.get(queue.size() - 1) == null) {\r\n            queue.remove(queue.size() - 1);\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"{\");\r\n        sb.append(queue.get(0).val);\r\n        for (int i = 1; i < queue.size(); i++) {\r\n            if (queue.get(i) == null) {\r\n                sb.append(\",#\");\r\n            } else {\r\n                sb.append(\",\");\r\n                sb.append(queue.get(i).val);\r\n            }\r\n        }\r\n        sb.append(\"}\");\r\n        return sb.toString();\r\n    }\r\n    \r\n    /**\r\n     * This method will be invoked second, the argument data is what exactly\r\n     * you serialized at method \"serialize\", that means the data is not given by\r\n     * system, it's given by your own serialize method. So the format of data is\r\n     * designed by yourself, and deserialize it here as you serialize it in \r\n     * \"serialize\" method.\r\n     */\r\n    public TreeNode deserialize(String data) {\r\n        if (data.equals(\"{}\")) {\r\n            return null;\r\n        }\r\n        String[] vals = data.substring(1, data.length() - 1).split(\",\");\r\n        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();\r\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\r\n        queue.add(root);\r\n        int index = 0;\r\n        boolean isLeftChild = true;\r\n        for (int i = 1; i < vals.length; i++) {\r\n            if (!vals[i].equals(\"#\")) {\r\n                TreeNode node = new TreeNode(Integer.parseInt(vals[i]));\r\n                if (isLeftChild) {\r\n                    queue.get(index).left = node;\r\n                } else {\r\n                    queue.get(index).right = node;\r\n                }\r\n                queue.add(node);\r\n            }\r\n            if (!isLeftChild) {\r\n                index++;\r\n            }\r\n            isLeftChild = !isLeftChild;\r\n        }\r\n        return root;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    string serialize(TreeNode *root) {\r\n        vector<TreeNode *> Q;\r\n        Q.push_back(root);\r\n\r\n        for (int i = 0; i < Q.size(); i++) {\r\n            TreeNode *node = Q[i];\r\n            if (node == NULL) {\r\n                continue;\r\n            }\r\n            Q.push_back(node->left);\r\n            Q.push_back(node->right);\r\n        }\r\n\r\n        while (Q.size() > 0 && Q[Q.size() - 1] == NULL) {\r\n            Q.pop_back();\r\n        }\r\n\r\n        if (Q.size() == 0) {\r\n            return \"{}\";\r\n        }\r\n\r\n        stringstream ss;\r\n        ss << \"{\" << Q[0]->val;\r\n        for (int i = 1; i < Q.size(); i++) {\r\n            if (Q[i] == NULL) {\r\n                ss << \",#\";\r\n            } else {\r\n                ss << \",\" << Q[i]->val;\r\n            }\r\n        }\r\n        ss << \"}\";\r\n    \r\n        return ss.str(); \r\n    }\r\n\r\n    TreeNode *deserialize(string data) {\r\n        if (data == \"{}\") {\r\n            return NULL;\r\n        }\r\n\r\n        vector<string> vals = split(data.substr(1, data.size() - 2), \",\");\r\n        TreeNode *root = new TreeNode(atoi(vals[0].c_str()));\r\n        queue<TreeNode *> Q;\r\n        Q.push(root);\r\n\r\n        bool isLeftChild= true;\r\n        for (int i = 1; i < vals.size(); i++) {\r\n            if (vals[i] != \"#\") {\r\n                TreeNode *node = new TreeNode(atoi(vals[i].c_str()));\r\n                if (isLeftChild) {\r\n                    Q.front()->left = node;\r\n                } else {\r\n                    Q.front()->right = node;\r\n                }\r\n                Q.push(node);\r\n            }\r\n            if (!isLeftChild) {\r\n                Q.pop();\r\n            }\r\n\r\n            isLeftChild = !isLeftChild; \r\n        }\r\n        return root;\r\n    }\r\n\r\n    vector<string> split(const string &str, string delim) {\r\n        vector<string> results;\r\n        int lastIndex = 0, index;\r\n        while ((index = str.find(delim, lastIndex)) != string::npos) {\r\n            results.push_back(str.substr(lastIndex, index - lastIndex));\r\n            lastIndex = index + delim.length();\r\n        }\r\n\r\n        if (lastIndex != str.length()) {\r\n            results.push_back(str.substr(lastIndex, str.length() - lastIndex));\r\n        }\r\n\r\n        return results;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n\r\n\r\n    def serialize(self, root):\r\n        if root is None:\r\n            return \"{}\"\r\n\r\n        queue = [root]\r\n        index = 0\r\n        while index < len(queue):\r\n            if queue[index] is not None:\r\n                queue.append(queue[index].left)\r\n                queue.append(queue[index].right)\r\n            index += 1\r\n\r\n        while queue[-1] is None:\r\n            queue.pop()\r\n\r\n        return '{%s}' % ','.join([str(node.val) if node is not None else '#'\r\n                                  for node in queue])\r\n\r\n\r\n    def deserialize(self, data):\r\n        data = data.strip('\\n')\r\n\r\n        if data == '{}':\r\n            return None\r\n\r\n        vals = data[1:-1].split(',')\r\n            \r\n        root = TreeNode(int(vals[0]))\r\n        queue = [root]\r\n        isLeftChild = True\r\n        index = 0\r\n\r\n        for val in vals[1:]:\r\n            if val is not '#':\r\n                node = TreeNode(int(val))\r\n                if isLeftChild:\r\n                    queue[index].left = node\r\n                else:\r\n                    queue[index].right = node\r\n                queue.append(node)\r\n\r\n            if not isLeftChild:\r\n                index += 1\r\n            isLeftChild = not isLeftChild\r\n\r\n        return root"}]},{"id":109,"unique_name":"valid-parentheses","title":"有效的括号序列","description":"给定一个字符串所表示的括号序列，包含以下字符： `'(', ')'`, `'{'`, `'}'`, `'['` and `']'`， 判定是否是有效的括号序列。","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean isValidParentheses(String s) {\r\n        Stack<Character> stack = new Stack<Character>();\r\n        for (Character c : s.toCharArray()) {\r\n\t    if (\"({[\".contains(String.valueOf(c))) {\r\n                stack.push(c);\r\n            } else {\r\n               if (!stack.isEmpty() && is_valid(stack.peek(), c)) {\r\n                   stack.pop();\r\n               } else {\r\n                   return false;\r\n               }\r\n           }\r\n       }\r\n       return stack.isEmpty();\r\n    }\r\n\r\n    private boolean is_valid(char c1, char c2) {\r\n        return (c1 == '(' && c2 == ')') || (c1 == '{' && c2 == '}')\r\n            || (c1 == '[' && c2 == ']');\r\n    }\r\n}\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param s A string\r\n     * @return whether the string is a valid parentheses\r\n     */\r\n    public boolean isValidParentheses(String s) {\r\n        // Write your code here\r\n        Stack<Character> stack = new Stack<>();\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '(' || c == '[' || c == '{') {\r\n                stack.push(c);\r\n            }\r\n            if (c == ')') {\r\n                if (stack.isEmpty() || stack.pop() != '(') {\r\n                    return false;\r\n                }\r\n            }\r\n            if (c == ']') {\r\n                if (stack.isEmpty() || stack.pop() != '[') {\r\n                    return false;\r\n                }\r\n            }\r\n            if (c == '}') {\r\n                if (stack.isEmpty() || stack.pop() != '{') {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return stack.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n"},{"language":"cpp","code":"// 高频题班版本 version 1\r\nclass Solution {\r\npublic:\r\n  /**\r\n   * @param s A string\r\n   * @return whether the string is a valid parentheses\r\n   */\r\n  bool isValidParentheses(string& s) {\r\n    // Write your code here\r\n    vector<char> stack;\r\n    stack.push_back(' ');\r\n    for (int i = 0; i < s.size(); i++) {\r\n      char item = s[i];\r\n      if (item == '(' || item == '[' || item == '{') {\r\n        stack.push_back(item);\r\n      }\r\n      \r\n      if (item == ')') {\r\n        if (stack.back() != '(') {\r\n          return false;\r\n        }\r\n        stack.pop_back();  \r\n      }\r\n      \r\n      if (item == ']') {\r\n        if (stack.back() != '[') {\r\n          return false;\r\n        }\r\n        stack.pop_back();  \r\n      }  \r\n      \r\n      if (item == '}') {\r\n        if (stack.back() != '{') {\r\n          return false;\r\n        }\r\n        stack.pop_back();  \r\n      }    \r\n    } \r\n    if (stack.back() != ' ') {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n};\r\n\r\n\r\n// version 2\r\nclass Solution {\r\npublic:\r\n    /*\r\n    题意：输入一个只包含括号的字符串，判断括号是否匹配\r\n    模拟堆栈，读到左括号压栈，读到右括号判断栈顶括号是否匹配\r\n    */\r\n    bool isValidParentheses((string s) {\r\n        int len = s.length();\r\n        vector<char> stack;\r\n        for (int i = 0; i < len; i++) {\r\n            // 左括号压栈\r\n            if (s[i] == '(' || s[i] == '[' || s[i] == '{') stack.push_back(s[i]);\r\n            else {\r\n                // 右括号出栈\r\n                if (stack.empty()) return false;\r\n                char top = stack[stack.size() - 1];\r\n                if (s[i] == ')' && top != '(')\r\n                    return false;\r\n                if (s[i] == ']' && top != '[') \r\n                    return false;\r\n                if (s[i] == '}' && top != '{') \r\n                    return false;\r\n                stack.pop_back();\r\n            }\r\n        }\r\n        // 栈中无多余左括号\r\n        if (stack.size() > 0) return false;\r\n        return true;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    '''\r\n    题意：输入一个只包含括号的字符串，判断括号是否匹配\r\n    模拟堆栈，读到左括号压栈，读到右括号判断栈顶括号是否匹配\r\n    '''\r\n    def isValidParentheses(self, s):\r\n        stack = []\r\n        for ch in s:\r\n            # 压栈\r\n            if ch == '{' or ch == '[' or ch == '(':\r\n                stack.append(ch)\r\n            else:\r\n                # 栈需非空\r\n                if not stack:\r\n                    return False\r\n                # 判断栈顶是否匹配\r\n                if ch == ']' and stack[-1] != '[' or ch == ')' and stack[-1] != '(' or ch == '}' and stack[-1] != '{':\r\n                    return False\r\n                # 弹栈\r\n                stack.pop()\r\n        return not stack"}]},{"id":116,"unique_name":"roman-to-integer","title":"罗马数字转整数","description":"给定一个罗马数字，将其转换成整数。\r\n\r\n返回的结果要求在1到3999的范围内。","solutions":[{"language":"java","code":"public class Solution {\r\n \tpublic int romanToInt(String s) {\r\n\t    if (s == null || s.length()==0) {\r\n                return 0;\r\n\t    }\r\n\t    Map<Character, Integer> m = new HashMap<Character, Integer>();\r\n\t    m.put('I', 1);\r\n\t    m.put('V', 5);\r\n\t    m.put('X', 10);\r\n\t    m.put('L', 50);\r\n\t    m.put('C', 100);\r\n\t    m.put('D', 500);\r\n\t    m.put('M', 1000);\r\n\r\n\t    int length = s.length();\r\n\t    int result = m.get(s.charAt(length - 1));\r\n\t    for (int i = length - 2; i >= 0; i--) {\r\n\t        if (m.get(s.charAt(i + 1)) <= m.get(s.charAt(i))) {\r\n\t            result += m.get(s.charAt(i));\r\n\t        } else {\r\n\t            result -= m.get(s.charAt(i));\r\n\t        }\r\n\t    }\r\n\t    return result;\r\n\t}\r\n}\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param s Roman representation\r\n     * @return an integer\r\n     */\r\n    public int romanToInt(String s) {\r\n        // Write your code here\r\n        int ans;\r\n        char[] sc = s.toCharArray();\r\n        ans = toInt(sc[0]);                        //0 special\r\n        for (int i = 1; i < s.length(); i++) {\r\n            ans += toInt(sc[i]);\r\n            if (toInt(sc[i - 1]) < toInt(sc[i])) {\r\n                ans -= toInt(sc[i - 1]) * 2;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    int toInt(char s) {\r\n        switch(s) {\r\n            case 'I':return 1;\r\n            case 'V':return 5;\r\n            case 'X':return 10;\r\n            case 'L':return 50;\r\n            case 'C':return 100;\r\n            case 'D':return 500;\r\n            case 'M':return 1000;\r\n        }\r\n        return 0;\r\n    }\r\n}"},{"language":"cpp","code":"\r\nclass Solution {\r\npublic:\r\n  int romanToInt(string s) {\r\n    int ans = 0;\r\n    ans = toInt(s[0]);\r\n    for (int i = 1; i < s.length(); i++) {\r\n      ans += toInt(s[i]);\r\n      if (toInt(s[i-1]) < toInt(s[i])) { \r\n        ans -= toInt(s[i-1]) * 2;\r\n      } \r\n    }\r\n    return ans;\r\n  }\r\n  \r\n  int toInt(char s) {\r\n    switch(s) {\r\n      case 'I':return 1;\r\n      case 'V':return 5;\r\n      case 'X':return 10;\r\n      case 'L':return 50;\r\n      case 'C':return 100;\r\n      case 'D':return 500;\r\n      case 'M':return 1000;\r\n    }\r\n    return 0;\r\n  }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {string} s\r\n    # @return {integer}\r\n    def romanToInt(self, s):\r\n        ROMAN = {\r\n            'I': 1,\r\n            'V': 5,\r\n            'X': 10,\r\n            'L': 50,\r\n            'C': 100,\r\n            'D': 500,\r\n            'M': 1000\r\n        }\r\n        \r\n        if s == \"\":\r\n            return 0\r\n            \r\n        index = len(s) - 2\r\n        sum = ROMAN[s[-1]]\r\n        while index >= 0:\r\n            if ROMAN[s[index]] < ROMAN[s[index + 1]]:\r\n                sum -= ROMAN[s[index]]\r\n            else:\r\n                sum += ROMAN[s[index]]\r\n            index -= 1\r\n        return sum"}]},{"id":94,"unique_name":"valid-sudoku","title":"判断数独是否合法","description":"请判定一个数独是否有效。\r\n\r\n该数独可能只填充了部分数字，其中缺少的数字用 `.` 表示。","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean isValidSudoku(char[][] board) {\r\n        boolean[] visited = new boolean[9];\r\n        \r\n        // row\r\n        for(int i = 0; i<9; i++){\r\n            Arrays.fill(visited, false);\r\n            for(int j = 0; j<9; j++){\r\n                if(!process(visited, board[i][j]))\r\n                    return false;\r\n            }\r\n        }\r\n        \r\n        //col\r\n        for(int i = 0; i<9; i++){\r\n            Arrays.fill(visited, false);\r\n            for(int j = 0; j<9; j++){\r\n                if(!process(visited, board[j][i]))\r\n                    return false;\r\n            }\r\n        }\r\n        \r\n        // sub matrix\r\n        for(int i = 0; i<9; i+= 3){\r\n            for(int j = 0; j<9; j+= 3){\r\n                Arrays.fill(visited, false);\r\n                for(int k = 0; k<9; k++){\r\n                    if(!process(visited, board[i + k/3][ j + k%3]))\r\n                    return false;                   \r\n                }\r\n            }\r\n        }\r\n        return true;\r\n        \r\n    }\r\n    \r\n    private boolean process(boolean[] visited, char digit){\r\n        if(digit == '.'){\r\n            return true;\r\n        }\r\n        \r\n        int num = digit - '0';\r\n        if ( num < 1 || num > 9 || visited[num-1]){\r\n            return false;\r\n        }\r\n        \r\n        visited[num-1] = true;\r\n        return true;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    bool isValidSudoku(const vector<vector<char>>& board) {\n        bool used[9];\n        for (int i = 0; i < 9; ++i) {\n            fill(used, used + 9, false);\n            for (int j = 0; j < 9; ++j) // 检查行\n                if (!check(board[i][j], used))\n                    return false;\n            fill(used, used + 9, false);\n            for (int j = 0; j < 9; ++j) // 检查列\n                if (!check(board[j][i], used))\n                    return false;\n        }\n        for (int r = 0; r < 3; ++r) // 检查9 个子格子\n            for (int c = 0; c < 3; ++c) {\n                fill(used, used + 9, false);\n                for (int i = r * 3; i < r * 3 + 3; ++i)\n                    for (int j = c * 3; j < c * 3 + 3; ++j)\n                        if (!check(board[i][j], used))\n                            return false;\n            }\n        return true;\n    }\n    bool check(char ch, bool used[9]) {\n        if (ch == '.') return true;\n        if (used[ch - '1']) return false;\n        return used[ch - '1'] = true;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param board, a 9x9 2D array\n    # @return a boolean\n    def isValidSudoku(self, board):\n        row = [set([]) for i in range(9)]\n        col = [set([]) for i in range(9)]\n        grid = [set([]) for i in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == '.':\n                    continue\n                if board[r][c] in row[r]:\n                    return False\n                if board[r][c] in col[c]:\n                    return False\n\n                g = r / 3 * 3 + c / 3\n                if board[r][c] in grid[g]:\n                    return False\n                grid[g].add(board[r][c])\n                row[r].add(board[r][c])\n                col[c].add(board[r][c])\n\n        return True\n"}]},{"id":9,"unique_name":"lru-cache","title":"LRU缓存策略","description":"<p>为最近最少使用（LRU）<span style=\"line-height: 1.42857143;\">缓存</span><span style=\"line-height: 1.42857143;\">策略设计一个数据结构，它应该支持以下操作：获取数据（<font color=\"#e76363\"><b>get</b></font>）和写入数据（<b><font color=\"#e76363\">set</font></b>）。</span></p><p>获取数据<b><font color=\"#e76363\">get(key)</font></b>：如果缓存中存在key，则获取其数据值（通常是正数），否则返回-1。</p><p>写入数据<font color=\"#e76363\"><b>set(key, value)</b></font>：如果key还没有在缓存中，则写入其数据值。当缓存达到上限，它应该在写入新数据之前删除最近最少使用的数据用来腾出空闲位置。</p>","solutions":[{"language":"java","code":"public class LRUCache {\n    private class Node{\n        Node prev;\n        Node next;\n        int key;\n        int value;\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n\n    private int capacity;\n    private HashMap<Integer, Node> hs = new HashMap<Integer, Node>();\n    private Node head = new Node(-1, -1);\n    private Node tail = new Node(-1, -1);\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        tail.prev = head;\n        head.next = tail;\n    }\n\n    public int get(int key) {\n        if( !hs.containsKey(key)) {\n            return -1;\n        }\n\n        // remove current\n        Node current = hs.get(key);\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n\n        // move current to tail\n        move_to_tail(current);\n\n        return hs.get(key).value;\n    }\n\n    public void set(int key, int value) {\n        // get 这个方法会把key挪到最末端，因此，不需要再调用 move_to_tail\n        if (get(key) != -1) {\n            hs.get(key).value = value;\n            return;\n        }\n\n        if (hs.size() == capacity) {\n            hs.remove(head.next.key);\n            head.next = head.next.next;\n            head.next.prev = head;\n        }\n\n        Node insert = new Node(key, value);\n        hs.put(key, insert);\n        move_to_tail(insert);\n    }\n\n    private void move_to_tail(Node current) {\n        current.prev = tail.prev;\n        tail.prev = current;\n        current.prev.next = current;\n        current.next = tail;\n    }\n}"},{"language":"cpp","code":"class KeyValue {\r\npublic:\r\n    int key, value;\r\n    KeyValue *next;\r\n    KeyValue(int key, int value) {\r\n        next = NULL;\r\n        this->key = key;\r\n        this->value = value;\r\n    }\r\n    KeyValue() {\r\n        this->next = NULL;\r\n        this->key = 0;\r\n        this->value = 0;\r\n    }\r\n};\r\n\r\nclass LRUCache{\r\nprivate:\r\n    void moveToTail(KeyValue *prev) {\r\n        if (prev->next == tail) {\r\n            return;\r\n        }\r\n        \r\n        KeyValue *node = prev->next;\r\n        prev->next = node->next;\r\n        if (node->next != NULL) {\r\n            hash[node->next->key] = prev;\r\n        }\r\n        tail->next = node;\r\n        node->next = NULL;\r\n        hash[node->key] = tail;\r\n        tail = node;\r\n    }\r\n    \r\npublic:\r\n    unordered_map<int, KeyValue *> hash;\r\n    KeyValue *head, *tail;\r\n    int capacity, size;\r\n    \r\n    LRUCache(int capacity) {\r\n        this->head = new KeyValue(0, 0);\r\n        this->tail = head;\r\n        this->capacity = capacity;\r\n        this->size = 0;\r\n        hash.clear();\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (hash.find(key) == hash.end()) {\r\n            return -1;\r\n        }\r\n        \r\n        moveToTail(hash[key]);\r\n        return hash[key]->next->value;\r\n    }\r\n    \r\n    void set(int key, int value) {\r\n        if (hash.find(key) != hash.end()) {\r\n            hash[key]->next->value = value;\r\n            moveToTail(hash[key]);\r\n        } else {\r\n            KeyValue *node = new KeyValue(key, value);\r\n            tail->next = node;\r\n            hash[key] = tail;\r\n            tail = node;\r\n            size++;\r\n            if (size > capacity) {\r\n                hash.erase(head->next->key);\r\n                head->next = head->next->next;\r\n                if (head->next != NULL) {\r\n                    hash[head->next->key] = head;\r\n                }\r\n                size--;\r\n            }\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class LinkedNode:\r\n    \r\n    def __init__(self, key=None, value=None, next=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.next = next\r\n\r\nclass LRUCache:\r\n\r\n    # @param capacity, an integer\r\n    def __init__(self, capacity):\r\n        self.hash = {}\r\n        self.head = LinkedNode()\r\n        self.tail = self.head\r\n        self.capacity = capacity\r\n    \r\n    def push_back(self, node):\r\n        self.hash[node.key] = self.tail\r\n        self.tail.next = node\r\n        self.tail = node\r\n    \r\n    def pop_front(self):\r\n        del self.hash[self.head.next.key]\r\n        self.head.next = self.head.next.next\r\n        self.hash[self.head.next.key] = self.head\r\n        \r\n    # change \"prev->node->next...->tail\"\r\n    # to \"prev->next->...->tail->node\"\r\n    def kick(self, prev):\r\n        node = prev.next\r\n        if node == self.tail:\r\n            return\r\n        prev.next = node.next\r\n        if node.next is not None:\r\n            self.hash[node.next.key] = prev\r\n            node.next = None\r\n        self.push_back(node)\r\n\r\n    # @return an integer\r\n    def get(self, key):\r\n        if key not in self.hash:\r\n            return -1\r\n        self.kick(self.hash[key])\r\n        return self.hash[key].next.value\r\n\r\n    # @param key, an integer\r\n    # @param value, an integer\r\n    # @return nothing\r\n    def set(self, key, value):\r\n        if key in self.hash:\r\n            self.kick(self.hash[key])\r\n            self.hash[key].next.value = value\r\n        else:\r\n            self.push_back(LinkedNode(key, value))\r\n            if len(self.hash) > self.capacity:\r\n                self.pop_front()\r\n        "}]},{"id":17,"unique_name":"copy-list-with-random-pointer","title":"复制带随机指针的链表","description":"<p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。</p><p><span style=\"line-height: 1.42857143;\">返回一个深拷贝的链表。&nbsp;</span></p>","solutions":[{"language":"java","code":"//HashMap version\r\npublic class Solution {\r\n    public RandomListNode copyRandomList(RandomListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        HashMap<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\r\n        RandomListNode dummy = new RandomListNode(0);\r\n        RandomListNode pre = dummy, newNode;\r\n        while (head != null) {\r\n            if (map.containsKey(head)) {\r\n                newNode = map.get(head);\r\n            } else {\r\n                newNode = new RandomListNode(head.label);\r\n                map.put(head, newNode);\r\n            }\r\n            pre.next = newNode;\r\n\r\n            if (head.random != null) {\r\n                if (map.containsKey(head.random)) {\r\n                    newNode.random = map.get(head.random);\r\n                } else {\r\n                    newNode.random = new RandomListNode(head.random.label);\r\n                    map.put(head.random, newNode.random);\r\n                }\r\n            }\r\n\r\n            pre = newNode;\r\n            head = head.next;\r\n        }\r\n\r\n        return dummy.next;\r\n    }\r\n}\r\n\r\n/*第一遍扫的时候巧妙运用next指针， 开始数组是1->2->3->4  。 然后扫描过程中 先建立copy节点 1->1`->2->2`->3->3`->4->4`, 然后第二遍copy的时候去建立边的copy， 拆分节点, 一边扫描一边拆成两个链表，这里用到两个dummy node。第一个链表变回  1->2->3 , 然后第二变成 1`->2`->3`  */\r\n//No HashMap version\r\npublic class Solution {\r\n    private void copyNext(RandomListNode head) {\r\n        while (head != null) {\r\n            RandomListNode newNode = new RandomListNode(head.label);\r\n            newNode.random = head.random;\r\n            newNode.next = head.next;\r\n            head.next = newNode;\r\n            head = head.next.next;\r\n        }\r\n    }\r\n\r\n    private void copyRandom(RandomListNode head) {\r\n        while (head != null) {\r\n            if (head.next.random != null) {\r\n                head.next.random = head.random.next;\r\n            }\r\n            head = head.next.next;\r\n        }\r\n    }\r\n\r\n    private RandomListNode splitList(RandomListNode head) {\r\n        RandomListNode newHead = head.next;\r\n        while (head != null) {\r\n            RandomListNode temp = head.next;\r\n            head.next = temp.next;\r\n            head = head.next;\r\n            if (temp.next != null) {\r\n                temp.next = temp.next.next;\r\n            }\r\n        }\r\n        return newHead;\r\n    }\r\n\r\n    public RandomListNode copyRandomList(RandomListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        copyNext(head);\r\n        copyRandom(head);\r\n        return splitList(head);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition for singly-linked list with a random pointer.\n * struct RandomListNode {\n *     int label;\n *     RandomListNode *next, *random;\n *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    /**\n     * @param head: The head of linked list with a random pointer.\n     * @return: A new head of a deep copy of the list.\n     */\n    RandomListNode *copyRandomList(RandomListNode *head) {\n        // write your code here\n        unordered_map<RandomListNode*, RandomListNode*> old2new;\n        RandomListNode* dummy = new RandomListNode(-1);\n        RandomListNode* tmp = head;\n        RandomListNode* curr = dummy;\n        while (tmp) {\n            RandomListNode* newNode = new RandomListNode(tmp->label);\n            old2new[tmp] = newNode;\n            curr->next = newNode;\n            curr = curr -> next;\n            tmp = tmp->next;\n        }\n        tmp = head;\n        while (tmp) {\n            if (tmp->random) {\n                old2new[tmp]->random = old2new[tmp->random];\n            }\n            tmp = tmp-> next;\n        }\n        return dummy->next;\n    }\n};\n"},{"language":"python","code":"# Definition for singly-linked list with a random pointer.\n# class RandomListNode:\n#     def __init__(self, x):\n#         self.label = x\n#         self.next = None\n#         self.random = None\nclass Solution:\n    # @param head: A RandomListNode\n    # @return: A RandomListNode\n    def copyRandomList(self, head):\n        # write your code here\n        if head == None:\n            return None\n            \n        myMap = {}\n        nHead = RandomListNode(head.label)\n        myMap[head] = nHead\n        p = head\n        q = nHead\n        while p != None:\n            q.random = p.random\n            if p.next != None:\n                q.next = RandomListNode(p.next.label)\n                myMap[p.next] = q.next\n            else:\n                q.next = None\n            p = p.next\n            q = q.next\n        \n        p = nHead\n        while p!= None:\n            if p.random != None:\n                p.random = myMap[p.random]\n            p = p.next\n        return nHead\n"}]},{"id":127,"unique_name":"median-of-two-sorted-arrays","title":"两个排序数组的中位数","description":"<p><span style=\"line-height: 1.42857143;\">两个排序的数组</span><span style=\"line-height: 1.42857143;\">A和B</span><span style=\"line-height: 1.42857143;\">分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。</span></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public double findMedianSortedArrays(int A[], int B[]) {\r\n        int len = A.length + B.length;\r\n        if (len % 2 == 1) {\r\n            return findKth(A, 0, B, 0, len / 2 + 1);\r\n        }\r\n        return (\r\n            findKth(A, 0, B, 0, len / 2) + findKth(A, 0, B, 0, len / 2 + 1)\r\n        ) / 2.0;\r\n    }\r\n\r\n    // find kth number of two sorted array\r\n    public static int findKth(int[] A, int A_start,\r\n                              int[] B, int B_start,\r\n                              int k){\t\t\r\n\t\tif (A_start >= A.length) {\r\n\t\t\treturn B[B_start + k - 1];\r\n\t\t}\r\n\t\tif (B_start >= B.length) {\r\n\t\t\treturn A[A_start + k - 1];\r\n\t\t}\r\n\r\n\t\tif (k == 1) {\r\n\t\t\treturn Math.min(A[A_start], B[B_start]);\r\n\t\t}\r\n\t\t\r\n\t\tint A_key = A_start + k / 2 - 1 < A.length\r\n\t\t            ? A[A_start + k / 2 - 1]\r\n\t\t            : Integer.MAX_VALUE;\r\n\t\tint B_key = B_start + k / 2 - 1 < B.length\r\n\t\t            ? B[B_start + k / 2 - 1]\r\n\t\t            : Integer.MAX_VALUE; \r\n\t\t\r\n\t\tif (A_key < B_key) {\r\n\t\t\treturn findKth(A, A_start + k / 2, B, B_start, k - k / 2);\r\n\t\t} else {\r\n\t\t\treturn findKth(A, A_start, B, B_start + k / 2, k - k / 2);\r\n\t\t}\r\n\t}\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n    对于一个长度为n的已排序数列a，若n为奇数，中位数为a[n / 2 + 1] , \r\n    若n为偶数，则中位数(a[n / 2] + a[n / 2 + 1]) / 2\r\n    如果我们可以在两个数列中求出第K小的元素，便可以解决该问题\r\n    不妨设数列A元素个数为n，数列B元素个数为m，各自升序排序，求第k小元素\r\n    取A[k / 2] B[k / 2] 比较，\r\n    如果 A[k / 2] > B[k / 2] 那么，所求的元素必然不在B的前k / 2个元素中(证明反证法)\r\n    反之，必然不在A的前k / 2个元素中，于是我们可以将A或B数列的前k / 2元素删去，求剩下两个数列的\r\n    k - k / 2小元素，于是得到了数据规模变小的同类问题，递归解决\r\n    如果 k / 2 大于某数列个数，所求元素必然不在另一数列的前k / 2个元素中，同上操作就好。\r\n    */\r\n    double findKth(vector<int>& A, vector<int>& B, int A_st, int B_st, int k) {\r\n        // 边界情况，任一数列为空\r\n        if (A_st >= A.size()) {\r\n            return B[B_st + k - 1];\r\n        }\r\n        if (B_st >= B.size()) {\r\n            return A[A_st + k - 1];\r\n        }\r\n        // k等于1时表示取最小值，直接返回min\r\n        if (k == 1) return min(A[A_st], B[B_st]);\r\n        int A_key = A_st + k / 2 - 1 >= A.size() ? INT_MAX : A[A_st + k / 2 - 1];\r\n        int B_key = B_st + k / 2 - 1 >= B.size() ? INT_MAX : B[B_st + k / 2 - 1];\r\n        if (A_key < B_key){\r\n            return findKth(A, B, A_st + k / 2, B_st, k - k / 2);\r\n        } else {\r\n            return findKth(A, B, A_st, B_st + k / 2, k - k / 2);\r\n        }\r\n        \r\n    }\r\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\r\n        int sum = nums1.size() + nums2.size();\r\n        double ret;\r\n        \r\n        if (sum & 1) {\r\n            ret = findKth(nums1, nums2, 0, 0, sum / 2 + 1);\r\n        } else {\r\n            ret = ((findKth(nums1, nums2, 0, 0, sum / 2)) +\r\n                    findKth(nums1, nums2, 0, 0, sum / 2 + 1)) / 2.0;\r\n        }\r\n        return ret;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A: An integer array.\r\n    @param B: An integer array.\r\n    @return: a double whose format is *.5 or *.0\r\n    \"\"\"\r\n    def findMedianSortedArrays(self, A, B):\r\n        n = len(A) + len(B)\r\n        if n % 2 == 1:\r\n            return self.findKth(A, B, n / 2 + 1)\r\n        else:\r\n            smaller = self.findKth(A, B, n / 2)\r\n            bigger = self.findKth(A, B, n / 2 + 1)\r\n            return (smaller + bigger) / 2.0\r\n\r\n    def findKth(self, A, B, k):\r\n        if len(A) == 0:\r\n            return B[k - 1]\r\n        if len(B) == 0:\r\n            return A[k - 1]\r\n        if k == 1:\r\n            return min(A[0], B[0])\r\n        \r\n        a = A[k / 2 - 1] if len(A) >= k / 2 else None\r\n        b = B[k / 2 - 1] if len(B) >= k / 2 else None\r\n        \r\n        if b is None or (a is not None and a < b):\r\n            return self.findKth(A[k / 2:], B, k - k / 2)\r\n        return self.findKth(A, B[k / 2:], k - k / 2)"}]},{"id":514,"unique_name":"move-zeroes","title":"移动零","description":"给一个数组 *nums* 写一个函数将 `0` 移动到数组的最后面，非零元素保持原数组的顺序","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums an integer array\r\n     * @return nothing, do this in-place\r\n     */\r\n    public void moveZeroes(int[] nums) {\r\n        // Write your code here\r\n        int left = 0, right = 0;\r\n        while (right < nums.length) {\r\n            if (nums[right] != 0) {\r\n                int temp = nums[left];\r\n                nums[left] = nums[right];\r\n                nums[right] = temp;\r\n                left++;\r\n            }\r\n            right++;\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    void moveZeroes(vector<int>& nums) {\r\n        int left = 0, right = 0;\r\n        while (right < nums.size()) {\r\n            if (nums[right]) {\r\n                swap(nums[left++], nums[right]);\r\n            }\r\n            right++;\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums an integer array\r\n    # @return nothing, do this in-place\r\n    def moveZeroes(self, nums):\r\n        # Write your code here\r\n        left = 0;\r\n        right = 0;\r\n        while right < len(nums):\r\n            if nums[right] != 0:\r\n                nums[left], nums[right] = nums[right], nums[left]\r\n                left += 1;\r\n            right += 1;"}]},{"id":465,"unique_name":"reverse-pairs","title":"逆序对","description":"在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给你一个数组，求出这个数组中逆序对的总数。\r\n概括：如果a[i] > a[j] 且 i < j， a[i] 和 a[j] 构成一个逆序对。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A an array\r\n     * @return total of reverse pairs\r\n     */\r\n    public long reversePairs(int[] A) {\r\n        return mergeSort(A, 0, A.length - 1);\r\n    }\r\n    \r\n    private int mergeSort(int[] A, int start, int end) {\r\n        if (start >= end) {\r\n            return 0;\r\n        }\r\n        \r\n        int mid = (start + end) / 2;\r\n        int sum = 0;\r\n        sum += mergeSort(A, start, mid);\r\n        sum += mergeSort(A, mid+1, end);\r\n        sum += merge(A, start, mid, end);\r\n        return sum;\r\n    }\r\n    \r\n    private int merge(int[] A, int start, int mid, int end) {\r\n        int[] temp = new int[A.length];\r\n        int leftIndex = start;\r\n        int rightIndex = mid + 1;\r\n        int index = start;\r\n        int sum = 0;\r\n        \r\n        while (leftIndex <= mid && rightIndex <= end) {\r\n            if (A[leftIndex] <= A[rightIndex]) {\r\n                temp[index++] = A[leftIndex++];\r\n            } else {\r\n                temp[index++] = A[rightIndex++];\r\n                sum += mid - leftIndex + 1;\r\n            }\r\n        }\r\n        while (leftIndex <= mid) {\r\n            temp[index++] = A[leftIndex++];\r\n        }\r\n        while (rightIndex <= end) {\r\n            temp[index++] = A[rightIndex++];\r\n        }\r\n        \r\n        for (int i = start; i <= end; i++) {\r\n            A[i] = temp[i];\r\n        }\r\n        \r\n        return sum;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\nprivate:\r\n    int* tmp;\r\npublic:\r\n    /**\r\n     * @param A an array\r\n     * @return total of reverse pairs\r\n     */\r\n    long long reversePairs(vector<int>& A) {\r\n        // Write your code here\r\n        int n = A.size();\r\n        tmp = new int[n];\r\n        return mergeSort(A, 0, n-1);\r\n    }\r\n\r\n    long long merge(vector<int> &A, int l, int m, int r) {\r\n        int i = l, j = m + 1, k = l;\r\n        long long ans = 0;\r\n        while (i <= m && j <= r) {\r\n            if (A[i] > A[j]) {\r\n                tmp[k++] = A[j++];\r\n                ans += m - i + 1;\r\n            } else {\r\n                tmp[k++] = A[i++];\r\n            }\r\n        }\r\n        while (i <= m) tmp[k++] = A[i++];\r\n        while (j <= r) tmp[k++] = A[j++];\r\n        for (i = l;i <= r; ++i)\r\n            A[i] = tmp[i];\r\n        return ans;\r\n    }\r\n\r\n    long long mergeSort(vector<int> &A, int l,int r) {\r\n        long long ans = 0;\r\n        if (l < r) {\r\n            int m = (l + r) >> 1;\r\n            ans += mergeSort(A, l, m);\r\n            ans += mergeSort(A, m + 1, r);\r\n            ans += merge(A, l, m, r);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} A an array\r\n    # @return {int} total of reverse pairs\r\n    def reversePairs(self, A):\r\n        # Write your code here\r\n        self.tmp = [0] * len(A)\r\n        return self.mergeSort(A, 0, len(A) - 1)\r\n\r\n    def mergeSort(self, A, l, r):\r\n        if l >= r:\r\n            return 0\r\n        \r\n        m = (l + r) >> 1\r\n        ans = self.mergeSort(A, l, m) + self.mergeSort(A, m + 1, r)\r\n        i, j, k = l, m + 1, l\r\n        while i <= m and j <= r:\r\n            if A[i] > A[j]:\r\n                self.tmp[k] = A[j]\r\n                j += 1\r\n                ans += m - i + 1\r\n            else:\r\n                self.tmp[k] = A[i]\r\n                i += 1\r\n            k += 1\r\n    \r\n        while i <= m:\r\n            self.tmp[k] = A[i]\r\n            k += 1\r\n            i += 1\r\n        while j <= r:\r\n            self.tmp[k] = A[j]\r\n            k += 1\r\n            j += 1\r\n        for i in xrange(l, r + 1):\r\n            A[i] = self.tmp[i]\r\n\r\n        return ans\r\n                  \r\n"}]},{"id":163,"unique_name":"maximal-rectangle","title":"最大矩形","description":"给你一个二维矩阵，权值为`False`和`True`，找到一个最大的矩形，使得里面的值全部为`True`，输出它的面积","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param matrix a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    public int maximalRectangle(boolean[][] matrix) {\r\n        // Write your code here\r\n        int m = matrix.length;\r\n        int n = m == 0 ? 0 : matrix[0].length;\r\n        int[][] height = new int[m][n + 1];\r\n \r\n        int maxArea = 0;\r\n        for (int i = 0; i < m; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                if (! matrix[i][j]) {\r\n                    height[i][j] = 0;\r\n                } else {\r\n                    height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;\r\n                }\r\n            }\r\n        }\r\n \r\n        for (int i = 0; i < m; i++) {\r\n            int area = maxAreaInHist(height[i]);\r\n            if (area > maxArea) {\r\n                maxArea = area;\r\n            }\r\n        }\r\n \r\n        return maxArea;\r\n    }\r\n \r\n    private int maxAreaInHist(int[] height) {\r\n        Stack<Integer> stack = new Stack<Integer>();\r\n    \r\n        int i = 0;\r\n        int max = 0;\r\n     \r\n        while (i < height.length) {\r\n            if (stack.isEmpty() || height[stack.peek()] <= height[i]) {\r\n                stack.push(i++);\r\n            } else {\r\n                int t = stack.pop();\r\n                max = Math.max(max, height[t]\r\n                        * (stack.isEmpty() ? i : i - stack.peek() - 1));\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\n\r\n// 动态规划专题班版本\r\npublic class Solution {\r\n    /**\r\n     * @param matrix a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    public int maximalRectangle(boolean[][] A) {\r\n        // A is boolean\r\n        // when calculating left and right, check A[i-1][j] is true\r\n        if (A==null||A.length==0||A[0].length==0) {\r\n            return 0;\r\n        }\r\n        int m = A.length;\r\n        int n = A[0].length;\r\n        int[][] up = new int[m][n];\r\n        int[][] left = new int[m][n];\r\n        int[][] right = new int[m][n];\r\n        int i, j, k, l, r, res = 0;\r\n        \r\n        for (i=0; i<m; ++i) {\r\n            // calc up\r\n            for (j=0; j<n; ++j) {\r\n                if (!A[i][j]) {\r\n                    up[i][j] = 0;\r\n                }\r\n                else {\r\n                    up[i][j] = 1;\r\n                    if (i>0) {\r\n                        up[i][j] += up[i-1][j];\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // calc left\r\n            l = 0;\r\n            for (j=0; j<n; ++j) {\r\n                if (!A[i][j]) {\r\n                    l = left[i][j] = 0;\r\n                }\r\n                else {\r\n                    ++l;\r\n                    left[i][j] = l;\r\n                    if (i>0&&A[i-1][j]&&left[i-1][j] < left[i][j]) {\r\n                        left[i][j] = left[i-1][j];\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // calc right\r\n            r=0;\r\n            for (j=n-1; j>=0; --j) {\r\n                if (!A[i][j]) {\r\n                    r = right[i][j] = 0;\r\n                }\r\n                else {\r\n                    ++r;\r\n                    right[i][j] = r;\r\n                    if (i>0&&A[i-1][j]&&right[i-1][j] < right[i][j]) {\r\n                        right[i][j] = right[i-1][j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        for (i=0; i<m; ++i) {\r\n            for (j=0; j<n; ++j) {\r\n                res = Math.max(res, up[i][j] * (left[i][j] + right[i][j] - 1));\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}"},{"language":"cpp","code":"// version 1: O(n^2)\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param matrix a boolean 2D matrix\r\n     * @return an integer\r\n     */\r\n    int maximalRectangle(vector<vector<bool> > &matrix) {\r\n        // Write your code here\r\n                if(matrix.empty() || matrix[0].empty()) {\r\n            return 0;\r\n        }\r\n\r\n        int m = matrix.size();\r\n        int n = matrix[0].size();\r\n\r\n        vector<vector<int> > height(m, vector<int>(n, 0));\r\n        for(int i = 0; i < m; i++) {\r\n            for(int j = 0; j < n; j++) {\r\n                if(!matrix[i][j]) {\r\n                    height[i][j] = 0;\r\n                } else {\r\n                    height[i][j] = (i == 0) ? 1 : height[i - 1][j] + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        int maxArea = 0;\r\n        for(int i = 0; i < m; i++) {\r\n            maxArea = max(maxArea, largestRectangleArea(height[i]));\r\n        }\r\n        return maxArea;\r\n    }\r\n\r\n    int largestRectangleArea(vector<int> &height) {\r\n        vector<int> s;\r\n        height.push_back(0);\r\n\r\n        int sum = 0;\r\n        int i = 0;\r\n        while(i < height.size()) {\r\n            if(s.empty() || height[i] > height[s.back()]) {\r\n                s.push_back(i);\r\n                i++;\r\n            } else {\r\n                int t = s.back();\r\n                s.pop_back();\r\n                sum = max(sum, height[t] * (s.empty() ? i : i - s.back() - 1));\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n};\r\n\r\n// version 2, O(n^3)\r\nclass Solution {\r\npublic:\r\n    int getMaxLength(vector<char> &r1, vector<char> &r2) {\r\n        // r1 = r1 and r2\r\n        int lastIndex = -1;\r\n        int maxLength = 0;\r\n        for (int i = 0; i < r1.size(); i++) {\r\n            r1[i] = (r1[i] == '1' && r2[i] == '1') ? '1' : '0';\r\n            if (r1[i] == '0') {\r\n                if (lastIndex == -1) {\r\n                    continue;\r\n                }\r\n                maxLength = max(maxLength, i - lastIndex);\r\n                lastIndex = -1;\r\n            } else {\r\n                if (lastIndex == -1) {\r\n                    lastIndex = i;\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        if (lastIndex != -1) {\r\n            maxLength = max(maxLength, (int)(r1.size()) - lastIndex);\r\n        }\r\n        return maxLength;\r\n    }\r\n    \r\n    int maximalRectangle(vector<vector<char> > &matrix) {\r\n        if (matrix.size() == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int n = matrix.size();\r\n        int m = matrix[0].size();\r\n        vector<char> row;\r\n        \r\n        int result = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            row = matrix[i];\r\n            for (int j = i; j < n; j++) {\r\n                int maxLength = getMaxLength(row, matrix[j]);\r\n                result = max(result, maxLength * (j - i + 1));\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {boolean[][]} matrix, a list of lists of boolean\r\n    # @return {int} an integer\r\n    def largestRectangleArea(self, height):\r\n        stack = []\r\n        i = 0\r\n        area = 0\r\n        while i < len(height):\r\n            if stack == [] or height[i] > height[stack[len(stack)-1]]:\r\n                stack.append(i)\r\n            else:\r\n                curr = stack.pop()\r\n                width = i if stack == [] else i-stack[len(stack)-1]-1\r\n                area = max(area,width * height[curr])\r\n                i -= 1\r\n            i += 1\r\n        while stack != []:\r\n            curr = stack.pop()\r\n            width = i if stack == [] else len(height) - stack[len(stack)-1]-1\r\n            area = max(area, width * height[curr])\r\n        return area\r\n        \r\n    def maximalRectangle(self, matrix):\r\n        # Write your code here\r\n        if matrix == []:\r\n            return 0\r\n        a=[0 for i in range(len(matrix[0]))]\r\n        maxArea=0\r\n        for i in range(len(matrix)):\r\n            for j in range(len(matrix[i])):\r\n                a[j] = a[j] + 1 if matrix[i][j] else 0\r\n            \r\n            maxArea = max(maxArea, self.largestRectangleArea(a))\r\n        \r\n        return maxArea"}]},{"id":353,"unique_name":"wiggle-sort","title":"摆动排序","description":"给你一个没有排序的数组，请将原数组就地重新排列满足如下性质\r\n```\r\nnums[0] <= nums[1] >= nums[2] <= nums[3]....\r\n```\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums a list of integer\r\n     * @return void\r\n     */\r\n    public void wiggleSort(int[] nums) {\r\n        // Write your code here\r\n        for(int i=1; i<nums.length; i++) {\r\n            if((i%2==1 && (nums[i] < nums[i-1]) || \r\n              (i%2==0) && (nums[i] > nums[i-1]))) {\r\n                swap(nums, i-1, i);\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void swap(int[] nums, int i, int j) {\r\n        int temp = nums[i];\r\n        nums[i] = nums[j];\r\n        nums[j] = temp;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums a list of integer\r\n     * @return void\r\n     */  \r\n    void wiggleSort(vector<int>& nums) {\r\n        // Write your code here\r\n        int n = nums.size();\r\n        if (n < 2)\r\n            return;\r\n        for (int i = 1; i < n; ++i) {\r\n            if ((i % 2 == 1) && nums[i] < nums[i - 1] ||\r\n                (i % 2 == 0) && nums[i] > nums[i - 1]) {\r\n                int temp = nums[i];\r\n                nums[i] = nums[i - 1];\r\n                nums[i - 1] = temp;\r\n            }\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    \"\"\"\r\n    @param {int[]} nums a list of integer\r\n    @return nothing, modify nums in-place instead\r\n    \"\"\"\r\n    def wiggleSort(self, nums):\r\n        # Write your code here\r\n        n = len(nums)\r\n        for i in xrange(1, n):\r\n            if i % 2 == 1 and nums[i] < nums[i - 1] or \\\r\n                i % 2 == 0 and nums[i] > nums[i - 1]:\r\n                nums[i], nums[i - 1] = nums[i- 1], nums[i]"}]},{"id":278,"unique_name":"number-of-airplanes-in-the-sky","title":"数飞机","description":"给出飞机的起飞和降落时间的列表，用 interval 序列表示. 请计算出天上同时最多有多少架飞机？","solutions":[{"language":"java","code":"/**\r\n * Definition of Interval:\r\n * public classs Interval {\r\n *     int flag, end;\r\n *     Interval(int flag, int end) {\r\n *         this.flag = flag;\r\n *         this.end = end;\r\n *     }\r\n */\r\nclass Point{\r\n    int time;\r\n    int flag;\r\n\r\n    Point(int t, int s){\r\n      this.time = t;\r\n      this.flag = s;\r\n    }\r\n    public static Comparator<Point> PointComparator  = new Comparator<Point>(){\r\n      public int compare(Point p1, Point p2){\r\n        if(p1.time == p2.time) return p1.flag - p2.flag;\r\n        else return p1.time - p2.time;\r\n      }\r\n    };\r\n}\r\n  \r\nclass Solution {\r\n    /**\r\n     * @param intervals: An interval array\r\n     * @return: Count of airplanes are in the sky.\r\n     */\r\n  public int countOfAirplanes(List<Interval> airplanes) { \r\n    List<Point> list = new ArrayList<>(airplanes.size()*2);\r\n    for(Interval i : airplanes){\r\n      list.add(new Point(i.start, 1));\r\n      list.add(new Point(i.end, 0));\r\n    }\r\n\r\n    Collections.sort(list,Point.PointComparator );\r\n    int count = 0, ans = 0;\r\n    for(Point p : list){\r\n      if(p.flag == 1) count++;\r\n      else count--;\r\n      ans = Math.max(ans, count);\r\n    }\r\n\r\n    return ans;\r\n  }\r\n    \r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of Interval:\n * classs Interval {\n *     int start, end;\n *     Interval(int start, int end) {\n *         this->start = start;\n *         this->end = end;\n *     }\n */\nclass Solution {\npublic:\n    /**\n     * @param intervals: An interval array\n     * @return: Count of airplanes are in the sky.\n     */\n    priority_queue<int,vector<int>,greater<int> >q;\n\n    static bool comp(const Interval& a, const Interval& b){\n        return a.start < b.start;\n    }\n    static int max(int a, int b) {\n        return a > b ? a : b;\n    }\n    int countOfAirplanes(vector<Interval> &airplanes) {\n        // write your code here\n        sort(airplanes.begin(), airplanes.end(), comp);\n        int result = 0;\n\n        int len = airplanes.size();\n        for (int i = 0; i < len; ++i) {\n            while (q.size() > 0 && q.top() <= airplanes[i].start) \n                q.pop();\n\n            q.push(airplanes[i].end);\n            result = max(result, q.size());\n        }\n        return result;\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of Interval.\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\ndef sorter(x, y):\n    if x[0] != y[0]:\n        return x[0] - y[0]\n    return x[1] - y[1]\n\nclass Solution:\n    # @param airplanes, a list of Interval\n    # @return an integer\n    def countOfAirplanes(self, airplanes):\n        timepoints = []\n        for airplane in airplanes:\n            timepoints.append((airplane.start, 1))\n            timepoints.append((airplane.end, -1))\n            \n        timepoints = sorted(timepoints, cmp=sorter)\n        \n        sum, most = 0, 0\n        for t, delta in timepoints:\n            sum += delta\n            most = max(most, sum)\n            \n        return most"}]},{"id":408,"unique_name":"continuous-subarray-sum","title":"连续子数组求和","description":"给定一个整数数组，请找出一个连续子数组，使得该子数组的和最大。输出答案时，请分别返回第一个数字和最后一个数字的下标。（如果两个相同的答案，请返回其中任意一个）","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param A an integer array\n     * @return  A list of integers includes the index of the first number and the index of the last number\n     */\n    public ArrayList<Integer> continuousSubarraySum(int[] A) {\n        // Write your code here\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        result.add(0);\n        result.add(0);\n\n        int len = A.length;\n        int start = 0, end = 0;\n        int sum = 0;\n        int ans = -0x7fffffff;\n        for (int i = 0; i < len; ++i) {\n            if (sum < 0) {\n                sum = A[i];\n                start = end = i;\n            } else {\n                sum += A[i];\n                end = i;\n            }\n            if (sum >= ans) {\n                ans = sum;\n                result.set(0, start);\n                result.set(1, end);\n            }\n        }\n        return result;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param A an integer array\n     * @return  A list of integers includes the index of \n     *          the first number and the index of the last number\n     */\n    vector<int> continuousSubarraySum(vector<int>& A) {\n        // Write your code here\n        vector<int> result;\n        result.push_back(0);\n        result.push_back(0);\n\n        int len = A.size();\n        int start = 0, end = 0;\n        int sum = 0;\n        int ans = -0x7fffffff;\n        for (int i = 0; i < len; ++i) {\n            if (sum < 0) {\n                sum = A[i];\n                start = end = i;\n            } else {\n                sum += A[i];\n                end = i;\n            }\n            if (sum >= ans) {\n                ans = sum;\n                result[0] = start;\n                result[1] = end;\n            }\n        }\n        return result;\n    }\n};"},{"language":"python","code":"class Solution:\n    # @param {int[]} A an integer array\n    # @return {int[]}  A list of integers includes the index of the \n    #                  first number and the index of the last number\n    def continuousSubarraySum(self, A):\n        # Write your code here\n        ans = -0x7fffffff\n        sum = 0\n        start, end = 0, -1\n        result = [-1, -1]\n        for x in A:\n            if sum < 0:\n                sum = x\n                start = end + 1\n                end = start\n            else:\n                sum += x\n                end += 1\n            if sum > ans:\n                ans = sum\n                result = [start, end]\n\n        return result\n"}]},{"id":266,"unique_name":"longest-increasing-continuous-subsequence","title":"最长上升连续子序列","description":"给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）","solutions":[{"language":"java","code":"public class Solution {\n    public int longestIncreasingContinuousSubsequence(int[] A) {\n        if (A == null || A.length == 0) {\n            return 0;\n        }\n        \n        int n = A.length;\n        int answer = 1;\n        \n        // from left to right\n        int length = 1; // just A[0] itself\n        for (int i = 1; i < n; i++) {\n            if (A[i] > A[i - 1]) {\n                length++;\n            } else {\n                length = 1;\n            }\n            answer = Math.max(answer, length);\n        }\n        \n        // from right to left\n        length = 1;\n        for (int i = n - 2; i >= 0; i--) {\n            if (A[i] > A[i + 1]) {\n                length++;\n            } else {\n                length = 1;\n            }\n            answer = Math.max(answer, length);\n        }\n        \n        return answer;\n    }\n}\n\n//  方法二\npublic class Solution {\n    /**\n     * @param A an array of Integer\n     * @return  an integer\n     */\n    \n    int LIS(int[] A) {\n        int n = A.length;\n        int[] f = new int[n];\n        int i, res = 0;\n        for (i = 0; i < n; ++i) {\n            f[i] = 1;\n            if (i > 0 && A[i-1] < A[i]) {\n                f[i] = f[i-1] + 1;\n            }\n            if (f[i] > res) {\n                res = f[i];\n            }\n        }\n        \n        return res;\n    }\n     \n    public int longestIncreasingContinuousSubsequence(int[] A) {\n        int n = A.length;\n        int r1 = LIS(A);\n        int i = 0, j = n-1, t;\n        while (i < j) {\n            t = A[i];\n            A[i] = A[j];\n            A[j] = t;\n            ++i;\n            --j;\n        }\n        \n        int r2 = LIS(A);\n        \n        if (r1 > r2) {\n            return r1;\n        }\n        else {\n            return r2;\n        }\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A an array of Integer\r\n     * @return  an integer\r\n     */\r\n    int longestIncreasingContinuousSubsequence(vector<int>& A) {\r\n        // Write your code here\r\n        int max = 1, s = 1, l = 1;\r\n        int len = A.size();\r\n        if (len == 0)\r\n            return 0;\r\n        for (int i = 1; i < len; ++i) {\r\n            if (A[i] > A[i-1])\r\n                s += 1;\r\n            else {\r\n                if (s > max) max = s;\r\n                s = 1;\r\n            } \r\n            \r\n            if (A[i] < A[i-1])\r\n                l += 1;\r\n            else {\r\n                if (l > max) max = l;\r\n                l = 1;\r\n            } \r\n        }\r\n        if (s > max) max = s;\r\n        if (l > max) max = l;\r\n        return max;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} A an array of Integer\r\n    # @return {int}  an integer\r\n    def longestIncreasingContinuousSubsequence(self, A):\r\n        return max(self.getLongest(A), self.getLongest(list(reversed(A))))\r\n        \r\n    def getLongest(self, A):\r\n        length, longest = 0, 0\r\n        for index, a in enumerate(A):\r\n            if index == 0 or A[index] < A[index - 1]:\r\n                length = 1\r\n            else:\r\n                length += 1\r\n            longest = max(longest, length)\r\n        return longest"}]},{"id":410,"unique_name":"partition-array-by-odd-and-even","title":"奇偶分割数组","description":"分割一个整数数组，使得奇数在前偶数在后。\r\n","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param nums: an array of integers\n     * @return: nothing\n     */\n    public void partitionArray(int[] nums) {\n        int start = 0, end = nums.length - 1;\n        while (start < end) {\n            while (start < end && nums[start] % 2 == 1) {\n                start++;\n            }\n            while (start < end && nums[end] % 2 == 0) {\n                end--;\n            }\n            if (start < end) {\n                int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp;\n                start++;\n                end--;\n            } \n        }\n    }\n}\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param nums: a vector of integers\n     * @return: nothing\n     */\n    void partitionArray(vector<int> &nums) {\n        // write your code here\n        int start = 0, end = nums.size() - 1;\n        while (start < end) {\n            while (start < end && nums[start] % 2 == 1) ++start;\n            while (start < end && nums[end] % 2 == 0) --end;\n            if (start < end) swap(nums[start++], nums[end--]);\n        }\n        int i=0;\n        for (; i<nums.size(); ++i) \n            if (nums[i]%2==0) break;\n        if (i>0) swap(nums[0], nums[i-1]);\n    }\n};"},{"language":"python","code":"class Solution:\n    # @param nums: a list of integers\n    # @return: nothing\n    def partitionArray(self, nums):\n        # write your code here\n        start, end = 0, len(nums)-1\n        while start<end:\n            while start<end and nums[start]%2==1: start += 1\n            while start<end and nums[end]%2==0: end -=1\n            if start<end:\n                nums[start], nums[end] = nums[end], nums[start]\n                start += 1\n                end -= 1\n"}]},{"id":411,"unique_name":"next-permutation-ii","title":"下一个排列","description":"给定一个若干整数的排列，给出按正数大小进行字典序从小到大排序后的下一个排列。\r\n\r\n如果没有下一个排列，则输出字典序最小的序列。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param num: an array of integers\r\n     * @return: return nothing (void), do not return anything, modify num in-place instead\r\n     */\r\n     \r\n    public void reverse(int[] num, int start, int end) {\r\n        for (int i = start, j = end; i < j; i++, j--) {\r\n            int temp = num[i];\r\n            num[i] = num[j];\r\n            num[j] = temp;\r\n        }\r\n    }\r\n    \r\n    public void nextPermutation(int[] num) {\r\n        // find the last increase index\r\n        int index = -1;\r\n        for (int i = num.length - 2; i >= 0; i--) {\r\n            if (num[i] < num[i + 1]) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        if (index == -1) {\r\n            reverse(num, 0, num.length - 1);\r\n            return;\r\n        }\r\n        \r\n        // find the first bigger one\r\n        int biggerIndex = index + 1;\r\n        for (int i = num.length - 1; i > index; i--) {\r\n            if (num[i] > num[index]) {\r\n                biggerIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // swap them to make the permutation bigger\r\n        int temp = num[index];\r\n        num[index] = num[biggerIndex];\r\n        num[biggerIndex] = temp;\r\n        \r\n        // reverse the last part\r\n        reverse(num, index + 1, num.length - 1);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: a vector of integers\r\n     * @return: return nothing (void), do not return anything, modify nums in-place instead\r\n     */\r\n    void nextPermutation(vector<int> &nums) {\r\n        next_permutation(nums.begin(), nums.end());\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param nums: a list of integer\r\n    # @return: return nothing (void), do not return anything, modify nums in-place instead\r\n    def nextPermutation(self, nums):\r\n        # write your code here\r\n        i = len(nums)-1\r\n        temp = []\r\n        while i>0 and nums[i]<=nums[i-1]: i=i-1\r\n        if i==0:\r\n            for j in xrange(len(nums)-1, -1, -1): temp.append(nums[j])\r\n            for j in xrange(len(nums)): nums[j] = temp[j]\r\n            return\r\n        for j in xrange(i-1): temp.append(nums[j])\r\n        p = len(nums)-1\r\n        while nums[p]<=nums[i-1]: p=p-1\r\n        nums[p], nums[i-1] = nums[i-1], nums[p]\r\n        temp.append(nums[i-1])\r\n        for j in xrange(len(nums)-1, i-1, -1): temp.append(nums[j])\r\n        for j in xrange(len(nums)): nums[j] = temp[j]\r\n        return        "}]},{"id":269,"unique_name":"coins-in-a-line-ii","title":"硬币排成线 II","description":"有 `n` 个不同价值的硬币排成一条线。两个参赛者轮流从左边依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值高的人获胜。\r\n\r\n请判定 **第一个玩家** 是输还是赢？","solutions":[{"language":"java","code":"// linpz version\r\npublic class Solution {\r\n    /**\r\n     * @param values: an array of integers\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    public boolean firstWillWin(int[] values) {\r\n        // write your code here\r\n        int n = values.length;\r\n        int[] sum = new int[n + 1];\r\n        for (int i = 1; i <= n; ++i)\r\n            sum[i] = sum[i -  1] + values[n - i];\r\n\r\n        int[] dp = new int[n + 1];\r\n        dp[1] = values[n - 1];\r\n        for (int i = 2; i <= n; ++i)\r\n            dp[i] = Math.max(sum[i] - dp[i - 1], sum[i] - dp[i - 2]);\r\n            \r\n        return dp[n]  > sum[n] / 2;\r\n    }\r\n}\r\n\r\n// 方法一\r\nimport java.util.*;\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param values: an array of integers\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    public boolean firstWillWin(int[] values) {\r\n        // write your code here\r\n        int []dp = new int[values.length + 1];\r\n        boolean []flag =new boolean[values.length + 1];\r\n        int sum = 0;\r\n        for(int now : values) \r\n            sum += now;\r\n        \r\n        return sum < 2*MemorySearch(values.length, dp, flag, values);\r\n    }\r\n    int MemorySearch(int n, int []dp, boolean []flag, int []values) { \r\n        if(flag[n] == true)\r\n            return dp[n];\r\n        flag[n] = true;\r\n        if(n == 0)  {\r\n            dp[n] = 0;  \r\n        } else if(n == 1) {\r\n            dp[n] = values[values.length-1];\r\n        } else if(n == 2) {\r\n            dp[n] = values[values.length-1] + values[values.length-2]; \r\n        } else if(n == 3){\r\n            dp[n] = values[values.length-2] + values[values.length-3]; \r\n        } else {\r\n            dp[n] = Math.max(\r\n                Math.min(MemorySearch(n-2, dp, flag,values) , MemorySearch(n-3, dp, flag, values)) + values[values.length-n],\r\n                Math.min(MemorySearch(n-3, dp, flag, values), MemorySearch(n-4, dp, flag, values)) + values[values.length-n] + values[values.length - n + 1]\r\n                );\r\n        }\r\n    \r\n        return dp[n];\r\n    }    \r\n}\r\n\r\n// 方法二\r\npublic class Solution {\r\n    /**\r\n     * @param values: an array of integers\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    public boolean firstWillWin(int[] values) {\r\n        // write your code here\r\n        int n = values.length;\r\n        int []dp = new int[n + 1];\r\n        boolean []flag =new boolean[n + 1];\r\n        int []sum = new int[n+1];\r\n        int allsum = values[n-1];\r\n        sum[n-1] = values[n-1];\r\n        for(int i = n-2; i >= 0; i--) { \r\n            sum[i] += sum[i+1] + values[i];\r\n            allsum += values[i];\r\n        }\r\n        return allsum/2 < MemorySearch(0, n, dp, flag, values, sum);\r\n    }\r\n    int MemorySearch(int i, int n, int []dp, boolean []flag, int []values, int []sum) {\r\n        if(flag[i] == true)\r\n            return dp[i];\r\n        flag[i] = true;\r\n        if(i == n)  {\r\n            dp[n] = 0;  \r\n        } else if(i == n-1) {\r\n            dp[i] = values[i];\r\n        } else if(i == n-2) {\r\n            dp[i] = values[i] + values[i + 1]; \r\n        } else {\r\n            dp[i] = sum[i] -\r\n                Math.min(MemorySearch(i+1, n, dp, flag, values, sum) , MemorySearch(i+2, n, dp, flag, values, sum));\r\n        }\r\n        return dp[i];\r\n    }\r\n   \r\n}\r\n\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param values: a vector of integers\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    bool firstWillWin(vector<int> &values) {\r\n        // write your code here\r\n        vector<int> sum, f;\r\n        int n = values.size(), total = 0;\r\n        if (n<3) return true;\r\n        for (int i=0; i<n; ++i) total += values[i];   \r\n        for (int i=0; i<n; ++i) {\r\n            sum.push_back(total);\r\n            total -= values[i];\r\n        }\r\n        f.push_back(sum[n-1]);\r\n        f.push_back(sum[n-2]);\r\n        for (int i=n-3; i>=0; --i)\r\n            f.push_back(max(values[i]+(sum[i+1]-f[n-1-i-1]), values[i]+values[i+1]+(sum[i+2]-f[n-1-i-2])));\r\n        if (f[n-1]<sum[0]-f[n-1]) return false;\r\n        else return true;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param values: a list of integers\r\n    # @return: a boolean which equals to True if the first player will win\r\n    def firstWillWin(self, values):\r\n        # write your code here\r\n        n, total = len(values), 0\r\n        sumv, f = [], []\r\n        if n<3: return True\r\n        for i in xrange(n): total += values[i]\r\n        for i in xrange(n):\r\n            sumv.append(total)\r\n            total -= values[i]\r\n        f.append(sumv[n-1])\r\n        f.append(sumv[n-2])\r\n        for i in xrange(n-3, -1, -1):\r\n            f.append(max(values[i]+(sumv[i+1]-f[n-1-i-1]), values[i]+values[i+1]+(sumv[i+2]-f[n-1-i-2])))\r\n        if f[n-1]<sumv[0]-f[n-1]: return False\r\n        else: return True\r\n"}]},{"id":268,"unique_name":"coins-in-a-line","title":"硬币排成线","description":"有 `n` 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。\r\n\r\n请判定 **第一个玩家** 是输还是赢？","solutions":[{"language":"java","code":"// 方法一\r\npublic class Solution {\r\n    /**\r\n     * @param n: an integer\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    public boolean firstWillWin(int n) {\r\n        // write your code here\r\n        int []dp = new int[n+1];\r\n        \r\n        return MemorySearch(n, dp);\r\n        \r\n    }\r\n    boolean MemorySearch(int n, int []dp) { // 0 is empty, 1 is false, 2 is true\r\n        if(dp[n] != 0) {\r\n            if(dp[n] == 1)\r\n                return false;\r\n            else\r\n                return true;\r\n        }\r\n        if(n <= 0) {\r\n            dp[n] = 1;\r\n        } else if(n == 1) {\r\n            dp[n] = 2;\r\n        } else if(n == 2) {\r\n            dp[n] = 2;\r\n        } else if(n == 3) {\r\n            dp[n] = 1;\r\n        } else {\r\n            if((MemorySearch(n-2, dp) && MemorySearch(n-3, dp)) || \r\n                (MemorySearch(n-3, dp) && MemorySearch(n-4, dp) )) {\r\n                dp[n] = 2;\r\n            } else {\r\n                dp[n] = 1;\r\n            }\r\n        }\r\n        if(dp[n] == 2) \r\n            return true;\r\n        return false;\r\n    }\r\n}\r\n\r\n// 方法二 StackOverflow\r\npublic class Solution {\r\n    /**\r\n     * @param n: an integer\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    public boolean firstWillWin(int n) {\r\n        // write your code here\r\n        boolean []dp = new boolean[n+1];\r\n        boolean []flag = new boolean[n+1];\r\n        return MemorySearch(n, dp, flag);\r\n    }\r\n    boolean MemorySearch(int i, boolean []dp, boolean []flag) {\r\n        if(flag[i] == true) {\r\n            return dp[i];\r\n        }\r\n        if(i == 0) {\r\n            dp[i] = false;\r\n        } else if(i == 1) {\r\n            dp[i] = true;\r\n        } else if(i == 2) {\r\n            dp[i] = true;\r\n        } else {\r\n            dp[i] = !MemorySearch(i-1, dp, flag) || !MemorySearch(i-2, dp, flag);\r\n        }\r\n        flag[i] =true;\r\n        return dp[i];\r\n    }\r\n}\r\n\r\n//方法三\r\npublic class Solution {\r\n    /**\r\n     * @param n: an integer\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n    public boolean firstWillWin(int n) {\r\n        // write your code here\r\n        if (n == 0)\r\n            return false;\r\n        else if (n == 1)\r\n            return true;\r\n        else if (n == 2)\r\n            return true;\r\n            \r\n        boolean []dp = new boolean[n+1];\r\n        dp[0] = false;\r\n        dp[1] = true;\r\n        dp[2] = true;\r\n        for (int i = 3; i <= n; i++) \r\n            dp[i] = !dp[i - 1] || !dp[i - 2];\r\n            \r\n        return dp[n];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n: an integer\r\n     * @return: a boolean which equals to true if the first player will win\r\n     */\r\n     bool firstWillWin(int n) {\r\n        // write your code here\r\n        if (n%3==0) return false;\r\n        else return true;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    # @param n: an integer\r\n    # @return: a boolean which equals to True if the first player will win\r\n    def firstWillWin(self, n):\r\n        # write your code here\r\n        if n%3==0: return False\r\n        else: return True\r\n"}]},{"id":262,"unique_name":"the-smallest-difference","title":"最小差","description":"给定两个整数数组（第一个是数组 `A`，第二个是数组 `B`），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A, B: Two integer arrays.\r\n     * @return: Their smallest difference.\r\n     */\r\n    public int smallestDifference(int[] A, int[] B) {\r\n        if (A == null || A.length == 0 || B == null || B.length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        Arrays.sort(A);\r\n        Arrays.sort(B);\r\n        \r\n        int ai = 0, bi = 0;\r\n        int min = Integer.MAX_VALUE;\r\n        while (ai < A.length && bi < B.length) {\r\n            min = Math.min(min, Math.abs(A[ai] - B[bi]));\r\n            if (A[ai] < B[bi]) {\r\n                ai++;\r\n            } else {\r\n                bi++;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A, B: Two integer arrays.\r\n     * @return: Their smallest difference.\r\n     */\r\n    int smallestDifference(vector<int> &A, vector<int> &B) {\r\n        // write your code here\r\n        int diff = 0x7fffffff;\r\n        int la = A.size();\r\n        set<int> s;\r\n        for (int i = 0; i < la; ++i)\r\n               s.insert(A[i]);\r\n\r\n        int lb = B.size();\r\n        for (int i = 0; i < lb; ++i) {\r\n            set<int>::iterator it = s.lower_bound(B[i]);\r\n            if (it != s.end())\r\n                diff = min(diff, *it - B[i]);\r\n            if (it != s.begin()) {\r\n                it --;\r\n                diff = min(diff, B[i] - *it);\r\n            }\r\n        }\r\n        return diff;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    # @param A, B: Two lists of integer\r\n    # @return: An integer\r\n    def smallestDifference(self, A, B):\r\n        # write your code here\r\n        C = []\r\n        for x in A:\r\n            C.append((x, 'A'))\r\n        for x in B:\r\n            C.append((x, 'B'))\r\n\r\n        C.sort()\r\n\r\n        diff = 0x7fffffff\r\n        cnt = len(C)\r\n        for i in xrange(cnt - 1):\r\n            if  C[i][1] != C[i + 1][1]:\r\n                diff = min(diff, C[i + 1][0] -C[i][0]) \r\n        \r\n        return diff\r\n"}]},{"id":73,"unique_name":"permutation-sequence","title":"第k个排列","description":"给定 *n* 和 *k*，求`123..n`组成的排列中的第 *k* 个排列。","solutions":[{"language":"java","code":"public class Solution {\r\n\r\n    public String getPermutation(int n, int k) {\r\n        StringBuilder sb = new StringBuilder();\r\n        boolean[] used = new boolean[n];\r\n\r\n        k = k - 1;\r\n        int factor = 1;\r\n        for (int i = 1; i < n; i++) {\r\n            factor *= i;\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            int index = k / factor;\r\n            k = k % factor;\r\n            for (int j = 0; j < n; j++) {\r\n                if (used[j] == false) {\r\n                    if (index == 0) {\r\n                        used[j] = true;\r\n                        sb.append((char) ('0' + j + 1));\r\n                        break;\r\n                    } else {\r\n                        index--;\r\n                    }\r\n                }\r\n            }\r\n            if (i < n - 1) {\r\n                factor = factor / (n - 1 - i);\r\n            }\r\n        }\r\n\r\n        return sb.toString();\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        string s(n, '0');\n        string result;\n        for (int i = 0; i < n; ++i)\n            s[i] += i + 1;\n        return kth_permutation(s, k);\n    }\nprivate:\n    int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; ++i)\n            result *= i;\n        return result;\n    }\n    // seq 已排好序，是第一个排列\n    template<typename Sequence>\n    Sequence kth_permutation(const Sequence &seq, int k) {\n        const int n = seq.size();\n        Sequence S(seq);\n        Sequence result;\n        int base = factorial(n - 1);\n        --k; // 康托编码从0 开始\n        for (int i = n - 1; i > 0; k %= base, base /= i, --i) {\n            auto a = next(S.begin(), k / base);\n            result.push_back(*a);\n            S.erase(a);\n        }\n        result.push_back(S[0]); // 最后一个\n        return result;\n    }\n};\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param n: n\r\n    @param k: the k-th permutation\r\n    @return: the k-th permutation\r\n    \"\"\"\r\n    def getPermutation(self, n, k):\r\n        fac = [1]\r\n        for i in range(1, n + 1):\r\n            fac.append(fac[-1] * i)\r\n        \r\n        elegible = range(1, n + 1)\r\n        per = []\r\n        for i in range(n):\r\n            digit = (k - 1) / fac[n - i - 1]\r\n            per.append(elegible[digit])\r\n            elegible.remove(elegible[digit])\r\n            k = (k - 1) % fac[n - i - 1] + 1\r\n        return \"\".join([str(x) for x in per])\r\n"}]},{"id":506,"unique_name":"reorder-array-to-construct-the-minimum-number","title":"将数组重新排序以构造最小值","description":"给定一个整数数组，请将其重新排序，以构造最小值。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums n non-negative integer array\r\n     * @return a string\r\n     */\r\n    public String minNumber(int[] nums) {\r\n        // Write your code here\r\n        int n = nums.length;\r\n        if (n < 1) return \"\";\r\n        \r\n        String[] strs = new String[n];\r\n        for (int i = 0; i < n; i++) {\r\n            strs[i] = String.valueOf(nums[i]);\r\n        }\r\n        \r\n        Arrays.sort(strs, new Cmp());\r\n        \r\n        String ans = \"\";\r\n        for (int i = n - 1; i >= 0; i--) {\r\n        \tans = ans.concat(strs[i]);\r\n        }\r\n        \r\n        int i = 0;\r\n        while (i < n && ans.charAt(i) == '0')\r\n            i ++;\r\n\r\n        if (i == n) return \"0\";\r\n        return ans.substring(i);\r\n    }\r\n}\r\nclass Cmp implements Comparator<String>{\r\n\t@Override\r\n\tpublic int compare(String a, String b) {\r\n\t\tString ab = a.concat(b);\r\n\t\tString ba = b.concat(a);\r\n\t\treturn ba.compareTo(ab);\r\n\t}\r\n}\r\n"},{"language":"cpp","code":"#include <sstream>\r\n\r\n\r\nbool cmp(const string s1, const string s2) {\r\n    return (s1 + s2) < (s2 + s1);\r\n}\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nums n non-negative integer array\r\n     * @return a string\r\n     */\r\n    string minNumber(vector<int>& nums) {\r\n        // Write your code here\r\n        vector<string> s_nums(nums.size());\r\n        stringstream stream;\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            stream << nums[i];\r\n            stream >> s_nums[i];\r\n            stream.clear();\r\n        }\r\n        sort(s_nums.begin(), s_nums.end(), cmp);\r\n        string result;\r\n        for (int i = 0; i < s_nums.size(); ++i) {\r\n            result += s_nums[i];\r\n        }\r\n        string res;\r\n        bool flag = false;\r\n        for (int i = 0; i < result.size(); ++i) {\r\n            if (result[i] != '0') {\r\n                res.push_back(result[i]);\r\n                flag = true;\r\n            } else if (flag) {\r\n                res.push_back(result[i]);\r\n            }\r\n        }\r\n        if (!flag) res.push_back('0');\r\n        return res;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums n non-negative integer array\r\n    # @return {str} a string\r\n    def minNumber(self, nums):\r\n        # Write your code here\r\n        nums.sort(cmp=self.cmp)\r\n        \r\n        result = ''.join([str(ele) for ele in nums])\r\n        i, length = 0, len(result)\r\n        while i + 1 < length:\r\n            if result[i] != '0':\r\n                break\r\n            i += 1\r\n\r\n        return result[i:]\r\n\r\n\r\n    def cmp(self, a, b):\r\n        if str(a) + str(b) < str(b) + str(a):\r\n            return -1\r\n        elif str(a) + str(b) == str(b) + str(a):\r\n            return 1\r\n        else:\r\n            return 0\r\n"}]},{"id":436,"unique_name":"unique-characters","title":"判断字符串是否没有重复字符","description":"实现一个算法确定字符串中的字符是否均唯一出现","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param str: a string\n     * @return: a boolean\n     */\n    public boolean isUnique(String str) {\n        // write your code here\n        boolean[] char_set = new boolean[256];\n        for (int i = 0; i < str.length(); i++) {\n        int val = str.charAt(i);\n        if (char_set[val]) return false;\n            char_set[val] = true;\n        }\n        return true;\n    }\n}\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param str: a string\n     * @return: a boolean\n     */\n    bool isUnique(string &str) {\n        // write your code here\n        int ch[128] = {0};\n        for (int i=0; i<str.length(); ++i) \n            if (ch[str[i]]!=0) return false;\n            else ch[str[i]]=1;\n        return true;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param s: a string\n    # @return: a boolean\n    def isUnique(self, s):\n        # write your code here\n        ch = range(129)\n        for i in range(129):\n            ch[i] = 0\n        for i in range(len(s)):\n            if ch[ord(s[i])]==0:\n                ch[ord(s[i])] = 1\n            else:\n                return False\n        return True\n"}]},{"id":92,"unique_name":"combination-sum","title":"数字组合","description":"<p>给出一个候选数字的set(C)和目标数字(T),找到C中所有的组合，使找出的数字和为T。C中的数字可以无限制重复被选取。</p><p>例如,给出候选数组<font color=\"#e76363\"><b>[2,3,6,7]</b></font>和目标数字7，所求的解为：</p><p><font color=\"#e76363\"><b>[7]，</b></font></p><p><font color=\"#e76363\"><b>[<span style=\"line-height: 1.42857143;\">2,2,3]</span></b></font></p>","solutions":[{"language":"java","code":"// version 1: Remove duplicates & generate a new array\r\npublic class Solution {\r\n    /**\r\n     * @param candidates: A list of integers\r\n     * @param target:An integer\r\n     * @return: A list of lists of integers\r\n     */\r\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\r\n        List<List<Integer>> results = new ArrayList<>();\r\n        if (candidates == null || candidates.length == 0) {\r\n            return results;\r\n        }\r\n        \r\n        int[] nums = removeDuplicates(candidates);\r\n        \r\n        dfs(nums, 0, new ArrayList<Integer>(), target, results);\r\n        \r\n        return results;\r\n    }\r\n    \r\n    private int[] removeDuplicates(int[] candidates) {\r\n        Arrays.sort(candidates);\r\n        \r\n        int index = 0;\r\n        for (int i = 0; i < candidates.length; i++) {\r\n            if (candidates[i] != candidates[index]) {\r\n                candidates[++index] = candidates[i];\r\n            }\r\n        }\r\n        \r\n        int[] nums = new int[index + 1];\r\n        for (int i = 0; i < index + 1; i++) {\r\n            nums[i] = candidates[i];\r\n        }\r\n        \r\n        return nums;\r\n    }\r\n    \r\n    private void dfs(int[] nums,\r\n                     int startIndex,\r\n                     List<Integer> combination,\r\n                     int remainTarget,\r\n                     List<List<Integer>> results) {\r\n        if (remainTarget == 0) {\r\n            results.add(new ArrayList<Integer>(combination));\r\n            return;\r\n        }\r\n        \r\n        for (int i = startIndex; i < nums.length; i++) {\r\n            if (remainTarget < nums[i]) {\r\n                break;\r\n            }\r\n            combination.add(nums[i]);\r\n            dfs(nums, i, combination, remainTarget - nums[i], results);\r\n            combination.remove(combination.size() - 1);\r\n        }\r\n    }\r\n}\r\n\r\n// version 2: reuse candidates array\r\npublic class Solution {\r\n    public  List<List<Integer>> combinationSum(int[] candidates, int target) {\r\n        List<List<Integer>> result = new ArrayList<>();\r\n        if (candidates == null) {\r\n            return result;\r\n        }\r\n\r\n        List<Integer> combination = new ArrayList<>();\r\n        Arrays.sort(candidates);\r\n        helper(candidates, 0, target, combination, result);\r\n\r\n        return result;\r\n    }\r\n\r\n     void helper(int[] candidates,\r\n                 int index,\r\n                 int target,\r\n                 List<Integer> combination,\r\n                 List<List<Integer>> result) {\r\n        if (target == 0) {\r\n            result.add(new ArrayList<Integer>(combination));\r\n            return;\r\n        }\r\n\r\n        for (int i = index; i < candidates.length; i++) {\r\n            if (candidates[i] > target) {\r\n                break;\r\n            }\r\n\r\n            if (i != index && candidates[i] == candidates[i - 1]) {\r\n                continue;\r\n            }\r\n\r\n            combination.add(candidates[i]);\r\n            helper(candidates, i, target - candidates[i], combination, result);\r\n            combination.remove(combination.size() - 1);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\nprivate:\r\n    const int index_count;\r\n    vector<vector<int> > results;\r\npublic:\r\n    Solution() : index_count(10000) {};\r\n    void backtrace(int target, int sum, vector<int> &candidates, int index[], int n)\r\n    {\r\n        if (sum > target) {\r\n            return;    \r\n        }\r\n        if (sum == target)\r\n        {\r\n            vector<int> result;\r\n            for (int i = 1; i <= n; ++i)\r\n            {\r\n                result.push_back(candidates[index[i]]);    \r\n            }\r\n            results.push_back(result);\r\n            return;\r\n        }\r\n        for (int i = index[n]; i < candidates.size(); ++i)\r\n        {\r\n            index[n+1] = i;\r\n            backtrace(target, sum+candidates[i], candidates, index, n+1);\r\n        }\r\n    }\r\n    /**\r\n     * @param candidates: A list of integers\r\n     * @param target:An integer\r\n     * @return: A list of lists of integers\r\n     */\r\n    vector<vector<int> > combinationSum(vector<int> &candidates, int target) {\r\n        // write your code here\r\n        sort(candidates.begin(), candidates.end());\r\n        int m = 0, n = candidates.size();\r\n        for (int i = 1; i < n; ++i)\r\n            if (candidates[i] != candidates[m])\r\n                candidates[++m] = candidates[i];\r\n        candidates.resize(m + 1);\r\n\r\n        int *index = new int[index_count];\r\n        memset(index, 0, sizeof(int)*index_count);\r\n        \r\n        results.clear();\r\n        backtrace(target, 0, candidates, index, 0);\r\n\r\n        delete[] index;\r\n\r\n        return results;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param candidates, a list of integers\r\n    # @param target, integer\r\n    # @return a list of lists of integers\r\n    def combinationSum(self, candidates, target):\r\n        # write your code here\r\n        candidates = list(set(candidates))\r\n        candidates.sort()\r\n        Solution.ret = []\r\n        self.DFS(candidates, target, 0, [])\r\n        return Solution.ret\r\n\r\n    def DFS(self, candidates, target, start, valuelist):\r\n        length = len(candidates)\r\n        if target == 0:\r\n            return Solution.ret.append(valuelist)\r\n        for i in range(start, length):\r\n            if target < candidates[i]:\r\n                return\r\n            self.DFS(candidates, target - candidates[i], i, valuelist + [candidates[i]])"}]},{"id":27,"unique_name":"longest-consecutive-sequence","title":"最长连续序列","description":"<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return an integer\r\n     */\r\n    public int longestConsecutive(int[] nums) {\r\n        HashSet<Integer> set = new HashSet<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            set.add(nums[i]);\r\n        }\r\n        \r\n        int longest = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            int down = nums[i] - 1;\r\n            while (set.contains(down)) {\r\n                set.remove(down);\r\n                down--;\r\n            }\r\n            \r\n            int up = nums[i] + 1;\r\n            while (set.contains(up)) {\r\n                set.remove(up);\r\n                up++;\r\n            }\r\n            \r\n            longest = Math.max(longest, up - down - 1);\r\n        }\r\n        \r\n        return longest;\r\n    }\r\n}\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return an integer\r\n     */\r\n    public int longestConsecutive(int[] num) {\r\n        // write you code here\r\n        Set<Integer> set = new HashSet<>();\r\n        for (int item : num) {\r\n            set.add(item);\r\n        }\r\n\r\n        int ans = 0;\r\n        for (int item : num) {\r\n            if (set.contains(item)) {\r\n                set.remove(item);\r\n\r\n                int pre = item - 1;\r\n                int next = item + 1;\r\n                while (set.contains(pre)) {\r\n                    set.remove(pre);\r\n                    pre--;\r\n                }\r\n                while (set.contains(next)) {\r\n                    set.remove(next);\r\n                    next++;\r\n                }\r\n                ans = Math.max(ans, next - pre - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n  /**\r\n   * @param nums: A list of integers\r\n   * @return an integer\r\n   */\r\n  int longestConsecutive(vector<int> &num) {\r\n    // write you code here\r\n    unordered_set<int> map(num.begin(), num.end());\r\n    int ans = 0;\r\n    for (int i = 0; i < num.size(); i++) { \r\n      if (map.find(num[i]) != map.end()) {\r\n        map.erase(num[i]);\r\n        int pre = num[i] - 1;\r\n        int next = num[i] + 1;\r\n        while (map.find(pre) != map.end()) { \r\n          map.erase(pre);\r\n          pre--;\r\n        } \r\n        while (map.find(next) != map.end()) { \r\n          map.erase(next);\r\n          next++;\r\n        } \r\n        ans = max(ans, next - pre - 1);\r\n      }\r\n    } \r\n    return ans;\r\n  }\r\n};"},{"language":"python","code":"# O(n)\r\nclass Solution:\r\n    \"\"\"\r\n    @param num, a list of integer\r\n    @return an integer\r\n    \"\"\"\r\n    def longestConsecutive(self, num):\r\n        # write your code here\r\n        dict={}\r\n        \r\n        for x in num:\r\n            dict[x] = 1\r\n            \r\n        ans = 0\r\n        \r\n        for x in num:\r\n            if x in dict:\r\n                len = 1\r\n                del dict[x]\r\n                l = x - 1\r\n                r = x + 1\r\n                while l in dict:\r\n                    del dict[l]\r\n                    l -= 1 \r\n                    len += 1\r\n                while r in dict:\r\n                    del dict[r]\r\n                    r += 1\r\n                    len += 1\r\n                if ans < len:\r\n                    ans = len\r\n                    \r\n        return ans\r\n        \r\n\r\n# O(nlogn)\r\nclass Solution:\r\n    # @param num, a list of integer\r\n    # @return an integer\r\n    def longestConsecutive(self, num):\r\n        num.sort()\r\n        l = num[0] \r\n        ans = 1\r\n        tmp = 1\r\n        for n in num:\r\n            if(n - l == 0):\r\n                continue;\r\n            elif(n - l == 1):\r\n                tmp += 1\r\n            else:\r\n                if tmp > ans:\r\n                    ans = tmp\r\n                tmp = 1\r\n            l = n\r\n        if tmp > ans:\r\n            ans = tmp\r\n        return ans\r\n"},{"language":"javascript","code":"/**\n * @param num: A list of integers\n * @return: An integer\n */\nconst longestConsecutive = function (num) {\n    var hashSet = new Array();\n    var i, pre, next;\n    var ans;\n    for (i = 0; i < num.length; i++) {\n        hashSet[num[i]] = true;\n    }\n    ans = 0;\n    for (i = 0; i < num.length; i++) {\n        if (hashSet.hasOwnProperty(num[i])) {\n            delete(hashSet[num[i]]);\n            pre = num[i] - 1;\n            next = num[i] + 1;\n            while (hashSet.hasOwnProperty(pre)) {\n                delete(hashSet[pre]);\n                pre--;\n            }\n            while (hashSet.hasOwnProperty(next)) {\n                delete(hashSet[next]);\n                next++;\n            }\n            ans = Math.max(ans, next - pre - 1);\n        }\n    }\n    return ans;\n}"}]},{"id":77,"unique_name":"jump-game","title":"跳跃游戏","description":"<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　</p><p>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　</p><p>判断你是否能到达数组的最后一个位置。</p>","solutions":[{"language":"java","code":"// version 1: Dynamic Programming\r\n// 这个方法，复杂度是 O(n^2) 可能会超时，但是依然需要掌握。\r\npublic class Solution {\r\n    public boolean canJump(int[] A) {\r\n        boolean[] can = new boolean[A.length];\r\n        can[0] = true;\r\n        \r\n        for (int i = 1; i < A.length; i++) {\r\n            for (int j = 0; j < i; j++) {\r\n                if (can[j] && j + A[j] >= i) {\r\n                    can[i] = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return can[A.length - 1];\r\n    }\r\n}\r\n\r\n\r\n// version 2: Greedy\r\npublic class Solution {\r\n    public boolean canJump(int[] A) {\r\n        // think it as merging n intervals\r\n        if (A == null || A.length == 0) {\r\n            return false;\r\n        }\r\n        int farthest = A[0];\r\n        for (int i = 1; i < A.length; i++) {\r\n            if (i <= farthest && A[i] + i >= farthest) {\r\n                farthest = A[i] + i;\r\n            }\r\n        }\r\n        return farthest >= A.length - 1;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    bool canJump(vector<int> A) {\r\n        int tmpMax = 0;\r\n        int n = A.size();\r\n        for (int i = 0; i < n; i++) {\r\n            if (i > tmpMax) return false;\r\n            if (tmpMax < i + A[i])\r\n                tmpMax = i + A[i];\r\n        }\r\n        return true;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param A, a list of integers\r\n    # @return a boolean\r\n    def canJump(self, A):\r\n        p = 0\r\n        ans = 0\r\n        for item in A[:-1]:\r\n            ans = max(ans, p + item)\r\n            if(ans <= p):\r\n                return False\r\n            p += 1\r\n        return True\r\n\r\n"}]},{"id":221,"unique_name":"median","title":"中位数","description":"<p>给定一个未排序的整数数组，找到其中位数。</p><p>中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: An integer denotes the middle number of the array.\r\n     */\r\n    public int median(int[] nums) {\r\n        return sub(nums, 0, nums.length - 1, (nums.length + 1)/2);\r\n    }\r\n    private int sub(int[] nums, int start, int end, int size) {\r\n        int mid = (start + end) / 2;\r\n        int pivot = nums[mid];\r\n        int i = start - 1, j = end + 1;\r\n        for (int k = start; k < j; k++) {\r\n            if (nums[k] < pivot) {\r\n                i++;\r\n                int tmp = nums[i];\r\n                nums[i] = nums[k];\r\n                nums[k] = tmp;\r\n            } else if (nums[k] > pivot) {\r\n                j--;\r\n                int tmp = nums[j];\r\n                nums[j] = nums[k];\r\n                nums[k] = tmp;\r\n                k--;\r\n            }\r\n        }\r\n        if (i - start + 1 >= size) {\r\n            return sub(nums, start, i, size);\r\n        } else if (j - start >= size) {\r\n            return nums[j-1];\r\n        } else {\r\n            return sub(nums, j, end, size - (j - start));\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param nums: A list of integers.\n     * @return: An integer denotes the middle number of the array.\n     */\n    int median(vector<int> &nums) {\n        // write your code here\n        int k = (nums.size() + 1) / 2;\n        priority_queue<int> que;\n        int len = nums.size();\n        for(int i = 0; i < len; i ++) {\n            if(que.size() == k) {\n                if(nums[i] < que.top()) {\n                    que.pop();\n                    que.push(nums[i]);\n                }\n            }else {\n                que.push(nums[i]);\n            }\n        }\n        return que.top();\n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param nums: A list of integers.\n    @return: An integer denotes the middle number of the array.\n    \"\"\"\n    def median(self, nums):\n        # write your code here\n        nums.sort()\n        return nums[(len(nums)-1)/2]\n"},{"language":"javascript","code":"/**\n * @param nums: A list of integers\n * @return: An integer denotes the middle number of the array\n */\nconst median = function (nums) {\n    sub = function(nums, start, end, size) {\n        var mid = Math.floor((start + end) / 2);\n        var pivot = nums[mid];\n        var i = start - 1, j = end + 1, k;\n        var tmp;\n        for (k = start; k < j; k++) {\n            if (nums[k] < pivot) {\n                i++;\n                tmp = nums[i];\n                nums[i] = nums[k];\n                nums[k] = tmp;\n            } else if (nums[k] > pivot) {\n                j--;\n                tmp = nums[j];\n                nums[j] = nums[k];\n                nums[k] = tmp;\n                k--;\n            }\n        }\n        if (i - start + 1 >= size) {\n            return sub(nums, start, i, size);\n        } else if (j - start >= size) {\n            return nums[j-1];\n        } else {\n            return sub(nums, j, end, size - (j - start));\n        }\n    }\n    return sub(nums, 0, nums.length - 1, Math.floor((nums.length + 1)/2));\n}"}]},{"id":167,"unique_name":"find-peak-element","title":"寻找峰值","description":"你给出一个整数数组(size为n)，其具有以下特点：\r\n\r\n- 相邻位置的数字是不同的\r\n- A[0] < A[1] 并且 A[n - 2] > A[n - 1]\r\n\r\n假定*P*是峰值的位置则满足`A[P] > A[P-1]`且`A[P] > A[P+1]`，返回数组中任意一个峰值的位置。","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * @param A: An integers array.\r\n     * @return: return any of peek positions.\r\n     */\r\n    public int findPeak(int[] A) {\r\n        // write your code here\r\n        int start = 1, end = A.length-2; // 1.答案在之间，2.不会出界 \r\n        while(start + 1 <  end) {\r\n            int mid = (start + end) / 2;\r\n            if(A[mid] < A[mid - 1]) {\r\n                end = mid;\r\n            } else if(A[mid] < A[mid + 1]) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        if(A[start] < A[end]) {\r\n            return end;\r\n        } else { \r\n            return start;\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param A: An integers array.\n     * @return: return any of peek positions.\n     */\n    int findPeak(vector<int> &A) {\n        int l = 1, r = A.size();\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (A[mid] > A[mid-1] && A[mid] > A[mid+1])\n                return mid;\n            if (A[mid] > A[mid-1])\n                l = mid + 1;\n            else    \n                r = mid - 1;\n        }\n        return -1;\n    }\n};"},{"language":"python","code":"class Solution:\r\n    #@param A: An integers list.\r\n    #@return: return any of peek positions.\r\n    def findPeak(self, A):\r\n        # write your code here\r\n        start, end = 1, len(A) - 2\r\n        while start + 1 <  end:\r\n            mid = (start + end) / 2\r\n            if A[mid] < A[mid - 1]:\r\n                end = mid\r\n            elif A[mid] < A[mid + 1]:\r\n                start = mid\r\n            else:\r\n                end = mid\r\n\r\n        if A[start] < A[end]:\r\n            return end\r\n        else:\r\n            return start"}]},{"id":96,"unique_name":"search-for-a-range","title":"搜索区间","description":"给定一个包含 *n* 个整数的排序数组，找出给定目标值 *target* 的起始和结束位置。\r\n\r\n如果目标值不在数组中，则返回`[-1, -1]`","solutions":[{"language":"java","code":"public class Solution {\r\n    public int[] searchRange(int[] A, int target) {\r\n        if (A.length == 0) {\r\n            return new int[]{-1, -1};\r\n        }\r\n        \r\n        int start, end, mid;\r\n        int[] bound = new int[2]; \r\n        \r\n        // search for left bound\r\n        start = 0; \r\n        end = A.length - 1;\r\n        while (start + 1 < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (A[mid] == target) {\r\n                end = mid;\r\n            } else if (A[mid] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        if (A[start] == target) {\r\n            bound[0] = start;\r\n        } else if (A[end] == target) {\r\n            bound[0] = end;\r\n        } else {\r\n            bound[0] = bound[1] = -1;\r\n            return bound;\r\n        }\r\n        \r\n        // search for right bound\r\n        start = 0;\r\n        end = A.length - 1;\r\n        while (start + 1 < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (A[mid] == target) {\r\n                start = mid;\r\n            } else if (A[mid] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        if (A[end] == target) {\r\n            bound[1] = end;\r\n        } else if (A[start] == target) {\r\n            bound[1] = start;\r\n        } else {\r\n            bound[0] = bound[1] = -1;\r\n            return bound;\r\n        }\r\n        \r\n        return bound;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\n  /** \r\n   *@param A : an integer sorted array\r\n   *@param target :  an integer to be inserted\r\n   *return : a list of length 2, [index1, index2]\r\n   */\r\npublic:\r\n  vector<int> searchRange(vector<int> &A, int target) {\r\n    // write your code here\r\n    vector<int> ans;\r\n    int ansl = -1;\r\n    for (int l = 0, r = A.size() - 1; l <= r;) {\r\n      int mid = l + (r - l) / 2;\r\n      if (A[mid] > target) {\r\n        r = mid - 1;\r\n      }\r\n      if (A[mid] < target) {\r\n        l = mid + 1;\r\n      }\r\n      if (A[mid] == target) {\r\n        ansl = mid;\r\n        r = mid - 1;\r\n      }\r\n    }\r\n    \r\n    int ansr = -1;\r\n    for (int l = 0, r = A.size() - 1; l <= r;) {\r\n      int mid = l + (r - l) / 2;\r\n      if (A[mid] > target) {\r\n        r = mid - 1;\r\n      }\r\n      if (A[mid] < target) {\r\n        l = mid + 1;\r\n      }\r\n      if (A[mid] == target) {\r\n        ansr = mid;\r\n        l = mid + 1;\r\n      }\r\n    }\r\n    ans.push_back(ansl);\r\n    ans.push_back(ansr);\r\n    return ans;\r\n  }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A : a list of integers\r\n    @param target : an integer to be searched\r\n    @return : a list of length 2, [index1, index2]\r\n    \"\"\"\r\n    def searchRange(self, A, target):\r\n        if len(A) == 0:\r\n            return [-1, -1]\r\n        \r\n        start, end = 0, len(A) - 1\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            if A[mid] < target:\r\n                start = mid\r\n            else:\r\n                end = mid\r\n        \r\n        if A[start] == target:\r\n            leftBound = start\r\n        elif A[end] == target:\r\n            leftBound = end\r\n        else:\r\n            return [-1, -1]\r\n        \r\n        start, end = leftBound, len(A) - 1\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            if A[mid] <= target:\r\n                start = mid\r\n            else:\r\n                end = mid\r\n        if A[end] == target:\r\n            rightBound = end\r\n        else:\r\n            rightBound = start\r\n        return [leftBound, rightBound]\r\n"},{"language":"javascript","code":"/**\n * @param A: an integer sorted array\n * @param target: an integer to be inserted\n * @return: a list of length 2, [index1, index2]\n */\nconst searchRange = function (A, target) {\n    var start, end, mid;\n    var bound = new Array(2); \n    if (A.length === 0) {\n        bound[0] = -1;\n        bound[1] = -1;\n        return bound;\n    }\n    start = 0; \n    end = A.length - 1;\n    while (start + 1 < end) {\n        mid = start + Math.floor((end - start) / 2);\n        if (A[mid] === target) {\n            end = mid;\n        } else if (A[mid] < target) {\n            start = mid;\n        } else {\n            end = mid;\n        }\n    }\n    if (A[start] === target) {\n        bound[0] = start;\n    } else if (A[end] === target) {\n        bound[0] = end;\n    } else {\n        bound[0] = bound[1] = -1;\n        return bound;\n    }\n    start = 0;\n    end = A.length - 1;\n    while (start + 1 < end) {\n        mid = start + Math.floor((end - start) / 2);\n        if (A[mid] === target) {\n            start = mid;\n        } else if (A[mid] < target) {\n            start = mid;\n        } else {\n            end = mid;\n        }\n    }\n    if (A[end] === target) {\n        bound[1] = end;\n    } else if (A[start] === target) {\n        bound[1] = start;\n    } else {\n        bound[0] = bound[1] = -1;\n        return bound;\n    }\n    return bound;\n}"}]},{"id":95,"unique_name":"search-insert-position","title":"搜索插入位置","description":"<p><span style=\"line-height: 1.42857143;\">给定一个排序数组和一个目标值，如果在数组中找到目标值则返回索引。如果没有，返回到它将会被按顺序插入的位置。</span><br></p><p>你可以假设在数组中无重复元素。</p>","solutions":[{"language":"java","code":"// version 1: find the first position >= target\r\npublic class Solution {\r\n    public int searchInsert(int[] A, int target) {\r\n        if (A == null || A.length == 0) {\r\n            return 0;\r\n        }\r\n        int start = 0, end = A.length - 1;\r\n        \r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (A[mid] == target) {\r\n                return mid;\r\n            } else if (A[mid] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (A[start] >= target) {\r\n            return start;\r\n        } else if (A[end] >= target) {\r\n            return end;\r\n        } else {\r\n            return end + 1;\r\n        }\r\n    }\r\n}\r\n\r\n// version 2: find the last position < target, return +1， 要特判一下target小于所有数组里面的元素\r\n\r\npublic class Solution {\r\n    public int searchInsert(int[] A, int target) {\r\n        if (A == null || A.length == 0) {\r\n            return 0;\r\n        }\r\n        int start = 0;\r\n        int end = A.length - 1;\r\n        int mid;\r\n        \r\n        if (target < A[0]) {\r\n            return 0;\r\n        }\r\n        // find the last number less than target\r\n        while (start + 1 < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (A[mid] == target) {\r\n                return mid;\r\n            } else if (A[mid] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (A[end] == target) {\r\n            return end;\r\n        }\r\n        if (A[end] < target) {\r\n            return end + 1;\r\n        }\r\n        if (A[start] == target) {\r\n            return start;\r\n        }\r\n        return start + 1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\n    /** \r\n     * param A : an integer sorted array\r\n     * param target :  an integer to be inserted\r\n     * return : an integer\r\n     */\r\npublic:\r\n    int searchInsert(vector<int> &A, int target) {\r\n        // find first position >= target\r\n        if (A.size() == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int start = 0, end = A.size() - 1;\r\n        while (start + 1 < end) {\r\n            int mid = (end - start) / 2 + start;\r\n            if (A[mid] >= target) {\r\n                end = mid;\r\n            } else {\r\n                start = mid;\r\n            }\r\n        }\r\n        \r\n        if (A[start] >= target) {\r\n            return start;\r\n        }\r\n        if (A[end] >= target) {\r\n            return end;\r\n        }\r\n        \r\n        return A.size();\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A : a list of integers\r\n    @param target : an integer to be inserted\r\n    @return : an integer\r\n    \"\"\"\r\n    def searchInsert(self, A, target):\r\n        if len(A) == 0:\r\n            return 0\r\n            \r\n        start, end = 0, len(A) - 1\r\n        # first position >= target\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            if A[mid] >= target:\r\n                end = mid\r\n            else:\r\n                start = mid\r\n        \r\n        if A[start] >= target:\r\n            return start\r\n        if A[end] >= target:\r\n            return end\r\n        return len(A)"}]},{"id":447,"unique_name":"maximum-subarray-difference","title":"最大子数组差","description":"<p>给定一个整数数组，找出两个<b><font color=\"#e76363\">不重叠</font></b>的子数组A和B，使两个子数组和的差的绝对值<strong style=\"line-height: 1.42857143; font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\"><font color=\"#e76363\">|SUM(A) - SUM(B)|</font></strong><span style=\"line-height: 1.42857143;\">最大。</span></p><p>返回这个最大的差值。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: An integer indicate the value of maximum difference between two\r\n     *          Subarrays\r\n     */\r\n    public int maxDiffSubArrays(int[] nums) {\r\n        // write your code here\r\n        int size = nums.length;\r\n        int[] left_max = new int[size];\r\n        int[] left_min = new int[size];\r\n        int[] right_max = new int[size];\r\n        int[] right_min = new int[size];\r\n        int[] copy = new int[size];\r\n        /*Get negative copy*/\r\n        for(int i = 0; i < size; i++){\r\n            copy[i] = -1 * nums[i];\r\n        }\r\n        int max = Integer.MIN_VALUE;\r\n        int sum = 0;\r\n        int minSum = 0;\r\n        /*Forward: get max subarray*/\r\n        for(int i = 0; i < size; i++){\r\n            sum += nums[i];\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(sum, minSum);\r\n            left_max[i] = max;\r\n        }\r\n        /*Backward: get max subarray*/\r\n        max = Integer.MIN_VALUE;\r\n        sum = 0;\r\n        minSum = 0;\r\n        for(int i = size - 1; i >= 0; i--){\r\n            sum += nums[i];\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(sum, minSum);\r\n            right_max[i] = max;\r\n        }\r\n        /*Forward: get min subarray*/\r\n        max = Integer.MIN_VALUE;\r\n        sum = 0;\r\n        minSum = 0;\r\n        for(int i = 0; i < size; i++){\r\n            sum += copy[i];\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(sum, minSum);\r\n            left_min[i] = -1 * max;\r\n        }\r\n        /*Backward: get min subarray*/\r\n        max = Integer.MIN_VALUE;\r\n        sum = 0;\r\n        minSum = 0;\r\n        for(int i = size - 1; i >= 0; i--){\r\n            sum += copy[i];\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(sum, minSum);\r\n            right_min[i] = -1 * max;\r\n        }\r\n        int diff = 0;\r\n        for(int i = 0; i < size - 1; i++){\r\n            diff = Math.max(diff, Math.abs(left_max[i] - right_min[i + 1]));\r\n            diff = Math.max(diff, Math.abs(left_min[i] - right_max[i + 1]));\r\n        }\r\n        return diff;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param nums: A list of integers\n     * @return: An integer indicate the value of maximum difference between two\n     *          Subarrays\n     */\nint maxDiffSubArrays(vector<int> nums) {\n    const int n = nums.size();\n    if (n < 2) {\n        return 0;\n    }\n    vector<int> lMax(n), rMax(n), lMin(n), rMin(n);\n    for (int i = 0, peek = INT_MIN, cur = 0; i < n; i++) {\n        cur += nums[i];\n        peek = max(peek, cur);\n        lMax[i] = peek;\n        if (cur < 0) {\n            cur = 0;\n        }\n    }\n    for (int i = n - 1, peek = INT_MIN, cur = 0; i > 0; i--) {\n        cur += nums[i];\n        peek = max(peek, cur);\n        rMax[i - 1] = peek;\n        if (cur < 0) {\n            cur = 0;\n        }\n    }\n    for (int i = 0, peek = INT_MAX, cur = 0; i < n; i++) {\n        cur += nums[i];\n        peek = min(cur, peek);\n        lMin[i] = peek;\n        if (cur > 0) {\n            cur = 0;\n        }\n    }\n    for (int i = n - 1, peek = INT_MAX, cur = 0; i > 0; i--) {\n        cur += nums[i];\n        peek = min(peek, cur);\n        rMin[i - 1] = peek;\n        if (cur > 0) {\n            cur = 0;\n        }\n    }\n    int result = INT_MIN;\n    for (int i = 0; i < n - 1; i++) {\n        int temp = max(lMax[i] - rMin[i], rMax[i] - lMin[i]);\n        result = max(result, temp);\n    }\n    return result;\n}\n};\n\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @return: An integer indicate the value of maximum difference between two\n             Subarrays\n    \"\"\"\n    def maxDiffSubArrays(self, nums):\n        # write your code here\n        n = len(nums)\n        mx1 = [0]*n\n        mx1[0] = nums[0]\n        mn1 = [0]*n\n        mn1[0] = nums[0]\n        forward = [mn1[0], mx1[0]]\n        array_f = [0]*n\n        array_f[0] = forward[:]\n        for i in range(1, n):\n            mx1[i] = max(mx1[i-1] + nums[i], nums[i])\n            mn1[i] = min(mn1[i-1] + nums[i], nums[i])\n            forward = [min(mn1[i], forward[0]), max(mx1[i], forward[1])]\n            array_f[i] = forward[:]\n        mx2 = [0]*n\n        mx2[n-1] = nums[n-1]\n        mn2 = [0]*n\n        mn2[n-1] = nums[n-1]\n        backward = [mn2[n-1], mx2[n-1]]\n        array_b = [0]*n\n        array_b[n-1] = backward[:] \n        for i in range(n-2, -1, -1):\n            mx2[i] = max(mx2[i+1] + nums[i], nums[i])\n            mn2[i] = min(mn2[i+1] + nums[i], nums[i])\n            backward = [min(mn2[i], backward[0]), max(mx2[i], backward[1])]\n            array_b[i] = backward[:]\n        result = -65535\n        for i in range(n-1):\n            result = max(result, abs(array_f[i][0] - array_b[i+1][1]), abs(array_f[i][1] - array_b[i+1][0]))\n        return result\n"},{"language":"javascript","code":"/**\n * @param nums: A list of integers\n * @return: An integer indicate the value of maximum difference between two substrings\n */\nconst maxDiffSubArrays = function (nums) {\n    var size = nums.length;\n    var left_max = new Array(size);\n    var left_min = new Array(size);\n    var right_max = new Array(size);\n    var right_min = new Array(size);\n    var copy = new Array(size);\n    var max, sum, minSum, diff;\n    var i;\n    for (i = 0; i < size; i++) {\n        copy[i] = -1 * nums[i];\n    }\n    max = -Number.MAX_VALUE;\n    sum = 0;\n    minSum = 0;\n    for (i = 0; i < size; i++) {\n        sum += nums[i];\n        max = Math.max(max, sum - minSum);\n        minSum = Math.min(sum, minSum);\n        left_max[i] = max;\n    }\n    max = -Number.MAX_VALUE;\n    sum = 0;\n    minSum = 0;\n    for (i = size - 1; i >= 0; i--) {\n        sum += nums[i];\n        max = Math.max(max, sum - minSum);\n        minSum = Math.min(sum, minSum);\n        right_max[i] = max;\n    }\n    max = -Number.MAX_VALUE;\n    sum = 0;\n    minSum = 0;\n    for(i = 0; i < size; i++){\n        sum += copy[i];\n        max = Math.max(max, sum - minSum);\n        minSum = Math.min(sum, minSum);\n        left_min[i] = -1 * max;\n    }\n    max = -Number.MAX_VALUE;\n    sum = 0;\n    minSum = 0;\n    for(i = size - 1; i >= 0; i--){\n        sum += copy[i];\n        max = Math.max(max, sum - minSum);\n        minSum = Math.min(sum, minSum);\n        right_min[i] = -1 * max;\n    }\n    diff = 0;\n    for(i = 0; i < size - 1; i++){\n        diff = Math.max(diff, Math.abs(left_max[i] - right_min[i + 1]));\n        diff = Math.max(diff, Math.abs(left_min[i] - right_max[i + 1]));\n    }\n    return diff;\n}"}]},{"id":285,"unique_name":"minimum-subarray","title":"最小子数组","description":"<p>给定一个整数数组，找到一个具有最小和的子数组。返回其最小和。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: a list of integers\r\n     * @return: A integer indicate the sum of minimum subarray\r\n     */\r\n    public int minSubArray(ArrayList<Integer> nums) {\r\n        if (nums == null)\r\n            return 0;\r\n        int len = nums.size();\r\n        int min = Integer.MAX_VALUE, currSum = 0;\r\n        int []localmin  = new int[len];\r\n        int []globalmin = new int[len];\r\n        for (int i = 0; i < len; i++) {\r\n            if( i ==0 )\r\n                globalmin[i] = localmin[i] = nums.get(i);\r\n            else {\r\n                localmin[i] = Math.min(localmin[i - 1] + nums.get(i), nums.get(i));\r\n                globalmin[i] = Math.min(globalmin[i - 1], localmin[i]);\r\n            }\r\n            \r\n        }\r\n        return globalmin[len-1];\r\n    }\r\n}"},{"language":"cpp","code":"#include <vector>\n\nusing namespace std;\n\n\nclass Solution {\npublic:\n    int minSubArray(vector<int> nums) {\n        int minSum = nums[0];\n        int sum = 0;\n        int maxSum = 0;\n\n        for (int i = 0; i < nums.size(); i++) {\n            sum += nums[i];\n            if (sum - maxSum < minSum) {\n                minSum = sum - maxSum;\n            }\n            if (sum > maxSum) {\n                sum = maxSum;\n            }\n        }\n        return minSum;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param nums: a list of integers\n    @return: A integer denote the sum of minimum subarray\n    \"\"\"\n    def minSubArray(self, nums):\n        sum = 0\n        minSum = nums[0]\n        maxSum = 0\n        for num in nums:\n            sum += num\n            if sum - maxSum < minSum:\n                minSum = sum - maxSum\n            if sum > maxSum:\n                maxSum = sum\n        return minSum\n"}]},{"id":164,"unique_name":"maximum-subarray-iii","title":"最大子数组 III","description":"给定一个整数数组和一个整数 *k*，找出 *k* 个**不重叠**子数组使得它们的和最大。每个子数组的数字在数组中的位置应该是连续的。\r\n\r\n返回最大的和。","solutions":[{"language":"java","code":"// 方法一 划分类DP\r\npublic class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @param k: An integer denote to find k non-overlapping subarrays\r\n     * @return: An integer denote the sum of max k non-overlapping subarrays\r\n     */\r\n    public int maxSubArray(int[] nums, int k) {\r\n        if (nums.length < k) {\r\n            return 0;\r\n        }\r\n        int len = nums.length;\r\n        \r\n       \r\n        int[][] globalMax = new int[k + 1][len + 1];\r\n        int[][] localMax = new int[k + 1][len + 1];\r\n        \r\n        for (int i = 1; i <= k; i++) {\r\n            localMax[i][i-1] = Integer.MIN_VALUE;\r\n            //小于 i 的数组不能够partition\r\n            for (int j = i; j <= len; j++) {\r\n                localMax[i][j] = Math.max(localMax[i][j-1], globalMax[i - 1][j-1]) + nums[j-1];\r\n                if (j == i)\r\n                    globalMax[i][j] = localMax[i][j];\r\n                else\r\n                    globalMax[i][j] = Math.max(globalMax[i][j-1], localMax[i][j]);\r\n            }\r\n        }\r\n        return globalMax[k][len];\r\n    }\r\n    \r\n}\r\n\r\n\r\n//方法二\r\npublic class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @param k: An integer denote to find k non-overlapping subarrays\r\n     * @return: An integer denote the sum of max k non-overlapping subarrays\r\n     */ \r\n    public static int maxSubArray(ArrayList<Integer> nums, int k) {\r\n        // write your code\r\n        int len = nums.size();\r\n        int[][] f = new int[k+1][len];\r\n        for (int i = 1; i < k+1; i++) {\r\n            int sum = 0;\r\n            for (int j = 0; j < i; j++) {\r\n                sum += nums.get(j);\r\n            }\r\n            f[i][i-1] = sum;\r\n        }\r\n        for (int i = 1; i < len; i++) {\r\n        \tf[1][i] = Math.max(f[1][i-1]+nums.get(i), nums.get(i));\r\n        }\r\n        \r\n        for (int i = 2; i < k+1; i++) {\r\n            for (int n = i;  n< len; n++) {\r\n                int curMax = f[i][n-1] + nums.get(n);\r\n                for (int j = i-2; j < n; j++) {\r\n                    if ((f[i-1][j] + nums.get(n)) > curMax) {\r\n                        curMax = f[i-1][j] + nums.get(n);\r\n                    }\r\n                }\r\n                f[i][n] = curMax;\r\n            }\r\n        }\r\n        \r\n        int res = Integer.MIN_VALUE;\r\n        for (int i = k-1; i < len; i++){\r\n            if (f[k][i] > res) {\r\n                res = f[k][i];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @param k: An integer denote to find k non-overlapping subarrays\r\n     * @return: An integer denote the sum of max k non-overlapping subarrays\r\n     */\r\n    int maxSubArray(vector<int> nums, int k) {\r\n\tconst int n = nums.size();\r\n\tvector<vector<int> > f(k + 1, vector<int>(n + 1));\r\n\tvector<vector<int> > p(k + 1, vector<int>(n + 1));\r\n\tint sum;\r\n\tfor (int i = 1; i <= k; i++) {\r\n\t\tsum = INT_MIN;\r\n\t\tf[i][i] = f[i - 1][i - 1] + nums[i - 1];\r\n\t\tp[i][i] = f[i][i];\r\n\t\tsum = f[i][i];\r\n\t\tfor (int j = i + 1; j <= n; j++) {\r\n\t\t\tif (f[i][j - 1] < p[i - 1][j - 1]) {\r\n\t\t\t\tf[i][j] = p[i - 1][j - 1] + nums[j - 1];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tf[i][j] = f[i][j - 1] + nums[j - 1];\r\n\t\t\t}\r\n\t\t\tsum = max(sum, f[i][j]);\r\n\t\t\tp[i][j] = sum;\r\n\t\t}\r\n\t}\r\n\tint result = INT_MIN;\r\n\tfor (int i = k; i <= n; i++) {\r\n\t\tresult = max(result, f[k][i]);\r\n\t}\r\n\treturn result;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers\r\n    @param k: An integer denote to find k non-overlapping subarrays\r\n    @return: An integer denote the sum of max k non-overlapping subarrays\r\n    \"\"\"\r\n    def maxSubArray(self, nums, k):\r\n        oo = 2 ** 32\r\n        n = len(nums)\r\n        f = [[-oo] * (k + 1), [-oo] * (k + 1)]\r\n        g = [[-oo] * (k + 1), [-oo] * (k + 1)]\r\n        \r\n        f[0][0] = 0\r\n        g[0][0] = 0\r\n        for i in range(1, n + 1):\r\n            f[i % 2][0] = 0\r\n            g[i % 2][0] = 0\r\n            for j in range(1, k + 1):\r\n                f[i % 2][j] = max(f[(i - 1) % 2][j] + nums[i - 1],\r\n                                  g[(i - 1) % 2][j - 1] + nums[i - 1])\r\n                g[i % 2][j] = max(g[(i - 1) % 2][j], f[i % 2][j])\r\n        return g[n % 2][k]\r\n"},{"language":"javascript","code":"/**\n * @param nums: A list of integers\n * @param k: An integer denote to find k non-overlapping subarrays\n * @return: An integer denote the sum of max k non-overlapping subarrays\n */\nconst maxSubArray = function (nums, k) {\n    if (nums.length < k) {\n        return 0;\n    }\n    var len = nums.length;\n    var globalMax = new Array(k + 1);\n    var localMax = new Array(k + 1);\n    var i, j;\n    for (i = 0; i <= k; i++) {\n        globalMax[i] = new Array(len + 1);\n        localMax[i] = new Array(len + 1);\n        for (j = 0; j <= len; j++) {\n            globalMax[i][j] = 0;\n            localMax[i][j] = 0;\n        }\n    }\n    for (i = 1; i <= k; i++) {\n        localMax[i][i - 1] = -Number.MAX_VALUE;\n        for (j = i; j <= len; j++) {\n            localMax[i][j] = Math.max(localMax[i][j-1], globalMax[i - 1][j-1]) + nums[j-1];\n            if (j == i) {\n                globalMax[i][j] = localMax[i][j];   \n            }\n            else {\n                globalMax[i][j] = Math.max(globalMax[i][j-1], localMax[i][j]);\n            }\n        }\n    }\n    return globalMax[k][len];\n}"}]},{"id":165,"unique_name":"maximum-subarray-ii","title":"最大子数组 II","description":"给定一个整数数组，找出两个 *不重叠* 子数组使得它们的和最大。\r\n每个子数组的数字在数组中的位置应该是连续的。\r\n返回最大的和。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: An integer denotes the sum of max two non-overlapping subarrays\r\n     */\r\n    public int maxTwoSubArrays(ArrayList<Integer> nums) {\r\n        // write your code\r\n        int size = nums.size();\r\n        int[] left = new int[size];\r\n        int[] right = new int[size];\r\n        int sum = 0;\r\n        int minSum = 0;\r\n        int max = Integer.MIN_VALUE;\r\n        for(int i = 0; i < size; i++){\r\n            sum += nums.get(i);\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(sum, minSum);\r\n            left[i] = max;\r\n        }\r\n        sum = 0;\r\n        minSum = 0;\r\n        max = Integer.MIN_VALUE;\r\n        for(int i = size - 1; i >= 0; i--){\r\n            sum += nums.get(i);\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(sum, minSum);\r\n            right[i] = max;\r\n        }\r\n        max = Integer.MIN_VALUE;\r\n        for(int i = 0; i < size - 1; i++){\r\n            max = Math.max(max, left[i] + right[i + 1]);\r\n        }\r\n        return max;\r\n    }\r\n}"},{"language":"cpp","code":"#define __STDC_LIMIT_MACROS\r\n#include <stdint.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: An integer denotes the sum of max two non-overlapping subarrays\r\n     */\r\n    int maxTwoSubArrays(vector<int> &nums) {\r\n        if (nums.size() == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int result = -2147483648;\r\n        int n = (int)nums.size();\r\n        vector<int> maxLeft(n + 1, -2147483648);\r\n        vector<int> maxRight(n + 1, -2147483648);\r\n        vector<int> profit(n + 1, 0);\r\n        \r\n        vector<int> sum(n + 1, 0);\r\n        \r\n        for (int i = 1; i <= n; i++) {\r\n            sum[i] = sum[i - 1] + nums[i - 1];\r\n        }\r\n        \r\n        maxLeft[0] = -2147483648;\r\n        for (int i = 1, valley = 0; i < sum.size(); i++) {            \r\n            maxLeft[i] = max(maxLeft[i - 1], sum[i] - valley);\r\n            valley = min(valley, sum[i]);\r\n        }\r\n        \r\n        \r\n        for (int i = n, peak = sum[n]; i > 0; i--) {\r\n            if (i == n) {\r\n                maxRight[i] = peak - sum[i - 1];\r\n            } else {\r\n                maxRight[i]= max(maxRight[i + 1], peak - sum[i - 1]);\r\n            }\r\n            peak = max(peak, sum[i - 1]);\r\n        }\r\n        \r\n        for (int i = 1; i < n; i++) {\r\n            profit[i] = maxLeft[i] + maxRight[i + 1];\r\n            result = max(result, profit[i]);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers\r\n    @return: An integer denotes the sum of max two non-overlapping subarrays\r\n    \"\"\"\r\n    def maxTwoSubArrays(self, nums):\r\n        # write your code here   \r\n        # write your code here   \r\n        n = len(nums)\r\n        a = nums[:]\r\n    \taa = nums[:]\r\n        for i in range(1, n):\r\n            a[i] = max(nums[i], a[i-1] + nums[i])\r\n            aa[i] = max(a[i], aa[i-1])\r\n        b = nums[:]\r\n    \tbb = nums[:]\r\n        for i in range(n-2, -1, -1):\r\n            b[i] = max(b[i+1] + nums[i], nums[i])\r\n            bb[i] = max(b[i], bb[i+1])\r\n        mx = -65535\r\n        for i in range(n - 1):\r\n            mx = max(aa[i]+b[i+1], mx)\r\n\r\n        return mx"}]},{"id":79,"unique_name":"maximum-subarray","title":"最大子数组","description":"给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。","solutions":[{"language":"java","code":"// Version 1: Greedy\r\n\r\npublic class Solution {\r\n    public int maxSubArray(int[] A) {\r\n        if (A == null || A.length == 0){\r\n            return 0;\r\n        }\r\n        \r\n        int max = Integer.MIN_VALUE, sum = 0;\r\n        for (int i = 0; i < A.length; i++) {\r\n            sum += A[i];\r\n            max = Math.max(max, sum);\r\n            sum = Math.max(sum, 0);\r\n        }\r\n\r\n        return max;\r\n    }\r\n}\r\n\r\n// Version 2: Prefix Sum\r\n\r\npublic class Solution {\r\n    public int maxSubArray(int[] A) {\r\n        if (A == null || A.length == 0){\r\n            return 0;\r\n        }\r\n        \r\n        int max = Integer.MIN_VALUE, sum = 0, minSum = 0;\r\n        for (int i = 0; i < A.length; i++) {\r\n            sum += A[i];\r\n            max = Math.max(max, sum - minSum);\r\n            minSum = Math.min(minSum, sum);\r\n        }\r\n\r\n        return max;\r\n    }\r\n}\r\n\r\n\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param nums: a list of integers\r\n     * @return: A integer indicate the sum of minimum subarray\r\n     */\r\n    public int maxSubArray(int[] nums) {\r\n        // write your code\r\n        if(nums.length == 0){\r\n            return 0; \r\n        }\r\n        int n = nums.length;\r\n        int[] global = new int[2];\r\n        int[] local = new int[2];\r\n        global[0] = nums[0];\r\n        local[0] = nums[0];\r\n        for(int i = 1; i < n; i ++) {  \r\n            local[i % 2] = Math.max(nums[i], local[(i - 1) % 2] + nums[i]);  \r\n            global[i % 2] = Math.max(local[i % 2], global[(i - 1) % 2]);  \r\n        }  \r\n        return global[(n-1) % 2];  \r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: A integer indicate the sum of max subarray\r\n     */\r\n    int maxSubArray(vector<int> nums) {\r\n        int sum = 0, minSum = 0, maxSum = INT_MIN;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            sum += nums[i];\r\n            maxSum = max(maxSum, sum - minSum);\r\n            minSum = min(minSum, sum);\r\n        }\r\n        return maxSum;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n\r\n    def maxSubArray(self, nums):\r\n        if nums is None or len(nums) == 0:\r\n            return 0\r\n        maxSum = nums[0]\r\n        minSum = 0\r\n        sum = 0\r\n        for num in nums:\r\n            sum += num\r\n            if sum - minSum > maxSum:\r\n                maxSum = sum - minSum\r\n            if sum < minSum:\r\n                minSum = sum\r\n        return maxSum\r\n"},{"language":"javascript","code":"/**\n * @param nums: A list of integers\n * @return: A integer indicate the sum of max subarray\n */\nconst maxSubArray = function (nums) {\n    if (nums === null || nums.length === 0) {\n        return 0;\n    }\n    var maxSum = nums[0], minSum = 0, sum = 0;\n    var i;\n    for (i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum - minSum > maxSum) {\n            maxSum = sum - minSum;\n        }\n        if (sum < minSum) {\n            minSum = sum;\n        }\n    }\n    return maxSum;\n}"}]},{"id":191,"unique_name":"partition-array","title":"数组划分","description":"给出一个整数数组 *nums* 和一个整数 *k*。划分数组（即移动数组 *nums* 中的元素），使得：\r\n\r\n- 所有小于k的元素移到左边\r\n- 所有大于等于k的元素移到右边\r\n\r\n返回数组划分的位置，即数组中第一个位置 *i*，满足 *nums*[*i*] 大于等于 *k*。","solutions":[{"language":"java","code":"public class Solution {\r\n    /** \r\n     *@param nums: The integer array you should partition\r\n     *@param k: As description\r\n     *return: The index after partition\r\n     */\r\n    public int partitionArray(int[] nums, int k) {\r\n        if(nums == null || nums.length == 0){\r\n            return 0;\r\n        }\r\n        \r\n        int left = 0, right = nums.length - 1;\r\n        while (left <= right) {\r\n\r\n            while (left <= right && nums[left] < k) {\r\n                left++;\r\n            }\r\n\r\n            while (left <= right && nums[right] >= k) {\r\n                right--;\r\n            }\r\n\r\n            if (left <= right) {\r\n                int temp = nums[left];\r\n                nums[left] = nums[right];\r\n                nums[right] = temp;\r\n                \r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int partitionArray(vector<int> &nums, int k) {\r\n        int i = 0, j = nums.size() - 1;\r\n        while (i <= j) {\r\n            while (i <= j && nums[i] < k) i++;\r\n            while (i <= j && nums[j] >= k) j--;\r\n            if (i <= j) {\r\n                int temp = nums[i];\r\n                nums[i] = nums[j];\r\n                nums[j] = temp;\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: The integer array you should partition\r\n    @param k: As description\r\n    @return: The index after partition\r\n    \"\"\"\r\n    def partitionArray(self, nums, k):\r\n        start, end = 0, len(nums) - 1\r\n        while start <= end:\r\n            while start <= end and nums[start] < k:\r\n                start += 1\r\n            while start <= end and nums[end] >= k:\r\n                end -= 1\r\n            if start <= end:\r\n                nums[start], nums[end] = nums[end], nums[start]\r\n                start += 1\r\n                end -= 1\r\n        return start"},{"language":"javascript","code":"/**\n * @param nums: The integer array you should partition\n * @param k: An integer\n * @return: The index after partition\n */\nconst partitionArray = function (nums, k) {\n    if (nums === null || nums.length === 0) {\n        return 0;\n    }\n    var left = 0, right = nums.length - 1, temp;\n    while (left <= right) {\n        while (left <= right && nums[left] < k) {\n            left++;\n        }\n        while (left <= right && nums[right] >= k) {\n            right--;\n        }\n        if (left <= right) {\n            temp = nums[left];\n            nums[left] = nums[right];\n            nums[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    return left;\n}"}]},{"id":313,"unique_name":"first-position-of-target","title":"二分查找","description":"给定一个排序的整数数组（升序）和一个要查找的整数`target`，用`O(logn)`的时间查找到target第一次出现的下标（从0开始），如果target不存在于数组中，返回`-1`。","solutions":[{"language":"java","code":"// version 1: with jiuzhang template\r\nclass Solution {\r\n    /**\r\n     * @param nums: The integer array.\r\n     * @param target: Target to find.\r\n     * @return: The first position of target. Position starts from 0.\r\n     */\r\n    public int binarySearch(int[] nums, int target) {\r\n        if (nums == null || nums.length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        int start = 0, end = nums.length - 1;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (nums[mid] == target) {\r\n                end = mid;\r\n            } else if (nums[mid] < target) {\r\n                start = mid;\r\n                // or start = mid + 1\r\n            } else {\r\n                end = mid;\r\n                // or end = mid - 1\r\n            }\r\n        }\r\n        \r\n        if (nums[start] == target) {\r\n            return start;\r\n        }\r\n        if (nums[end] == target) {\r\n            return end;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n\r\n// version 2: without jiuzhang template\r\nclass Solution {\r\n    /**\r\n     * @param nums: The integer array.\r\n     * @param target: Target to find.\r\n     * @return: The first position of target. Position starts from 0.\r\n     */\r\n    public int binarySearch(int[] nums, int target) {\r\n        if (nums == null || nums.length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        int start = 0, end = nums.length - 1;\r\n        while (start < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (nums[mid] == target) {\r\n                end = mid;\r\n            } else if (nums[mid] < target) {\r\n                start = mid + 1;\r\n            } else {\r\n                end = mid - 1;\r\n            }\r\n        }\r\n        \r\n        if (nums[start] == target) {\r\n            return start;\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int binarySearch(vector<int> &A, int target) {\r\n        if (A.size() == 0) {\r\n            return -1;\r\n        }\r\n\r\n        int start = 0;\r\n        int end = A.size() - 1;\r\n        int mid;\r\n\r\n        while (start + 1 < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (A[mid] == target) {\r\n                end = mid;\r\n            } else if (A[mid] < target) {\r\n                start = mid;\r\n            } else if (A[mid] > target) {\r\n                end = mid;\r\n            }\r\n        }\r\n\r\n        if (A[start] == target) {\r\n            return start;\r\n        }\r\n        if (A[end] == target) {\r\n            return end;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param nums: The integer array\r\n    # @param target: Target number to find\r\n    # @return the first position of target in nums, position start from 0 \r\n    def binarySearch(self, nums, target):\r\n        # write your code here\r\n        left, right = 0, len(nums)\r\n        while left + 1 < right :\r\n            mid = (left + right) / 2\r\n            if nums[mid] < target :\r\n                left = mid\r\n            else :\r\n                right = mid\r\n        if nums[left] == target :\r\n            return left\r\n        elif nums[right] == target :\r\n            return right\r\n        return -1;"},{"language":"javascript","code":"/**\n * @param nums: The integer array.\n * @param target: Target to find.\n * @return: The first position of target. Position starts from 0.\n */\nconst binarySearch = function (nums, target) {\n    var left, right, mid, res;\n    res = 0;\n    left = 0;\n    right = nums.length - 1;\n    while (left <= right) {\n        mid = Math.floor((left + right) / 2);\n        if (nums[mid] === target) {\n            res = mid;\n        }\n        if (nums[mid] >= target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (nums[res] != target) {\n        return -1;\n    }\n    return res;\n}"}]},{"id":190,"unique_name":"merge-sorted-array-ii","title":"合并排序数组 II","description":"<p>合并两个排序的整数数组A和B变成一个新的数组。</p>","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * @param A and B: sorted integer array A and B.\r\n     * @return: A new sorted integer array\r\n     */\r\n    public int[] mergeSortedArray(int[] A, int[] B) {\r\n        // Write your code here\r\n        int[] ans = new int[A.length + B.length];\r\n        int a = 0, b = 0, temp = 0;\r\n        while(a != A.length && b != B.length) {\r\n            if(A[a] > B[b]){\r\n                ans[temp] = B[b++];\r\n            }\r\n            else {\r\n                ans[temp] = A[a++];\r\n            }\r\n            temp ++;\r\n        }\r\n        if(a != A.length){\r\n            while(a != A.length){\r\n                ans[temp++] = A[a++];\r\n            }\r\n        }\r\n        else {\r\n            while(b != B.length){\r\n                ans[temp++] = B[b++];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A and B: sorted integer array A and B.\r\n     * @return: A new sorted integer array\r\n     */\r\n    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {\r\n        vector<int> C;\r\n        int i = 0, j = 0;\r\n        while (i < A.size() && j < B.size()) {\r\n            if (A[i] < B[j]) {\r\n                C.push_back(A[i++]);\r\n            } else {\r\n                C.push_back(B[j++]);\r\n            }\r\n        }\r\n        while (i < A.size()) {\r\n            C.push_back(A[i++]);\r\n        }\r\n        while (j < B.size()) {\r\n            C.push_back(B[j++]);\r\n        }\r\n        return C;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    #@param A and B: sorted integer array A and B.\r\n    #@return: A new sorted integer array\r\n    def mergeSortedArray(self, A, B):\r\n        # write your code here\r\n        ans = []\r\n        i, j = 0, 0\r\n        n, m = len(A), len(B)\r\n        while i < n and j < m :\r\n            if A[i] < B[j] :\r\n                ans.append(A[i])\r\n                i += 1\r\n            else :\r\n                ans.append(B[j])\r\n                j += 1\r\n        while i < n :\r\n            ans.append(A[i])\r\n            i += 1\r\n        while j < m :\r\n            ans.append(B[j])\r\n            j += 1\r\n        return ans\r\n        "}]},{"id":76,"unique_name":"merge-intervals","title":"合并区间","description":"给出若干闭合区间，合并所有重叠的部分。","solutions":[{"language":"java","code":"public class Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        if (intervals == null || intervals.size() <= 1) {\n            return intervals;\n        }\n        \n        Collections.sort(intervals, new IntervalComparator());       \n  \n        List<Interval> result = new ArrayList<Interval>();\n        Interval last = intervals.get(0);\n        for (int i = 1; i < intervals.size(); i++) {\n            Interval curt = intervals.get(i);\n            if (curt.start <= last.end ){\n                last.end = Math.max(last.end, curt.end);\n            }else{\n                result.add(last);\n                last = curt;\n            }\n        }\n        \n        result.add(last);\n        return result;\n    }\n    \n    \n    private class IntervalComparator implements Comparator<Interval> {\n        public int compare(Interval a, Interval b) {\n            return a.start - b.start;\n        }\n    }\n\n}\n\n\n// version: 高频题班\nclass Solution {\n    /**\n     * @param intervals, a collection of intervals\n     * @return: A new sorted interval list.\n     */\n    public List<Interval> merge(List<Interval> intervals) {\n        // write your code here\n        List<Interval> ans = new ArrayList<>();\n\n        intervals.sort(Comparator.comparing(i -> i.start));  //lambda 匿名函数：输入i  返回i.start\n\n        Interval last = null;\n        for (Interval item : intervals) {\n            if (last == null || last.end < item.start) {\n                ans.add(item);\n                last = item;\n            } else {\n                last.end = Math.max(last.end, item.end); // Modify the element already in list\n            }\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n  /**\r\n   * @param intervals: interval list.\r\n   * @return: A new interval list.\r\n   */\r\n  static bool cmp(const Interval &a, const Interval &b) {\r\n    return (a.start < b.start);\r\n  }\r\n  \r\n  vector<Interval> merge(vector<Interval>& intervals) {\r\n    // write your code here\r\n    vector<Interval> ans;\r\n    if (intervals.empty()) {\r\n      return ans;\r\n    } \r\n    \r\n    sort(intervals.begin(), intervals.end(), cmp);\r\n    ans.push_back(intervals[0]);\r\n    for (int i = 1; i < intervals.size(); i++) { \r\n      if (ans.back().end >= intervals[i].start) { \r\n        ans.back().end = max(ans.back().end, intervals[i].end);\r\n      } else { \r\n        ans.push_back(intervals[i]);\r\n      } \r\n    } \r\n    return ans;  \r\n  }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of Interval.\r\nclass Interval(object):\r\n    def __init__(self, start, end):\r\n        self.start = start\r\n        self.end = end\r\n\"\"\"\r\n\r\nclass Solution:\r\n    # @param intervals, a list of Interval\r\n    # @return a list of Interval\r\n    def merge(self, intervals):\r\n        intervals = sorted(intervals, key=lambda x: x.start)\r\n        result = []\r\n        for interval in intervals:\r\n            if len(result) == 0 or result[-1].end < interval.start:\r\n                result.append(interval)\r\n            else:\r\n                result[-1].end = max(result[-1].end, interval.end)\r\n        return result"}]},{"id":20,"unique_name":"candy","title":"分糖果","description":"有 *N* 个小孩站成一列。每个小孩有一个评级。\r\n\r\n按照以下要求，给小孩分糖果：\r\n\r\n* 每个小孩至少得到一颗糖果。 \r\n\r\n* 评级越高的小孩可以比他相邻的两个小孩得到更多的糖果。\r\n\r\n需最少准备多少糖果？\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    public int candy(int[] ratings) {\r\n        if(ratings == null || ratings.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        int[] count = new int[ratings.length];\r\n        Arrays.fill(count, 1);\r\n        int sum = 0;\r\n        for(int i = 1; i < ratings.length; i++) {\r\n            if(ratings[i] > ratings[i - 1]) {\r\n                count[i] = count[i - 1] + 1;\r\n            }\r\n        }\r\n\r\n        for(int i = ratings.length - 1; i >= 1; i--) {\r\n            sum += count[i];\r\n            if(ratings[i - 1] > ratings[i] && count[i - 1] <= count[i]) {  // second round has two conditions\r\n                count[i-1] = count[i] + 1;\r\n            }\r\n        }\r\n        sum += count[0];\r\n        return sum;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int candy(vector<int>& ratings) {\r\n        vector<int> candies(ratings.size());\r\n\r\n        candies[0] = 1;\r\n        for (int i = 1; i < ratings.size(); i++) {\r\n            if (ratings[i] > ratings[i - 1]) {\r\n                candies[i] = candies[i - 1] + 1;\r\n            } else {\r\n                candies[i] = 1;\r\n            }\r\n        }\r\n        \r\n        for (int i = ratings.size() - 2; i >= 0; i--) {\r\n            if (ratings[i] > ratings[i + 1]) {\r\n                candies[i] = max(candies[i], candies[i + 1] + 1);\r\n            }\r\n        }\r\n        \r\n        int sum = 0;\r\n        for (int i = 0; i < candies.size(); i++) {\r\n            sum += candies[i];\r\n        }\r\n        \r\n        return sum;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\n    # @param ratings, a list of integer\n    # @return an integer\n    def candy(self, ratings):\n        candynum = [1 for i in range(len(ratings))]\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                candynum[i] = candynum[i-1] + 1\n        for i in range(len(ratings)-2, -1, -1):\n            if ratings[i+1] < ratings[i] and candynum[i+1] >= candynum[i]:\n                candynum[i] = candynum[i+1] + 1\n        return sum(candynum)\n"}]},{"id":65,"unique_name":"plus-one","title":"加一","description":"给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。\n\n该数字按照数位高低进行排列，最高位的数在列表的最前面。","solutions":[{"language":"java","code":"public class Solution {\r\n    // The complexity is O(1)\r\n    // f(n) = 9/10 + 1/10 * O(n-1)\r\n    //  ==>  O(n) =  10 / 9 = 1.1111 = O(1)\r\n    \r\n    public int[] plusOne(int[] digits) {\r\n        int carries = 1;\r\n        for(int i = digits.length-1; i>=0 && carries > 0; i--){  // fast break when carries equals zero\r\n            int sum = digits[i] + carries;\r\n            digits[i] = sum % 10;\r\n            carries = sum / 10;\r\n        }\r\n        if(carries == 0)\r\n            return digits;\r\n            \r\n        int[] rst = new int[digits.length+1];\r\n        rst[0] = 1;\r\n        for(int i=1; i< rst.length; i++){\r\n            rst[i] = digits[i-1];\r\n        }\r\n        return rst;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    vector<int> plusOne(vector<int> &digits) {\n        add(digits, 1);\n        return digits;\n    }\nprivate:\n    // 0 <= digit <= 9\n    void add(vector<int> &digits, int digit) {\n        int c = digit; // carry, 进位\n        for (auto it = digits.rbegin(); it != digits.rend(); ++it) {\n            *it += c;\n            c = *it / 10;\n            *it %= 10;\n        }\n        if (c > 0) digits.insert(digits.begin(), 1);\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param {int[]} digits a number represented as an array of digits\n    # @return {int[]} the result\n    def plusOne(self, digits):\n        digits = list(reversed(digits))\n        digits[0] += 1\n        i, carry = 0, 0\n        while i < len(digits):\n            next_carry = (digits[i] + carry) / 10\n            digits[i] = (digits[i] + carry) % 10\n            i, carry = i + 1, next_carry\n        if carry > 0:\n            digits.append(carry)\n        \n        return list(reversed(digits))"}]},{"id":118,"unique_name":"container-with-most-water","title":"装最多水的容器","description":"给定 *n* 个非负整数 a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, 每个数代表了坐标中的一个点 `(i, ai)`。画 *n* 条垂直线，使得 *i* 垂直线的两个端点分别为`(i, ai)`和`(i, 0)`。找到两条线，使得其与 *x* 轴共同构成一个容器，以容纳最多水。\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param heights: an array of integers\r\n     * @return: an integer\r\n     */\r\n    int computeArea(int left, int right,  int[] heights) {\r\n        return (right-left)*Math.min(heights[left], heights[right]);\r\n    }\r\n    \r\n    public int maxArea(int[] heights) {\r\n        // write your code here\r\n        int left = 0, ans=  0 ; \r\n        int right = heights.length - 1;\r\n        while(left <= right) {\r\n            ans = Math.max(ans,computeArea(left, right, heights));\r\n            if(heights[left]<=heights[right])\r\n                left++;\r\n            else\r\n                right--;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n--------------------------------------\r\n\r\n\r\npublic class Solution {\r\n    // for any i, the maxium area will be the farthest j that has a[j] > a[i];\r\n    public int maxArea(int[] height) {\r\n        if(height == null || height.length < 2) {\r\n            return 0;\r\n        }\r\n        int max = 0;\r\n        int left = 0;\r\n        int right = height.length -1;\r\n        while(left < right) {\r\n            max = Math.max( max, (right - left) * Math.min(height[left], height[right]));\r\n            if(height[left] < height[right]){\r\n                left++;\r\n            } else {\r\n                right--;\r\n            }\r\n        }\r\n        return max;\r\n        \r\n    }\r\n}\r\n"},{"language":"cpp","code":"\r\nC++ Version\r\n-------------------\r\nclass Solution {\r\npublic:\r\n    int maxArea(vector<int> &height) {\r\n        int max = 0, area;\r\n        int start = 0, end = height.size() - 1;\r\n        while (start < end) {\r\n            if (height[start] > height[end]) {\r\n                area = height[end] * (end - start);\r\n                end --;\r\n            } else {\r\n                area = height[start] * (end - start);\r\n                start ++;\r\n            }\r\n            if (area > max) {\r\n                max = area;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    '''\r\n    题意:任取两个a[i]、a[j] 使得min(a[i], a[j]) * abs(i - j)最大化\r\n    用两个指针从两侧向中间扫描，每次移动数值较小的指针，用反证法可以证明\r\n    总是可以得到最优答案\r\n    '''\r\n    def maxArea(self, height):\r\n        left, right = 0, len(height) - 1\r\n        ans = 0\r\n        while left < right:\r\n            if height[left] < height[right]:\r\n                area = height[left] * (right - left)\r\n                left += 1\r\n            else:\r\n                area = height[right] * (right - left)\r\n                right -= 1\r\n            ans = max(ans, area) \r\n        return ans"}]},{"id":74,"unique_name":"spiral-matrix-ii","title":"螺旋矩阵 II","description":"给你一个数`n`生成一个包含`1-n^2`的螺旋形矩阵","solutions":[{"language":"java","code":"public class Solution {\r\n    public int[][] generateMatrix(int n) {\r\n        if (n < 0) {\r\n            return null;\r\n        }\r\n\r\n        int[][] result = new int[n][n];\r\n\r\n        int xStart = 0;\r\n        int yStart = 0;\r\n        int num = 1;\r\n\r\n        while (n > 0) {\r\n            if (n == 1) {\r\n                result[yStart][xStart] = num++;\r\n                break;\r\n            }\r\n\r\n            for (int i = 0; i < n - 1; i++) {\r\n                result[yStart][xStart + i] = num++;\r\n            }\r\n\r\n            for (int i = 0; i < n - 1; i++) {\r\n                result[yStart + i][xStart + n - 1] = num++;\r\n            }\r\n\r\n            for (int i = 0; i < n - 1; i++) {\r\n                result[yStart + n - 1][xStart + n - 1 - i] = num++;\r\n            }\r\n\r\n            for (int i = 0; i < n - 1; i++) {\r\n                result[yStart + n - 1 - i][xStart] = num++;\r\n            }\r\n\r\n            xStart++;\r\n            yStart++;\r\n            n = n - 2;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n an integer\n     * @return a square matrix\n     */\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> ret(n,vector<int>(n,0));\n        int cnt = n/2;\n        int val = 1;\n        for (int i = 0; i < cnt; i++) {\n            int last = n - 1 - i;\n            for (int j = i; j < last; j++) \n                ret[i][j] = val++;\n            for (int j = i; j < last; j++)\n                ret[j][last] = val++;\n            for (int j = last; j > i; j--)\n                ret[last][j] = val ++;\n            for (int j = last; j > i; j--)\n                ret[j][i] = val++;\n        }\n        if (n % 2 == 1) {\n            ret[n/2][n/2] = val;\n        }\n        return ret;\n    }\n};\n\n\nclass Solution {\npublic:\n    /**\n     * @param n an integer\n     * @return a square matrix\n     */\n    vector<vector<int>> generateMatrix(int n) {\n        // Write your code here\n        step[0][0] = 0;\n        step[0][1] = 1;\n        step[1][0] = 1;\n        step[1][1] = 0;\n        step[2][0] = 0;\n        step[2][1] = -1;\n        step[3][0] = -1;\n        step[3][1] = 0;\n        vector<vector<int> > ret(n, vector<int>(n));\n        memset(canUse, true, sizeof(canUse));\n        dfs(1, ret, 0, 0, -1);\n        \n        return ret;\n    }\n\nprivate:\n    int step[4][2];\n    bool canUse[100][100];\npublic:\n    void dfs(int dep, vector<vector<int> > &matrix, int direct, int x, int y)\n    {\n        for(int i = 0; i < 4; i++)\n        {\n            int j = (direct + i) % 4;\n            int tx = x + step[j][0];\n            int ty = y + step[j][1];\n            if (0 <= tx && tx < matrix.size() && 0 <= ty && ty < matrix[0].size() && canUse[tx][ty])\n            {\n                canUse[tx][ty] = false;\n                matrix[tx][ty] = dep;              \n                dfs(dep + 1, matrix, j, tx, ty);               \n            }            \n        }\n    }\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n an integer\r\n    # @return {int[][]} a square matrix\r\n    def generateMatrix(self, n):\r\n        # Write your code here\r\n        if n == 0: return []\r\n        matrix = [[0 for i in range(n)] for j in range(n)]\r\n        up = 0; down = len(matrix)-1\r\n        left = 0; right = len(matrix[0])-1\r\n        direct = 0; count = 0\r\n        while True:\r\n            if direct == 0:\r\n                for i in range(left, right+1):\r\n                    count += 1; matrix[up][i] = count\r\n                up += 1\r\n            if direct == 1:\r\n                for i in range(up, down+1):\r\n                    count += 1; matrix[i][right] = count\r\n                right -= 1\r\n            if direct == 2:\r\n                for i in range(right, left-1, -1):\r\n                    count += 1; matrix[down][i] = count\r\n                down -= 1\r\n            if direct == 3:\r\n                for i in range(down, up-1, -1):\r\n                    count += 1; matrix[i][left] = count\r\n                left += 1\r\n            if count == n*n: return matrix\r\n            direct = (direct+1) % 4"}]},{"id":78,"unique_name":"spiral-matrix","title":"螺旋矩阵","description":"给定一个包含 *m* x *n* 个要素的矩阵，（*m* 行, *n* 列），按照螺旋顺序，返回该矩阵中的所有要素。","solutions":[{"language":"java","code":"// 九章硅谷求职算法集训营版本\npublic class Solution {\n    /**\n     * @param n: a Integer\n     * @return: a spiral array\n     */\n    public int[][] spiralArray(int n) {\n        int[][] res = new int[n][n];\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        int x, y, d;\n        int i, j;\n        for (i = 0; i < n; ++i) {\n            for (j = 0; j < n; ++j) {\n                res[i][j] = -1;\n            }\n        }\n        \n        x = y = d = 0;\n        for (i = 1; i <= n * n; ++i) {\n            res[x][y] = i;\n            if (x + dx[d] < 0 || x + dx[d] >= n || y + dy[d] < 0 || y + dy[d] >= n || res[x + dx[d]][y + dy[d]] != -1) {\n                d = (d + 1) % 4;\n            }\n            \n            x += dx[d];\n            y += dy[d];\n        }\n        \n        return res;\n    }\n}\n\n\n// version 2\npublic class Solution {\n    public ArrayList<Integer> spiralOrder(int[][] matrix) {\n        ArrayList<Integer> rst = new ArrayList<Integer>();\n        if(matrix == null || matrix.length == 0) \n            return rst;\n        \n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int count = 0;\n        while(count * 2 < rows && count * 2 < cols){\n            for(int i = count; i < cols-count; i++)\n                rst.add(matrix[count][i]);\n            \n            \n            for(int i = count+1; i< rows-count; i++)\n                rst.add(matrix[i][cols-count-1]);\n            \n            if(rows - 2 * count == 1 || cols - 2 * count == 1)  // if only one row /col remains\n                break;\n                \n            for(int i = cols-count-2; i>=count; i--)\n                rst.add(matrix[rows-count-1][i]);\n                \n            for(int i = rows-count-2; i>= count+1; i--)\n                rst.add(matrix[i][count]);\n            \n            count++;\n        }\n        return rst;\n    }\n}\n\n// version 3: easier to understand but more code\nclass Direction {\n    public static int DOWN = 0;\n    public static int RIGHT = 1;\n    public static int LEFT = 2;\n    public static int UP = 3;\n    \n    private static int[] dx = new int[]{1, 0, 0, -1};\n    private static int[] dy = new int[]{0, 1, -1, 0};\n\n    public static int turnRight(int direction) {\n        if (direction == DOWN) {\n            return LEFT;\n        } else if (direction == RIGHT) {\n            return DOWN;\n        } else if (direction == LEFT) {\n            return UP;\n        } else if (direction == UP) {\n            return RIGHT;\n        }\n        return -1;\n    }\n    \n    public static int[] move(int[] cursor, int direction) {\n        int[] nextCursor = new int[2];\n        nextCursor[0] = cursor[0] + dx[direction];\n        nextCursor[1] = cursor[1] + dy[direction];\n        return nextCursor;\n    }\n}\n\npublic class Solution {\n    /**\n     * @param matrix a matrix of m x n elements\n     * @return an integer list\n     */\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> order = new ArrayList<Integer>();\n        \n        // check corner case\n        if (matrix == null || matrix.length == 0) {\n            return order;\n        }\n        int n = matrix.length;\n        \n        if (matrix[0] == null || matrix[0].length == 0) {\n            return order;\n        }\n        int m = matrix[0].length;\n        \n        int direction = Direction.RIGHT;\n        int[] cursor = new int[]{0, 0};\n        \n        for (int i = 0; i < n * m; i++) {\n            order.add(matrix[cursor[0]][cursor[1]]);\n            // mark the visited position as -1\n            matrix[cursor[0]][cursor[1]] = -1;\n            int[] nextCursor = Direction.move(cursor, direction);\n            // if outside of matrix or marked before, turn right\n            if (nextCursor[0] < 0 || nextCursor[0] >= n ||\n                  nextCursor[1] < 0 || nextCursor[1] >= m ||\n                  matrix[nextCursor[0]][nextCursor[1]] == -1) {\n                direction = Direction.turnRight(direction);\n                nextCursor = Direction.move(cursor, direction);\n            }\n            cursor = nextCursor;\n        }\n        \n        return order;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param matrix a matrix of m x n elements\r\n     * @return an integer array\r\n     */\r\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\r\n        // Write your code here\r\n        step[0][0] = 0;\r\n        step[0][1] = 1;\r\n        step[1][0] = 1;\r\n        step[1][1] = 0;\r\n        step[2][0] = 0;\r\n        step[2][1] = -1;\r\n        step[3][0] = -1;\r\n        step[3][1] = 0;\r\n        ret.clear();\r\n        memset(canUse, true, sizeof(canUse));\r\n        dfs(matrix, 0, 0, -1);\r\n        \r\n        return ret;\r\n    }\r\nprivate:\r\n    int step[4][2];\r\n    vector<int> ret;\r\n    bool canUse[100][100];\r\npublic:\r\n    void dfs(vector<vector<int> > &matrix, int direct, int x, int y)\r\n    {\r\n        for(int i = 0; i < 4; i++)\r\n        {\r\n            int j = (direct + i) % 4;\r\n            int tx = x + step[j][0];\r\n            int ty = y + step[j][1];\r\n            if (0 <= tx && tx < matrix.size() && 0 <= ty && ty < matrix[0].size() && canUse[tx][ty])\r\n            {\r\n                canUse[tx][ty] = false;\r\n                ret.push_back(matrix[tx][ty]);                \r\n                dfs(matrix, j, tx, ty);               \r\n            }            \r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[][]} matrix a matrix of m x n elements\r\n    # @return {int[]} an integer array\r\n    def spiralOrder(self, matrix):\r\n        # Write your code here\r\n        if matrix == []: return []\r\n        up = 0; left = 0\r\n        down = len(matrix)-1\r\n        right = len(matrix[0])-1\r\n        direct = 0  # 0: go right   1: go down  2: go left  3: go up\r\n        res = []\r\n        while True:\r\n            if direct == 0:\r\n                for i in range(left, right+1):\r\n                    res.append(matrix[up][i])\r\n                up += 1\r\n            if direct == 1:\r\n                for i in range(up, down+1):\r\n                    res.append(matrix[i][right])\r\n                right -= 1\r\n            if direct == 2:\r\n                for i in range(right, left-1, -1):\r\n                    res.append(matrix[down][i])\r\n                down -= 1\r\n            if direct == 3:\r\n                for i in range(down, up-1, -1):\r\n                    res.append(matrix[i][left])\r\n                left += 1\r\n            if up > down or left > right: return res\r\n            direct = (direct+1) % 4"}]},{"id":89,"unique_name":"trapping-rain-water","title":"接雨水","description":"","solutions":[{"language":"java","code":"//Version 0: Two pointer\r\npublic class Solution {\r\n    /**\r\n     * @param heights: an array of integers\r\n     * @return: a integer\r\n     */\r\n    public int trapRainWater(int[] heights) {\r\n        // write your code here\r\n        int left = 0, right = heights.length - 1; \r\n        int res = 0;\r\n        if(left >= right)\r\n            return res;\r\n        int leftheight = heights[left];\r\n        int rightheight = heights[right];\r\n        while(left < right) {\r\n            if(leftheight < rightheight) {\r\n                left ++;\r\n                if(leftheight > heights[left]) {\r\n                    res += (leftheight - heights[left]);\r\n                } else {\r\n                    leftheight = heights[left];\r\n                }\r\n            } else {\r\n                right --;\r\n                if(rightheight > heights[right]) {\r\n                    res += (rightheight - heights[right]);\r\n                } else {\r\n                    rightheight = heights[right];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}      \r\n\r\n// Version 1\r\npublic class Solution {\r\n    /**\r\n     * @param heights: an array of integers\r\n     * @return: a integer\r\n     */\r\n    public int trapRainWater(int[] heights) {\r\n        if (heights.length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int[] maxHeights = new int[heights.length + 1];\r\n        maxHeights[0] = 0;\r\n        for (int i = 0; i < heights.length; i++) {\r\n            maxHeights[i + 1] = Math.max(maxHeights[i], heights[i]);\r\n        }\r\n        \r\n        int max = 0, area = 0;\r\n        for (int i = heights.length - 1; i >= 0; i--) {\r\n            area += Math.min(max, maxHeights[i]) > heights[i]\r\n                    ? Math.min(max, maxHeights[i]) - heights[i]\r\n                    : 0;\r\n            max = Math.max(max, heights[i]);\r\n        }\r\n        \r\n        return area;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int trapRainWater(vector<int>& heights) {\r\n        int maxHeight = 0, maxIndex;\r\n        for (int i = 0; i < heights.size(); i++) {\r\n            if (heights[i] > maxHeight) {\r\n                maxHeight = heights[i];\r\n                maxIndex = i;\r\n            }\r\n        }\r\n        \r\n        int sum = 0;\r\n        maxHeight = 0;\r\n        for (int i = 0; i < maxIndex; i++) {\r\n            if (maxHeight > heights[i]) {\r\n                sum += maxHeight - heights[i];\r\n            }\r\n            maxHeight = max(maxHeight, heights[i]);\r\n        }\r\n        \r\n        maxHeight = 0;\r\n        for (int i = heights.size() - 1; i > maxIndex; i--) {\r\n            if (maxHeight > heights[i]) {\r\n                sum += maxHeight - heights[i];\r\n            }\r\n            maxHeight = max(maxHeight, heights[i]);\r\n        }\r\n        \r\n        return sum;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param heights: a list of integers\r\n    # @return: an integer\r\n    def trapRainWater(self, heights):\r\n        # write your code here\r\n        n = len(heights)\r\n        if n==0: return 0\r\n        pos = []\r\n        neg = []\r\n\r\n        p = q = 0\r\n        pos.append(p)\r\n        while (q<n-1):\r\n            q += 1\r\n            if (heights[p]<=heights[q]):\r\n                pos.append(q)\r\n                p = q\r\n        \r\n        p = q = n-1;\r\n        neg.append(p)\r\n        while (q>0):\r\n            q -= 1\r\n            if (heights[q]>heights[p]):\r\n                neg.append(q)\r\n                p = q\r\n        \r\n        ans = 0\r\n        for i in xrange(len(pos)-1):\r\n            for j in xrange(pos[i]+1, pos[i+1]):\r\n                ans += heights[pos[i]]-heights[j]\r\n        for i in xrange(len(neg)-1):\r\n            for j in xrange(neg[i+1]+1, neg[i]):\r\n                ans += heights[neg[i]]-heights[j]\r\n        return ans\r\n        \r\n"}]},{"id":90,"unique_name":"first-missing-positive","title":"丢失的第一个正整数","description":"给出一个无序的整数数组，找出其中没有出现的最小正整数。","solutions":[{"language":"java","code":"public class Solution {\r\n\r\n    public int firstMissingPositive(int[] A) {\r\n        if (A == null) {\r\n            return 1;\r\n        }\r\n\r\n        for (int i = 0; i < A.length; i++) {\r\n            while (A[i] > 0 && A[i] <= A.length && A[i] != (i+1)) {\r\n                int tmp = A[A[i]-1];\r\n                if (tmp == A[i]) {\r\n                    break;\r\n                }\r\n                A[A[i]-1] = A[i];\r\n                A[i] = tmp;\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < A.length; i ++) {\r\n                if (A[i] != i + 1) {\r\n                    return i + 1;\r\n                }\r\n        }\r\n\r\n        return A.length + 1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int firstMissingPositive(vector<int>& nums) {\r\n        int n = nums.size();\r\n        for (int i = 0; i < n; i++) {\r\n            while (nums[i] != i + 1 && nums[i] >= 1 && nums[i] <= n) {\r\n                if (nums[nums[i] - 1] == nums[i]) {\r\n                    break;\r\n                }\r\n                int temp = nums[i];\r\n                nums[i] = nums[temp - 1];\r\n                nums[temp - 1] = temp;\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (nums[i] != i + 1) {\r\n                return i + 1;\r\n            }\r\n        }\r\n        return n + 1;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\n    # @param A, a list of integers\n    # @return an integer\n    def firstMissingPositive(self, A):\n        # write your code here\n        n = len(A)\n        i = 0\n        if n == 0: \n            return 1\n        while i < n:\n            while A[i] != i + 1 and A[i] <= n and A[i] > 0 and A[i] != A[A[i] - 1]: \n                t = A[i]\n                A[i] = A[A[i] - 1] \n                A[t - 1] = t\n            i = i + 1\n        for i in xrange(n):\n            if A[i] != i + 1: return i + 1\n        return n + 1"}]},{"id":103,"unique_name":"remove-element","title":"删除元素","description":"<p>给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。</p><p>元素的顺序可以改变，并且对新的数组不会有影响。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int removeElement(int[] A, int elem) {\r\n        int i = 0;\r\n        int pointer = A.length - 1;\r\n        while(i <= pointer){\r\n            if(A[i] == elem){\r\n                A[i] = A[pointer];\r\n                pointer--;\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        return pointer + 1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /** \n     *@param A: A list of integers\n     *@param elem: An integer\n     *@return: The new length after remove\n     */\n    int removeElement(vector<int> &A, int elem) {\n        // write your code here\n        int start = 0;\n        int n = A.size();\n        for(int i = 0; i < n; i++)\n            if (elem != A[i]) {\n                A[start++] = A[i];\n            }\n        return start;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param A: A list of integers\n    @param elem: An integer\n    @return: The new length after remove\n    \"\"\"\n    def removeElement(self, A, elem):\n        # write your code here\n        j = len(A)-1\n        for i in range(len(A) - 1, -1, -1):\n            if A[i] == elem:\n                A[i], A[j] = A[j], A[i]\n                j -= 1\n        return j+1\n"}]},{"id":91,"unique_name":"combination-sum-ii","title":"数字组合 II","description":"<p>给出一组候选数字(C)和目标数字(T),找出C中所有的组合，使组合中数字的和为T。C中每个数字在每个组合中只能使用一次。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param num: Given the candidate numbers\r\n     * @param target: Given the target number\r\n     * @return: All the combinations that sum to target\r\n     */\r\n    public List<List<Integer>> combinationSum2(int[] candidates,\r\n            int target) {\r\n        List<List<Integer>> results = new ArrayList<>();\r\n        if (candidates == null || candidates.length == 0) {\r\n            return results;\r\n        }\r\n\r\n        Arrays.sort(candidates);\r\n        List<Integer> combination = new ArrayList<Integer>();\r\n        helper(candidates, 0, combination, target, results);\r\n\r\n        return results;\r\n    }\r\n\r\n    private void helper(int[] candidates,\r\n                        int startIndex,\r\n                        List<Integer> combination,\r\n                        int target,\r\n                        List<List<Integer>> results) {\r\n        if (target == 0) {\r\n            results.add(new ArrayList<Integer>(combination));\r\n            return;\r\n        }\r\n\r\n        for (int i = startIndex; i < candidates.length; i++) {\r\n            if (i != startIndex && candidates[i] == candidates[i - 1]) {\r\n                continue;\r\n            }\r\n            if (target < candidates[i]) {\r\n                break;\r\n            }\r\n            combination.add(candidates[i]);\r\n            helper(candidates, i + 1, combination, target - candidates[i], results);\r\n            combination.remove(combination.size() - 1);\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n\t/**\r\n\t * @param num: Given the candidate numbers\r\n\t * @param target: Given the target number\r\n\t * @return: All the combinations that sum to target\r\n\t */\r\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\r\n\t\t// write your code here\r\n        sort(num.begin(), num.end());\r\n        vector<int> stack, rec; int sum=0, cur=0;\r\n        vector<vector<int> > ans;\r\n        while (cur<num.size() && num[cur]+sum<=target) {\r\n\t\t\tstack.push_back(num[cur]);\r\n\t\t\trec.push_back(cur);\r\n\t\t\tsum+=num[cur++];\r\n\t\t}\r\n\t\tif (sum==target) ans.push_back(stack);\r\n\t\twhile (rec.size()!=0) {\r\n\t\t\tcur=rec.back(); int x=num[cur];\r\n\t\t\tsum-=x; stack.pop_back(); rec.pop_back();\r\n\t\t\tfor (++cur; cur<num.size(); ++cur)\r\n\t\t\t\tif (num[cur]!=x || sum+num[cur]>target) break;\r\n\t\t\tif (cur<num.size() && num[cur]!=x)\r\n\t\t\t\twhile (cur<num.size() && num[cur]+sum<=target) {\r\n\t\t\t\t\tstack.push_back(num[cur]);\r\n\t\t\t\t\trec.push_back(cur);\r\n\t\t\t\t\tsum+=num[cur++];\r\n\t\t\t\t}\r\n\t\t\tif (sum==target) ans.push_back(stack);\r\n\t\t}\r\n\t\treturn ans;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:    \r\n    \"\"\"\r\n    @param candidates: Given the candidate numbers\r\n    @param target: Given the target number\r\n    @return: All the combinations that sum to target\r\n    \"\"\"\r\n    def combinationSum2(self, candidates, target): \r\n        # write your code here\r\n        candidates.sort()        \r\n        self.ans, tmp, use = [], [], [0] * len(candidates)        \r\n        self.dfs(candidates, target, 0, 0, tmp, use)        \r\n        return self.ans    \r\n    def dfs(self, can, target, p, now, tmp, use):        \r\n        if now == target:            \r\n            self.ans.append(tmp[:])            \r\n            return        \r\n        for i in range(p, len(can)):            \r\n            if now + can[i] <= target and (i == 0 or can[i] != can[i-1] or use[i-1] == 1):                \r\n                tmp.append(can[i])\r\n                use[i] = 1                \r\n                self.dfs(can, target, i+1, now + can[i], tmp, use)                \r\n                tmp.pop()                \r\n                use[i] = 0\r\n"}]},{"id":33,"unique_name":"combinations","title":"组合","description":"<p>组给出两个整数n和k，返回从<b><font color=\"#e76363\">1......n</font></b>中选出的k个数的组合。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public List<List<Integer>> combine(int n, int k) {\r\n        List<List<Integer>> rst = new ArrayList<List<Integer>>();\r\n        List<Integer> solution = new ArrayList<Integer>();\r\n        \r\n        helper(rst, solution, n, k, 1);\r\n        return rst;\r\n    }\r\n    \r\n    private void helper(List<List<Integer>> rst, List<Integer> solution, \r\n        int n, int k, int start) {\r\n        if (solution.size() == k){\r\n            rst.add(new ArrayList(solution));\r\n            return;\r\n        }\r\n        \r\n        for(int i = start; i<= n; i++){\r\n            solution.add(i);\r\n            \r\n            // the new start should be after the next number after i\r\n            helper(rst, solution, n, k, i + 1); \r\n            solution.remove(solution.size() - 1);\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n: Given the range of numbers\r\n     * @param k: Given the numbers of combinations\r\n     * @return: All the combinations of k numbers out of 1..n\r\n     */\r\n    vector<vector<int> > combine(int n, int k) {\r\n        // write your code here\r\n        vector<vector<int> > ans;vector<int> stack;\r\n        for (int i=1; i<=k; ++i) stack.push_back(i);\r\n        ans.push_back(stack);\r\n        while (1){\r\n            while (stack.size()>0 && stack.back()==n+stack.size()-k) stack.pop_back();\r\n            if (stack.size()==0) break;\r\n            ++stack[stack.size()-1];\r\n            while (stack.size()<k) stack.push_back(stack[stack.size()-1]+1);\r\n            ans.push_back(stack);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"    \r\n    @param n: Given the range of numbers\r\n    @param k: Given the numbers of combinations\r\n    @return: All the combinations of k numbers out of 1..n   \r\n    \"\"\"\r\n    def combine(self, n, k):      \r\n        # write your code here  \r\n        self.res = []\r\n        tmp = []\r\n        self.dfs(n, k, 1, 0, tmp)       \r\n        return self.res\r\n\r\n    def dfs(self, n, k, m, p, tmp):\r\n        if k == p:\r\n            self.res.append(tmp[:])\r\n            return\r\n        for i in range(m, n+1):            \r\n            tmp.append(i)            \r\n            self.dfs(n, k, i+1, p+1, tmp)            \r\n            tmp.pop()\r\n"}]},{"id":34,"unique_name":"best-time-to-buy-and-sell-stock-iii","title":"买卖股票的最佳时机 III","description":"<p>假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。<span style=\"line-height: 1.42857143;\">设计一个算法来找到最大的利润。你最多可以完成两笔交易。</span></p>","solutions":[{"language":"java","code":"// 动态规划专题班版本 verison 1\r\nclass Solution {\r\n    /**\r\n     * @param prices: Given an integer array\r\n     * @return: Maximum profit\r\n     */\r\n    \r\n    private int update(int a, int b, int delta) {\r\n        if (b == Integer.MIN_VALUE) {\r\n            return a;\r\n        }\r\n        \r\n        if (b + delta > a) {\r\n            return b + delta;\r\n        }\r\n        \r\n        return a;\r\n    } \r\n     \r\n    public int maxProfit(int[] prices) {\r\n        int K = 2;\r\n        int n = prices.length;\r\n        int i, j, k;\r\n        \r\n        int[][] f = new int[n+1][2*K+1+1];\r\n        for (i = 0; i <= n; ++i) {\r\n            for (j = 1; j <= 2*K+1; ++j) {\r\n                f[i][j] = Integer.MIN_VALUE;\r\n            }\r\n        }\r\n        \r\n        f[0][1] = 0;\r\n        for (i = 1; i <= n; ++i) {\r\n            for (j = 1; j <= 2 * K + 1; j += 2) {\r\n                f[i][j] = update(f[i][j], f[i-1][j], 0);\r\n                if (j > 1 && i > 1) f[i][j] = update(f[i][j], f[i - 1][j - 1], prices[i - 1] - prices[i - 2]);\r\n            }\r\n            \r\n            for (j = 2; j <= 2 * K; j += 2) {\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j], prices[i - 1] - prices[i - 2]);\r\n                if (j > 1) f[i][j] = update(f[i][j], f[i-1][j-1], 0);\r\n            }\r\n        }\r\n        \r\n        int res = Integer.MIN_VALUE;\r\n        for (j = 1; j <= 2 * K + 1; j += 2) {\r\n            res = update(res, f[n][j], 0);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n// version 2\r\npublic class Solution {\r\n    public int maxProfit(int[] prices) {\r\n        if (prices == null || prices.length <= 1) {\r\n            return 0;\r\n        }\r\n\r\n        int[] left = new int[prices.length];\r\n        int[] right = new int[prices.length];\r\n\r\n        // DP from left to right;\r\n        left[0] = 0;\r\n        int min = prices[0];\r\n        for (int i = 1; i < prices.length; i++) {\r\n            min = Math.min(prices[i], min);\r\n            left[i] = Math.max(left[i - 1], prices[i] - min);\r\n        }\r\n\r\n        //DP from right to left;\r\n        right[prices.length - 1] = 0;\r\n        int max = prices[prices.length - 1];\r\n        for (int i = prices.length - 2; i >= 0; i--) {\r\n            max = Math.max(prices[i], max);\r\n            right[i] = Math.max(right[i + 1], max - prices[i]);\r\n        }\r\n\r\n        int profit = 0;\r\n        for (int i = 0; i < prices.length; i++){\r\n            profit = Math.max(left[i] + right[i], profit);  \r\n        }\r\n\r\n        return profit;\r\n    }\r\n}\r\n\r\n// 方法二\r\nclass Solution {\r\n    /**\r\n     * @param k: An integer\r\n     * @param prices: Given an integer array\r\n     * @return: Maximum profit\r\n     */\r\n    private int update(int a, int b, int delta) {\r\n        if (b == Integer.MIN_VALUE) {\r\n            return a;\r\n        }\r\n        \r\n        if (b + delta > a) {\r\n            return b + delta;\r\n        }\r\n        \r\n        return a;\r\n    }  \r\n     \r\n    public int maxProfit(int K, int[] prices) {\r\n        int n = prices.length;\r\n        int i, j, k;\r\n        if (K == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        if (K >= n - 1) {\r\n            j = 0;\r\n            for (i = 1; i < n; ++i) {\r\n                if (prices[i] > prices[i - 1]) {\r\n                    j += prices[i] - prices[i - 1];\r\n                }\r\n            }\r\n            \r\n            return j;\r\n        }\r\n        \r\n        int[][] f = new int[n+1][2*K+1];\r\n        for (i = 0; i <= n; ++i) {\r\n            for (j = 0; j <= 2*K; ++j) {\r\n                f[i][j] = Integer.MIN_VALUE;\r\n            }\r\n        }\r\n        \r\n        f[0][0] = 0;\r\n        for (i = 1; i <= n; ++i) {\r\n            int delta;\r\n            if (i == 1) {\r\n                delta = 0;\r\n            }\r\n            else {\r\n                delta = prices[i-1] - prices[i - 2];\r\n            }\r\n            \r\n            f[i][0] = update(f[i][0], f[i-1][0], 0);\r\n            for (j = 1; j <= 2 * K; j += 2) {\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j], delta);\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j-1], delta);\r\n            }\r\n            \r\n            for (j = 2; j <= 2 * K; j += 2) {\r\n                f[i][j] = update(f[i][j], f[i-1][j], 0);\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j-1], delta);\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j-2], delta);\r\n            }\r\n        }\r\n        \r\n        int res = Integer.MIN_VALUE;\r\n        for (j = 2; j <= 2 * K; j += 2) {\r\n            res = update(res, f[n][j], 0);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param prices: Given an integer array\r\n     * @return: Maximum profit\r\n     */\r\n    int maxProfit(vector<int> &prices) {\r\n        if (prices.size() == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        vector<int> profit(prices.size());\r\n        int buy = 0;\r\n        buy = prices[0];\r\n        profit[0] = 0;\r\n        for (int i = 1; i < prices.size(); i++) {\r\n            profit[i] = max(profit[i - 1], prices[i] - buy);\r\n            buy = min(buy, prices[i]);\r\n        }\r\n        \r\n        int sell = prices[prices.size() - 1];\r\n        int best = 0;\r\n        for (int i = prices.size() - 2; i >= 0; i--) {\r\n            best = max(best, sell - prices[i] + profit[i]);\r\n            sell = max(sell, prices[i]);\r\n        }\r\n        \r\n        return best;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param prices: Given an integer array\r\n    @return: Maximum profit\r\n    \"\"\"\r\n    def maxProfit(self, prices):\r\n        # write your code here\r\n        n = len(prices)\r\n        if n <= 1:\r\n            return 0\r\n        p1 = [0] * n\r\n        p2 = [0] * n\r\n        \r\n        minV = prices[0]\r\n        for i in range(1,n):\r\n            minV = min(minV, prices[i]) \r\n            p1[i] = max(p1[i - 1], prices[i] - minV)\r\n        \r\n        maxV = prices[-1]\r\n        for i in range(n-2, -1, -1):\r\n            maxV = max(maxV, prices[i])\r\n            p2[i] = max(p2[i + 1], maxV - prices[i])\r\n        \r\n        res = 0\r\n        for i in range(n):\r\n            res = max(res, p1[i] + p2[i])\r\n        return res\r\n"},{"language":"javascript","code":"/**\n * @param prices: Given an integer array\n * @return: Maximum profit\n */\nconst maxProfit = function (prices) {\n    update = function(a, b, delta) {\n        if (b == -Number.MAX_VALUE) {\n            return a;\n        }\n        if (b + delta > a) {\n            return b + delta;\n        }\n        return a;\n    } \n    var K = 2;\n    var n = prices.length;\n    var i, j, k;\n    var f;\n    var res;\n    f = new Array(n + 1);\n    for (i = 0; i < n + 1; i++) {\n        f[i] = new Array(2 * K + 1 + 1);\n    }\n    for (i = 0; i <= n; ++i) {\n        for (j = 1; j <= 2*K+1; ++j) {\n            f[i][j] = -Number.MAX_VALUE;\n        }\n    }\n    f[0][1] = 0;\n    for (i = 1; i <= n; ++i) {\n        for (j = 1; j <= 2 * K + 1; j += 2) {\n            f[i][j] = update(f[i][j], f[i-1][j], 0);\n            if (j > 1 && i > 1) f[i][j] = update(f[i][j], f[i - 1][j - 1], prices[i - 1] - prices[i - 2]);\n        }\n        for (j = 2; j <= 2 * K; j += 2) {\n            if (i > 1) f[i][j] = update(f[i][j], f[i-1][j], prices[i - 1] - prices[i - 2]);\n            if (j > 1) f[i][j] = update(f[i][j], f[i-1][j-1], 0);\n        }\n    }\n    res = -Number.MAX_VALUE;\n    for (j = 1; j <= 2 * K + 1; j += 2) {\n        res = update(res, f[n][j], 0);\n    }\n    return res;\n}"}]},{"id":35,"unique_name":"best-time-to-buy-and-sell-stock-ii","title":"买卖股票的最佳时机 II","description":"<p>假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。<span style=\"line-height: 1.42857143;\">设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。</span></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int maxProfit(int[] prices) {\r\n        int profit = 0;\r\n        for (int i = 0; i < prices.length - 1; i++) {\r\n            int diff = prices[i+1] - prices[i];\r\n            if (diff > 0) {\r\n                profit += diff;\r\n            }\r\n        }\r\n        return profit;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param prices: Given an integer array\n     * @return: Maximum profit\n     */\n    int maxProfit(vector<int> &prices) {\n        // write your code here\n        int total=0;\n        if(!prices.empty())\n        {\n            for(int i=0; i<prices.size()-1; i++)\n            {\n                if(prices[i+1]>prices[i])total+=prices[i+1]-prices[i];\n            }\n        }\n        return total;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param prices: Given an integer array\n    @return: Maximum profit\n    \"\"\"\n    def maxProfit(self, prices):\n        # write your code here\n        total = 0\n        low, high = sys.maxint, sys.maxint\n        for x in prices:\n            if x > high:\n                high = x\n            else:\n                total += high - low\n                high, low = x, x\n        return total + high - low\n"},{"language":"javascript","code":"/**\n * @param prices: Given an integer array\n * @return: Maximum profit\n */\nconst maxProfit = function (prices) {\n    var profit = 0, diff;\n    var i;\n    for (i = 0; i < prices.length - 1; i++) {\n        diff = prices[i+1] - prices[i];\n        if (diff > 0) {\n            profit += diff;\n        }\n    }\n    return profit;\n}"}]},{"id":130,"unique_name":"largest-rectangle-in-histogram","title":"直方图最大矩形覆盖","description":"","solutions":[{"language":"java","code":"public class Solution {\r\n    public int largestRectangleArea(int[] height) {\r\n        if (height == null || height.length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        Stack<Integer> stack = new Stack<Integer>();\r\n        int max = 0;\r\n        for (int i = 0; i <= height.length; i++) {\r\n            int curt = (i == height.length) ? -1 : height[i];\r\n            while (!stack.isEmpty() && curt <= height[stack.peek()]) {\r\n                int h = height[stack.pop()];\r\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\r\n                max = Math.max(max, h * w);\r\n            }\r\n            stack.push(i);\r\n        }\r\n        \r\n        return max;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param height: A list of integer\n     * @return: The area of largest rectangle in the histogram\n     */\n    int largestRectangleArea(vector<int> &height) {\n        // write your code here\n        if(height.size() == 0) return 0;\n        int res = 0;\n        vector<int> tmp = height;\n        tmp.push_back(0);  // Important\n \n        stack<int> s;\n        for(int i = 0; i < tmp.size(); i++)\n        {\n            if(s.empty() || (!s.empty() && tmp[i] >= tmp[s.top()])) s.push(i);\n            else{\n                while(!s.empty() && tmp[s.top()] > tmp[i])\n                {\n                    int idx = s.top(); s.pop();\n                    int width = s.empty() ? i : (i-s.top()-1);\n                    res = max(res, tmp[idx] * width);\n                }\n                s.push(i);  // Important\n            }\n        }\n        return res;\n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param height: A list of integer\n    @return: The area of largest rectangle in the histogram\n    \"\"\"\n    def largestRectangleArea(self, height):\n        # write your code here\n        stack=[]; i=0; area=0\n        while i<len(height):\n            if stack==[] or height[i]>height[stack[len(stack)-1]]:\n                stack.append(i)\n            else:\n                curr=stack.pop()\n                width=i if stack==[] else i-stack[len(stack)-1]-1\n                area=max(area,width*height[curr])\n                i-=1\n            i+=1\n        while stack!=[]:\n            curr=stack.pop()\n            width=i if stack==[] else len(height)-stack[len(stack)-1]-1\n            area=max(area,width*height[curr])\n        return area\n"},{"language":"javascript","code":"/**\n * @param height: A list of integer\n * @return: The area of largest rectangle in the histogram\n */\nconst largestRectangleArea = function (height) {\n    if (height === null || height.length === 0) {\n        return 0;\n    }\n    var stack = [];\n    var max = 0, curt;\n    var i;\n    var h, w;\n    for (i = 0; i <= height.length; i++) {\n        curt = (i == height.length) ? -1 : height[i];\n        while (stack.length !== 0 && curt <= height[stack[stack.length - 1]]) {\n            h = height[stack.pop()];\n            w = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max = Math.max(max, h * w);\n        }\n        stack.push(i);\n    }\n    return max;\n}"}]},{"id":86,"unique_name":"jump-game-ii","title":"跳跃游戏 II","description":"<p>给出一个非负整数数组，你最初定位在数组的第一个位置。<br></p><p><span style=\"line-height: 1.42857143;\">数组中的每个元素代表你在那个位置可以跳跃的最大长度。</span>　　　</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>","solutions":[{"language":"java","code":"// version 1: Dynamic Programming\r\n// 这个方法，复杂度是 O(n^2)，会超时，但是依然需要掌握。\r\npublic class Solution {\r\n    public int jump(int[] A) {\r\n        // state\r\n        int[] steps = new int[A.length];\r\n\r\n        // initialize\r\n        steps[0] = 0;\r\n        for (int i = 1; i < A.length; i++) {\r\n            steps[i] = Integer.MAX_VALUE;\r\n        }\r\n\r\n        // function\r\n        for (int i = 1; i < A.length; i++) {\r\n            for (int j = 0; j < i; j++) {\r\n                if (steps[j] != Integer.MAX_VALUE && j + A[j] >= i) {\r\n                    steps[i] = Math.min(steps[i], steps[j] + 1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // answer\r\n        return steps[A.length - 1];\r\n    }\r\n}\r\n\r\n\r\n// version 2: Greedy\r\npublic class Solution {\r\n    public int jump(int[] A) {\r\n        if (A == null || A.length == 0) {\r\n            return -1;\r\n        }\r\n        int start = 0, end = 0, jumps = 0;\r\n        while (end < A.length - 1) {\r\n            jumps++;\r\n            int farthest = end;\r\n            for (int i = start; i <= end; i++) {\r\n                if (A[i] + i > farthest) {\r\n                    farthest = A[i] + i;\r\n                }\r\n            }\r\n            start = end + 1;\r\n            end = farthest;\r\n        }\r\n        return jumps;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int jump(vector<int> A) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        int n = A.size();\r\n        int minstep = 0;\r\n        int ldist = 0;\r\n        int hdist = 0;\r\n        if (n == 1) return 0;\r\n        while(ldist <= hdist) {\r\n            ++minstep;\r\n            int lasthdist = hdist;\r\n            for(int i = ldist; i <= lasthdist; ++i) {\r\n                int possibledist = i + A[i];\r\n                if (possibledist >= n-1)\r\n                    return minstep;\r\n                if (possibledist > hdist) {\r\n                    hdist = possibledist;\r\n                }\r\n            }\r\n            ldist = lasthdist + 1;\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param A, a list of integers\r\n    # @return an integer\r\n    def jump(self, A):\r\n        p = [0]\r\n        for i in range(len(A) - 1):\r\n            while(i + A[i] >= len(p) and len(p) < len(A)):\r\n                p.append(p[i] + 1)\r\n        return p[-1]\r\n"},{"language":"javascript","code":"/**\n * @param A: A list of integers\n * @return: An integer\n */\nconst jump = function (A) {\n    if (A === null || A.length === 0) {\n        return -1;\n    }\n    var start = 0, end = 0, jumps = 0;\n    var farthest;\n    var i;\n    while (end < A.length - 1) {\n        jumps++;\n        farthest = end;\n        for (i = start; i <= end; i++) {\n            if (A[i] + i > farthest) {\n                farthest = A[i] + i;\n            }\n        }\n        start = end + 1;\n        end = farthest;\n    }\n    return jumps;\n}"}]},{"id":70,"unique_name":"unique-paths-ii","title":"不同的路径 II","description":"\"[不同的路径](http://www.lintcode.com/problem/unique-paths/ \"不同的路径\")\" 的跟进问题：\r\n\r\n现在考虑网格中有障碍物，那样将会有多少条不同的路径？\r\n\r\n网格中的障碍和空位置分别用 1 和 0 来表示。","solutions":[{"language":"java","code":"public class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {\n            return 0;\n        }\n        \n        int n = obstacleGrid.length;\n        int m = obstacleGrid[0].length;\n        int[][] paths = new int[n][m];\n        \n        for (int i = 0; i < n; i++) {\n            if (obstacleGrid[i][0] != 1) {\n                paths[i][0] = 1;\n            } else {\n                break;\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            if (obstacleGrid[0][i] != 1) {\n                paths[0][i] = 1; \n            } else {\n                break;\n            }\n        }\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                if (obstacleGrid[i][j] != 1) {\n                    paths[i][j] = paths[i - 1][j] + paths[i][j - 1];\n                } else {\n                    paths[i][j] = 0;\n                }\n            }\n        }\n        \n        return paths[n - 1][m - 1];\n    }\n}\n\n// 方法二\npublic class Solution {\n    /**\n     * @param obstacleGrid: A list of lists of integers\n     * @return: An integer\n     */\n    public int uniquePathsWithObstacles(int[][] A) {\n        int m = A.length;\n        if (m == 0) {\n            return 0;\n        }\n        int n = A[0].length;\n        if (n == 0) {\n            return 0;\n        }\n        \n        if (A[0][0] == 1 || A[m-1][n-1] == 1) {\n            return 0;\n        }\n        \n        int[][] f = new int[2][n];\n        int i, j, old, now;\n        now = 0;\n\n        for (i = 0; i < m; ++i) {\n            old = now;\n            now = 1 - now;\n            for (j = 0; j < n; ++j) {\n                f[now][j] = 0;\n                if (A[i][j] == 1) {\n                    f[now][j] = 0;\n                }\n                else {\n                    if (i == 0 && j == 0) {\n                        f[now][j] = 1;\n                    }\n                    if (i > 0) {\n                        f[now][j] += f[old][j];\n                    }\n                    if (j > 0) {\n                        f[now][j] += f[now][j-1];\n                    }\n                }\n            }\n        }\n        \n        return f[now][n-1];\n    }\n}\n\n\n// 记忆化搜索\n// 九章硅谷求职算法集训营版本\npublic class Solution {\n    /**\n     * @param obstacleGrid: A list of lists of integers\n     * @return: An integer\n     */\n     \n    int[][] f;\n    int[][] A;\n    int m;\n    int n;\n    \n    void calc(int i, int j) {\n        if (f[i][j] != -1) {\n            return;\n        }\n        \n        if (A[i][j] == 1) {\n            f[i][j] = 0;\n            return;\n        }\n        \n        if (i == 0 && j == 0) {\n            f[i][j] = 1;\n            return;\n        }\n        \n        f[i][j] = 0;\n        if (i > 0) {\n            calc(i - 1, j);\n            f[i][j] += f[i - 1][j];\n        }\n        \n        if (j > 0) {\n            calc(i, j - 1);\n            f[i][j] += f[i][j - 1];\n        }\n    }\n    \n    public int uniquePathsWithObstacles(int[][] AA) {\n        A = AA;\n        m = A.length;\n        if (m == 0) {\n            return 0;\n        }\n        \n        n = A[0].length;\n        if (n == 0) {\n            return 0;\n        }\n        \n        int i, j;\n        f = new int[m][n];\n        for (i = 0; i < m; ++i) {\n            for (j = 0; j < n; ++j) {\n                f[i][j] = -1;\n            }\n        }\n    \n        calc(m - 1, n - 1);\n        return f[m - 1][n - 1];\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param obstacleGrid: A list of lists of integers\r\n     * @return: An integer\r\n     */ \r\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\r\n        // write your code here\r\n        int m = obstacleGrid.size();\r\n        if(m<=0){\r\n            return 0;\r\n        }\r\n        int n = obstacleGrid[0].size();\r\n        if(n<=0){\r\n            return 0;\r\n        }\r\n        if(obstacleGrid[0][0]==1){\r\n            return 0;\r\n        }\r\n        \r\n        int map[101][101];\r\n        map[0][0]=1;\r\n        for(int i=1;i<m;i++){\r\n            if(obstacleGrid[i][0]==1)\r\n                map[i][0]=0;\r\n            else\r\n                map[i][0]=map[i-1][0];\r\n        } \r\n        for(int i=1;i<n;i++){\r\n             if(obstacleGrid[0][i]==1)\r\n                map[0][i]=0;\r\n            else\r\n                map[0][i]=map[0][i-1];\r\n        } \r\n        for(int i=1;i<m;i++)\r\n            for(int j=1;j<n;j++){\r\n                if(obstacleGrid[i][j]==1){\r\n                    map[i][j]=0;\r\n                }\r\n                else\r\n                    map[i][j]=map[i-1][j]+map[i][j-1];\r\n            }\r\n            \r\n        return map[m-1][n-1];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n\r\n    def uniquePathsWithObstacles(self, obstacleGrid):\r\n        mp = obstacleGrid\r\n        for i in range(len(mp)):\r\n            for j in range(len(mp[i])):\r\n                if i == 0 and j == 0:\r\n                    mp[i][j] = 1 - mp[i][j]\r\n                elif i == 0:\r\n                    if mp[i][j] == 1:\r\n                        mp[i][j] = 0\r\n                    else:\r\n                        mp[i][j] = mp[i][j - 1]\r\n                elif j == 0:\r\n                    if mp[i][j] == 1:\r\n                        mp[i][j] = 0\r\n                    else:\r\n                        mp[i][j] = mp[i - 1][j]\r\n                else:\r\n                    if mp[i][j] == 1:\r\n                        mp[i][j] = 0\r\n                    else:\r\n                        mp[i][j] = mp[i - 1][j] + mp[i][j - 1]\r\n        if mp[-1][-1] > 2147483647: \r\n            return -1\r\n        else:\r\n            return mp[-1][-1]\r\n\r\n"}]},{"id":71,"unique_name":"unique-paths","title":"不同的路径","description":"有一个机器人的位于一个 *m* × *n* 个网格左上角。\r\n\r\n机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。\r\n\r\n问有多少条不同的路径？","solutions":[{"language":"java","code":"public class Solution {\r\n    public int uniquePaths(int m, int n) {\r\n        if (m == 0 || n == 0) {\r\n            return 1;\r\n        }\r\n        \r\n        int[][] sum = new int[m][n];\r\n        for (int i = 0; i < m; i++) {\r\n            sum[i][0] = 1;\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            sum[0][i] = 1;\r\n        }\r\n        for (int i = 1; i < m; i++) {\r\n            for (int j = 1; j < n; j++) {\r\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1];\r\n            }\r\n        }\r\n        return sum[m - 1][n - 1];\r\n    }\r\n}\r\n\r\n// 方法二\r\npublic class Solution {\r\n    /**\r\n     * @param n, m: positive integer (1 <= n ,m <= 100)\r\n     * @return an integer\r\n     */\r\n    public int uniquePaths(int m, int n) {\r\n        int[][] f = new int[m][n];\r\n        int i, j;\r\n        for (i = 0; i < m; ++i) {\r\n            for (j = 0; j < n; ++j) {\r\n                if (i == 0 || j == 0) {\r\n                    f[i][j] = 1;\r\n                }\r\n                else {\r\n                    f[i][j] = f[i-1][j] + f[i][j-1];\r\n                }\r\n            }\r\n        }\r\n        \r\n        return f[m-1][n-1];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n, m: positive integer (1 <= n ,m <= 100)\r\n     * @return an integer\r\n     */\r\n    int uniquePaths(int m, int n) {\r\n        // wirte your code here\r\n        vector<vector<int> > f(m, vector<int>(n));\r\n        \r\n        for(int i = 0; i < n; i++)\r\n            f[0][i] = 1;\r\n            \r\n        for(int i = 0; i < m; i++)\r\n            f[i][0] = 1;\r\n            \r\n        for(int i = 1; i < m; i++)\r\n            for(int j = 1; j < n; j++)\r\n                f[i][j] = f[i-1][j] + f[i][j-1];\r\n                \r\n        return f[m-1][n-1];\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    # @return an integer\r\n    def c(self, m, n):\r\n        mp = {}\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if(i == 0 or j == 0):\r\n                    mp[(i, j)] = 1\r\n                else:\r\n                    mp[(i, j)] = mp[(i - 1, j)] + mp[(i, j - 1)]\r\n        return mp[(m - 1, n - 1)]\r\n\r\n    def uniquePaths(self, m, n):\r\n        return self.c(m, n)"},{"language":"javascript","code":"/**\n * @param m: positive integer (1 <= m <= 100)\n * @param n: positive integer (1 <= n <= 100)\n * @return: An integer\n */\nconst uniquePaths = function (m, n) {\n    var f, i, j;\n    f = new Array(m);\n    for (i = 0; i < m; i++) f[i] = new Array(n);\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            if (i === 0 || j === 0) {\n                f[i][j] = 1;\n            } else {\n                f[i][j] = f[i - 1][j] + f[i][j - 1];\n            }\n        }\n    }\n    return f[m - 1][n - 1];\n}"}]},{"id":133,"unique_name":"search-in-rotated-sorted-array-ii","title":"搜索旋转排序数组 II","description":"<p>跟进“搜索旋转排序数组”，假如有重复元素又将如何？</p><p><i>是否会影响运行时间复杂度？</i></p><p><i>如何影响？</i></p><p><i>为何会影响？</i></p><p>写出一个函数判断给定的目标值是否出现在数组中。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    // 这个问题在面试中不会让实现完整程序\r\n    // 只需要举出能够最坏情况的数据是 [1,1,1,1... 1] 里有一个0即可。\r\n    // 在这种情况下是无法使用二分法的，复杂度是O(n)\r\n    // 因此写个for循环最坏也是O(n)，那就写个for循环就好了\r\n    //  如果你觉得，不是每个情况都是最坏情况，你想用二分法解决不是最坏情况的情况，那你就写一个二分吧。\r\n    //  反正面试考的不是你在这个题上会不会用二分法。这个题的考点是你想不想得到最坏情况。\r\n    public boolean search(int[] A, int target) {\r\n        for (int i = 0; i < A.length; i ++) {\r\n            if (A[i] == target) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\n    /** \r\n     * param A : an integer ratated sorted array and duplicates are allowed\r\n     * param target :  an integer to be search\r\n     * return : a boolean \r\n     */\r\npublic:\r\n    bool search(vector<int> &A, int target) {\r\n        // write your code here\r\n        int ans = -1;\r\n        int len = A.size();\r\n        int cnt = 0;\r\n        for ( int i = 0; i < len; ++i) {\r\n            if (A[i] == target) {\r\n                ans = i;\r\n            }\r\n            if (i != 0)\r\n                if (A[i] < A[i-1])\r\n                    cnt ++;\r\n        }\r\n        if (cnt  > 1)\r\n            ans = -ans;\r\n        return (ans>=0);\r\n    }\r\n};\r\n"},{"language":"python","code":"    \"\"\"\r\n    @param A : an integer ratated sorted array and duplicates are allowed\r\n    @param target : an integer to be searched\r\n    @return : a boolean\r\n    \"\"\"\r\n    def search(self, A, target):\r\n        # write your code here\r\n        for num in A:\r\n            if num == target:\r\n                return True\r\n        return False"}]},{"id":113,"unique_name":"3sum-closest","title":"最接近的三数之和","description":"给一个包含 *n* 个整数的数组 *S*, 找到和与给定整数 *target* 最接近的三元组，返回这三个数的和。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param numbers: Give an array numbers of n integer\r\n     * @param target : An integer\r\n     * @return : return the sum of the three integers, the sum closest target.\r\n     */\r\n    public int threeSumClosest(int[] numbers, int target) {\r\n        if (numbers == null || numbers.length < 3) {\r\n            return -1;\r\n        }\r\n        \r\n        Arrays.sort(numbers);\r\n        int bestSum = numbers[0] + numbers[1] + numbers[2];\r\n        for (int i = 0; i < numbers.length; i++) {\r\n            int start = i + 1, end = numbers.length - 1;\r\n            while (start < end) {\r\n                int sum = numbers[i] + numbers[start] + numbers[end];\r\n                if (Math.abs(target - sum) < Math.abs(target - bestSum)) {\r\n                    bestSum = sum;\r\n                }\r\n                if (sum < target) {\r\n                    start++;\r\n                } else {\r\n                    end--;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return bestSum;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param numbers: Give an array numbers of n integer\r\n     * @param target: An integer\r\n     * @return: return the sum of the three integers, the sum closest target.\r\n     */\r\n    int threeSumClosest(vector<int> nums, int target) {\r\n        sort(nums.begin(), nums.end());\r\n        int result = nums[0] + nums[1] + nums[2];\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            int start = i + 1, end = nums.size() - 1;\r\n            while (start < end) {\r\n                if (abs(result - target) > \r\n                        abs(nums[i] + nums[start] + nums[end] - target)) {\r\n                    result = nums[i] + nums[start] + nums[end];\r\n                }\r\n                if (nums[i] + nums[start] + nums[end] < target) {\r\n                    start++;\r\n                } else {\r\n                    end--;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param numbers: Give an array numbers of n integer\r\n    @param target : An integer\r\n    @return : return the sum of the three integers, the sum closest target.\r\n    \"\"\"\r\n    def threeSumClosest(self, numbers, target):\r\n        numbers.sort()\r\n        ans = None\r\n        for i in range(len(numbers)):\r\n            l, r = i + 1, len(numbers) - 1\r\n            while (l < r):                    \r\n                sum = numbers[l] + numbers[r] + numbers[i]\r\n                if ans is None or abs(sum- target) < abs(ans - target):\r\n                    ans = sum\r\n                if sum <= target:\r\n                    l = l + 1\r\n                else:\r\n                    r = r - 1\r\n        return ans\r\n"},{"language":"javascript","code":"/**\n * @param numbers: Give an array numbers of n integer\n * @param target: An integer\n * @return: return the sum of the three integers, the sum closest target.\n */\nconst threeSumClosest = function (numbers, target) {\n    sortNumber = function(a, b) {\n        return a - b;\n    }\n    var res = numbers[0] + numbers[1] + numbers[2];\n    var i, start, end;\n    numbers.sort(sortNumber);\n    for (i = 0; i < numbers.length; i++) {\n        start = i + 1;\n        end = numbers.length - 1;\n        while (start < end) {\n            if (Math.abs(res - target) >\n                Math.abs(numbers[i] + numbers[start] + numbers[end] - target)) {\n                    res = numbers[i] + numbers[start] + numbers[end];\n                }\n            if (numbers[i] + numbers[start] + numbers[end] < target) {\n                start++;\n            } else {\n                end--;\n            }\n        }\n    }\n    return res;\n}"}]},{"id":112,"unique_name":"4sum","title":"四数之和","description":"<p><span style=\"line-height: 30px;\">给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target的四元组(a, b, c, d)。</span></p>","solutions":[{"language":"java","code":"public class Solution {\r\n\tpublic List<List<Integer>> fourSum(int[] num, int target) {\r\n\t\tList<List<Integer>> rst = new ArrayList<List<Integer>>();\r\n\t\tArrays.sort(num);\r\n\r\n\t\tfor (int i = 0; i < num.length - 3; i++) {\r\n\t\t\tif (i != 0 && num[i] == num[i - 1]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tfor (int j = i + 1; j < num.length - 2; j++) {\r\n\t\t\t\tif (j != i + 1 && num[j] == num[j - 1])\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tint left = j + 1;\r\n\t\t\t\tint right = num.length - 1;\r\n\t\t\t\twhile (left < right) {\r\n\t\t\t\t\tint sum = num[i] + num[j] + num[left] + num[right];\r\n\t\t\t\t\tif (sum < target) {\r\n\t\t\t\t\t\tleft++;\r\n\t\t\t\t\t} else if (sum > target) {\r\n\t\t\t\t\t\tright--;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tArrayList<Integer> tmp = new ArrayList<Integer>();\r\n\t\t\t\t\t\ttmp.add(num[i]);\r\n\t\t\t\t\t\ttmp.add(num[j]);\r\n\t\t\t\t\t\ttmp.add(num[left]);\r\n\t\t\t\t\t\ttmp.add(num[right]);\r\n\t\t\t\t\t\trst.add(tmp);\r\n\t\t\t\t\t\tleft++;\r\n\t\t\t\t\t\tright--;\r\n\t\t\t\t\t\twhile (left < right && num[left] == num[left - 1]) {\r\n\t\t\t\t\t\t\tleft++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile (left < right && num[right] == num[right + 1]) {\r\n\t\t\t\t\t\t\tright--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn rst;\r\n\t}\r\n}\r\n"},{"language":"cpp","code":"\r\n\r\nclass Solution {\r\npublic:\r\n    /*\r\n    题意：找到数列中所有和等于目标数的四元组，需去重\r\n    多枚举一个数后，参照3Sum的做法，O(N^3)\r\n    */\r\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\r\n        int len = nums.size();\r\n        int left, right, sum;\r\n        sort(nums.begin(), nums.end());\r\n        vector<vector<int>> res;\r\n        vector<int> tmp;\r\n        for (int i = 0; i < len - 3; i++) {\r\n            if (i && nums[i] == nums[i - 1]) continue;\r\n            for (int j = i + 1; j < len - 2; j++) {\r\n                if (j != i + 1 && nums[j] == nums[j - 1]) continue;\r\n                sum = target - nums[i] - nums[j];\r\n                left = j + 1;\r\n                right = len - 1;\r\n                while (left < right) {\r\n                    if (nums[left] + nums[right] == sum) {\r\n                        tmp.clear();\r\n                        tmp.push_back(nums[i]);\r\n                        tmp.push_back(nums[j]);\r\n                        tmp.push_back(nums[left]);\r\n                        tmp.push_back(nums[right]);\r\n                        res.push_back(tmp);\r\n                        left++;\r\n                        right--;\r\n                        while (left < right && nums[left] == nums[left - 1]) left++;\r\n                        while (left < right && nums[right] == nums[right + 1]) right--;\r\n                    } else \r\n                        if (nums[left] + nums[right] > sum) right--;\r\n                        else left++;\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution(object):\r\n    '''\r\n    题意：找到数列中所有和等于目标数的四元组，需去重\r\n    多枚举一个数后，参照3Sum的做法，O(N^3)    \r\n    '''\r\n    def fourSum(self, nums, target):\r\n        nums.sort()\r\n        res = []\r\n        length = len(nums)\r\n        for i in range(0, length - 3):\r\n            if i and nums[i] == nums[i - 1]:\r\n                continue\r\n            for j in range(i + 1, length - 2):\r\n                if j != i + 1 and nums[j] == nums[j - 1]:\r\n                    continue\r\n                sum = target - nums[i] - nums[j]\r\n                left, right = j + 1, length - 1\r\n                while left < right:\r\n                    if nums[left] + nums[right] == sum:\r\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\r\n                        right -= 1\r\n                        left += 1\r\n                        while left < right and nums[left] == nums[left - 1]:\r\n                            left += 1\r\n                        while left < right and nums[right] == nums[right + 1]:\r\n                            right -= 1\r\n                    elif nums[left] + nums[right] > sum:\r\n                        right -= 1\r\n                    else:\r\n                        left += 1\r\n        return res"}]},{"id":144,"unique_name":"recover-rotated-sorted-array","title":"恢复旋转排序数组","description":"给定一个**旋转**排序数组，在原地恢复其排序。","solutions":[{"language":"java","code":"import java.util.ArrayList;\r\n\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param nums: The rotated sorted array\r\n     * @return: The recovered sorted array\r\n     */\r\n    private void reverse(ArrayList<Integer> nums, int start, int end) {\r\n        for (int i = start, j = end; i < j; i++, j--) {\r\n            int temp = nums.get(i);\r\n            nums.set(i, nums.get(j));\r\n            nums.set(j, temp);\r\n        }\r\n    }\r\n\r\n    public void recoverRotatedSortedArray(ArrayList<Integer> nums) {\r\n        for (int index = 0; index < nums.size() - 1; index++) {\r\n            if (nums.get(index) > nums.get(index + 1)) {\r\n                reverse(nums, 0, index);\r\n                reverse(nums, index + 1, nums.size() - 1);\r\n                reverse(nums, 0, nums.size() - 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int getGCD(int a, int b) {\n        if (a % b == 0) {\n            return b;\n        }    \n        return getGCD(b, a % b);\n    }\n    \n    void recoverRotatedSortedArray(vector<int> &nums) {\n        int offset = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i - 1] > nums[i]) {\n                offset = i;\n            }\n        }\n        if (offset == 0) {\n            return;\n        }\n        offset = nums.size() - offset;\n        \n        int gcd = getGCD(offset, nums.size());\n        for (int i = 0; i < gcd; i++) {\n            int next = (i + offset) % nums.size();\n            while (next != i) {\n                int temp = nums[i]; nums[i] = nums[next]; nums[next] = temp;\n                next = (next + offset) % nums.size();\n            }\n        }\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param nums: The rotated sorted array\n    @return:  The recovered sorted array\n    \"\"\"\n    def recoverRotatedSortedArray(self, nums):\n        return sorted(nums)\n"}]},{"id":700,"unique_name":"folding-array","title":"折叠数组","description":"给一个长度为 `n` 的数组 `nums` 和一个长度为 `k` 的数组 `req`, 你需要根据要求折叠数组，并输出折叠的结果\n1.如果 `req[i] = 0` 意味着你应该从`左`到`右`折叠, 例如:\n```\n1 2 3 4 5 6 7 8  ==>   4 3 2 1\n                       5 6 7 8\n```\n2.如果 `req[i] = 1` 意味着你应该从`右`往`左`折叠, 例如:\n```\n1 2 3 4 5 6 7 8  ==>   8 7 6 5\n                       1 2 3 4\n```\n更多的例子:\n```\n从左到右折叠\n4 3 2 1  ==>  6 5\n5 6 7 8       3 4\n              2 1\n              7 8\n\n\n从右到左折叠\n6 5  ==>   8\n3 4        1\n2 1        4\n7 8        5\n           6\n           3\n           2\n           7 \n```\n","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : the original array\n     * @param : the direction each time\n     * @return: the final folded array \n     */\n    public int[] folding(int[] nums, int[] req) {\n        // write your code here\n        // in the kth round, m = n/2**k\n        // left to right m 0, m 1, m 0, m 1...\n        // right to left m 1, m 0, m 1, m 0...\n        // move all the 0's to the first half\n        // then reverse the first n/2 elements\n        int n = nums.length;\n        int k = req.length;\n        int l = 1;\n        for (int i = 0; i < k; i++) {\n            int m = n / (2*l);\n            fold(nums, m, l, req[i]);\n            l *= 2;\n        }\n        return nums;\n    }\n    // move l segments of 0's of length m to the first half\n    private void fold(int[] nums, int m, int l, int dir) {\n        for (int i = 0; i < l; i++) {\n            // the ith segment swap i + dir times\n            insert(nums, m, 2*m * i + m*dir, i+dir);\n        }\n        reverse(nums);\n    }\n    // swap segments of length m starting from i t times\n    private void insert(int[] nums, int m, int i, int t) {\n        for (int j = 0; j < t; j++) {\n            interval_swap(nums, m, i - j*m);\n        }\n    }\n    // swap a segment of length m with the previous segment\n    private void interval_swap(int[] nums, int m, int i) {\n        for (int j = 0; j < m; j++) {\n            swap(nums, i+j, i+j-m);\n        }\n    }\n    private void swap(int[] nums, int i , int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    // reverse the first half of the array\n    private void reverse(int[] nums) {\n        int i = 0;\n        int j = nums.length / 2 - 1;\n        while (i < j) {\n            swap(nums, i++, j--);\n        }\n    }\n}"}]},{"id":794,"unique_name":"reverse-array","title":"翻转数组","description":"原地翻转给出的数组 `nums`","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param nums: a integer array\n     * @return: nothing\n     */\n    public void reverseArray(int[] nums) {\n        int n = nums.length;\n        int i, j, t;\n        i = 0;\n        j = n - 1;\n        while (i < j) {\n            t = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n            ++i;\n            --j;\n        }\n    }\n}"}]},{"id":431,"unique_name":"singleton","title":"单例","description":"**单例** 是最为最常见的设计模式之一。对于任何时刻，如果某个类只存在且最多存在一个具体的实例，那么我们称这种设计模式为单例。例如，对于 class Mouse (不是动物的mouse哦)，我们应将其设计为 singleton 模式。\r\n\r\n你的任务是设计一个 `getInstance` 方法，对于给定的类，每次调用 `getInstance` 时，都可得到同一个实例。","solutions":[{"language":"java","code":"class Solution {\n    /**\n     * @return: The same instance of this class every time\n     */\n    public static Solution instance = null;\n    public static Solution getInstance() {\n        if (instance == null) {\n            instance = new Solution();\n        }\n        return instance;\n    }\n};\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @return: The same instance of this class every time\n     */\n    static Solution* instance;\n    static Solution* getInstance() {\n        if (instance == NULL) {\n            instance = new Solution();\n        }\n        return instance;\n    }\n};\n\nSolution* Solution::instance = NULL;"},{"language":"python","code":"class Solution:\n    # @return: The same instance of this class every time\n    instance = None\n    \n    @classmethod\n    def getInstance(cls):\n        if cls.instance is None:\n            cls.instance = Solution()\n        return cls.instance\n"}]},{"id":361,"unique_name":"parking-lot","title":"停车场","description":"设计一个停车场\r\n1. 一共有*n*层，每层*m*列，每列*k*个位置\r\n2.停车场可以停摩托车，公交车，汽车\r\n3.停车位分别有摩托车位，汽车位，大型停车位\r\n4.每一列，摩托车位编号范围为`[0,k/4)`,汽车停车位编号范围为`[k/4,k/4*3)`,大型停车位编号范围为`[k/4*3,k)`\r\n5.一辆摩托车可以停在任何停车位\r\n6.一辆汽车可以停在一个汽车位或者大型停车位\r\n7.一辆公交车可以停在一列里的连续5个大型停车位。","solutions":[{"language":"java","code":"// enum type for Vehicle\r\nenum VehicleSize {\r\n\tMotorcycle,\r\n\tCompact,\r\n\tLarge,\r\n}\r\n\r\n//abstract Vehicle class\r\nabstract class Vehicle {\r\n    // Write your code here\r\n\tprotected int spotsNeeded;\r\n\tprotected VehicleSize size;\r\n\tprotected String licensePlate;  // id for a vehicle\r\n\r\n\tprotected ArrayList<ParkingSpot> parkingSpots = new ArrayList<ParkingSpot>(); // id for parking where may occupy multi\r\n\r\n\tpublic int getSpotsNeeded() {\r\n\t\treturn spotsNeeded;\r\n\t}\r\n\t\r\n\tpublic VehicleSize getSize() {\r\n\t\treturn size;\r\n\t}\r\n\r\n\t/* Park vehicle in this spot (among others, potentially) */\r\n\tpublic void parkInSpot(ParkingSpot spot) {\r\n\t\tparkingSpots.add(spot);\r\n\t}\r\n\t\r\n\t/* Remove car from spot, and notify spot that it's gone */\r\n\tpublic void clearSpots() {\r\n\t\tfor (int i = 0; i < parkingSpots.size(); i++) {\r\n\t\t\tparkingSpots.get(i).removeVehicle();\r\n\t\t}\r\n\t\tparkingSpots.clear();\r\n\t}\r\n\t//this need to be implement in subclass\r\n\tpublic abstract boolean canFitInSpot(ParkingSpot spot);\r\n    public abstract void print(); \r\n}\r\n\r\nclass Motorcycle extends Vehicle {\r\n    // Write your code here\r\n\tpublic Motorcycle() {\r\n\t\tspotsNeeded = 1;\r\n\t\tsize = VehicleSize.Motorcycle;\r\n\t}\r\n\t\r\n\tpublic boolean canFitInSpot(ParkingSpot spot) {\r\n\t\treturn true;\r\n\t}\r\n    \r\n    public void print() {  \r\n        System.out.print(\"M\");  \r\n    }\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    // Write your code here\r\n\tpublic Car() {\r\n\t\tspotsNeeded = 1;\r\n\t\tsize = VehicleSize.Compact;\r\n\t}\r\n\t\r\n\tpublic boolean canFitInSpot(ParkingSpot spot) {\r\n\t\treturn spot.getSize() == VehicleSize.Large || spot.getSize() == VehicleSize.Compact;\r\n\t}\r\n\r\n    public void print() {  \r\n        System.out.print(\"C\");  \r\n    } \r\n}\r\n\r\nclass Bus extends Vehicle {\r\n    // Write your code here\r\n\tpublic Bus() {\r\n\t\tspotsNeeded = 5;\r\n\t\tsize = VehicleSize.Large;\r\n\t}\r\n\r\n\tpublic boolean canFitInSpot(ParkingSpot spot) {\r\n\t\treturn spot.getSize() == VehicleSize.Large;\r\n\t}\r\n\r\n    public void print() {  \r\n        System.out.print(\"B\");  \r\n    } \r\n}\r\n\r\nclass ParkingSpot {\r\n    // Write your code here\r\n\tprivate Vehicle vehicle;\r\n\tprivate VehicleSize spotSize;\r\n\tprivate int row;\r\n\tprivate int spotNumber;\r\n\tprivate Level level;\r\n\r\n\tpublic ParkingSpot(Level lvl, int r, int n, VehicleSize sz) {\r\n\t\tlevel = lvl;\r\n\t\trow = r;\r\n\t\tspotNumber = n;\r\n\t\tspotSize = sz;\r\n\t}\r\n\t\r\n\tpublic boolean isAvailable() {\r\n\t\treturn vehicle == null;\r\n\t}\r\n\t/* Checks if the spot is big enough for the vehicle (and is available). This compares\r\n\t * the SIZE only. It does not check if it has enough spots. */\r\n\tpublic boolean canFitVehicle(Vehicle vehicle) {\r\n\t\treturn isAvailable() && vehicle.canFitInSpot(this);\r\n\t}\r\n\t/* Park vehicle in this spot. */\r\n\tpublic boolean park(Vehicle v) {\r\n\t\tif (!canFitVehicle(v)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvehicle = v;\r\n\t\tvehicle.parkInSpot(this);\r\n\t\treturn true;\r\n\t}\r\n\t/* Remove vehicle from spot, and notify level that a new spot is available */\r\n\tpublic void removeVehicle() {\r\n\t\tlevel.spotFreed();\r\n\t\tvehicle = null;\r\n\t}\r\n\t\r\n\tpublic int getRow() {\r\n\t\treturn row;\r\n\t}\r\n\t\r\n\tpublic int getSpotNumber() {\r\n\t\treturn spotNumber;\r\n\t}\r\n\t\r\n\tpublic VehicleSize getSize() {\r\n\t\treturn spotSize;\r\n\t}\r\n\r\n    public void print() {  \r\n        if (vehicle == null) {  \r\n            if (spotSize == VehicleSize.Compact) {  \r\n                System.out.print(\"c\");  \r\n            } else if (spotSize == VehicleSize.Large) {  \r\n                System.out.print(\"l\");  \r\n            } else if (spotSize == VehicleSize.Motorcycle) {  \r\n                System.out.print(\"m\");  \r\n            }  \r\n        } else {  \r\n            vehicle.print();  \r\n        }  \r\n    }\r\n}\r\n\r\n/* Represents a level in a parking garage */\r\nclass Level {\r\n    // Write your code here\r\n\tprivate int floor;\r\n\tprivate ParkingSpot[] spots;\r\n\tprivate int availableSpots = 0; // number of free spots\r\n\tprivate int SPOTS_PER_ROW;\r\n\r\n\r\n\tpublic Level(int flr, int num_rows, int spots_per_row) {\r\n\t\tfloor = flr;\r\n        int SPOTS_PER_ROW = spots_per_row;\r\n        int numberSpots  = 0;\r\n\t\tspots = new ParkingSpot[num_rows * spots_per_row];\r\n\r\n\t\t//init size for each spot in array spots\r\n        for (int row = 0; row < num_rows; ++row) {\r\n            for (int spot = 0; spot < spots_per_row / 4; ++spot) {\r\n                VehicleSize sz = VehicleSize.Motorcycle;\r\n                spots[numberSpots] = new ParkingSpot(this, row, numberSpots, sz);\r\n                numberSpots ++;\r\n            }\r\n            for (int spot = spots_per_row / 4; spot < spots_per_row / 4 * 3; ++spot) {\r\n                VehicleSize sz = VehicleSize.Compact;\r\n                spots[numberSpots] = new ParkingSpot(this, row, numberSpots, sz);\r\n                numberSpots ++;\r\n            }\r\n            for (int spot = spots_per_row / 4 * 3; spot < spots_per_row; ++spot) {\r\n                VehicleSize sz = VehicleSize.Large;\r\n                spots[numberSpots] = new ParkingSpot(this, row, numberSpots, sz);\r\n                numberSpots ++;\r\n            }\r\n        }\r\n\r\n        availableSpots = numberSpots;\r\n\t}\r\n\r\n\t/* Try to find a place to park this vehicle. Return false if failed. */\r\n\tpublic boolean parkVehicle(Vehicle vehicle) {\r\n\t\tif (availableSpots() < vehicle.getSpotsNeeded()) {\r\n\t\t\treturn false; // no enough spots\r\n\t\t}\r\n\t\tint spotNumber = findAvailableSpots(vehicle);\r\n\t\tif(spotNumber < 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn parkStartingAtSpot(spotNumber, vehicle);\r\n\t}\r\n\r\n\t/* find a spot to park this vehicle. Return index of spot, or -1 on failure. */\r\n\tprivate int findAvailableSpots(Vehicle vehicle) {\r\n\t\tint spotsNeeded = vehicle.getSpotsNeeded();\r\n\t\tint lastRow = -1;\r\n\t\tint spotsFound = 0;\r\n\r\n\t\tfor(int i = 0; i < spots.length; i++){\r\n\t\t\tParkingSpot spot = spots[i];\r\n\t\t\tif(lastRow != spot.getRow()){\r\n\t\t\t\tspotsFound = 0;\r\n\t\t\t\tlastRow = spot.getRow();\r\n\t\t\t}\r\n\t\t\tif(spot.canFitVehicle(vehicle)){\r\n\t\t\t\tspotsFound++;\r\n\t\t\t}else{\r\n\t\t\t\tspotsFound = 0;\r\n\t\t\t}\r\n\t\t\tif(spotsFound == spotsNeeded){\r\n\t\t\t\treturn i - (spotsNeeded - 1); // index of spot\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/* Park a vehicle starting at the spot spotNumber, and continuing until vehicle.spotsNeeded. */\r\n\tprivate boolean parkStartingAtSpot(int spotNumber, Vehicle vehicle) {\r\n\t\tvehicle.clearSpots();\r\n\r\n\t\tboolean success = true;\r\n\t\t\r\n\t\tfor (int i = spotNumber; i < spotNumber + vehicle.spotsNeeded; i++) {\r\n\t\t\t success &= spots[i].park(vehicle);\r\n\t\t}\r\n\t\t\r\n\t\tavailableSpots -= vehicle.spotsNeeded;\r\n\t\treturn success;\r\n\t}\r\n\r\n\t/* When a car was removed from the spot, increment availableSpots */\r\n\tpublic void spotFreed() {\r\n\t\tavailableSpots++;\r\n\t}\r\n\r\n\tpublic int availableSpots() {\r\n\t\treturn availableSpots;\r\n\t}\r\n\r\n    public void print() {  \r\n        int lastRow = -1;  \r\n        for (int i = 0; i < spots.length; i++) {  \r\n            ParkingSpot spot = spots[i];  \r\n            if (spot.getRow() != lastRow) {  \r\n                System.out.print(\"  \");  \r\n                lastRow = spot.getRow();  \r\n            }  \r\n            spot.print();  \r\n        }  \r\n    }\r\n}\r\n\r\npublic class ParkingLot {\r\n\tprivate Level[] levels;\r\n\tprivate int NUM_LEVELS;\r\n\t\r\n    // @param n number of leves\r\n    // @param num_rows  each level has num_rows rows of spots\r\n    // @param spots_per_row each row has spots_per_row spots\r\n\tpublic ParkingLot(int n, int num_rows, int spots_per_row) {\r\n        // Write your code here\r\n        NUM_LEVELS = n;\r\n\t\tlevels = new Level[NUM_LEVELS];\r\n\t\tfor (int i = 0; i < NUM_LEVELS; i++) {\r\n\t\t\tlevels[i] = new Level(i, num_rows, spots_per_row);\r\n\t\t}\r\n\t}\r\n\r\n\t// Park the vehicle in a spot (or multiple spots)\r\n    // Return false if failed\r\n\tpublic boolean parkVehicle(Vehicle vehicle) {\r\n        // Write your code here\r\n\t\tfor (int i = 0; i < levels.length; i++) {\r\n\t\t\tif (levels[i].parkVehicle(vehicle)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n    // unPark the vehicle\r\n\tpublic void unParkVehicle(Vehicle vehicle) {\r\n        // Write your code here\r\n\t\tvehicle.clearSpots();\r\n\t}\r\n\r\n    public void print() {  \r\n        for (int i = 0; i < levels.length; i++) {  \r\n            System.out.print(\"Level\" + i + \": \");  \r\n            levels[i].print();\r\n            System.out.println(\"\");  \r\n        }  \r\n        System.out.println(\"\");  \r\n    } \r\n}"},{"language":"cpp","code":"// enum type for Vehicle\r\nenum class VehicleSize {\r\n    Motorcycle,\r\n    Compact,\r\n    Large\r\n};\r\n\r\nclass Vehicle {\r\npublic:\r\n    virtual VehicleSize size() {}\r\n    virtual int spot_num() {}\r\n};\r\n\r\nclass Bus: public Vehicle {\r\npublic:\r\n    VehicleSize size() {\r\n        return VehicleSize::Large;\r\n    }\r\n    int spot_num() {\r\n        return 5;\r\n    }\r\n};\r\n\r\nclass Car: public Vehicle {\r\npublic:\r\n    VehicleSize size() {\r\n        return VehicleSize::Compact;\r\n    }\r\n    int spot_num() {\r\n        return 1;\r\n    }\r\n};\r\n\r\nclass Motorcycle: public Vehicle {\r\npublic:\r\n    VehicleSize size() {\r\n        return VehicleSize::Motorcycle;\r\n    }\r\n    int spot_num() {\r\n        return 1;\r\n    }\r\n};\r\n\r\nclass Level {\r\npublic:\r\n    Level(int num_rows, int spots_per_row) {\r\n        for (int i = 0 ; i < num_rows; ++i) {\r\n            spots.push_back(vector<Vehicle*>(spots_per_row, NULL));\r\n        }\r\n        this->num_rows = num_rows;\r\n        this->spots_per_row = spots_per_row;\r\n    }\r\n    \r\n    bool park_vehicle(Vehicle* vehicle) {\r\n        for (int row = 0; row < num_rows; ++row) {\r\n            int start = 0;\r\n            if (vehicle->size() == VehicleSize::Compact) {\r\n                start = spots_per_row / 4;\r\n            } else if (vehicle->size() == VehicleSize::Large) {\r\n                start = spots_per_row / 4 * 3;\r\n            }\r\n            for (int i = start; i < spots_per_row - vehicle->spot_num() + 1; ++i) {\r\n                bool can_park = true;\r\n                for (int j = i; j < i +  vehicle->spot_num(); ++j) {\r\n                    if (spots[row][j] != NULL) {\r\n                        can_park = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (can_park) {\r\n                    for (int j = i; j < i + vehicle->spot_num(); ++j) {\r\n                        spots[row][j] = vehicle;\r\n                    } \r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    void unpark_vehicle(Vehicle *vehicle) {\r\n        for (int row = 0; row < num_rows; ++row) {\r\n            for (int i = 0; i < spots_per_row; ++i)\r\n                if (spots[row][i] == vehicle) {\r\n                    spots[row][i] = NULL;\r\n                }\r\n        }\r\n    }\r\n    \r\nprivate:\r\n    vector<vector<Vehicle*>> spots;\r\n    int num_rows;\r\n    int spots_per_row;\r\n    \r\n};\r\n\r\nclass ParkingLot {\r\npublic:\r\n    // @param n number of leves\r\n    // @param num_rows  each level has num_rows rows of spots\r\n    // @param spots_per_row each row has spots_per_row spots\r\n    ParkingLot(int n, int num_rows, int spots_per_row) {\r\n        for (int i = 0; i < n; ++i) {\r\n            Level *level = new Level(num_rows, spots_per_row);\r\n            levels.push_back(level);\r\n        }\r\n    }\r\n\r\n    // Park the vehicle in a spot (or multiple spots)\r\n    // Return false if failed\r\n    bool parkVehicle(Vehicle* vehicle) {\r\n        for (int i = 0; i < levels.size(); ++i) {\r\n            if (levels[i]->park_vehicle(vehicle)) {\r\n                vehicle_to_level[vehicle] = levels[i];\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // unPark the vehicle\r\n    void unParkVehicle(Vehicle* vehicle) {\r\n        Level *level = vehicle_to_level[vehicle];\r\n        if (level) {\r\n            level->unpark_vehicle(vehicle);\r\n        }\r\n    }\r\n    \r\nprivate:\r\n    vector<Level*> levels;\r\n    map<Vehicle*, Level*> vehicle_to_level;\r\n};"},{"language":"python","code":"# enum type for Vehicle\r\nclass VehicleSize:\r\n    Motorcycle = 1\r\n    Compact = 2\r\n    Large = 3\r\n    Other = 99\r\n\r\nclass Vehicle:\r\n    # Write your code here\r\n    def __init__(self):\r\n        self.parking_spots = []\r\n        self.spots_needed = 0\r\n        self.size = None\r\n        self.license_plate = None\r\n\r\n    def get_spots_needed(self):\r\n        return self.spots_needed\r\n\r\n    def get_size(self):\r\n        return self.size\r\n\r\n    def park_in_spot(self, spot):\r\n        self.parking_spots.append(spot)\r\n\r\n    def clear_spots(self):\r\n        for spot in self.parking_spots:\r\n            spot.remove_vehicle()\r\n        \r\n        self.park_sports = []  \r\n\r\n    def can_fit_in_spot(self, spot):\r\n        raise NotImplementedError('This method should have implemented.')\r\n\r\n\r\nclass Motorcycle(Vehicle):\r\n    # Write your code here\r\n    def __init__(self):\r\n        Vehicle.__init__(self)\r\n        self.spots_needed = 1\r\n        self.size = VehicleSize.Motorcycle\r\n\r\n    def can_fit_in_spot(self, spot):\r\n        return True\r\n\r\n\r\nclass Car(Vehicle):\r\n    # Write your code here\r\n    def __init__(self):\r\n        Vehicle.__init__(self)\r\n        self.spots_needed = 1\r\n        self.size = VehicleSize.Compact\r\n\r\n    def can_fit_in_spot(self, spot):\r\n        return spot.get_size() == VehicleSize.Large or \\\r\n                spot.get_size() == VehicleSize.Compact\r\n\r\n\r\nclass Bus(Vehicle):\r\n    # Write your code here\r\n    def __init__(self):\r\n        Vehicle.__init__(self)\r\n        self.spots_needed = 5\r\n        self.size = VehicleSize.Large\r\n\r\n    def can_fit_in_spot(self, spot):\r\n        return spot.get_size() == VehicleSize.Large\r\n\r\n\r\nclass ParkingSpot:\r\n    # Write your code here\r\n    def __init__(self, lvl, r, n, sz):\r\n        self.level = lvl\r\n        self.row = r\r\n        self.spot_number = n\r\n        self.spot_size = sz\r\n        self.vehicle = None\r\n\r\n    def is_available(self):\r\n        return self.vehicle == None\r\n\r\n    def can_fit_vehicle(self, vehicle):\r\n        return self.is_available() and vehicle.can_fit_in_spot(self)\r\n\r\n    def park(self, v):\r\n        if not self.can_fit_vehicle(v):\r\n            return False\r\n\r\n        self.vehicle = v\r\n        self.vehicle.park_in_spot(self)\r\n        return True\r\n\r\n    def remove_vehicle(self):\r\n        self.level.spot_freed()\r\n        self.vehicle = None\r\n\r\n    def get_row(self):\r\n        return self.row\r\n\t\r\n    def get_spot_number(self):\r\n        return self.spot_number\r\n\r\n    def get_size(self):\r\n        return self.spot_size\r\n\r\n\r\nclass Level:\r\n    # Write your code here\r\n    def __init__(self, flr, num_rows, spots_per_row):\r\n        self.floor = flr\r\n        self.spots_per_row = spots_per_row\r\n        self.number_spots = 0\r\n        self.available_spots = 0;\r\n        self.spots = []\r\n        \r\n        for row in xrange(num_rows):\r\n            for spot in xrange(0, spots_per_row / 4):\r\n                sz = VehicleSize.Motorcycle\r\n                self.spots.append(ParkingSpot(self, row, self.number_spots, sz))\r\n                self.number_spots += 1\r\n\r\n            for spot in xrange(spots_per_row / 4, spots_per_row / 4 * 3):\r\n                sz = VehicleSize.Compact\r\n                self.spots.append(ParkingSpot(self, row, self.number_spots, sz))\r\n                self.number_spots += 1\r\n\r\n            for spot in xrange(spots_per_row / 4 * 3, spots_per_row):\r\n                sz = VehicleSize.Large\r\n                self.spots.append(ParkingSpot(self, row, self.number_spots, sz))\r\n                self.number_spots += 1\r\n\r\n        self.available_spots = self.number_spots\r\n        \r\n    def park_vehicle(self, vehicle):\r\n        if self.get_available_spots() < vehicle.get_spots_needed():\r\n            return False\r\n\r\n        spot_num = self.find_available_spots(vehicle)\r\n\r\n        if spot_num < 0:\r\n            return False\r\n        return self.park_starting_at_spot(spot_num, vehicle)\r\n\r\n    def find_available_spots(self, vehicle):\r\n        spots_needed = vehicle.get_spots_needed()\r\n        last_row = -1\r\n        spots_found = 0\r\n        \r\n        for i in xrange(len(self.spots)):\r\n            spot = self.spots[i]\r\n            if last_row != spot.get_row():\r\n                spots_found = 0\r\n                last_row = spot.get_row()\r\n            if spot.can_fit_vehicle(vehicle):\r\n                spots_found += 1\r\n            else:\r\n                spots_found = 0\r\n            \r\n            if spots_found == spots_needed:\r\n                return i - (spots_needed - 1)\r\n\r\n        return -1\r\n\r\n    def park_starting_at_spot(self, spot_num, vehicle):\r\n        vehicle.clear_spots()\r\n        success = True\r\n\r\n        for i in xrange(spot_num, spot_num + vehicle.get_spots_needed()):\r\n            success = success and self.spots[i].park(vehicle)\r\n        \r\n        self.available_spots -= vehicle.get_spots_needed()\r\n        return success\r\n\r\n    def spot_freed(self):\r\n        self.available_spots += 1\r\n\r\n    def get_available_spots(self):\r\n        return self.available_spots\r\n\r\n\r\nclass ParkingLot:\r\n    # @param {int} n number of leves\r\n    # @param {int} num_rows  each level has num_rows rows of spots\r\n    # @param {int} spots_per_row each row has spots_per_row spots\r\n    def __init__(self, n, num_rows, spots_per_row):\r\n        # Write your code here\r\n        self.levels = []\r\n        for i in xrange(n):\r\n            self.levels.append(Level(i, num_rows, spots_per_row))\r\n\r\n\t# Park the vehicle in a spot (or multiple spots)\r\n    # Return false if failed\r\n    def park_vehicle(self, vehicle):\r\n        # Write your code here\r\n        for level in self.levels:\r\n            if level.park_vehicle(vehicle):\r\n                return True\r\n        return False\r\n\r\n    # unPark the vehicle\r\n    def unpark_vehicle(self, vehicle):\r\n        # Write your code here\r\n        vehicle.clear_spots()\r\n"}]},{"id":362,"unique_name":"shape-factory","title":"形状工厂","description":"工厂模式是一种常见的设计模式。实现一个形状工厂 `ShapeFactory` 来创建不同的形状类。这里我们假设只有三角形，正方形和矩形三种形状。","solutions":[{"language":"java","code":"/**\r\n * Your object will be instantiated and called as such:\r\n * ShapeFactory sf = new ShapeFactory();\r\n * Shape shape = sf.getShape(shapeType);\r\n * shape.draw();\r\n */\r\ninterface Shape {\r\n    void draw();\r\n}\r\n\r\nclass Rectangle implements Shape {\r\n    // Write your code here\r\n    @Override\r\n    public void draw() {\r\n        System.out.println(\" ---- \");\r\n        System.out.println(\"|    |\");\r\n        System.out.println(\" ---- \");\r\n   }\r\n}\r\n\r\nclass Square implements Shape {\r\n    // Write your code here\r\n   @Override\r\n   public void draw() {\r\n        System.out.println(\" ---- \");\r\n        System.out.println(\"|    |\");\r\n        System.out.println(\"|    |\");\r\n        System.out.println(\" ---- \");\r\n   }\r\n}\r\n\r\nclass Triangle implements Shape {\r\n    // Write your code here\r\n   @Override\r\n   public void draw() {\r\n        System.out.println(\"  /\\\\\");\r\n        System.out.println(\" /  \\\\\");\r\n        System.out.println(\"/____\\\\\");\r\n   }\r\n}\r\n\r\npublic class ShapeFactory {\r\n    /**\r\n     * @param shapeType a string\r\n     * @return Get object of type Shape\r\n     */\r\n    public Shape getShape(String shapeType) {\r\n        // Write your code here\r\n        if (shapeType == null) {\r\n            return null;\r\n        }\t\t\r\n        if (shapeType.equalsIgnoreCase(\"Triangle\")) {\r\n            return new Triangle();\r\n        } else if(shapeType.equalsIgnoreCase(\"Rectangle\")) {\r\n            return new Rectangle();         \r\n        } else if(shapeType.equalsIgnoreCase(\"Square\")) {\r\n            return new Square();\r\n        }\r\n        return null;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Your object will be instantiated and called as such:\r\n * ShapeFactory* sf = new ShapeFactory();\r\n * Shape* shape = sf->getShape(shapeType);\r\n * shape->draw();\r\n */\r\nclass Shape {\r\npublic:\r\n    virtual void draw() const=0;\r\n};\r\n\r\nclass Rectangle: public Shape {\r\n    // Write your code here\r\npublic:\r\n    void draw() const {\r\n        cout << \" ----\" << endl;\r\n        cout << \"|    |\" << endl;\r\n        cout << \" ----\" << endl;\r\n    }\r\n};\r\n\r\nclass Square: public Shape {\r\n    // Write your code here\r\npublic:\r\n    void draw() const {\r\n        cout << \" ----\" << endl;\r\n        cout << \"|    |\" << endl;\r\n        cout << \"|    |\" << endl;\r\n        cout << \" ----\" << endl;\r\n    }\r\n};\r\n\r\nclass Triangle: public Shape {\r\n    // Write your code here\r\npublic:\r\n    void draw() const {\r\n        cout << \"  /\\\\\" << endl;\r\n        cout << \" /  \\\\\" << endl;\r\n        cout << \"/____\\\\\" << endl;\r\n    }\r\n};\r\n\r\nclass ShapeFactory {\r\npublic:\r\n    /**\r\n     * @param shapeType a string\r\n     * @return Get object of type Shape\r\n     */\r\n    Shape* getShape(string& shapeType) {\r\n        // Write your code here\r\n        if (shapeType == \"Triangle\") {\r\n            return new Triangle();\r\n        } else if(shapeType == \"Rectangle\") {\r\n            return new Rectangle();         \r\n        } else if(shapeType == \"Square\") {\r\n            return new Square();\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n\r\n\r\n\r\n\r\n"},{"language":"python","code":"\"\"\"\r\nYour object will be instantiated and called as such:\r\nsf = ShapeFactory()\r\nshape = sf.getShape(shapeType)\r\nshape.draw()\r\n\"\"\"\r\nclass Shape:\r\n    def draw(self):\r\n        raise NotImplementedError('This method should have implemented.')\r\n\r\nclass Triangle(Shape):\r\n    # Write your code here\r\n    def draw(self):\r\n        print \"  /\\\\\"\r\n        print \" /  \\\\\"\r\n        print \"/____\\\\\"\r\n\r\nclass Rectangle(Shape):\r\n    # Write your code here\r\n    def draw(self):\r\n        print \" ----\"\r\n        print \"|    |\"\r\n        print \" ----\"\r\n\r\nclass Square(Shape):\r\n    # Write your code here\r\n    def draw(self):\r\n        print \" ----\"\r\n        print \"|    |\"\r\n        print \"|    |\"\r\n        print \" ----\"\r\n\r\nclass ShapeFactory:\r\n    # @param {string} shapeType a string\r\n    # @return {Shape} Get object of type Shape\r\n    def getShape(self, shapeType):\r\n        # Write your code here\r\n        if shapeType == \"Triangle\":\r\n            return Triangle()\r\n        elif shapeType == \"Rectangle\":\r\n            return Rectangle()\r\n        elif shapeType == \"Square\":\r\n            return Square()\r\n        else:\r\n            return None"}]},{"id":215,"unique_name":"assignment-operator-overloading-c-only","title":"赋值运算符重载","description":"实现赋值运算符重载函数，确保：\r\n\r\n- 新的数据可准确地被复制\r\n- 旧的数据可准确地删除/释放\r\n- 可进行 `A = B = C` 赋值\r\n\r\n","solutions":[{"language":"cpp","code":"class Solution {\r\npublic:\r\n    char *m_pData;\r\n    Solution() {\r\n        this->m_pData = NULL;\r\n    }\r\n    Solution(char *pData) {\r\n        if (pData) {\r\n            m_pData = new char[strlen(pData) + 1];\r\n            strcpy(m_pData, pData);\r\n        } else {\r\n            m_pData = NULL;\r\n        }\r\n    }\r\n\r\n    // Implement an assignment operator\r\n    Solution operator=(const Solution &object) {\r\n        if (this == &object) {\r\n            return *this;\r\n        }\r\n        \r\n        if (object.m_pData) {\r\n            char *temp = m_pData;\r\n            try {\r\n                m_pData = new char[strlen(object.m_pData)+1];\r\n                strcpy(m_pData, object.m_pData);\r\n                if (temp)\r\n                    delete[] temp;\r\n            } catch (bad_alloc& e) {\r\n                m_pData = temp;\r\n            }\r\n        } else {\r\n            m_pData = NULL;\r\n        }\r\n        return *this;\r\n    }\r\n};\r\n"}]},{"id":654,"unique_name":"convert-bst-to-greater-tree","title":"把二叉搜索树转化成更大的树","description":"给定二叉搜索树(BST)，将其转换为更大的树，使原始BST上每个节点的值都更改为在原始树中大于等于该节点值的节点值之和(包括该节点)。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the new root\r\n     */\r\n    public int sum = 0;\r\n\r\n    void helper(TreeNode root){\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        if (root.right != null) {\r\n            helper(root.right);\r\n        }\r\n        \r\n        root.val = (sum += root.val);\r\n        if (root.left != null) {\r\n            helper(root.left);\r\n        }\r\n    }\r\n\r\n    public TreeNode convertBST(TreeNode root) {\r\n        // Write your code here\r\n        helper(root);\r\n        return root;\r\n    }\r\n}\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the new root\r\n     */\r\n    int sum = 0;\r\n\r\n    void dfs(TreeNode cur) {\r\n        if (cur == null) {\r\n            return;\r\n        }\r\n        dfs(cur.right);\r\n        sum += cur.val;\r\n        cur.val = sum;\r\n        dfs(cur.left);\r\n    }\r\n\r\n    public TreeNode convertBST(TreeNode root) {\r\n        // Write your code here\r\n        dfs(root);\r\n        return root;\r\n    }\r\n}"},{"language":"cpp","code":"\r\nclass Solution {\r\npublic:\r\n  /**\r\n   * @param root the root of binary tree\r\n   * @return the new root\r\n   */\r\n  int sum;\r\n  void dfs(TreeNode* cur) {\r\n    if (cur == NULL) {\r\n      return;\r\n    }\r\n    dfs(cur->right);     \r\n    sum += cur->val;      \r\n    cur->val = sum;\r\n    dfs(cur->left);\r\n  }\r\n  \r\n  TreeNode* convertBST(TreeNode* root) {\r\n    // Write your code here\r\n    sum = 0;\r\n    dfs(root);\r\n    return root;\r\n  }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        self.val = val\r\n        self.left, self.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    # @param {TreeNode} root the root of binary tree\r\n    # @return {TreeNode} the new root\r\n    def convertBST(self, root):\r\n        # Write your code here\r\n        self.sum = 0\r\n        self.helper(root)\r\n        return root\r\n\r\n    def helper(self, root):\r\n        if root is None:\r\n            return\r\n        if root.right:\r\n            self.helper(root.right)\r\n        \r\n        self.sum += root.val\r\n        root.val = self.sum\r\n        if root.left:\r\n            self.helper(root.left)"}]},{"id":605,"unique_name":"maximum-subtree","title":"最大子树","description":"给你一棵二叉树，找二叉树中的一棵子树，他的所有节点之和最大。\r\n\r\n返回这棵子树的根节点。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the maximum weight node\r\n     */\r\n    public TreeNode result = null;\r\n    public int maximum_weight = Integer.MIN_VALUE;\r\n\r\n    public TreeNode findSubtree(TreeNode root) {\r\n        // Write your code here\r\n        helper(root);\r\n        \r\n        return result;\r\n    }\r\n\r\n    public int helper(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int left_weight = helper(root.left);\r\n        int right_weight = helper(root.right);\r\n\r\n        if (result == null || left_weight + right_weight + root.val > maximum_weight) {\r\n            maximum_weight = left_weight + right_weight + root.val;\r\n            result = root;\r\n        }\r\n\r\n        return left_weight + right_weight + root.val;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the maximum weight node\r\n     */\r\n    TreeNode* findSubtree(TreeNode* root) {\r\n        // Write your code here\r\n        helper(root);\r\n        return result;\r\n    }\r\n\r\n    int helper(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return 0;\r\n        }\r\n        int left_weight = helper(root->left);\r\n        int right_weight = helper(root->right);\r\n\r\n        if (result == nullptr || left_weight + right_weight + root->val > maximum_weight) {\r\n            maximum_weight = left_weight + right_weight + root->val;\r\n            result = root;\r\n        }\r\n        return left_weight + right_weight + root->val;\r\n    }\r\n\r\nprivate:\r\n    TreeNode* result = nullptr;\r\n    int maximum_weight = INT_MIN;\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {TreeNode} root the root of binary tree\r\n    # @return {int} the maximum weight node\r\n    import sys\r\n    maximum_weight = 0\r\n    result = None\r\n\r\n    def findSubtree(self, root):\r\n        # Write your code here\r\n        self.helper(root)\r\n\r\n        return self.result\r\n\r\n    def helper(self, root):\r\n        if root is None:\r\n            return 0\r\n\r\n        left_weight = self.helper(root.left)\r\n        right_weight = self.helper(root.right)\r\n        \r\n        if left_weight + right_weight + root.val >= self.maximum_weight or self.result is None:\r\n            self.maximum_weight = left_weight + right_weight + root.val\r\n            self.result = root\r\n\r\n        return left_weight + right_weight + root.val"}]},{"id":611,"unique_name":"remove-substrings","title":"移除子串","description":"给出一个字符串 `s` 以及 `n` 个子串。你可以从字符串 s 中移除 n 个子串中的任意一个，使得剩下来s的长度最小，输出这个最小长度。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param s a string\r\n     * @param dict a set of n substrings\r\n     * @return the minimum length\r\n     */\r\n    public int minLength(String s, Set<String> dict) {\r\n        // Write your code here\r\n        Queue<String> que = new LinkedList<String>();\r\n        Set<String> hash = new HashSet<String>();\r\n    \r\n        int min = s.length();\r\n        que.offer(s);\r\n        hash.add(s);\r\n\r\n        while (!que.isEmpty()) {\r\n            s = que.poll();\r\n            for (String sub : dict) {\r\n                int found = s.indexOf(sub);\r\n                while (found != -1) {\r\n                    String new_s = s.substring(0, found) +\r\n                        s.substring(found + sub.length(), s.length());\r\n                    if (!hash.contains(new_s)) {\r\n                        if (new_s.length() < min)\r\n                            min = new_s.length();\r\n                        que.offer(new_s);\r\n                        hash.add(new_s);\r\n                    }\r\n                    found = s.indexOf(sub, found + 1);\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param s a string\r\n     * @param dict a set of n substrings\r\n     * @return the minimum length\r\n     */\r\n    int minLength(string& s, set<string>& dict) {\r\n        // Write your code here\r\n        queue<string> que;\r\n        unordered_set<string> hash;\r\n    \r\n        int min = s.size();\r\n        que.push(s);\r\n        hash.insert(s);\r\n\r\n        while (!que.empty()) {\r\n            string s = que.front();\r\n            que.pop();\r\n            for (auto& sub : dict) {\r\n                int found = s.find(sub);\r\n                while (found != -1) {\r\n                    string new_s = s.substr(0, found) +\r\n                        s.substr(found + sub.size(), s.size() - found - sub.size());\r\n                    if (hash.find(new_s) == hash.end()) {\r\n                        if (new_s.size() < min)\r\n                            min = new_s.size();\r\n                        que.push(new_s);\r\n                        hash.insert(new_s);\r\n                    }\r\n                    found = s.find(sub, found + 1);\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {string} s a string\r\n    # @param {set} dict a set of n substrings\r\n    # @return {int} the minimum length\r\n    def minLength(self, s, dict):\r\n        # Write your code here\r\n        import Queue\r\n        que = Queue.Queue()\r\n        que.put(s)\r\n        hash = set([s])\r\n    \r\n        min = len(s)\r\n\r\n        while not que.empty():\r\n            s = que.get()\r\n            for sub in dict:\r\n                found = s.find(sub)\r\n                while found != -1:\r\n                    new_s = s[:found] + s[found + len(sub):]\r\n                    if new_s not in hash:\r\n                        if len(new_s) < min:\r\n                            min = len(new_s)\r\n                        que.put(new_s)\r\n                        hash.add(new_s)\r\n\r\n                    found = s.find(sub, found + 1)\r\n        return min"}]},{"id":577,"unique_name":"subtree-with-maximum-average","title":"具有最大平均数的子树","description":"给一棵二叉树，找到有最大平均值的子树。返回子树的根结点。","solutions":[{"language":"java","code":"// version 1: Traverse + Divide Conquer\r\npublic class Solution {\r\n    private class ResultType {\r\n        public int sum, size;\r\n        public ResultType(int sum, int size) {\r\n            this.sum = sum;\r\n            this.size = size;\r\n        }\r\n    }\r\n    \r\n    private TreeNode subtree = null;\r\n    private ResultType subtreeResult = null;\r\n    \r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the root of the maximum average of subtree\r\n     */\r\n    public TreeNode findSubtree2(TreeNode root) {\r\n        helper(root);\r\n        return subtree;\r\n    }\r\n    \r\n    private ResultType helper(TreeNode root) {\r\n        if (root == null) {\r\n            return new ResultType(0, 0);\r\n        }\r\n        \r\n        ResultType left = helper(root.left);\r\n        ResultType right = helper(root.right);\r\n        ResultType result = new ResultType(\r\n            left.sum + right.sum + root.val,\r\n            left.size + right.size + 1\r\n        );\r\n        \r\n        if (subtree == null ||\r\n            subtreeResult.sum * result.size < result.sum * subtreeResult.size\r\n        ) {\r\n            subtree = root;\r\n            subtreeResult = result;\r\n        }\r\n        return result;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right>;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right> = NULL;\r\n *     }\r\n * }\r\n */\r\nclass ResultType {\r\npublic:\r\n    int sum, size;\r\n    ResultType():sum(0), size(0) {}\r\n    ResultType(int _sum, int _size): sum(_sum), size(_size) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the root of the maximum average of subtree \r\n     */\r\n    TreeNode* findSubtree2(TreeNode* root) {\r\n        // Write your code here\r\n        helper(root);\r\n        return node;\r\n    }\r\n\r\n    ResultType helper(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return ResultType();\r\n        }\r\n        ResultType left = helper(root->left);\r\n        ResultType right = helper(root->right);\r\n        \r\n        ResultType result = ResultType(left.sum + right.sum + root->val,\r\n                                       left.size + right.size + 1);\r\n\r\n        if (node == NULL || result.sum * data.size >= data.sum * result.size) {\r\n            data = result;\r\n            node = root;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\nprivate:\r\n    TreeNode* node = NULL;\r\n    ResultType data;\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {TreeNode} root the root of binary tree\r\n    # @return {TreeNode} the root of the maximum average of subtree\r\n    average, node = 0, None\r\n\r\n    def findSubtree2(self, root):\r\n        # Write your code here\r\n        self.helper(root)\r\n        return self.node\r\n\r\n    def helper(self, root):\r\n        if root is None:\r\n            return 0, 0\r\n\r\n        left_sum, left_size = self.helper(root.left)\r\n        right_sum, right_size = self.helper(root.right)\r\n\r\n        sum, size = left_sum + right_sum + root.val, \\\r\n                    left_size + right_size + 1\r\n\r\n        if self.node is None or sum * 1.0 / size > self.average:\r\n            self.node = root\r\n            self.average = sum * 1.0 / size\r\n\r\n        return sum, size"}]},{"id":483,"unique_name":"create-maximum-number","title":"创建最大数","description":"给出两个长度分别是`m`和`n`的数组来表示两个大整数，数组的每个元素都是数字`0-9`。从这两个数组当中选出`k`个数字来创建一个最大数，其中`k`满足`k <= m + n`。选出来的数字在创建的最大数里面的位置必须和在原数组内的相对位置一致。返回`k`个数的数组。你应该尽可能的去优化算法的时间复杂度和空间复杂度。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums1 an integer array of length m with digits 0-9\r\n     * @param nums2 an integer array of length n with digits 0-9\r\n     * @param k an integer and k <= m + n\r\n     * @return an integer array\r\n     */\r\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\r\n        // Write your code here\r\n        if (k == 0)\r\n            return new int[0];\r\n\r\n        int m = nums1.length, n = nums2.length;\r\n        if (m + n < k) return null;\r\n        if (m + n == k) {\r\n            int[] results = merge(nums1, nums2, k);\r\n            return results;\r\n        } else {\r\n            int max = m >= k ? k : m;\r\n            int min = n >= k ? 0 : k - n;\r\n\r\n            int[] results = new int[k];\r\n            for(int i=0; i < k; ++i)\r\n                results[i] = -0x7ffffff;\r\n            for(int i = min; i <= max; ++i) {\r\n                int[] temp = merge(getMax(nums1, i), getMax(nums2, k - i), k);\r\n                results = isGreater(results, 0, temp, 0) ? results : temp;\r\n            }\r\n            return results;\r\n        }\r\n    }\r\n\r\n    private int[] merge(int[] nums1, int[] nums2, int k) {\r\n        int[] results = new int[k];\r\n        if (k == 0) return results;\r\n        int i = 0, j = 0;\r\n        for(int l = 0; l < k; ++l) {\r\n            results[l] = isGreater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\r\n        }\r\n        return results;\r\n    }\r\n\r\n    private boolean isGreater(int[] nums1, int i, int[] nums2, int j) {\r\n        for(; i < nums1.length && j < nums2.length; ++i, ++j) {\r\n            if (nums1[i] > nums2[j])\r\n                return true;\r\n            if (nums1[i] < nums2[j])\r\n                return false;\r\n        }\r\n        return i != nums1.length;\r\n    }\r\n\r\n    private int[] getMax(int[] nums, int k) {\r\n        if (k == 0)\r\n            return new int[0];\r\n        int[] results = new int[k];\r\n        int i = 0;\r\n        for(int j = 0; j < nums.length; ++j) {\r\n            while(nums.length - j + i > k && i > 0 && results[i-1] < nums[j])\r\n                i--;\r\n            if (i < k)\r\n                results[i++] = nums[j];\r\n        }\r\n        return results;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums1 an integer array of length m with digits 0-9\r\n     * @param nums2 an integer array of length n with digits 0-9\r\n     * @param k an integer and k <= m + n\r\n     * @return an integer array\r\n     */\r\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\r\n        // Write your code here\r\n        int len1 = nums1.size(), len2 = nums2.size();\r\n        vector<int> results;\r\n        for (int k1 = max(k - len2, 0); k1 <= min(k, len1); ++k1)\r\n            results = max(results, maxNumber(maxNumber(nums1, k1), maxNumber(nums2, k - k1)));\r\n        return results;\r\n    }\r\n\r\n    vector<int> maxNumber(vector<int> nums, int k) {\r\n        int drop = nums.size() - k;\r\n        vector<int> results;\r\n        for (int num : nums) {\r\n            while (drop && results.size() && results.back() < num) {\r\n                results.pop_back();\r\n                drop--;\r\n            }\r\n            results.push_back(num);\r\n        }\r\n        results.resize(k);\r\n        return results;\r\n    }\r\n\r\n    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {\r\n        vector<int> results;\r\n        while (nums1.size() + nums2.size()) {\r\n            vector<int>& now = nums1 > nums2 ? nums1 : nums2;\r\n            results.push_back(now[0]);\r\n            now.erase(now.begin());\r\n        }\r\n        return results;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums1 an integer array of length m with digits 0-9\r\n    # @param {int[]} nums2 an integer array of length n with digits 0-9\r\n    # @param {int} k an integer and k <= m + n\r\n    # @return {int[]} an integer array\r\n    def maxNumber(self, nums1, nums2, k):\r\n        # Write your code here\r\n        len1, len2 = len(nums1), len(nums2)\r\n        res = []\r\n        for x in range(max(0, k - len2), min(k, len1) + 1):\r\n            tmp = self.merge(self.getMax(nums1, x), self.getMax(nums2, k - x))\r\n            res = max(tmp, res)\r\n        return res\r\n\r\n    def getMax(self, nums, t):\r\n        ans = []\r\n        size = len(nums)\r\n        for x in range(size):\r\n            while ans and len(ans) + size - x > t and ans[-1] < nums[x]:\r\n                ans.pop()\r\n            if len(ans) < t:\r\n                ans.append(nums[x])\r\n        return ans\r\n\r\n    def merge(self, nums1, nums2):\r\n        return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\r\n"}]},{"id":404,"unique_name":"find-the-missing-number","title":"寻找缺失的数","description":"给出一个包含 0 .. *N* 中 *N* 个数的序列，找出0 .. *N* 中没有出现在序列中的那个数。","solutions":[{"language":"java","code":"public class Solution {\n    /**    \n     * @param nums: an array of integers\n     * @return: an integer\n     */\n    public int findMissing(int[] nums) {\n        // write your code here\n        int n = nums.length, i = 0;\n        while (i<n) {\n            while (nums[i]!=i && nums[i]<n) {\n                int t = nums[i];\n                nums[i] = nums[t];\n                nums[t] = t;\n            }\n            ++i;\n        }\n        for (i=0; i<n; ++i)\n            if (nums[i]!=i) return i;\n        return n;\n    }\n}\n\n//Math\npublic class Solution {\n    /**    \n     * @param nums: an array of integers\n     * @return: an integer\n     */\n    public int findMissing(int[] nums) {\n        long N = nums.length;\n        long sum = N * (N + 1) / 2;\n        for(int i : nums){\n            sum -= i;\n        }\n        return (int)sum;\n    }\n}\n\n//Xor\npublic int findMissing(int[] nums) {\n    // write your code here\n    int ans = 0;\n    for (int i = 0; i <= nums.length; i++) {\n        ans ^= i;\n    }\n    for (int i = 0; i < nums.length; i++) {\n        ans ^= nums[i];\n    }\n    return ans;\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**    \r\n     * @param nums: a vector of integers\r\n     * @return: an integer\r\n     */\r\n    int findMissing(vector<int> &nums) {\r\n        // write your code here\r\n        int n = nums.size(), i = 0;\r\n        while (i<n) {\r\n            while (nums[i]!=i && nums[i]<n) swap(nums[i], nums[nums[i]]);  \r\n            ++i;\r\n        }\r\n        for (int i=0; i<n; ++i)\r\n            if (nums[i]!=i) return i;\r\n        return n;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param nums: a list of integers\r\n    # @return: an integer\r\n    def findMissing(self, nums):\r\n        s = set(nums)\r\n        for i in range(0, len(nums) + 1):\r\n            if i not in s:\r\n                return i\r\n        return -1    \r\n\r\n"}]},{"id":207,"unique_name":"maximum-gap","title":"最大间距","description":"给定一个未经排序的数组，请找出其排序表中连续两个要素的最大间距。\r\n\r\n如果数组中的要素少于 2 个，请返回 0.\r\n","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * @param nums: an array of integers\r\n     * @return: the maximum difference\r\n     */\r\n    public int maximumGap(int[] nums) {\r\n        // write your code here\r\n        if (nums.length<2) return 0;\r\n        int minNum = -1, maxNum = -1, n = nums.length;\r\n        for (int i=0; i<n; ++i) {\r\n            minNum = min(nums[i], minNum);\r\n            maxNum = max(nums[i], maxNum);\r\n        }\r\n        if (maxNum==minNum) return 0;\r\n        double average = (maxNum-minNum) * 1.0 / (n - 1);\r\n        if (average==0) ++average;\r\n        int[] localMin = new int[n];\r\n        int[] localMax = new int[n];\r\n        for (int i=0; i<n; ++i) {\r\n            localMin[i] = -1;\r\n            localMax[i] = -1;\r\n        }\r\n        for (int i=0; i<n; ++i) {\r\n            int t = (int)((nums[i]-minNum) / average);\r\n            localMin[t] = min(localMin[t], nums[i]);\r\n            localMax[t] = max(localMax[t], nums[i]);\r\n        }\r\n        int ans = (int)average, left = 0, right = 1;\r\n        while (left<n-1) {\r\n            while (right<n && localMin[right]==-1) ++right;\r\n            if (right>=n) break;\r\n            ans = max(ans, localMin[right]-localMax[left]);\r\n            left = right;\r\n            ++right;\r\n        }\r\n        return ans;\r\n    }\r\n    private int min(int a, int b) {\r\n        if (a==-1) return b;\r\n        else \r\n            if (b==-1) return a;\r\n            else\r\n                if (a<b) return a;\r\n                else return b;\r\n    }\r\n    private int max(int a, int b) {\r\n        if (a==-1) return b;\r\n        else\r\n            if (b==-1) return a;\r\n            else\r\n                if (a>b) return a;\r\n                else return b;    \r\n    }\r\n}"},{"language":"cpp","code":"struct Block {\r\n  int max, min;\r\n};\r\nclass Solution {\r\npublic:\r\n    int maximumGap(vector<int>& nums) {\r\n        int n = nums.size();\r\n      \r\n        if (nums.size() < 2) {\r\n            return 0;\r\n        }\r\n        int min = nums[0];\r\n        int max = nums[0];\r\n        for (int i = 1; i < nums.size(); i++) {\r\n           min = min < nums[i] ? min : nums[i];\r\n           max = max > nums[i] ? max : nums[i];\r\n        }\r\n        if (max == min) {\r\n          return 0;\r\n        }\r\n        double block_size = (max - min) * 1.0 / (n - 1);\r\n        vector<Block> blocks(n);\r\n        for (int i = 0; i < n; i++) {\r\n          blocks[i].max = blocks[i].min = -1;\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n          int block_id = (nums[i] - min) / block_size;\r\n          if (blocks[block_id].max == -1) {\r\n            blocks[block_id].min = blocks[block_id].max = nums[i];\r\n          } else {\r\n            blocks[block_id].min = blocks[block_id].min < nums[i] ? blocks[block_id].min : nums[i];\r\n            blocks[block_id].max = blocks[block_id].max > nums[i] ? blocks[block_id].max : nums[i];\r\n          }\r\n        }\r\n      \r\n        int maxGap = -1;\r\n        int lastNumber = blocks[0].max;\r\n        for (int i = 1; i < n; i++) {\r\n          if (blocks[i].min == -1) {\r\n            continue;\r\n          }\r\n          maxGap = maxGap > blocks[i].min - lastNumber ? maxGap : blocks[i].min - lastNumber;\r\n          lastNumber = blocks[i].max;\r\n        }\r\n        return maxGap;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n     # @param nums: a list of integers\r\n     # @return: the maximum difference\r\n    def maximumGap(self, nums):\r\n        # write your code here\r\n        if (len(nums)<2): return 0\r\n        minNum = -1\r\n        maxNum = -1\r\n        n = len(nums)\r\n        for i in xrange(n):\r\n            minNum = self.min(nums[i], minNum)\r\n            maxNum = self.max(nums[i], maxNum)\r\n        if maxNum==minNum: return 0\r\n        average = (maxNum-minNum) * 1.0 / (n-1)\r\n        if average==0: average += 1\r\n        localMin = []\r\n        localMax = []\r\n        for i in xrange(n):\r\n            localMin.append(-1)\r\n            localMax.append(-1)\r\n        for i in xrange(n):\r\n            t = int((nums[i]-minNum) / average)\r\n            localMin[t] = self.min(localMin[t], nums[i])\r\n            localMax[t] = self.max(localMax[t], nums[i])\r\n        ans = average\r\n        left = 0\r\n        right = 1\r\n        while left<n-1:\r\n            while right<n and localMin[right]==-1: right += 1\r\n            if right>=n: break\r\n            ans = self.max(ans, localMin[right]-localMax[left])\r\n            left = right\r\n            right += 1\r\n        return ans\r\n    def min(self, a, b):\r\n        if (a==-1): return b\r\n        elif (b==-1): return a\r\n        elif (a<b): return a\r\n        else: return b\r\n    def max(self, a, b):\r\n        if (a==-1): return b\r\n        elif (b==-1): return a\r\n        elif (a>b): return a\r\n        else: return b"}]},{"id":185,"unique_name":"delete-digits","title":"删除数字","description":"给出一个字符串 *A*, 表示一个 *n* 位正整数, 删除其中 *k* 位数字, 使得剩余的数字仍然按照原来的顺序排列产生一个新的正整数。\r\n\r\n找到删除 *k* 个数字之后的最小正整数。\r\n\r\n*N* <= 240, *k* <= *N*\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     *@param A: A positive integer which has N digits, A is a string.\r\n     *@param k: Remove k digits.\r\n     *@return: A string\r\n     */\r\n    public String DeleteDigits(String A, int k) {\r\n        // write your code here\r\n        StringBuffer sb = new StringBuffer(A);\r\n        int i, j;\r\n        for (i = 0; i < k; i++) {\r\n            for (j = 0; j < sb.length() - 1 && sb.charAt(j) <= sb.charAt(j + 1); j++) {}\r\n                sb.delete(j, j + 1);\r\n        }\r\n        while (sb.length() > 1 && sb.charAt(0) == '0') {\r\n            sb.delete(0, 1);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     *@param A: A positive integer which has N digits, A is a string.\r\n     *@param k: Remove k digits.\r\n     *@return: A string\r\n     */\r\n    string remove(string A, int pos) {\r\n        return A.substr(0, pos) + A.substr(pos + 1, A.length() - pos - 1);\r\n    }\r\n    \r\n    string DeleteDigits(string A, int k) {\r\n        if (A.length() == k) {\r\n            return \"\";\r\n        }\r\n        \r\n        for (int i = 0; i < k; i++) {\r\n            for (int j = 0; j < A.length(); j++) {\r\n                if (j == A.length() - 1 || A[j + 1] < A[j]) {\r\n                    A = remove(A, j);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        int i = 0;\r\n        while (i < A.length() - 1 && A[i] == '0') {\r\n            i++;\r\n        }\r\n        return A.substr(i, A.length() - i);\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A: A positive integer which has N digits, A is a string.\r\n    @param k: Remove k digits.\r\n    @return: A string\r\n    \"\"\"\r\n    def DeleteDigits(self, A, k):\r\n        # write you code here\r\n        A = list(A)\r\n        while k > 0:\r\n            f = True\r\n            for i in xrange(len(A)-1):\r\n                if A[i] > A[i+1]:\r\n                    del A[i]\r\n                    f = False\r\n                    break\t \r\n            if f and len(A)>1:\r\n                A.pop()\r\n            k -= 1\r\n        while len(A)>1 and A[0]=='0':\r\n            del A[0]\r\n        return ''.join(A)   \r\n \r\n"}]},{"id":265,"unique_name":"single-number-iii","title":"落单的数 III","description":"<p>给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A : An integer array\r\n     * @return : Two integers\r\n     */\r\n    public List<Integer> singleNumberIII(int[] A) {\r\n        int xor = 0;\r\n        for (int i = 0; i < A.length; i++) {\r\n            xor ^= A[i];\r\n        }\r\n        \r\n        int lastBit = xor - (xor & (xor - 1));\r\n        int group0 = 0, group1 = 0;\r\n        for (int i = 0; i < A.length; i++) {\r\n            if ((lastBit & A[i]) == 0) {\r\n                group0 ^= A[i];\r\n            } else {\r\n                group1 ^= A[i];\r\n            }\r\n        }\r\n        \r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        result.add(group0);\r\n        result.add(group1);\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param A : An integer array\n     * @return : two integers\n     */\n    vector<int> singleNumberIII(vector<int> &A) {\n        // write your code here\n        int x = 0, len = A.size(), pos;\n        for (int i = 0; i < len; ++i)\n            x ^= A[i];\n        for (int i = 0; i < 32; ++i)\n            if (x & (1 << i)) {\n                pos = i;    \n                break;            \n            }\n        vector<int> results(2);\n        for (int i = 0; i < len; ++i)\n        if (A[i] & (1 << pos))\n            results[0] ^= A[i];\n        else\n            results[1] ^= A[i];\n        return results;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param A : An integer array\n    @return : Two integer\n    \"\"\"\n    def singleNumberIII(self, A):\n        # write your code here\n        s = 0\n        for x in A:\n            s ^= x\n        y = s & (-s)\n\n        ans = [0,0]\n        for x in A:\n            if (x & y) != 0:\n                ans[0] ^= x\n            else:\n                ans[1] ^= x                 \n        return ans\n        \n        \n"}]},{"id":18,"unique_name":"single-number-ii","title":"落单的数 II","description":"<p>给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。</p>","solutions":[{"language":"java","code":"public class Solution {\n    public int singleNumberII(int[] A) {\n        if (A == null || A.length == 0) {\n            return -1;\n        }\n        int result=0;\n        int[] bits=new int[32];\n        for (int i = 0; i < 32; i++) {\n            for(int j = 0; j < A.length; j++) {\n                bits[i] += A[j] >> i & 1;\n                bits[i] %= 3;\n            }\n\n            result |= (bits[i] << i);\n        }\n        return result;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    int singleNumberII(int A[], int n) {\n        int one=0;\n        int two=0;\n        int i,j,k;\n        for(i=0; i<n; i++)\n        {\n            two = two |(one&A[i]);\n            one = one^A[i];\n            \n            int three = two&one;\n            two = two^three;\n            one = one^three;\n        }\n        \n        return one|two;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n\t@param A : An integer array\n\t@return : An integer\n    \"\"\"\n    def singleNumberII(self, A):\n        # write your code here\n        n = len(A)\n        d = [0 for i in xrange(32)]\n        for x in A:\n            for j in xrange(32):\n                if ( ((1 << j) & x) > 0):\n                    d[j] += 1\n        ans = 0\n        for j in xrange(32):\n            t = d[j] % 3\n            if (t == 1):\n                ans  = ans + (1 << j)\n            elif (t != 0):\n                return -1\n        return ans\n        \n"},{"language":"javascript","code":"/**\n * @param A: An integer array\n * @return: An integer\n */\nconst singleNumberII = function (A) {\n    if (A === null || A.length === 0) {\n        return -1;\n    }\n    var result = 0;\n    var bits = new Array(32);\n    var i, j;\n    for (i = 0; i < 32; i++) {\n        bits[i] = 0;\n    }\n    for (i = 0; i < 32; i++) {\n        for(j = 0; j < A.length; j++) {\n            bits[i] += (A[j] >> i) & 1;\n            bits[i] %= 3;\n        }\n        result |= (bits[i] << i);\n    }\n    return result;\n}"}]},{"id":219,"unique_name":"majority-number-ii","title":"主元素 II","description":"<p>给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的三分之一。</p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: The majority number that occurs more than 1/3\r\n     */\r\n    public int majorityNumber(ArrayList<Integer> nums) {\r\n        int candidate1 = 0, candidate2 = 0;\r\n        int count1, count2;\r\n        count1 = count2 = 0;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (candidate1 == nums.get(i)) {\r\n                count1 ++;\r\n            } else if (candidate2 == nums.get(i)) {\r\n                count2 ++;\r\n            } else if (count1 == 0) {\r\n                candidate1 = nums.get(i);\r\n                count1 = 1;\r\n            } else if (count2 == 0) {\r\n                candidate2 = nums.get(i);\r\n                count2 = 1;\r\n            } else {\r\n                count1--;\r\n                count2--;\r\n            }\r\n        }\r\n        count1 = count2 = 0;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (nums.get(i) == candidate1) {\r\n                count1++;\r\n            } else if (nums.get(i) == candidate2) {\r\n                count2++;\r\n            }\r\n        }    \r\n        return count1 > count2 ? candidate1 : candidate2;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int majorityNumber(vector<int> nums) {\r\n        int candidate1, candidate2;\r\n        int count1, count2;\r\n        count1 = count2 = 0;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (candidate1 == nums[i]) {\r\n                count1 ++;\r\n            } else if (candidate2 == nums[i]) {\r\n                count2 ++;\r\n            } else if (count1 == 0) {\r\n                candidate1 = nums[i];\r\n                count1 = 1;\r\n            } else if (count2 == 0) {\r\n                candidate2 = nums[i];\r\n                count2 = 1;\r\n            } else {\r\n                count1--;\r\n                count2--;\r\n            }\r\n        }\r\n        count1 = count2 = 0;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (nums[i] == candidate1) {\r\n                count1++;\r\n            } else if (nums[i] == candidate2) {\r\n                count2++;\r\n            }\r\n        }    \r\n        return count1 > count2 ? candidate1 : candidate2;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers\r\n    @return: The majority number occurs more than 1/3\r\n    \"\"\"\r\n    def majorityNumber(self, nums):\r\n        candidate1, count1 = None, 0\r\n        candidate2, count2 = None, 0\r\n        for num in nums:\r\n            if candidate1 == num:\r\n                count1 += 1\r\n            elif candidate2 == num:\r\n                count2 += 1\r\n            elif count1 == 0:\r\n                count1 += 1\r\n                candidate1 = num\r\n            elif count2 == 0:\r\n                count2 += 1\r\n                candidate2 = num\r\n            else:\r\n                count1 -= 1\r\n                count2 -= 1\r\n    \r\n        count1, count2 = 0, 0\r\n        for num in nums:\r\n            if candidate1 == num:\r\n                count1 += 1\r\n            elif candidate2 == num:\r\n                count2 += 1\r\n    \r\n        return candidate1 if count1 > count2 else candidate2\r\n"}]},{"id":218,"unique_name":"majority-number","title":"主元素","description":"<p>给定一个整型数组，找出主元素，它在数组中的出现次数严格大于数组元素个数的二分之一。</p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: a list of integers\r\n     * @return: find a  majority number\r\n     */\r\n    public int majorityNumber(ArrayList<Integer> nums) {\r\n        int count = 0, candidate = -1;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (count == 0) {\r\n                candidate = nums.get(i);\r\n                count = 1;\r\n            } else if (candidate == nums.get(i)) {\r\n                count++;\r\n            } else {\r\n                count--;\r\n            }\r\n        }\r\n        return candidate;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int majorityNumber(vector<int> nums) {\r\n        int candidate, count = 0;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (count == 0) {\r\n                candidate = nums[i];\r\n                count ++;\r\n            } else {\r\n                if (candidate == nums[i]) {\r\n                    count ++;\r\n                } else {\r\n                    count --;\r\n                }\r\n            }\r\n        }\r\n        return candidate;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n\r\n    def majorityNumber(self, nums):\r\n        candidate = None\r\n        count = 0\r\n        for num in nums:\r\n            if count == 0:\r\n                candidate = num\r\n                count += 1\r\n            elif candidate == num:\r\n                count += 1\r\n            else:\r\n                count -= 1\r\n        return candidate\r\n"}]},{"id":87,"unique_name":"wildcard-matching","title":"通配符匹配","description":"<p>判断两个可能包含通配符“？”和“*”的字符串是否匹配。匹配规则如下：</p><pre>'?' 可以匹配任何单个字符。\r\n'*' 可以匹配任意字符串（包括空字符串）。\r\n\r\n两个串完全匹配才算匹配成功。\r\n\r\n函数接口如下:\r\nbool isMatch(const char *s, const char *p)</pre>","solutions":[{"language":"java","code":"\r\n// Time: O(|s||p|*log|s|), Space: O(|s|)\r\n// Time can also optimize to O(|s||p|)\r\n\r\npublic class Solution {\r\n\r\npublic boolean isMatch(String s, String p) {\r\n    // without this optimization, it will fail for large data set\r\n    int plenNoStar = 0;\r\n    for (char c : p.toCharArray())\r\n        if (c != '*') plenNoStar++;\r\n    if (plenNoStar > s.length()) return false;\r\n\r\n    s = \" \" + s;\r\n    p = \" \" + p;\r\n    int slen = s.length();\r\n    int plen = p.length();\r\n\r\n    boolean[] dp = new boolean[slen];\r\n    TreeSet<Integer> firstTrueSet = new TreeSet<Integer>();\r\n    firstTrueSet.add(0);\r\n    dp[0] = true;\r\n\r\n    boolean allStar = true;\r\n    for (int pi = 1; pi < plen; pi++) {\r\n        if (p.charAt(pi) != '*')\r\n            allStar = false;\r\n        for (int si = slen - 1; si >= 0; si--) {\r\n            if (si == 0) {\r\n                dp[si] = allStar ? true : false;\r\n            } else if (p.charAt(pi) != '*') {\r\n                if (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == '?') dp[si] = dp[si-1];\r\n                else dp[si] = false;\r\n            } else {\r\n                int firstTruePos = firstTrueSet.isEmpty() ? Integer.MAX_VALUE : firstTrueSet.first();\r\n                if (si >= firstTruePos) dp[si] = true;\r\n                else dp[si] = false;\r\n            }\r\n            if (dp[si]) firstTrueSet.add(si);\r\n            else firstTrueSet.remove(si);\r\n        }\r\n    }\r\n    return dp[slen - 1];\r\n}\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param s: A string \r\n     * @param p: A string includes \"?\" and \"*\"\r\n     * @return: A boolean\r\n     */\r\n    bool isMatch(const char *s, const char *p) {\r\n        if (s == NULL || p == NULL) {\r\n            return false;\r\n        }\r\n        \r\n        int n = strlen(s);\r\n        int m = strlen(p);\r\n        int f[n + 1][m + 1];\r\n        \r\n        memset(f, false, sizeof(f));\r\n        \r\n        f[0][0] = true;\r\n        for (int i = 1; i <= n; i++)\r\n            f[i][0] = false;\r\n        \r\n        for (int i = 1; i <= m; i++)\r\n            f[0][i] = f[0][i - 1] && p[i - 1] == '*';\r\n        \r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if (p[j - 1] == '*') {\r\n                    f[i][j] = f[i - 1][j] || f[i][j - 1];\r\n                } else if (p[j - 1] == '?') {\r\n                    f[i][j] = f[i - 1][j - 1];\r\n                } else {\r\n                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1]);\r\n                }\r\n            }\r\n        } // for\r\n        \r\n        return f[n][m];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param s: A string\r\n    @param p: A string includes \"?\" and \"*\"\r\n    @return: A boolean\r\n    \"\"\"\r\n    def isMatch(self, s, p):\r\n        # write your code here\r\n        n = len(s)\r\n        m = len(p)\r\n        f = [[False] * (m + 1) for i in range(n + 1)]\r\n        f[0][0] = True\r\n\r\n        if n == 0 and p.count('*') == m:\r\n            return True\r\n\r\n        for i in range(0, n + 1):\r\n            for j in range(0, m + 1):\r\n                if i > 0 and j > 0:\r\n                    f[i][j] |= f[i-1][j-1] and (s[i-1] == p[j-1] or p[j - 1] in ['?', '*'])\r\n\r\n                if i > 0 and j > 0:\r\n                    f[i][j] |= f[i - 1][j] and p[j - 1] == '*'\r\n\r\n                if j > 0:\r\n                    f[i][j] |= f[i][j - 1] and p[j - 1] == '*'\r\n\r\n\r\n        return f[n][m]"}]},{"id":21,"unique_name":"gas-station","title":"加油站","description":"在一条环路上有 _N_ 个加油站，其中第 _i_ 个加油站有汽油`gas[i]`，并且从第_i_个加油站前往第_i_+1个加油站需要消耗汽油`cost[i]`。\r\n\r\n你有一辆油箱容量无限大的汽车，现在要从某一个加油站出发绕环路一周，一开始油箱为空。\r\n\r\n求可环绕环路一周时出发的加油站的编号，若不存在环绕一周的方案，则返回`-1`。","solutions":[{"language":"java","code":"public class Solution {\r\n    public int canCompleteCircuit(int[] gas, int[] cost) {\r\n        if (gas == null || cost == null || gas.length == 0 || cost.length == 0) {\r\n            return -1;\r\n        }\r\n\r\n        int sum = 0;\r\n        int total = 0;\r\n        int index = -1;\r\n\r\n        for(int i = 0; i<gas.length; i++) {\r\n            sum += gas[i] - cost[i];\r\n            total += gas[i] - cost[i];\r\n            if(sum < 0) {\r\n                index = i;\r\n                sum = 0;\r\n            }\r\n        }\r\n        return total < 0 ? -1 : index + 1;\r\n        // index should be updated here for cases ([5], [4]);\r\n        // total < 0 is for case [2], [2]\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n\t/**\r\n\t * @param gas: a vector of integers\r\n\t * @param cost: a vector of integers\r\n\t * @return: an integer\r\n\t */\r\n\tint canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r\n\t\tint sum = 0;\r\n        int total = 0;\r\n        int index = -1;\r\n\r\n        for(int i = 0; i<gas.size(); i++) {\r\n            sum += gas[i] - cost[i];\r\n            total += gas[i] - cost[i];\r\n            if(sum < 0) {\r\n                index = i;\r\n                sum = 0;\r\n            }\r\n        }\r\n        return total < 0 ? -1 : index + 1;\r\n\t}\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param gas, a list of integers\r\n    # @param cost, a list of integers\r\n    # @return an integer\r\n    def canCompleteCircuit(self, gas, cost):\r\n        # write your code here\r\n        n = len(gas)        \r\n        diff = []\r\n        for i in xrange(n): diff.append(gas[i]-cost[i])\r\n        for i in xrange(n): diff.append(gas[i]-cost[i])\r\n        if n==1:\r\n            if diff[0]>=0: return 0\r\n            else: return -1\r\n        st = 0\r\n        now = 1\r\n        tot = diff[0]\r\n        while st<n:\r\n            while tot<0:\r\n                st = now\r\n                now += 1\r\n                tot = diff[st]\r\n                if st>n: return -1\r\n            while now!=st+n and tot>=0:\r\n                tot += diff[now]\r\n                now += 1\r\n            if now==st+n and tot>=0: return st\r\n        return -1\r\n"}]},{"id":19,"unique_name":"single-number","title":"落单的数","description":"<p>给出2*n + 1&nbsp;个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int singleNumber(int[] A) {\r\n        if(A == null || A.length == 0) {\r\n            return -1;\r\n        }\r\n        int rst = 0;\r\n        for (int i = 0; i < A.length; i++) {\r\n            rst ^= A[i];\r\n        }\r\n        return rst;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n\t/**\n\t * @param A : an integer array\n\t * return : a integer \n\t */\n    int singleNumber(vector<int> &A) {\n        int x;\n        for (int i = 0; i < A.size(); i++) {\n            x ^= A[i];\n        }\n        return x;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n   @param A : an integer array\n   @return : a integer\n   \"\"\"\n    def singleNumber(self, A):\n        # write your code here\n        ans = 0;\n        for x in A:\n            ans = ans ^ x\n        return ans\n"},{"language":"javascript","code":"/**\n * @param A: An integer array\n * @return: An integer\n */\nconst singleNumber = function (A) {\n    if(A === null || A.length === 0) {\n        return -1;\n    }\n    var rst = 0;\n    var i;\n    for (i = 0; i < A.length; i++) {\n        rst ^= A[i];\n    }\n    return rst;\n}"}]},{"id":172,"unique_name":"implement-queue-by-two-stacks","title":"用栈实现队列","description":"<p><span style=\"line-height: 1.42857143;\">正如标题所述，你需要使用两个栈来实现队列的一些操作。</span><br></p><p>队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。</p><p>pop和top方法都应该返回第一个元素的值。<br></p>","solutions":[{"language":"java","code":"public class MyQueue {\r\n    private Stack<Integer> stack1;\r\n    private Stack<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n       // do initialization if necessary\r\n       stack1 = new Stack<Integer>();\r\n       stack2 = new Stack<Integer>();\r\n    }\r\n    \r\n    private void stack2ToStack1(){\r\n        while(! stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        }\r\n    }\r\n    \r\n    public void push(int element) {\r\n        // write your code here\r\n        stack2.push(element);\r\n    }\r\n\r\n    public int pop() {\r\n        // write your code here\r\n        if(stack1.empty() == true){\r\n            this.stack2ToStack1();\r\n        }\r\n        return stack1.pop();\r\n    }\r\n\r\n    public int top() {\r\n        // write your code here\r\n        if(stack1.empty() == true){\r\n            this.stack2ToStack1();\r\n        }\r\n        return stack1.peek();\r\n    }\r\n}"},{"language":"cpp","code":"class MyQueue {\r\npublic:\r\n    stack<int> stack1;\r\n    stack<int> stack2;\r\n\r\n    MyQueue() {\r\n    }\r\n\r\n    void push(int element) {\r\n        stack1.push(element);\r\n    }\r\n    \r\n    void adjust() {\r\n        if (stack2.empty()) {\r\n            while (!stack1.empty()) {\r\n                stack2.push(stack1.top());\r\n                stack1.pop();\r\n            }\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        adjust();\r\n        int temp = stack2.top();\r\n        stack2.pop();\r\n        return temp;\r\n    }\r\n\r\n    int top() {\r\n        adjust();\r\n        return stack2.top();\r\n    }\r\n};"},{"language":"python","code":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def adjust(self):\r\n        if len(self.stack2) == 0:\r\n            while len(self.stack1) != 0:\r\n                self.stack2.append(self.stack1.pop())\r\n                \r\n    def push(self, element):\r\n        self.stack1.append(element)\r\n\r\n    def top(self):\r\n        self.adjust()\r\n        return self.stack2[len(self.stack2) - 1]\r\n\r\n    def pop(self):\r\n        self.adjust()\r\n        return self.stack2.pop()\r\n"}]},{"id":54,"unique_name":"binary-tree-zigzag-level-order-traversal","title":"二叉树的锯齿形层次遍历","description":"<p>给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行）&nbsp;</p>","solutions":[{"language":"java","code":"public class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n\n        if (root == null) {\n            return result;\n        }\n\n        Stack<TreeNode> currLevel = new Stack<TreeNode>();\n        Stack<TreeNode> nextLevel = new Stack<TreeNode>();\n        Stack<TreeNode> tmp;\n        \n        currLevel.push(root);\n        boolean normalOrder = true;\n\n        while (!currLevel.isEmpty()) {\n            ArrayList<Integer> currLevelResult = new ArrayList<Integer>();\n\n            while (!currLevel.isEmpty()) {\n                TreeNode node = currLevel.pop();\n                currLevelResult.add(node.val);\n\n                if (normalOrder) {\n                    if (node.left != null) {\n                        nextLevel.push(node.left);\n                    }\n                    if (node.right != null) {\n                        nextLevel.push(node.right);\n                    }\n                } else {\n                    if (node.right != null) {\n                        nextLevel.push(node.right);\n                    }\n                    if (node.left != null) {\n                        nextLevel.push(node.left);\n                    }\n                }\n            }\n\n            result.add(currLevelResult);\n            tmp = currLevel;\n            currLevel = nextLevel;\n            nextLevel = tmp;\n            normalOrder = !normalOrder;\n        }\n\n        return result;\n\n    }\n}"},{"language":"cpp","code":"#include <vector>\n#include <queue>\n#include <algorithm>\n#include \"lintcode.h\"\n\nusing namespace std;\n\n/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\n \nstruct Node\n{\n    TreeNode *node;\n    int level;\n    Node(){}\n    Node(TreeNode *n, int l):node(n), level(l){}\n}; \nclass Solution {\n    /**\n     * @param root: The root of binary tree.\n     * @return: A list of lists of integer include \n     *          the zigzag level order traversal of its nodes' values \n     */\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {\n        // write your code here\n        vector<vector<int> > ret;\n\t\tret.clear();       \n        if (root == NULL)\n            return ret;        \n        queue<Node> q;        \n        q.push(Node(root, 0));        \n        int curLevel = -1;        \n        vector<int> a;        \n        while(!q.empty())\n        {\n            Node node = q.front();            \n            if (node.node->left)\n                q.push(Node(node.node->left, node.level + 1));           \n            if (node.node->right)\n                q.push(Node(node.node->right, node.level + 1));   \n            if (curLevel != node.level)\n            {\n                if (curLevel != -1)\n                {\n                    if (curLevel % 2 == 1)\n                        reverse(a.begin(), a.end());\n                        \n                    ret.push_back(a);\n                }\n                a.clear();\n                curLevel = node.level;\n            }\n            a.push_back(node.node->val);\n            q.pop();\n        }        \n        if (curLevel % 2 == 1)\n            reverse(a.begin(), a.end());   \n        ret.push_back(a);\n        return ret;\n    }\n};\n"},{"language":"python","code":"from lintcode import TreeNode\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: A list of list of integer include \n             the zig zag level order traversal of its nodes' values\n    \"\"\"\n    def preorder(self, root, level, res):\n        if root:\n            if len(res) < level+1: res.append([])\n            if level % 2 == 0: \n                res[level].append(root.val)\n            else: \n                res[level].insert(0, root.val)\n            self.preorder(root.left, level+1, res)\n            self.preorder(root.right, level+1, res)\n    def zigzagLevelOrder(self, root):\n        self.results = []\n        self.preorder(root, 0, self.results)\n        return self.results\n"}]},{"id":50,"unique_name":"binary-tree-level-order-traversal-ii","title":"二叉树的层次遍历 II","description":"<p>给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历）</p>","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: buttom-up level order a list of lists of integer\r\n     */\r\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\r\n        List<List<Integer>> result = new ArrayList<>();\r\n        if (root == null) {\r\n            return result;\r\n        }\r\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n        queue.offer(root);\r\n        \r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            List<Integer> level = new ArrayList<>();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode head = queue.poll();\r\n                level.add(head.val);\r\n                if (head.left != null) {\r\n                    queue.offer(head.left);\r\n                }\r\n                if (head.right != null) {\r\n                    queue.offer(head.right);\r\n                }\r\n            }\r\n            result.add(level);\r\n        }\r\n        \r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <vector>\r\n#include \"lintcode.h\"\r\n#include <queue>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\n \r\n \r\nclass Solution {\r\n    /**\r\n     * @param root : The root of binary tree.\r\n     * @return : buttom-up level order a list of lists of integer\r\n     */\r\npublic:\r\n    vector<vector<int>> levelOrderBottom(TreeNode *root) {\r\n        // write your code here\r\n        vector<vector<int> > ret;\r\n\t\tret.clear();\r\n\t\tif(root == NULL)\r\n\t\t\treturn ret;\r\n\t\tqueue<TreeNode*> S;\r\n\t\tS.push(root);\r\n\t\tS.push(NULL);\r\n\t\tvector<int> tmp;\r\n\t\twhile(!S.empty()){\r\n\t\t\t//travesal current level\r\n\t\t\tTreeNode* p = S.front();\r\n\t\t\tS.pop();\r\n\t\t\tif(p!=NULL)\r\n\t\t\t{\r\n\t\t\t\ttmp.push_back(p->val);\r\n\t\t\t\tif(p->left) \r\n\t\t\t\t\tS.push(p->left);\r\n\t\t\t\tif(p->right)\r\n\t\t\t\t\tS.push(p->right);\r\n\t\t\t}else{\r\n\t\t\t\tif(!tmp.empty())\r\n\t\t\t\t{\t\r\n\t\t\t\t\tS.push(NULL);\r\n\t\t\t\t\tret.push_back(tmp);\r\n\t\t\t\t\ttmp.clear();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treverse(ret.begin(),ret.end());\r\n        return ret;\r\n    }\r\n};\r\n"},{"language":"python","code":"from lintcode import TreeNode\r\n\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: buttom-up level order in a list of lists of integers\r\n    \"\"\"\r\n    def levelOrderBottom(self, root):\r\n        # write your code here\r\n        self.results = []\r\n        if not root:\r\n            return self.results\r\n        q = [root]\r\n        while q:\r\n            new_q = []\r\n            self.results.append([n.val for n in q])\r\n            for node in q:\r\n                if node.left:\r\n                    new_q.append(node.left)\r\n                if node.right:\r\n                    new_q.append(node.right)\r\n            q = new_q\r\n        return list(reversed(self.results))\r\n"}]},{"id":665,"unique_name":"coin-change","title":"换硬币","description":"给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 `-1`.","solutions":[{"language":"java","code":"public class Solution {\r\n    public int coinChange(int[] A, int M) {\r\n        int[] f = new int[M + 1];\r\n        int n = A.length;\r\n        \r\n        f[0] = 0;\r\n        int i, j;\r\n        for (i = 1; i <= M; ++i) {\r\n            f[i] = -1;\r\n            for (j = 0; j < n; ++j) {\r\n                if (i >= A[j] && f[i - A[j]] != -1) {\r\n                    if (f[i] == -1 || f[i - A[j]] + 1 < f[i]) {\r\n                        f[i] = f[i - A[j]] + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return f[M];\r\n    }\r\n}"}]},{"id":573,"unique_name":"ones-and-zeroes","title":"一和零","description":"在计算机世界中, 由于资源限制, 我们一直想要追求的是产生最大的利益.\n现在，假设你分别是 m个 `0s` 和 n个 `1s` 的统治者. 另一方面, 有一个只包含 `0s` 和 `1s` 的字符串构成的数组.\n现在你的任务是找到可以由 m个 `0s` 和 n个 `1s` 构成的字符串的最大个数. 每一个 `0` 和 `1` 均只能使用一次","solutions":[{"language":"java","code":"//方法一 未进行空间复杂度优化：\r\npublic class Solution {\r\n    public int findMaxForm(String[] strs, int m, int n) {\r\n        int[][][] dp = new int[strs.length + 1][m + 1][n + 1];\r\n        for (int i = 1; i <= strs.length; i++) {\r\n            int[] cost = count(strs[i - 1]);\r\n            for (int j = 0; j <= m; j++) {\r\n                for (int k = 0; k <= n; k++) {\r\n                    if (j >= cost[0] && k >= cost[1]) {\r\n                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - cost[0]][k - cost[1]] + 1);\r\n                    } else {\r\n                        dp[i][j][k] = dp[i - 1][j][k];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[strs.length][m][n];\r\n    }\r\n\r\n    public int[] count(String str) {\r\n        int[] cost = new int[2];\r\n        for (int i = 0; i < str.length(); i++)\r\n            cost[str.charAt(i) - '0']++;\r\n        return cost;\r\n    }\r\n};\r\n// 方法二 进行空间复杂度优化：\r\npublic class Solution {\r\n    public int findMaxForm(String[] strs, int m, int n) {\r\n        int[][] dp = new int[m + 1][n + 1];\r\n        for (String s : strs) {\r\n            int[] cost = count(s);\r\n            for (int i = m; i >= cost[0]; i--)\r\n                for (int j = n; j >= cost[1]; j--)\r\n                    dp[i][j] = Math.max(dp[i][j], dp[i - cost[0]][j - cost[1]] + 1);\r\n        }\r\n        return dp[m][n];\r\n    }\r\n\r\n    public int[] count(String str) {\r\n        int[] cost = new int[2];\r\n        for (int i = 0; i < str.length(); i++)\r\n            cost[str.charAt(i) - '0']++;\r\n        return cost;\r\n    }\r\n};"}]},{"id":685,"unique_name":"guess-number-game-ii","title":"猜数游戏 II","description":"我们正在玩猜数游戏, 游戏内容如下:\n我在 1到 n 的范围内选择一个数作为待猜的数, 你需要来猜这个数,\n每次你猜错的时候, 我会告诉你我选择的这个数是比你说的数要高还是低, \n但是, 当你猜这个数为 x 并且猜错的时候你需要支付 $x. 当你猜到我选择的数时, 你将赢得这场游戏 ","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param n an integer\n     * @return how much money you need to have to guarantee a win\n     */\n    public int getMoneyAmount(int n) {\n        // Write your code here\n        int[][] dp = new int[n + 1][n + 1];\n        for (int len = 2; len <= n; len++) {\n            for (int start = 1; start <= n - len + 1; start++) {\n                int temp = Integer.MAX_VALUE;\n                for (int k = start + (len - 1) / 2; k < start + len - 1; k++) {\n                    int res = k + Math.max(dp[start][k - 1], dp[k + 1][start + len - 1]);\n                    temp = Math.min(res, temp);\n                }\n                dp[start][start + len - 1] = temp;\n            }\n\n        }\n        return dp[1][n];\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n an integer\n     * @return how much money you need to have to guarantee a win\n     */\n    int getMoneyAmount(int n) {\n        // Write your code here\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n        for (int len = 2; len <= n; len++) {\n            for (int start = 1; start <= n - len + 1; start++) {\n                int temp = INT_MAX;\n                for (int k = start + (len - 1) / 2; k < start + len - 1; k++) {\n                    int res = k + max(dp[start][k - 1], dp[k + 1][start + len - 1]);\n                    temp = min(res, temp);\n                }\n                dp[start][start + len - 1] = temp;\n            }\n\n        }\n        return dp[1][n];\n    }\n};"},{"language":"python","code":"class Solution:\n    # @param {int} n an integer\n    # @return {int} how much money you need to have to guarantee a win\n    def getMoneyAmount(self, n):\n        # Write your code here\n        dp = [[0 for _ in xrange(n + 1)] for __ in xrange(n + 1)]\n        for len in range(2, n + 1):\n            for start in range(1, n - len + 2):\n                import sys\n                temp = sys.maxint\n                for k in range(start + (len - 1) / 2, start + len - 1):\n                    res = k + max(dp[start][k - 1], dp[k + 1][start + len - 1])\n                    temp = min(res, temp)\n                dp[start][start + len - 1] = temp\n\n        return dp[1][n]"}]},{"id":673,"unique_name":"range-sum-query-2d-immutable","title":"平面范围求和 -不可变矩阵","description":"给一 二维矩阵,计算由左上角 `(row1, col1)` 和右下角 `(row2, col2)` 划定的矩形内元素和.","solutions":[{"language":"java","code":"public class NumMatrix {\r\n\r\n    private int[][] dp = null;\r\n\r\n    public NumMatrix(int[][] matrix) {\r\n        if (matrix.length == 0 || matrix[0].length == 0) {\r\n            return;\r\n        }\r\n        int n = matrix.length;\r\n        int m = matrix[0].length;\r\n        \r\n        dp = new int[n + 1][m + 1];\r\n        for (int r = 0; r < n; r++) {\r\n            for (int c = 0; c < m; c++) {\r\n                dp[r + 1][c + 1] = dp[r + 1][c] + dp[r][c + 1] + matrix[r][c] - dp[r][c];\r\n            }\r\n        }\r\n    }\r\n    \r\n    public int sumRegion(int row1, int col1, int row2, int col2) {\r\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\r\n    }\r\n}\r\n\r\n/**\r\n * Your NumMatrix object will be instantiated and called as such:\r\n * NumMatrix obj = new NumMatrix(matrix);\r\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\r\n */"},{"language":"cpp","code":"class NumMatrix {\r\nprivate:\r\n    vector<vector<int>> dp;\r\n\r\npublic:\r\n    NumMatrix(vector<vector<int>> matrix) {\r\n        if (matrix.size() == 0 || matrix[0].size() == 0) {\r\n            return;\r\n        }\r\n        int n = matrix.size();\r\n        int m = matrix[0].size();\r\n        \r\n        dp.resize(n + 1, vector<int>(m + 1, 0));\r\n        for (int r = 0; r < n; r++) {\r\n            for (int c = 0; c < m; c++) {\r\n                dp[r + 1][c + 1] = dp[r + 1][c] + dp[r][c + 1] + matrix[r][c] - dp[r][c];\r\n            }\r\n        }\r\n    }\r\n    \r\n    int sumRegion(int row1, int col1, int row2, int col2) {\r\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\r\n    }\r\n};\r\n\r\n/**\r\n * Your NumMatrix object will be instantiated and called as such:\r\n * NumMatrix obj = new NumMatrix(matrix);\r\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\r\n */"},{"language":"python","code":"class NumMatrix(object):\r\n\r\n    # @param {int[][]} matrix a 2D matrix\r\n    def __init__(self, matrix):\r\n        # Write your code here\r\n\r\n        if len(matrix) == 0 or len(matrix[0]) == 0:\r\n            return \r\n        \r\n        n = len(matrix)\r\n        m = len(matrix[0])\r\n        \r\n        self.dp  = [[0] * (m + 1) for _ in range(n + 1)]\r\n        for r in range(n):\r\n            for c in range(m):\r\n                self.dp[r + 1][c + 1] = self.dp[r + 1][c] + self.dp[r][c + 1] + \\\r\n                    matrix[r][c] - self.dp[r][c]\r\n\r\n        \r\n    # @param {int} row1 an integer\r\n    # @param {int} col1 an integer\r\n    # @param {int} row2 an integer\r\n    # @param {int} row2 an integer\r\n    # @return {int} the sum of region\r\n    def sumRegion(self, row1, col1, row2, col2):\r\n        # Write your code here\r\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - \\\r\n            self.dp[row2 + 1][col1] + self.dp[row1][col1]\r\n        \r\n\r\n\r\n# Your NumMatrix object will be instantiated and called as such:\r\n# obj = NumMatrix(matrix)\r\n# param_1 = obj.sumRegion(row1,col1,row2,col2)"}]},{"id":558,"unique_name":"partition-equal-subset-sum","title":"划分和相等的子集","description":"给一 `只含有正整数` 的 `非空` 数组, 找到这个数组是否可以划分为 `两个` 元素和相等的子集。","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean canPartition(int[] nums) {\r\n        int len = nums.length;\r\n        int sum = 0;\r\n        for(int i = 0; i < len ; i++ ){\r\n            sum += nums[i];\r\n        }\r\n        if(sum % 2 == 1){\r\n            return false;\r\n        }\r\n        sum /= 2;\r\n        boolean [] dp = new boolean[20000];\r\n        for(int i = 0; i <=sum ; i ++)\r\n            dp[i] = false;\r\n        dp[0] = true;\r\n        for(int i = 0; i < len; i++){\r\n            for(int j= sum ; j >= nums[i]; j--){\r\n                dp[j] |= dp[j - nums[i]];\r\n            }\r\n        }\r\n        return dp[sum];\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n        int len = nums.size();\r\n        int sum = 0;\r\n        for(int i=0; i< len ; i++){\r\n            sum += nums[i];\r\n        }\r\n        if(sum % 2 == 1 ){\r\n            return false;\r\n        } \r\n        sum /= 2;\r\n        int * dp = new int[20000];\r\n        for(int i=0; i <=sum; i++)\r\n            dp[i] = 0;\r\n        dp[0] = 1;\r\n        for(int i=0; i < len; i++){\r\n            for(int j = sum;j >= nums[i]; j--){\r\n                dp[j] |= dp[j - nums[i]];\r\n            }\r\n        }\r\n        return dp[sum];\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution(object):\r\n    def canPartition(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: bool\r\n        \"\"\"\r\n        length = len(nums)\r\n        mySum =  sum(nums);\r\n        if mySum % 2 == 1:\r\n            return False\r\n        mySum /= 2\r\n        dp = [False for x in range(20000)]\r\n        dp[0] = True\r\n        for i in range(0,length):\r\n            for j in range(mySum, nums[i] - 1, -1):\r\n                dp[j] |= dp[j - nums[i]]\r\n        return dp[mySum]"}]},{"id":509,"unique_name":"largest-divisible-subset","title":"最大整除子集","description":"给一个由 `无重复的正整数` 组成的集合，找出满足任意两个元素 `(Si, Sj)` 都有 `Si % Sj = 0` 或 `Sj % Si = 0` 成立的最大子集","solutions":[{"language":"java","code":"public class Solution {\r\n    public List<Integer> largestDivisibleSubset(int[] nums) {\r\n        Arrays.sort(nums);\r\n        int[] f = new int[nums.length];\r\n        int[] pre = new int[nums.length];\r\n        for (int i = 0; i < nums.length; i++) {\r\n            f[i] = 1;\r\n            pre[i] = i;\r\n            for (int j = 0; j < i; j++) {\r\n                if (nums[i] % nums[j] == 0 && f[i] < f[j] + 1) {\r\n                    f[i] = f[j] + 1;\r\n                    pre[i] = j;\r\n                }\r\n            }\r\n        }\r\n        \r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        if (nums.length == 0) {\r\n            return ans;\r\n        }\r\n        int max = 0;\r\n        int max_i = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (f[i] > max) {\r\n                max = f[i];\r\n                max_i = i;\r\n            }\r\n        }\r\n        ans.add(nums[max_i]);\r\n        while (max_i != pre[max_i]) {\r\n            max_i = pre[max_i];\r\n            ans.add(nums[max_i]);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums a set of distinct positive integers\r\n     * @return the largest subset \r\n     */\r\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\r\n        // Write your code here\r\n        sort(nums.begin(), nums.end());\r\n        \r\n        vector<int> dp(nums.size(), 0);\r\n        vector<int> father(nums.size(), 0);\r\n        \r\n        int n = nums.size();\r\n        int m = 0;\r\n        int index = -1;\r\n        \r\n        for(int i = 0; i < n; ++i) {\r\n            father[i] = -1;\r\n            dp[i] = 1;\r\n\r\n            for(int j = 0; j < i; ++j) {\r\n                if(nums[i] % nums[j] == 0 && dp[i] < 1 + dp[j]) {\r\n                    dp[i] = 1 + dp[j];\r\n                    father[i] = j;\r\n                }\r\n            }\r\n                    \r\n            if(dp[i] >= m) {\r\n                m = dp[i];\r\n                index = i;\r\n            }\r\n        }\r\n        \r\n        vector<int> result;\r\n        for(int i = 0; i < m; ++i) {\r\n            result.push_back(nums[index]);\r\n            index = father[index];\r\n        }\r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums a set of distinct positive integers\r\n    # @return {int[]} the largest subset \r\n    def largestDivisibleSubset(self, nums):\r\n        # Write your code here\r\n        n = len(nums)\r\n        dp = [1] * n\r\n        father = [-1] * n\r\n\r\n        nums.sort()\r\n        m, index = 0, -1\r\n        for i in xrange(n):\r\n            for j in xrange(i):\r\n                if nums[i] % nums[j] == 0:\r\n                    if 1 + dp[j] > dp[i]:\r\n                        dp[i] = dp[j] + 1\r\n                        father[i] = j\r\n\r\n            if dp[i] >= m:\r\n                m = dp[i]\r\n                index = i\r\n\r\n        result = []\r\n        for i in xrange(m):\r\n            result.append(nums[index])\r\n            index = father[index]\r\n\r\n        return result"}]},{"id":557,"unique_name":"frog-jump","title":"青蛙跳","description":"一只青蛙正要过河，这条河分成了 x 个单位，每个单位可能存在石头，青蛙可以跳到石头上，但它不能跳进水里。\n按照顺序给出石头所在的位置，判断青蛙能否到达最后一块石头所在的位置。刚开始时青蛙在第一块石头上，假设青蛙第一次跳只能跳一个单位的长度。\n如果青蛙最后一个跳 k 个单位，那么它下一次只能跳 `k - 1` ，`k` 或者 `k + 1` 个单位。注意青蛙只能向前跳。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param stones a list of stones' positions in sorted ascending order\r\n     * @return true if the frog is able to cross the river or false\r\n     */\r\n    public boolean canCross(int[] stones) {\r\n        // Write your code here\r\n        HashMap<Integer, HashSet<Integer>> dp =\r\n            new HashMap<Integer, HashSet<Integer>>(stones.length);\r\n        for (int i = 0; i < stones.length; i++) {\r\n        \tdp.put(stones[i], new HashSet<Integer>() );\r\n        }\r\n        dp.get(0).add(0);\r\n\r\n        for (int i = 0; i < stones.length - 1; ++i) {\r\n        \tint stone = stones[i];\r\n        \tfor (int k : dp.get(stone)) {\r\n                // k - 1\r\n                if (k - 1 > 0 && dp.containsKey(stone + k - 1))\r\n                    dp.get(stone + k - 1).add(k - 1);\r\n                // k\r\n                if (dp.containsKey(stone + k))\r\n                    dp.get(stone + k).add(k);\r\n                // k + 1\r\n                if (dp.containsKey(stone + k + 1))\r\n                    dp.get(stone + k + 1).add(k + 1);\r\n        \t}\r\n        }\r\n        \r\n        return !dp.get(stones[stones.length - 1]).isEmpty();\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param stones a list of stones' positions in sorted ascending order\r\n     * @return true if the frog is able to cross the river or false\r\n     */\r\n    bool canCross(vector<int>& stones) {\r\n        // Write your code here\r\n        unordered_map<int, unordered_set<int>> dp;\r\n        for (auto position : stones)\r\n            dp[position] = unordered_set<int>();\r\n        dp[0].insert(0);\r\n        for (auto position : stones) {\r\n            for (auto k : dp[position]) {\r\n                // k - 1\r\n                if (k - 1 > 0 && dp.find(position + k - 1) != dp.end())\r\n                    dp[position + k - 1].insert(k - 1);\r\n                // k\r\n                if (dp.find(position + k) != dp.end())\r\n                    dp[position + k].insert(k);\r\n                // k + 1\r\n                if (dp.find(position + k + 1) != dp.end())\r\n                    dp[position + k + 1].insert(k + 1);\r\n            }\r\n        }\r\n        return !dp[stones.back()].empty();\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} stones a list of stones' positions in sorted ascending order\r\n    # @return {boolean} true if the frog is able to cross the river or false\r\n    def canCross(self, stones):\r\n        # Write your code here\r\n        dp = {}\r\n        for stone in stones:\r\n            dp[stone] = set([])\r\n\r\n        dp[0].add(0)\r\n\r\n        for stone in stones:\r\n            for k in dp[stone]:\r\n                # k - 1\r\n                if k - 1 > 0 and stone + k - 1 in dp:\r\n                    dp[stone + k - 1].add(k - 1)\r\n                # k\r\n                if stone + k in dp:\r\n                    dp[stone + k].add(k)\r\n                # k + 1\r\n                if stone + k + 1 in dp:\r\n                    dp[stone + k + 1].add(k + 1)\r\n   \r\n        return len(dp[stones[-1]]) > 0"}]},{"id":495,"unique_name":"backpack-vi","title":"背包问题 VI","description":"给出一个都是正整数的数组 `nums`，其中没有重复的数。从中找出所有的和为 `target` 的组合个数。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums an integer array and all positive numbers, no duplicates\r\n     * @param target an integer\r\n     * @return an integer\r\n     */\r\n    public int backPackVI(int[] nums, int target) {\r\n        // Write your code here\r\n        int[] f = new int[target + 1];\r\n        f[0] = 1;\r\n        for (int i = 1; i <= target; ++i)\r\n            for (int  j = 0; j < nums.length; ++j)\r\n                if (i >= nums[j])\r\n                    f[i] += f[i - nums[j]];\r\n\r\n        return f[target];\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums an integer array and all positive numbers, no duplicates\r\n     * @param target an integer\r\n     * @return an integer\r\n     */\r\n    int backPackVI(vector<int>& nums, int target) {\r\n        // Write your code here\r\n        vector<int> dp(target + 1);\r\n        dp[0] = 1;\r\n        for (int i = 1; i <= target; ++i) {\r\n            for (auto a : nums)\r\n            if (i >= a) {\r\n                dp[i] += dp[i - a];\r\n            }\r\n        }\r\n        return dp.back();\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums an integer array and all positive numbers, no duplicates\r\n    # @param {int} target an integer\r\n    # @return {int} an integer\r\n    def backPackVI(self, nums, target):\r\n        # Write your code here\r\n        dp = [0 for i in xrange(target + 1)]\r\n        dp[0] = 1\r\n        \r\n        for j in xrange(1, target+1):\r\n            for a in nums:\r\n                if j >= a:\r\n                    dp[j] += dp[j - a]\r\n\r\n        return dp[target]\r\n"}]},{"id":497,"unique_name":"bomb-enemy","title":"炸弹袭击","description":"给一个二维矩阵, 每一个格子都可能是一堵墙 `W`, 一个敌人 `E` 或者空 `0` (数字 '0'), 返回你可以用一个炸弹杀死的最大敌人数. 炸弹会杀死所有在同一行和同一列没有墙阻隔的敌人, 因为墙比较坚固难以摧毁.","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param grid Given a 2D grid, each cell is either 'W', 'E' or '0'\r\n     * @return an integer, the maximum enemies you can kill using one bomb\r\n     */\r\n    public int maxKilledEnemies(char[][] grid) {\r\n        // Write your code here\r\n        int m = grid.length;\r\n        int n = m > 0 ? grid[0].length : 0;\r\n\r\n        int result = 0, rows = 0;\r\n        int[] cols = new int[n];\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (j == 0 || grid[i][j-1] == 'W') {\r\n                    rows = 0;\r\n                    for (int k = j; k < n && grid[i][k] != 'W'; ++k)\r\n                        if (grid[i][k] == 'E')\r\n                            rows += 1;\r\n                }\r\n                if (i == 0 || grid[i-1][j] == 'W') {\r\n                    cols[j] = 0;\r\n                    for (int k = i; k < m && grid[k][j] != 'W'; ++k)\r\n                        if (grid[k][j] == 'E')\r\n                            cols[j] += 1;\r\n                }\r\n\r\n                if (grid[i][j] == '0' && rows + cols[j] > result)\r\n                    result = rows + cols[j];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// 方法二\r\npublic class Solution {\r\n    /**\r\n     * @param grid Given a 2D grid, each cell is either 'W', 'E' or '0'\r\n     * @return an integer, the maximum enemies you can kill using one bomb\r\n     */\r\n    public int maxKilledEnemies(char[][] A) {\r\n        if (A == null || A.length == 0 || A[0].length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int m = A.length;\r\n        int n = A[0].length;\r\n        int[][] up = new int[m][n];\r\n        int[][] down = new int[m][n];\r\n        int[][] left = new int[m][n];\r\n        int[][] right = new int[m][n];\r\n        int i, j, t;\r\n        \r\n        for (i = 0; i < m; ++i) {\r\n            for (j = 0; j < n; ++j) {\r\n                up[i][j] = 0;\r\n                if (A[i][j] != 'W') {\r\n                    if (A[i][j] == 'E') {\r\n                        up[i][j] = 1;\r\n                    }\r\n                    \r\n                    if (i - 1 >= 0) {\r\n                        up[i][j] += up[i-1][j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        for (i = m - 1; i >= 0; --i) {\r\n            for (j = 0; j < n; ++j) {\r\n                down[i][j] = 0;\r\n                if (A[i][j] != 'W') {\r\n                    if (A[i][j] == 'E') {\r\n                        down[i][j] = 1;\r\n                    }\r\n                    \r\n                    if (i + 1 < m) {\r\n                        down[i][j] += down[i+1][j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        for (i = 0; i < m; ++i) {\r\n            for (j = 0; j < n; ++j) {\r\n                left[i][j] = 0;\r\n                if (A[i][j] != 'W') {\r\n                    if (A[i][j] == 'E') {\r\n                        left[i][j] = 1;\r\n                    }\r\n                    \r\n                    if (j - 1 >= 0) {\r\n                        left[i][j] += left[i][j-1];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        for (i = 0; i < m; ++i) {\r\n            for (j = n - 1; j >= 0; --j) {\r\n                right[i][j] = 0;\r\n                if (A[i][j] != 'W') {\r\n                    if (A[i][j] == 'E') {\r\n                        right[i][j] = 1;\r\n                    }\r\n                    \r\n                    if (j + 1 < n) {\r\n                        right[i][j] += right[i][j+1];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        int res = 0;\r\n        for (i = 0; i < m; ++i) {\r\n            for (j = 0; j < n; ++j) {\r\n                if (A[i][j] == '0') {\r\n                    t = up[i][j] + down[i][j] + left[i][j] + right[i][j];\r\n                    if (t > res) {\r\n                        res = t;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param grid Given a 2D grid, each cell is either 'W', 'E' or '0'\r\n     * @return an integer, the maximum enemies you can kill using one bomb\r\n     */\r\n     \r\n    int maxKilledEnemies(vector<vector<char>>& grid) {\r\n        // Write your code here\r\n        int n = grid.size();\r\n        int m = n > 0 ? grid[0].size() : 0;\r\n        \r\n        int left[n+2][m+2], right[n+2][m+2], up[n+2][m+2], down[n+2][m+2];\r\n        memset(left, 0, sizeof(left));\r\n        memset(right, 0, sizeof(right));\r\n        memset(up, 0, sizeof(up));\r\n        memset(down, 0, sizeof(down));\r\n        \r\n        // left\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if (grid[i-1][j-1] == 'E') {\r\n                    left[i][j] = left[i][j-1] + 1;\r\n                } else if (grid[i-1][j-1] == 'W') {\r\n                    left[i][j] = 0;\r\n                } else {\r\n                    left[i][j] = left[i][j-1];\r\n                }\r\n            }\r\n        }\r\n        \r\n        // up\r\n        for (int j = 1; j <= m; j++) {\r\n            for (int i = 1; i <= n; i++) {\r\n                if (grid[i-1][j-1] == 'E') {\r\n                    up[i][j] = up[i-1][j] + 1;\r\n                } else if (grid[i-1][j-1] == 'W') {\r\n                    up[i][j] = 0;\r\n                } else {\r\n                    up[i][j] = up[i-1][j];\r\n                }\r\n            }\r\n        }\r\n        \r\n        // right\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = m; j >= 1; j--) {\r\n                if (grid[i-1][j-1] == 'E') {\r\n                    right[i][j] = right[i][j+1] + 1;\r\n                } else if (grid[i-1][j-1] == 'W') {\r\n                    right[i][j] = 0;\r\n                } else {\r\n                    right[i][j] = right[i][j+1];\r\n                }\r\n            }\r\n        }\r\n        \r\n        // down\r\n        for (int i = n; i >= 1; i--) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if (grid[i-1][j-1] == 'E') {\r\n                    down[i][j] = down[i+1][j] + 1;\r\n                } else if (grid[i-1][j-1] == 'W') {\r\n                    down[i][j] = 0;\r\n                } else {\r\n                    down[i][j] = down[i+1][j];\r\n                }\r\n            }\r\n        }\r\n        \r\n        int result = 0;\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if(grid[i-1][j-1] == '0') {\r\n                    result = max(result, left[i][j] + right[i][j] + up[i][j] + down[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {character[][]} grid Given a 2D grid, each cell is either 'W', 'E' or '0'\r\n    # @return {int} an integer, the maximum enemies you can kill using one bomb\r\n    def maxKilledEnemies(self, grid):\r\n        # Write your code here\r\n        m, n = len(grid), 0\r\n        if m:\r\n            n = len(grid[0])\r\n        result, rows = 0, 0\r\n        cols = [0 for i in xrange(n)]\r\n\r\n        for i in xrange(m):\r\n            for j in xrange(n):\r\n                if j == 0 or grid[i][j-1] == 'W':\r\n                    rows = 0\r\n                    for k in xrange(j, n):\r\n                        if grid[i][k] == 'W':\r\n                            break\r\n                        if grid[i][k] == 'E':\r\n                            rows += 1\r\n\r\n                if i == 0 or grid[i-1][j] == 'W':\r\n                    cols[j] = 0\r\n                    for k in xrange(i, m):\r\n                        if grid[k][j] == 'W':\r\n                            break\r\n                        if grid[k][j] == 'E':\r\n                            cols[j] += 1\r\n\r\n                if grid[i][j] == '0' and rows + cols[j] > result:\r\n                    result = rows + cols[j]\r\n\r\n        return result\r\n"}]},{"id":462,"unique_name":"house-robber-ii","title":"打劫房屋 II","description":"在上次打劫完一条街道之后，窃贼又发现了一个新的可以打劫的地方，**但这次所有的房子围成了一个圈，这就意味着第一间房子和最后一间房子是挨着的**。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：**相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警**。\r\n\r\n给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 在不触动报警装置的情况下。","solutions":[{"language":"java","code":"public class Solution {\r\n    public int houseRobber2(int[] nums) {\r\n        if (nums.length == 0) {\r\n            return 0;\r\n        }\r\n        if (nums.length == 1) {\r\n            return nums[0];\r\n        }\r\n        return Math.max(robber1(nums, 0, nums.length - 2), robber1(nums, 1, nums.length - 1));\r\n    }\r\n    public int robber1(int[] nums, int st, int ed) {\r\n        int []res = new int[2];\r\n        if(st == ed) \r\n            return nums[ed];\r\n        if(st+1 == ed)\r\n            return Math.max(nums[st], nums[ed]);\r\n        res[st%2] = nums[st];\r\n        res[(st+1)%2] = Math.max(nums[st], nums[st+1]);\r\n        \r\n        for(int i = st+2; i <= ed; i++) {\r\n            res[i%2] = Math.max(res[(i-1)%2], res[(i-2)%2] + nums[i]);\r\n            \r\n        }\r\n        return res[ed%2];\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: An array of non-negative integers.\r\n     * return: The maximum amount of money you can rob tonight\r\n     */\r\n    int houseRobber2(vector<int>& nums) {\r\n        // write your code here\r\n        int n = nums.size();\r\n        if (n == 0)\r\n            return 0;\r\n        if (n == 1)\r\n            return nums[0];\r\n\r\n        vector<int> dp(n);\r\n        \r\n        dp[0] = 0;\r\n        dp[1] = nums[1];\r\n        for (int i = 2; i < n; ++i)\r\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\r\n\r\n        int answer = dp[n - 1];\r\n\r\n        dp[0] = nums[0];\r\n        dp[1] = max(dp[0], nums[1]);\r\n        for (int i = 2; i < n; ++i)\r\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\r\n\r\n        return max(dp[n - 2], answer);\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param nums: A list of non-negative integers.\r\n    # return: an integer\r\n    def houseRobber2(self, nums):\r\n        # write your code here\r\n        n = len(nums)\r\n        if n == 0:\r\n            return 0\r\n        if n == 1:\r\n            return nums[0]\r\n\r\n        dp = [0] * n\r\n        \r\n        dp[0], dp[1] = 0, nums[1]\r\n        for i in xrange(2, n):\r\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\r\n\r\n        answer = dp[n - 1]\r\n\r\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\r\n        for i in xrange(2, n):\r\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\r\n\r\n        return max(dp[n - 2], answer)\r\n"}]},{"id":666,"unique_name":"paint-house","title":"房屋染色","description":"这里有`n`个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小。\r\n\r\n费用通过一个`n`x`3` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染红色的费用，`cost[1][2]`表示房屋`1`染绿色的费用。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param costs n x 3 cost matrix\r\n     * @return an integer, the minimum cost to paint all houses\r\n     */\r\n    public int minCost(int[][] costs) {\r\n        int n = costs.length;\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        int[][] f = new int[2][3];\r\n        int old, now = 0;\r\n        f[now][0] = f[now][1] = f[now][2] = 0;\r\n        \r\n        int i, j, k;\r\n        for (i = 1; i <= n; ++i) {\r\n            old = now;\r\n            now = 1 - now;\r\n            for (j = 0; j < 3; ++j) {\r\n                f[now][j] = Integer.MAX_VALUE;\r\n                for (k = 0; k < 3; ++k) {\r\n                    if (k != j && f[old][k] + costs[i-1][j] < f[now][j]) {\r\n                        f[now][j] = f[old][k] + costs[i-1][j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        int res = f[now][0];\r\n        if (f[now][1] < res) {\r\n            res = f[now][1];\r\n        }\r\n        \r\n        if (f[now][2] < res) {\r\n            res = f[now][2];\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n"}]},{"id":658,"unique_name":"paint-fence","title":"栅栏染色","description":"我们有一个栅栏，它有`n`个柱子，现在要给柱子染色，有`k`种颜色可以染。\n必须保证不存在超过2个相邻的柱子颜色相同，求有多少种染色方案。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n non-negative integer, n posts\r\n     * @param k non-negative integer, k colors\r\n     * @return an integer, the total number of ways\r\n     */\r\n    public int numWays(int n, int k) {\r\n        // Write your code here\r\n        int dp[] = {0, k , k*k, 0};\r\n        if(n <= 2)\r\n            return dp[n];\r\n        if (k == 1)\r\n            return 0;\r\n        for(int i = 2; i < n; i++) {\r\n            dp[3] = (k - 1) * (dp[1] + dp[2]);\r\n            dp[1] = dp[2];\r\n            dp[2] = dp[3];\r\n        }\r\n        return dp[3];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n non-negative integer, n posts\r\n     * @param k non-negative integer, k colors\r\n     * @return an integer, the total number of ways\r\n     */\r\n    int numWays(int n, int k) {\r\n        // Write your code here\r\n        vector<int> dp = {0, k, k * k, 0};\r\n        if (n <= 2)\r\n            return dp[n];\r\n        if (k == 1)\r\n            return 0;\r\n        for (int i = 3; i <= n; ++i) {\r\n            dp[3] = (k - 1) * (dp[1] + dp[2]);\r\n            dp[1] = dp[2];\r\n            dp[2] = dp[3];\r\n        }\r\n        return dp[3];\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n non-negative integer, n posts\r\n    # @param {int} k non-negative integer, k colors\r\n    # @return {int} an integer, the total number of ways\r\n    def numWays(self, n, k):\r\n        # Write your code here\r\n        dp = [0, k, k * k]\r\n        if n <= 2:\r\n            return dp[n]\r\n        if k == 1 and n >= 3:\r\n            return 0\r\n        for i in xrange(2, n):\r\n            dp.append((k - 1) * (dp[-1] + dp[-2]))\r\n\r\n        return dp[-1]"},{"language":"javascript","code":"const numWays = function (n, k) {\n    var dp, i;\n    dp = [0, k, k * k, 0];\n    if (n <= 2) {\n        return dp[n];\n    }\n    if (k === 1) {\n        return 0;\n    }\n    for (i = 2; i < n; i++) {\n        dp[3] = (k - 1) * (dp[1] + dp[2]);\n        dp[1] = dp[2];\n        dp[2] = dp[3];\n    }\n    return dp[3];\n}"}]},{"id":500,"unique_name":"perfect-squares","title":"完美平方","description":"给一个正整数 n, 找到若干个完全平方数(比如1, 4, 9, ... )使得他们的和等于 n。你需要让平方数的个数最少。\r\n","solutions":[{"language":"java","code":"// version 0 DP\r\npublic class Solution {\r\n    /**\r\n     * @param n a positive integer\r\n     * @return an integer\r\n     */\r\n    public int numSquares(int n) {\r\n        // Write your code here\r\n        int[] dp = new int[n + 1];\r\n        Arrays.fill(dp, Integer.MAX_VALUE);\r\n        for(int i = 0; i * i <= n; ++i) {\r\n            dp[i * i] = 1;\r\n        }\r\n\r\n        for (int i = 0; i <= n; ++i) {\r\n            for (int j = 1; j * j <= i; ++j) {\r\n                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\r\n            }\r\n        }\r\n\r\n        return dp[n];\r\n    }\r\n}\r\n\r\n// version 1 DP \r\npublic class Solution {\r\n    /**\r\n     * @param n a positive integer\r\n     * @return an integer\r\n     */\r\n    public int numSquares(int n) {\r\n        // Write your code here\r\n        int[] dp = new int[n + 1];\r\n        Arrays.fill(dp, Integer.MAX_VALUE);\r\n        for(int i = 0; i * i <= n; ++i)\r\n            dp[i * i] = 1;\r\n\r\n        for (int i = 0; i <= n; ++i)\r\n            for (int j = 0; i + j * j <= n; ++j)\r\n                dp[i + j * j] = Math.min(dp[i] + 1, dp[i + j * j]);\r\n\r\n        return dp[n];\r\n    }\r\n}\r\n\r\n// version 2  Math\r\npublic class Solution {\r\n    /**\r\n     * @param n a positive integer\r\n     * @return an integer\r\n     */\r\n    public int numSquares(int n) {\r\n        // Write your code here\r\n        while (n % 4 == 0)\r\n            n /= 4;\r\n        if (n % 8 == 7)\r\n            return 4;\r\n        for (int i = 0; i * i <= n; ++i) {\r\n            int j = (int)Math.sqrt(n * 1.0 - i * i);\r\n            if (i * i + j * j == n) {\r\n                int res = 0;\r\n                if (i > 0)\r\n                    res += 1;\r\n                if (j > 0)\r\n                    res += 1;\r\n                return res;\r\n            }\r\n        }\r\n        return 3;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"// version 1\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param n a positive integer\r\n     * @return an integer\r\n     */\r\n    int numSquares(int n) {\r\n        // Write your code here\r\n        vector<int> dp{ 0 };\r\n        dp.resize(n + 1, INT_MAX);\r\n        for (int i = 1, k; (k = i * i) <= n; ++i)\r\n            for (int j = k; j <= n; ++j)\r\n                if (dp[j] > dp[j - k] + 1)\r\n                    dp[j] = dp[j - k] + 1;\r\n        return dp[n];\r\n    }\r\n};\r\n\r\n\r\n// version 2 Math\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param n a positive integer\r\n     * @return an integer\r\n     */\r\n    int numSquares(int n) {\r\n        // Write your code here\r\n        int ub = sqrt(n);\r\n        for (int a = 0; a <= ub; ++a) {\r\n            for (int b = a; b <= ub; ++b) {\r\n            int c = sqrt(n - a * a - b * b);\r\n                if (a * a + b * b + c * c == n)\r\n                    return !!a + !!b + !!c;\r\n            }\r\n        }\r\n        return 4;\r\n    }\r\n};\r\n\r\n// version 3 Math II\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param n a positive integer\r\n     * @return an integer\r\n     */\r\n    int numSquares(int n) {\r\n        // Write your code here\r\n        while (n % 4 == 0)\r\n            n /= 4;\r\n        if (n % 8 == 7)\r\n            return 4;\r\n        for (int i = 0; i * i <= n; ++i) {\r\n            int j = sqrt(n - i * i);\r\n            if (i * i + j * j == n)\r\n                return !!i + !!j;\r\n        }\r\n        return 3;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int} n a positive integer\r\n    # @return {int} an integer\r\n    def numSquares(self, n):\r\n        # Write your code here\r\n        while n % 4 == 0:\r\n            n /= 4\r\n        if n % 8 == 7:\r\n            return 4\r\n\r\n        for i in xrange(n+1):\r\n            temp = i * i\r\n            if temp <= n:\r\n                if int((n - temp)** 0.5 ) ** 2 + temp == n: \r\n                    return 1 + (0 if temp == 0 else 1)\r\n            else:\r\n                break\r\n        return 3\r\n"},{"language":"javascript","code":"const numSquares = function (n) {\n    var i, j, res;\n    while (n % 4 === 0) {\n        n /= 4;\n    }\n    if (n % 8 === 7) {\n        return 4;\n    }\n    for (i = 0; i * i <= n; ++i) {\n        j = Math.floor(Math.sqrt(n * 1.0 - i * i));\n        if (i * i + j * j === n) {\n            res = 0;\n            if (i > 0) {\n                res += 1;\n            }\n            if (j > 0) {\n                res += 1;\n            }\n            return res;\n        }\n    }\n    return 3;\n}"}]},{"id":139,"unique_name":"decode-ways","title":"解码方法","description":"有一个消息包含`A-Z`通过以下规则编码\r\n```\r\n'A' -> 1\r\n'B' -> 2\r\n...\r\n'Z' -> 26\r\n```\r\n现在给你一个加密过后的消息，问有几种解码的方式","solutions":[{"language":"java","code":"public class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int[] nums = new int[s.length() + 1];\n        nums[0] = 1;\n        nums[1] = s.charAt(0) != '0' ? 1 : 0;\n        for (int i = 2; i <= s.length(); i++) {\n            if (s.charAt(i - 1) != '0') {\n                nums[i] = nums[i - 1];\n            }\n            \n            int twoDigits = (s.charAt(i - 2) - '0') * 10 + s.charAt(i - 1) - '0';\n            if (twoDigits >= 10 && twoDigits <= 26) {\n                nums[i] += nums[i - 2];\n            }\n        }\n        return nums[s.length()];\n    }\n}\n\n// version: 高频题班\npublic class Solution {\n    /**\n     * @param s a string,  encoded message\n     * @return an integer, the number of ways decoding\n     */\n    public int numDecodings(String s) {\n        // Write your code here\n        int l = s.length();\n        if (l == 0) {\n            return 0;   // only for this problem, but the ans should be 1\n        }\n        int[] f = new int[l + 1];\n        f[0] = 1;\n        char sc[] = s.toCharArray();\n\n        for (int i = 1; i <= l; i++) {\n            if (sc[i - 1] != '0') {\n                f[i] += f[i - 1];\n            }\n            if (i >= 2) {\n                int val2 = (sc[i - 2] - '0') * 10 + sc[i - 1] - '0';\n                if (10 <= val2 && val2 <= 26) {\n                    f[i] += f[i - 2];\n                }\n            }\n        }\n        return f[l];\n    }\n}\n\n// 记忆化搜索\n// 九章硅谷求职算法集训营版本\npublic class Solution {\n    /**\n     * @param s a string,  encoded message\n     * @return an integer, the number of ways decoding\n     */\n    char[] s = null;\n    int[] f = null;\n    int n;\n    \n    void calc(int i) {\n        if (f[i] != -1) {\n            return;\n        }\n        \n        if (i == 0) {\n            f[i] = 1;\n            return;    \n        }\n        \n        int t = s[i - 1] - '0';\n        f[i] = 0;\n        calc(i - 1);\n        \n        if (t >= 1 && t <= 9) {\n            f[i] += f[i - 1];\n        }\n        \n        if (i > 1) {\n            calc(i - 2);\n            t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';\n            if (t >= 10 && t <= 26) {\n                f[i] += f[i - 2];\n            }\n        }\n    }\n    \n    public int numDecodings(String ss) {\n        s = ss.toCharArray();\n        n = s.length;\n        if (n == 0) {\n            return 0;\n        }\n        \n        f = new int[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            f[i] = -1;\n        }\n        \n        calc(n);\n        return f[n];\n    }\n}"},{"language":"cpp","code":"// 高频题班version 1\r\nclass Solution {\r\npublic:\r\n  /**\r\n   * @param s a string,  encoded message\r\n   * @return an integer, the number of ways decoding\r\n   */\r\n  int numDecodings(string& s) {\r\n    // Write your code here\r\n    int l = s.length();\r\n    if (l == 0) {\r\n      return 0;   // only for this problem, but the ans should be 1\r\n    }\r\n    vector<int> f(l + 1);\r\n    f[0] = 1;\r\n    \r\n    for (int i = 0; i < l; i++) {\r\n      f[i + 1] = 0;\r\n      if (s[i] != '0') {\r\n        f[i + 1] += f[i];\r\n      }\r\n      if(i >= 1 && (s[i - 1] - '0') * 10 + s[i] - '0' <= 26 && s[i - 1] != '0') {\r\n                f[i + 1] += f[i - 1];\r\n            }\r\n        }\r\n        return f[l];\r\n        \r\n    }\r\n};\r\n\r\n\r\n// version 2\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param s a string,  encoded message\r\n     * @return an integer, the number of ways decoding\r\n     */\r\n    int numDecodings(string& s) {\r\n        // Write your code here\r\n        if (s.size() == 0)\r\n            return 0;\r\n        else if (s.size() == 1)\r\n            return s[0] != '0' ? 1 : 0;  \r\n          \r\n        int* dp = new int[s.size()];  \r\n        dp[0] = s[0] != '0' ? 1 : 0;  \r\n        dp[1] = (s[0] != '0' && s[1] != '0'? 1 : 0) +\r\n        ((s[0] != '0' && (toInt(s[0]) * 10 + toInt(s[1])) <= 26) ? 1 : 0);  \r\n          \r\n        for (int i = 2; i < s.size(); ++i) {  \r\n            dp[i] = 0;  \r\n            if(s[i] != '0')\r\n                dp[i] += dp[i-1];\r\n            if(s[i-1] != '0' && (toInt(s[i-1]) * 10 + toInt(s[i])) <= 26){  \r\n                dp[i] += dp[i-2];  \r\n            }  \r\n        }  \r\n          \r\n        return dp[s.size() - 1];  \r\n    }\r\n\r\n    int toInt(char c){  \r\n        return c - '0';\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {string} s a string,  encoded message\r\n    # @return {int} an integer, the number of ways decoding\r\n    def numDecodings(self, s):\r\n        # Write your code here\r\n        if s == \"\" or s[0] == '0':\r\n            return 0\r\n\r\n        dp=[1,1]\r\n        for i in range(2,len(s) + 1):\r\n            if 10 <= int(s[i - 2 : i]) <=26 and s[i - 1] != '0':\r\n                dp.append(dp[i - 1] + dp[i - 2])\r\n            elif int(s[i-2 : i]) == 10 or int(s[i - 2 : i]) == 20:\r\n                dp.append(dp[i - 2])\r\n            elif s[i-1] != '0':\r\n                dp.append(dp[i-1])\r\n            else:\r\n                return 0\r\n\r\n        return dp[len(s)]\r\n"}]},{"id":461,"unique_name":"burst-ballons","title":"吹气球","description":"有n个气球，编号为`0`到`n-1`，每个气球都有一个分数，存在`nums`数组中。每次吹气球i可以得到的分数为 `nums[left] * nums[i] * nums[right]`，left和right分别表示`i`气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。","solutions":[{"language":"java","code":"//记忆化\r\npublic class Solution {\r\n    public int maxCoins(int[] nums) {\r\n        int n = nums.length;\r\n        int [][]dp = new int [n+2][n+2];\r\n        int [][]visit = new int[n+2][n+2]; \r\n        int [] arr = new int [n+2];\r\n        for (int i = 1; i <= n; i++){\r\n        \tarr[i] = nums[i-1];\r\n        }\r\n        arr[0] = 1;\r\n        arr[n+1] = 1;\r\n        \r\n        return search(arr, dp, visit, 1 , n);\r\n    }\r\n    public int search(int []arr, int [][]dp, int [][]visit, int left, int right) {\r\n        if(visit[left][right] == 1)\r\n        \treturn dp[left][right];\r\n    \t\r\n    \tint res = 0;\r\n        for (int k = left; k <= right; ++k) {\r\n        \tint midValue =  arr[left - 1] * arr[k] * arr[right + 1];\r\n        \tint leftValue = search(arr, dp, visit, left, k - 1);\r\n        \tint rightValue = search(arr, dp, visit, k + 1, right);\r\n            res = Math.max(res, leftValue + midValue + rightValue);\r\n        }\r\n        visit[left][right] = 1;\r\n        dp[left][right] = res;\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n// 非递归 请见c++版本"},{"language":"cpp","code":"// 非递归， 记忆化搜索版本可以建java\r\nclass Solution {\r\npublic:\r\n    int maxCoins(vector<int>& nums) {\r\n        int n = nums.size();\r\n        nums.insert(nums.begin(), 1);\r\n        nums.push_back(1);\r\n        vector<vector<int> > dp(nums.size(), vector<int>(nums.size() , 0));\r\n        for (int len = 1; len <= n; ++len) {\r\n            for (int left = 1; left <= n - len + 1; ++left) {\r\n                int right = left + len - 1;\r\n                for (int k = left; k <= right; ++k) {\r\n                    dp[left][right] = max(dp[left][right], nums[left - 1] * nums[k] * nums[right + 1] + dp[left][k - 1] + dp[k + 1][right]);\r\n                }\r\n            }\r\n        }\r\n        return dp[1][n];\r\n    }\r\n};"}]},{"id":177,"unique_name":"best-time-to-buy-and-sell-stock-iv","title":"买卖股票的最佳时机 IV","description":"假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。\r\n\r\n设计一个算法来找到最大的利润。你最多可以完成 `k` 笔交易。","solutions":[{"language":"java","code":"// 动态规划专题班版本 Version 1\r\nclass Solution {\r\n    /**\r\n     * @param prices: Given an integer array\r\n     * @return: Maximum profit\r\n     */\r\n    \r\n    private int update(int a, int b, int delta) {\r\n        if (b == Integer.MIN_VALUE) {\r\n            return a;\r\n        }\r\n        \r\n        if (b + delta > a) {\r\n            return b + delta;\r\n        }\r\n        \r\n        return a;\r\n    } \r\n     \r\n    public int maxProfit(int K, int[] prices) {\r\n        int n = prices.length;\r\n        int i, j, k;\r\n        if (K == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        if (K >= n - 1) {\r\n            j = 0;\r\n            for (i = 1; i < n; ++i) {\r\n                if (prices[i] > prices[i - 1]) {\r\n                    j += prices[i] - prices[i - 1];\r\n                }\r\n            }\r\n            \r\n            return j;\r\n        }\r\n        \r\n        int[][] f = new int[n+1][2*K+1+1];\r\n        for (i = 0; i <= n; ++i) {\r\n            for (j = 1; j <= 2*K+1; ++j) {\r\n                f[i][j] = Integer.MIN_VALUE;\r\n            }\r\n        }\r\n        \r\n        f[0][1] = 0;\r\n        for (i = 1; i <= n; ++i) {\r\n            for (j = 1; j <= 2 * K + 1; j += 2) {\r\n                f[i][j] = update(f[i][j], f[i-1][j], 0);\r\n                if (j > 1 && i > 1) f[i][j] = update(f[i][j], f[i - 1][j - 1], prices[i - 1] - prices[i - 2]);\r\n            }\r\n            \r\n            for (j = 2; j <= 2 * K; j += 2) {\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j], prices[i - 1] - prices[i - 2]);\r\n                if (j > 1) f[i][j] = update(f[i][j], f[i-1][j-1], 0);\r\n            }\r\n        }\r\n        \r\n        int res = Integer.MIN_VALUE;\r\n        for (j = 1; j <= 2 * K + 1; j += 2) {\r\n            res = update(res, f[n][j], 0);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n\r\n// version 2\r\nclass Solution {\r\n    /**\r\n     * @param k: An integer\r\n     * @param prices: Given an integer array\r\n     * @return: Maximum profit\r\n     */\r\n    public int maxProfit(int k, int[] prices) {\r\n        // write your code here\r\n        if (k == 0) {\r\n            return 0;\r\n        }\r\n        if (k >= prices.length / 2) {\r\n            int profit = 0;\r\n            for (int i = 1; i < prices.length; i++) {\r\n                if (prices[i] > prices[i - 1]) {\r\n                    profit += prices[i] - prices[i - 1];\r\n                }\r\n            }\r\n            return profit;\r\n        }\r\n        int n = prices.length;\r\n        int[][] mustsell = new int[n + 1][n + 1];   // mustSell[i][j] 表示前i天，至多进行j次交易，第i天必须sell的最大获益\r\n        int[][] globalbest = new int[n + 1][n + 1];  // globalbest[i][j] 表示前i天，至多进行j次交易，第i天可以不sell的最大获益\r\n        \r\n        mustsell[0][0] = globalbest[0][0] = 0;\r\n        for (int i = 1; i <= k; i++) {\r\n            mustsell[0][i] = globalbest[0][i] = 0;\r\n        }\r\n        \r\n        for (int i = 1; i < n; i++) {\r\n            int gainorlose = prices[i] - prices[i - 1];\r\n            mustsell[i][0] = 0;\r\n            for (int j = 1; j <= k; j++) {\r\n                mustsell[i][j] = Math.max(globalbest[(i - 1)][j - 1] + gainorlose,\r\n                                            mustsell[(i - 1)][j] + gainorlose);\r\n                globalbest[i][j] = Math.max(globalbest[(i - 1)][j], mustsell[i ][j]);\r\n            }\r\n        }\r\n        return globalbest[(n - 1)][k];\r\n    }\r\n};\r\n\r\n\r\n// 方法二\r\nclass Solution {\r\n    /**\r\n     * @param k: An integer\r\n     * @param prices: Given an integer array\r\n     * @return: Maximum profit\r\n     */\r\n    private int update(int a, int b, int delta) {\r\n        if (b == Integer.MIN_VALUE) {\r\n            return a;\r\n        }\r\n        \r\n        if (b + delta > a) {\r\n            return b + delta;\r\n        }\r\n        \r\n        return a;\r\n    }  \r\n     \r\n    public int maxProfit(int K, int[] prices) {\r\n        int n = prices.length;\r\n        int i, j, k;\r\n        if (K == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        if (K >= n - 1) {\r\n            j = 0;\r\n            for (i = 1; i < n; ++i) {\r\n                if (prices[i] > prices[i - 1]) {\r\n                    j += prices[i] - prices[i - 1];\r\n                }\r\n            }\r\n            \r\n            return j;\r\n        }\r\n        \r\n        int[][] f = new int[n+1][2*K+1];\r\n        for (i = 0; i <= n; ++i) {\r\n            for (j = 0; j <= 2*K; ++j) {\r\n                f[i][j] = Integer.MIN_VALUE;\r\n            }\r\n        }\r\n        \r\n        f[0][0] = 0;\r\n        for (i = 1; i <= n; ++i) {\r\n            int delta;\r\n            if (i == 1) {\r\n                delta = 0;\r\n            }\r\n            else {\r\n                delta = prices[i-1] - prices[i - 2];\r\n            }\r\n            \r\n            f[i][0] = update(f[i][0], f[i-1][0], 0);\r\n            for (j = 1; j <= 2 * K; j += 2) {\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j], delta);\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j-1], delta);\r\n            }\r\n            \r\n            for (j = 2; j <= 2 * K; j += 2) {\r\n                f[i][j] = update(f[i][j], f[i-1][j], 0);\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j-1], delta);\r\n                if (i > 1) f[i][j] = update(f[i][j], f[i-1][j-2], delta);\r\n            }\r\n        }\r\n        \r\n        int res = Integer.MIN_VALUE;\r\n        for (j = 2; j <= 2 * K; j += 2) {\r\n            res = update(res, f[n][j], 0);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int maxProfit(int k, vector<int> &prices) {\r\n        if (prices.empty())\r\n            return 0;\r\n\r\n        int ans = 0;\r\n        if (k >= prices.size() / 2)\r\n        {\r\n            for (int i = 1; i < prices.size(); ++i) {\r\n                if (prices[i] - prices[i - 1] > 0) {\r\n                    ans += prices[i] - prices[i - 1];\r\n                }\r\n            }\r\n        } else {\r\n            vector<int> local(k+1);\r\n            vector<int> global(k+1);\r\n            \r\n            for (int i = 0; i < prices.size() - 1; ++i) {\r\n                int increase = prices[i + 1] - prices[i];\r\n    \r\n                for (int j = k; j >= 1; --j) {\r\n                    local[j] = max(global[j - 1] + max(increase, 0), local[j] + increase);\r\n                    global[j] = max(global[j], local[j]);\r\n                }\r\n            }\r\n            ans = global[k];\r\n        }\r\n        return ans;\r\n    }\r\n   \r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param k: an integer\r\n    @param prices: an integer array\r\n    @return: an integer which is maximum profit\r\n    \"\"\"\r\n    def maxProfit(self, k, prices):\r\n        # write your code here\r\n        size = len(prices)\r\n        if k >= size / 2:\r\n            return self.quickSolve(size, prices)\r\n        dp = [None] * (2 * k + 1)\r\n        dp[0] = 0\r\n        for i in range(size):\r\n            for j in range(min(2 * k, i + 1) , 0 , -1):\r\n                dp[j] = max(dp[j], dp[j - 1] + prices[i] * [1, -1][j % 2])\r\n        return max(dp)\r\n\r\n    def quickSolve(self, size, prices):\r\n        sum = 0\r\n        for x in range(size - 1):\r\n            if prices[x + 1] > prices[x]:\r\n                sum += prices[x + 1] - prices[x]\r\n        return sum"}]},{"id":198,"unique_name":"house-robber","title":"打劫房屋","description":"假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 **当相邻的两个房子同一天被打劫时，该系统会自动报警**。\r\n\r\n给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 **在不触动报警装置的情况下**。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A: An array of non-negative integers.\r\n     * return: The maximum amount of money you can rob tonight\r\n     */\r\n    //---方法一---\r\n    public long houseRobber(int[] A) {\r\n        // write your code here\r\n        int n = A.length;\r\n        if(n == 0)\r\n            return 0;\r\n        long []res = new long[n+1];\r\n        \r\n        \r\n        res[0] = 0;\r\n        res[1] = A[0];\r\n        for(int i = 2; i <= n; i++) {\r\n            res[i] = Math.max(res[i-1], res[i-2] + A[i-1]);\r\n        }\r\n        return res[n];\r\n    }\r\n    //---方法二---\r\n    public long houseRobber(int[] A) {\r\n        // write your code here\r\n        int n = A.length;\r\n        if(n == 0)\r\n            return 0;\r\n        long []res = new long[2];\r\n        \r\n        \r\n        res[0] = 0;\r\n        res[1] = A[0];\r\n        for(int i = 2; i <= n; i++) {\r\n            res[i%2] = Math.max(res[(i-1)%2], res[(i-2)%2] + A[i-1]);\r\n        }\r\n        return res[n%2];\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A: An array of non-negative integers.\r\n     * return: The maximum amount of money you can rob tonight\r\n     */\r\n    long long houseRobber(vector<int> A) {\r\n        // write your code here\r\n        long long result = 0;\r\n        long long f = 0, g = 0, f1 = 0, g1 = 0;\r\n        int len = A.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            f1 = g + A[i];\r\n            g1 = max(f, g);\r\n            g = g1, f = f1;        \r\n        }\r\n        return max(g, f);\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param A: A list of non-negative integers.\r\n    # return: an integer\r\n    def houseRobber(self, A):\r\n        # write your code here\r\n        result = 0\r\n        f, g, f1, g1 = 0, 0, 0, 0\r\n        for x in A:\r\n            f1 = g + x\r\n            g1 = max(f, g)\r\n            g, f = g1, f1\r\n       \r\n        return max(f, g)"}]},{"id":507,"unique_name":"dices-sum","title":"骰子求和","description":"扔 *n* 个骰子，向上面的数字之和为 *S*。给定 Given *n*，请列出所有可能的 *S* 值及其相应的概率。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @return a list of Map.Entry<sum, probability>\r\n     */\r\n    public List<Map.Entry<Integer, Double>> dicesSum(int n) {\r\n        // Write your code here\r\n        // Ps. new AbstractMap.SimpleEntry<Integer, Double>(sum, pro)\r\n        // to create the pair.\r\n        List<Map.Entry<Integer, Double>> results = \r\n                new ArrayList<Map.Entry<Integer, Double>>();\r\n        \r\n        double[][] f = new double[n + 1][6 * n + 1];\r\n        for (int i = 1; i <= 6; ++i)\r\n            f[1][i] = 1.0 / 6;\r\n\r\n        for (int i = 2; i <= n; ++i)\r\n            for (int j = i; j <= 6 * n; ++j) {\r\n                for (int k = 1; k <= 6; ++k)\r\n                    if (j > k)\r\n                        f[i][j] += f[i - 1][j - k];\r\n\r\n                f[i][j] /= 6.0;\r\n            }\r\n\r\n        for (int i = n; i <= 6 * n; ++i) \r\n            results.add(new AbstractMap.SimpleEntry<Integer, Double>(i, f[n][i]));\r\n\r\n        return results;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n an integer\r\n     * @return a list of pair<sum, probability>\r\n     */\r\n    vector<pair<int, double>> dicesSum(int n) {\r\n        // Write your code here\r\n        vector<pair<int, double>> results;\r\n        vector<vector<double>> f(n + 1, vector<double>(6 * n + 1));\r\n\r\n        for (int i = 1; i <= 6; ++i) f[1][i] = 1.0 / 6;\r\n        \r\n        for (int i = 2; i <= n; ++i)\r\n            for (int j = i; j <= 6 * i; ++j) {\r\n                for (int k = 1; k <= 6; ++k)\r\n                    if (j > k)\r\n                        f[i][j] += f[i - 1][j - k];\r\n                f[i][j] /= 6.0;\r\n            }\r\n\r\n        for (int i = n; i <= 6 * n; ++i)\r\n            results.push_back(make_pair(i, f[n][i]));\r\n\r\n        return results;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int} n an integer\r\n    # @return {tuple[]} a list of tuple(sum, probability)\r\n    def dicesSum(self, n):\r\n        # Write your code here\r\n        results = []\r\n        f = [[0 for j in xrange(6 * n + 1)] for i in xrange(n + 1)]\r\n        \r\n        for i in xrange(1, 7):\r\n            f[1][i] = 1.0 / 6.0\r\n        for i in xrange(2, n + 1):\r\n            for j in xrange(i, 6 * n + 1):\r\n                for k in xrange(1, 7):\r\n                    if j > k:\r\n                        f[i][j] += f[i - 1][j - k]\r\n                f[i][j] /= 6.0\r\n\r\n        for i in xrange(n, 6 * n + 1):\r\n            results.append((i, f[n][i]))\r\n\r\n        return results\r\n"}]},{"id":521,"unique_name":"number-of-ways-to-represent-n-cents","title":"凑 N 分钱的方案数","description":"给你无限多个的 25 分，10 分，5 分和 1 分的硬币。问如果要凑出 `n` 分钱有多少种不同的方式？","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @return an integer\r\n     */\r\n    public int waysNCents(int n) {\r\n        int[] f = new int[n+1];\r\n        f[0] = 1;\r\n        int[] cents = new int[]{1, 5, 10, 25};\r\n        for (int i = 0; i < 4; i++) \r\n            for (int j = 1; j <= n; j++) {\r\n                if (j >= cents[i]) {\r\n                    f[j] += f[j-cents[i]];\r\n                }\r\n            }\r\n        return f[n];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n an integer\r\n     * @return an integer\r\n     */\r\n    int waysNCents(int n) {\r\n        // Write your code here\r\n        vector<int> cents = {1, 5, 10, 25};\r\n        vector<int> ways(n + 1);\r\n\r\n        ways[0] = 1;\r\n        for (int i = 0; i < 4; ++i)\r\n            for (int j = cents[i]; j <= n; ++j)\r\n                ways[j] += ways[j - cents[i]];\r\n\r\n        return ways[n];\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n an integer\r\n    # @return {int} an integer\r\n    def waysNCents(self, n):\r\n        # Write your code here\r\n        cents = [1, 5, 10, 25]\r\n        ways = [0 for _ in xrange(n + 1)]\r\n        \r\n        ways[0] = 1\r\n        for cent in cents:\r\n            for j in xrange(cent, n + 1):\r\n                ways[j] += ways[j - cent]\r\n        \r\n        return ways[n]"}]},{"id":187,"unique_name":"maximum-product-subarray","title":"乘积最大子序列","description":"<p>找出一个序列中乘积最大的连续子序列（至少包含一个数）。</p>","solutions":[{"language":"java","code":"// LeetCode version:\r\npublic class Solution {\r\n    /**\r\n     * @param nums: an array of integers\r\n     * @return: an integer\r\n     */\r\n    public int maxProduct(List<Integer> nums) {\r\n        int[] max = new int[nums.size()];\r\n        int[] min = new int[nums.size()];\r\n        \r\n        min[0] = max[0] = nums.get(0);\r\n        int result = nums.get(0);\r\n        for (int i = 1; i < nums.size(); i++) {\r\n            min[i] = max[i] = nums.get(i);\r\n            if (nums.get(i) > 0) {\r\n                max[i] = Math.max(max[i], max[i - 1] * nums.get(i));\r\n                min[i] = Math.min(min[i], min[i - 1] * nums.get(i));\r\n            } else if (nums.get(i) < 0) {\r\n                max[i] = Math.max(max[i], min[i - 1] * nums.get(i));\r\n                min[i] = Math.min(min[i], max[i - 1] * nums.get(i));\r\n            }\r\n            \r\n            result = Math.max(result, max[i]);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n// LintCode Version 1:\r\npublic class Solution {\r\n    /**\r\n     * @param nums: an array of integers\r\n     * @return: an integer\r\n     */\r\n    public int maxProduct(int[] nums) {\r\n        int[] max = new int[nums.length];\r\n        int[] min = new int[nums.length];\r\n        \r\n        min[0] = max[0] = nums[0];\r\n        int result = nums[0];\r\n        for (int i = 1; i < nums.length; i++) {\r\n            min[i] = max[i] = nums[i];\r\n            if (nums[i] > 0) {\r\n                max[i] = Math.max(max[i], max[i - 1] * nums[i]);\r\n                min[i] = Math.min(min[i], min[i - 1] * nums[i]);\r\n            } else if (nums[i] < 0) {\r\n                max[i] = Math.max(max[i], min[i - 1] * nums[i]);\r\n                min[i] = Math.min(min[i], max[i - 1] * nums[i]);\r\n            }\r\n            \r\n            result = Math.max(result, max[i]);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n//LintCode version2: O(1) Space Complexity\r\npublic class Solution {\r\n    /**\r\n     * @param nums: an array of integers\r\n     * @return: an integer\r\n     */\r\n    public int maxProduct(int[] nums) {\r\n        // write your code here\r\n        if (nums == null || nums.length == 0) {\r\n            return 0;\r\n        }\r\n        int minPre = nums[0], maxPre = nums[0];\r\n        int max = nums[0], min = nums[0];\r\n        int res = nums[0];\r\n        for (int i = 1; i < nums.length; i ++) {\r\n            max = Math.max(nums[i], Math.max(maxPre * nums[i], minPre * nums[i]));\r\n            min = Math.min(nums[i], Math.min(maxPre * nums[i], minPre * nums[i]));\r\n            res = Math.max(res, max);\r\n            maxPre = max;\r\n            minPre = min;\r\n        }\r\n        return res;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: a vector of integers\r\n     * @return: an integer\r\n     */\r\n    int maxProduct(vector<int>& nums) {\r\n        // write your code here\r\n        vector<int> f, g;\r\n        f.push_back(nums[0]);\r\n        g.push_back(nums[0]);\r\n        for (int i=1; i<nums.size(); ++i) {\r\n            f.push_back(max(max(f[i-1]*nums[i], g[i-1]*nums[i]), nums[i]));\r\n            g.push_back(min(min(f[i-1]*nums[i], g[i-1]*nums[i]), nums[i]));        \r\n        }\r\n        int m = f[0];\r\n        for (int i=1; i<f.size(); ++i) m = max(m, f[i]);\r\n        return m;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param nums: an integer[]\r\n    # @return: an integer\r\n    def maxProduct(self, nums):\r\n        # write your code here\r\n        f, g = [], []\r\n        f.append(nums[0])\r\n        g.append(nums[0])\r\n        for i in xrange(1, len(nums)):\r\n            f.append(max(f[i-1]*nums[i], g[i-1]*nums[i], nums[i]))\r\n            g.append(min(f[i-1]*nums[i], g[i-1]*nums[i], nums[i]))\r\n        m = f[0]\r\n        for i in xrange(1, len(f)): m = max(m, f[i])\r\n        return m\r\n"}]},{"id":440,"unique_name":"backpack-ii","title":"背包问题 II","description":"给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param m: An integer m denotes the size of a backpack\r\n     * @param A & V: Given n items with size A[i] and value V[i]\r\n     * @return: The maximum value\r\n     */\r\n     \r\n    public int backPackII(int m, int[] A, int V[]) {\r\n        // write your code here\r\n        int[][] dp = new int[A.length + 1][m + 1];\r\n        for(int i = 0; i <= A.length; i++){\r\n            for(int j = 0; j <= m; j++){\r\n                if(i == 0 || j == 0){\r\n                    dp[i][j] = 0;\r\n                }\r\n                else if(A[i-1] > j){\r\n                    dp[i][j] = dp[(i-1)][j];\r\n                }\r\n                else{\r\n                    dp[i][j] = Math.max(dp[(i-1)][j], dp[(i-1)][j-A[i-1]] + V[i-1]);\r\n                }\r\n            }\r\n        }\r\n        return dp[A.length][m];\r\n    }\r\n}\r\n\r\n// 方法二\r\npublic class Solution {\r\n    /**\r\n     * @param m: An integer m denotes the size of a backpack\r\n     * @param A & V: Given n items with size A[i] and value V[i]\r\n     */\r\n    public int backPackII(int m, int[] A, int V[]) {\r\n        // write your code here\r\n        int[] f = new int[m+1];\r\n        for (int i = 0; i <=m ; ++i) f[i] = 0;\r\n        int n = A.length , i, j;\r\n        for(i = 0; i < n; i++){\r\n            for(j = m; j >= A[i]; j--){\r\n                if (f[j] < f[j - A[i]] + V[i])\r\n                    f[j] = f[j - A[i]] + V[i];\r\n            }\r\n        }\r\n        return f[m];\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param m: An integer m denotes the size of a backpack\r\n     * @param A & V: Given n items with size A[i] and value V[i]\r\n     */\r\n    int backPackII(int m, vector<int> A, vector<int> V) {\r\n        // write your code here\r\n        int f[m + 1];\r\n        for (int i = 0; i <=m ; ++i) f[i] = 0;\r\n        int n = A.size() , i, j;\r\n        for(i = 0; i < n; i++){\r\n            for(j = m; j >= A[i]; j--){\r\n                f[j] = max(f[j], f[j - A[i]] + V[i]);\r\n            }\r\n        }\r\n        return f[m];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param m: An integer m denotes the size of a backpack\r\n    # @param A & V: Given n items with size A[i] and value V[i]\r\n    def backPackII(self, m, A, V):\r\n        # write your code here\r\n        f = [0 for i in xrange(m+1)]\r\n        n = len(A)\r\n        for i in range(n):\r\n            for j in xrange(m, A[i]-1, -1):\r\n                f[j] = max(f[j] , f[j-A[i]] + V[i])\r\n        return f[m]\r\n                \r\n\r\n"},{"language":"javascript","code":"/**\n * @param m: An integer m denotes the size of a backpack\n * @param A: Given n items with size A[i]\n * @param V: Given n items with value V[i]\n * @return: The maximum value\n */\nconst backPackII = function (m, A, V) {\n    var dp = new Array(A.length + 1);\n    var i, j;\n    for (i = 0; i < A.length + 1; i++) {\n        dp[i] = new Array(m + 1);\n    }\n    for(i = 0; i <= A.length; i++){\n        for(j = 0; j <= m; j++){\n            if(i === 0 || j === 0){\n                dp[i][j] = 0;\n            } else if(A[i-1] > j){\n                dp[i][j] = dp[(i-1)][j];\n            } else{\n                dp[i][j] = Math.max(dp[(i-1)][j], dp[(i-1)][j-A[i-1]] + V[i-1]);\n            }\n        }\n    }\n    return dp[A.length][m];\n}"}]},{"id":62,"unique_name":"climbing-stairs","title":"爬楼梯","description":"<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>","solutions":[{"language":"java","code":"public class Solution {\n    public int climbStairs(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int last = 1, lastlast = 1;\n        int now = 0;\n        for (int i = 2; i <= n; i++) {\n            now = last + lastlast;\n            lastlast = last;\n            last = now;\n        }\n        return now;\n    }\n}\n\n// 记忆化搜索\n// 九章硅谷求职算法集训营版本\npublic class Solution {\n    /**\n     * @param n: An integer\n     * @return: An integer\n     */\n    int[] result = null;\n\n    void f(int X) {\n         if (result[X] != -1) return;                                                 \n         if (X == 0 || X == 1) {\n            result[X] = 1;\n            return;\n         }\n         \n         f(X - 1);\n         f(X - 2);\n         result[X] = result[X - 1] + result[X - 2];\n    }\n\n    public int climbStairs(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        \n        result  = new int[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            result[i] = -1;\n        }\n        \n        f(n);\n        return result[n];\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n: an integer\r\n     * @return: an integer\r\n     */\r\n    int climbStairs(int n) {\r\n        // write your code here\r\n        if(n <= 2)\r\n            return n;\r\n        int* step = new int[n];\r\n        step[0] = 1;\r\n        step[1] = 2; \r\n        for(int i = 2; i < n; i++) {\r\n            step[i] = step[i-1] + step[i-2];\r\n        }\r\n        return step[n-1];\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param n: An integer\r\n    @return: An integer\r\n    \"\"\"\r\n    def climbStairs(self, n):\r\n        # write your code here\r\n        if n == 0:\r\n            return 1\r\n        if n <= 2:\r\n            return n\r\n        result=[1,2]\r\n        for i in range(n-2):\r\n            result.append(result[-2]+result[-1])\r\n        return result[-1]\r\n"},{"language":"javascript","code":"const climbStairs = function (n) {\n    var last, lastlast, now;\n    var i;\n    if (n <= 1) {\n        return n;\n    }\n    last = 1;\n    lastlast = 1;\n    now = 0;\n    for (i = 2; i <= n; i++) {\n        now = last + lastlast;\n        lastlast = last;\n        last = now;\n    }\n    return now;\n}"}]},{"id":37,"unique_name":"triangle","title":"数字三角形","description":"给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。\r\n","solutions":[{"language":"java","code":"// version 0: top-down\r\npublic class Solution {\r\n    /**\r\n     * @param triangle: a list of lists of integers.\r\n     * @return: An integer, minimum path sum.\r\n     */\r\n    public int minimumTotal(int[][] triangle) {\r\n        if (triangle == null || triangle.length == 0) {\r\n            return -1;\r\n        }\r\n        if (triangle[0] == null || triangle[0].length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        // state: f[x][y] = minimum path value from 0,0 to x,y\r\n        int n = triangle.length;\r\n        int[][] f = new int[n][n];\r\n        \r\n        // initialize \r\n        f[0][0] = triangle[0][0];\r\n        for (int i = 1; i < n; i++) {\r\n            f[i][0] = f[i - 1][0] + triangle[i][0];\r\n            f[i][i] = f[i - 1][i - 1] + triangle[i][i];\r\n        }\r\n        \r\n        // top down\r\n        for (int i = 1; i < n; i++) {\r\n            for (int j = 1; j < i; j++) {\r\n                f[i][j] = Math.min(f[i - 1][j], f[i - 1][j - 1]) + triangle[i][j];\r\n            }\r\n        }\r\n        \r\n        // answer\r\n        int best = f[n - 1][0];\r\n        for (int i = 1; i < n; i++) {\r\n            best = Math.min(best, f[n - 1][i]);\r\n        }\r\n        return best;\r\n    }\r\n}\r\n\r\n\r\n\r\n//Version 1: Bottom-Up\r\npublic class Solution {\r\n    /**\r\n     * @param triangle: a list of lists of integers.\r\n     * @return: An integer, minimum path sum.\r\n     */\r\n    public int minimumTotal(int[][] triangle) {\r\n        if (triangle == null || triangle.length == 0) {\r\n            return -1;\r\n        }\r\n        if (triangle[0] == null || triangle[0].length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        // state: f[x][y] = minimum path value from x,y to bottom\r\n        int n = triangle.length;\r\n        int[][] f = new int[n][n];\r\n        \r\n        // initialize \r\n        for (int i = 0; i < n; i++) {\r\n            f[n - 1][i] = triangle[n - 1][i];\r\n        }\r\n        \r\n        // bottom up\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            for (int j = 0; j <= i; j++) {\r\n                f[i][j] = Math.min(f[i + 1][j], f[i + 1][j + 1]) + triangle[i][j];\r\n            }\r\n        }\r\n        \r\n        // answer\r\n        return f[0][0];\r\n    }\r\n}\r\n\r\n\r\n//Version 2 : Memorize Search\r\npublic class Solution {\r\n    private int n;\r\n    private int[][] minSum;\r\n    private int[][] triangle;\r\n\r\n    private int search(int x, int y) {\r\n        if (x >= n) {\r\n            return 0;\r\n        }\r\n\r\n        if (minSum[x][y] != Integer.MAX_VALUE) {\r\n            return minSum[x][y];\r\n        }\r\n\r\n        minSum[x][y] = Math.min(search(x + 1, y), search(x + 1, y + 1))\r\n            + triangle[x][y];\r\n        return minSum[x][y];\r\n    }\r\n\r\n    public int minimumTotal(int[][] triangle) {\r\n        if (triangle == null || triangle.length == 0) {\r\n            return -1;\r\n        }\r\n        if (triangle[0] == null || triangle[0].length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        this.n = triangle.length;\r\n        this.triangle = triangle;\r\n        this.minSum = new int[n][n];\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                minSum[i][j] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n\r\n        return search(0, 0);\r\n    }\r\n} "},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param triangle: a list of lists of integers.\n     * @return: An integer, minimum path sum.\n     */\n    int minimumTotal(vector<vector<int> > &triangle) {\n        // write your code here\n        if (triangle.size() == 0)\n            return 0;\n            \n        vector<int> f(triangle[triangle.size()-1].size());\n        \n        f[0] = triangle[0][0];\n        for(int i = 1; i < triangle.size(); i++)\n            for(int j = triangle[i].size() - 1; j >= 0; j--)\n                if (j == 0)\n                    f[j] = f[j] + triangle[i][j];\n                else if (j == triangle[i].size() - 1)\n                    f[j] = f[j-1] + triangle[i][j];\n                else\n                    f[j] = min(f[j-1], f[j]) + triangle[i][j];\n                    \n        int ret = INT_MAX;\n        for(int i = 0; i < f.size(); i++)\n            ret = min(ret, f[i]);\n        return ret; \n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param triangle: a list of lists of integers.\n    @return: An integer, minimum path sum.\n    \"\"\"\n    def minimumTotal(self, triangle):\n        # write your code here\n        res=[triangle[0]]\n        N = len(triangle)\n        for i in range(1,len(triangle)):\n            res.append([])\n            for j in range(len(triangle[i])):\n                if j-1>=0 and j< len(triangle[i-1]):\n                    res[i].append(min(res[i-1][j-1],res[i-1][j])+triangle[i][j])\n                elif j-1>=0:\n                    res[i].append(res[i-1][j-1]+triangle[i][j])\n                else:\n                    res[i].append(res[i-1][j]+triangle[i][j])\n                 \n        minvalue = min(res[N-1])\n        return minvalue\n"}]},{"id":16,"unique_name":"word-break","title":"单词拆分 I","description":"<p><span style=\"line-height: 1.42857143;\">给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。</span><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    private int getMaxLength(Set<String> dict) {\r\n        int maxLength = 0;\r\n        for (String word : dict) {\r\n            maxLength = Math.max(maxLength, word.length());\r\n        }\r\n        return maxLength;\r\n    }\r\n\r\n    public boolean wordBreak(String s, Set<String> dict) {\r\n        if (s == null || s.length() == 0) {\r\n            return true;\r\n        }\r\n\r\n        int maxLength = getMaxLength(dict);\r\n        boolean[] canSegment = new boolean[s.length() + 1];\r\n\r\n        canSegment[0] = true;\r\n        for (int i = 1; i <= s.length(); i++) {\r\n            canSegment[i] = false;\r\n            for (int lastWordLength = 1;\r\n                     lastWordLength <= maxLength && lastWordLength <= i;\r\n                     lastWordLength++) {\r\n                if (!canSegment[i - lastWordLength]) {\r\n                    continue;\r\n                }\r\n                String word = s.substring(i - lastWordLength, i);\r\n                if (dict.contains(word)) {\r\n                    canSegment[i] = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return canSegment[s.length()];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param s: A string s\n     * @param dict: A dictionary of words dict\n     */\n    int getMaxLength(unordered_set<string> &dict) {\n        int maxLength = 0; // 试试看中文 \n        for (unordered_set<string>::iterator it = dict.begin(); it != dict.end(); ++it) { \n            maxLength = maxLength > (*it).length() ? maxLength : (*it).length();\n        }\n        return maxLength;\n    }\n    \n    bool wordBreak(string s, unordered_set<string> &dict) {\n        int maxLength = getMaxLength(dict);\n        bool *canSegment = new bool[s.length() + 1];\n        canSegment[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            canSegment[i] = false;\n            for (int j = 1; j <= maxLength && j <= i; j++) {\n                if (!canSegment[i - j]) {\n                    continue;\n                }\n                string word = s.substr(i - j, j);\n                if (dict.find(word) != dict.end()) {\n                    canSegment[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return canSegment[s.length()];\n    }\n};\n"},{"language":"python","code":"class Solution:\r\n    # @param s: A string s\r\n    # @param dict: A dictionary of words dict\r\n    def wordBreak(self, s, dict):\r\n        if len(dict) == 0:\r\n            return len(s) == 0\r\n            \r\n        n = len(s)\r\n        f = [False] * (n + 1)\r\n        f[0] = True\r\n        \r\n        maxLength = max([len(w) for w in dict])\r\n        for i in xrange(1, n + 1):\r\n            for j in range(1, min(i, maxLength) + 1):\r\n                if not f[i - j]:\r\n                    continue\r\n                if s[i - j:i] in dict:\r\n                    f[i] = True\r\n                    break\r\n        \r\n        return f[n]\r\n"}]},{"id":23,"unique_name":"palindrome-partitioning-ii","title":"分割回文串 II","description":"<p>给定一个字符串s，将s分割成一些子串，使每个子串都是回文。</p><p>返回s符合要求的的最少分割次数。</p>","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param s a string\n     * @return an integer\n     */\n    private boolean[][] CalcPalin(String s, int n) {\n        boolean[][] isPalin = new boolean[n][n];\n        int i, j, p;\n        for (i = 0; i < n; ++i) {\n            for (j = 0; j < n; ++j) {\n                isPalin[i][j] = false;\n            }\n        }\n        \n        for (p = 0; p < n; ++p) {\n            i = j = p;\n            while (i >= 0 && j < n && s.charAt(i) == s.charAt(j)) {\n                isPalin[i][j] = true;\n                --i;\n                ++j;\n            }\n        }\n        \n        for (p = 0; p < n-1; ++p) {\n            i = p;\n            j = p + 1;\n            while (i >= 0 && j < n && s.charAt(i) == s.charAt(j)) {\n                isPalin[i][j] = true;\n                --i;\n                ++j;\n            }\n        }\n\n        return isPalin;\n    }\n    public int minCut(String s) {\n        int n = s.length();\n        if (n == 0) {\n            return 0;\n        }\n        \n        int[] f = new int[n+1];\n        //int[] pi = new int[n + 1];\n        int i, j, p;\n        boolean[][] isPalin = CalcPalin(s, n);\n                \n        f[0] = 0;\n        for (i=1; i<=n; ++i) {\n            f[i] = Integer.MAX_VALUE;\n            for (j = 0; j < i; ++j) {\n                if (isPalin[j][i-1] && f[j] != Integer.MAX_VALUE && f[j] + 1 < f[i]) {\n                    f[i] = f[j] + 1;\n                    //pi[i] = j;\n                }\n            }\n        }\n        \n        // print solution\n        /*i = n;\n        while (i != 0) {\n            // pi[i]~i-1\n            for (j = pi[i]; j < i; ++j) {\n                System.out.print(s[j]);\n            }\n            \n            System.out.println(\"\");\n            i = pi[i];\n        }*/\n        \n        return f[n] - 1;\n    }\n};"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param s a string\n     * @return an integer\n     */\n    int minCut(string s) {\n        int n = s.length();\n        int f[n + 1];\n        bool isPalin[n][n];\n\n        for (int i = 0; i < n; i++) {\n            isPalin[i][i] = true;\n            if (i + 1 < n) {\n                isPalin[i][i + 1] = (s[i] == s[i + 1]);\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 2; j < n; j++) {\n                isPalin[i][j] = isPalin[i + 1][j - 1] && (s[i] == s[j]);\n            }\n        }\n        \n        f[0] = -1;\n        for (int i = 1; i <= n; i++) {\n            f[i] = i - 1;\n            for (int j = 0; j < i; j++) {\n                if (isPalin[j][i - 1]) {\n                    f[i] = min(f[i], f[j] + 1);\n                }\n            }\n        }\n        \n        return f[n];\n    }\n};"},{"language":"python","code":"class Solution:\n    # @param s, a string\n    # @return an integer\n    def minCut(self, s):\n        n = len(s)\n        f = []\n        p = [[False for x in range(n)] for x in range(n)]\n        #the worst case is cutting by each char\n        for i in range(n+1):\n            f.append(n - 1 - i) # the last one, f[n]=-1\n        for i in reversed(range(n)):\n            for j in range(i, n):\n                if (s[i] == s[j] and (j - i < 2 or p[i + 1][j - 1])):\n                    p[i][j] = True\n                    f[i] = min(f[i], f[j + 1] + 1)\n        return f[0]\n"}]},{"id":32,"unique_name":"binary-tree-maximum-path-sum","title":"二叉树中的最大路径和","description":"<span style=\"line-height: 30px;\"><font color=\"#000000\">给出一棵二叉树，</font></span><font color=\"#000000\"><span style=\"line-height: 30px;\">寻找一条路径使其路径和最大，路径可以在任一节点中开始和结束（路径和为两个节点之间所在路径上的节点权值之和）</span></font><br>","solutions":[{"language":"java","code":"public class Solution {\r\n    private class ResultType {\r\n        // singlePath: 从root往下走到任意点的最大路径，这条路径可以不包含任何点\r\n        // maxPath: 从树中任意到任意点的最大路径，这条路径至少包含一个点\r\n        int singlePath, maxPath; \r\n        ResultType(int singlePath, int maxPath) {\r\n            this.singlePath = singlePath;\r\n            this.maxPath = maxPath;\r\n        }\r\n    }\r\n\r\n    private ResultType helper(TreeNode root) {\r\n        if (root == null) {\r\n            return new ResultType(0, Integer.MIN_VALUE);\r\n        }\r\n        // Divide\r\n        ResultType left = helper(root.left);\r\n        ResultType right = helper(root.right);\r\n\r\n        // Conquer\r\n        int singlePath = Math.max(left.singlePath, right.singlePath) + root.val;\r\n        singlePath = Math.max(singlePath, 0);\r\n\r\n        int maxPath = Math.max(left.maxPath, right.maxPath);\r\n        maxPath = Math.max(maxPath, left.singlePath + right.singlePath + root.val);\r\n\r\n        return new ResultType(singlePath, maxPath);\r\n    }\r\n\r\n    public int maxPathSum(TreeNode root) {\r\n        ResultType result = helper(root);\r\n        return result.maxPath;\r\n    }\r\n}\r\n\r\n\r\n// Version 2:\r\n// SinglePath也定义为，至少包含一个点。\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: An integer.\r\n     */\r\n    private class ResultType {\r\n        int singlePath, maxPath;\r\n        ResultType(int singlePath, int maxPath) {\r\n            this.singlePath = singlePath;\r\n            this.maxPath = maxPath;\r\n        }\r\n    }\r\n\r\n    private ResultType helper(TreeNode root) {\r\n        if (root == null) {\r\n            return new ResultType(Integer.MIN_VALUE, Integer.MIN_VALUE);\r\n        }\r\n        // Divide\r\n        ResultType left = helper(root.left);\r\n        ResultType right = helper(root.right);\r\n\r\n        // Conquer\r\n        int singlePath =\r\n            Math.max(0, Math.max(left.singlePath, right.singlePath)) + root.val;\r\n\r\n        int maxPath = Math.max(left.maxPath, right.maxPath);\r\n        maxPath = Math.max(maxPath,\r\n                           Math.max(left.singlePath, 0) + \r\n                           Math.max(right.singlePath, 0) + root.val);\r\n\r\n        return new ResultType(singlePath, maxPath);\r\n    }\r\n\r\n    public int maxPathSum(TreeNode root) {\r\n        ResultType result = helper(root);\r\n        return result.maxPath;\r\n    }\r\n\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param root: The root of binary tree.\n     * @return: An integer\n     */\npublic:\n    int ans;\n    int solve_dp(TreeNode *root) {\n        if(root == NULL)\n            return 0;\n \n        int sum = root->val;\n        int lf = 0, rt = 0;\n        if(root->left)\n            lf = solve_dp(root->left);\n         \n        if(root->right) \n            rt = solve_dp(root->right);\n        if(lf > 0)\n            sum += lf;\n        if(rt > 0)\n            sum += rt;\n \n        ans = max(ans, sum);\n        return max(0, max(lf, rt))+root->val;\n    }\n    int maxPathSum(TreeNode *root) {\n        // write your code here\n        if (!root) return 0;\n        ans = -0x7fffff;\n        solve_dp(root);\n        return ans;\n    }\n};\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: An integer\r\n    \"\"\"\r\n    def maxPathSum(self, root):\r\n        maxSum, _ = self.maxPathHelper(root)\r\n        return maxSum\r\n        \r\n    def maxPathHelper(self, root):\r\n        if root is None:\r\n            return -sys.maxint, 0\r\n        \r\n        left = self.maxPathHelper(root.left)\r\n        right = self.maxPathHelper(root.right)\r\n        maxpath = max(left[0], right[0], root.val + left[1] + right[1])\r\n        single = max(left[1] + root.val, right[1] + root.val, 0)\r\n        \r\n        return maxpath, single"}]},{"id":442,"unique_name":"minimum-adjustment-cost","title":"最小调整代价","description":"<p>给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A: An integer array.\r\n     * @param target: An integer.\r\n     */\r\n    public int MinAdjustmentCost(ArrayList<Integer> A, int target) {\r\n        // write your code here\r\n        int n = A.size();\r\n        int[][] f = new int[n + 1][101];\r\n        for (int i = 0; i <= n ; ++i)\r\n            for (int j = 0; j <=100; ++j)\r\n                f[i][j] = Integer.MAX_VALUE;\r\n        for (int i = 0; i <= 100; ++i)\r\n            f[0][i] = 0;\r\n        for (int i = 1; i <=n; ++i)\r\n            for (int  j = 0; j <= 100;++j)\r\n                if (f[i-1][j] != Integer.MAX_VALUE)\r\n                for (int k = 0; k <= 100; ++k)\r\n                    if (Math.abs(j-k) <= target)\r\n                    if (f[i][k] > f[i-1][j] + Math.abs(A.get(i-1)-k))\r\n                        f[i][k] = f[i-1][j] + Math.abs(A.get(i-1)-k);  \r\n        int ans = Integer.MAX_VALUE;\r\n        for (int i = 0; i <= 100; ++i)\r\n            if (f[n][i] < ans)\r\n                ans = f[n][i];\r\n        return ans; \r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A: An integer array.\r\n     * @param target: An integer.\r\n     */\r\n    int MinAdjustmentCost(vector<int> A, int target) {\r\n        // write your code here\r\n        int n = A.size();\r\n        int f[n + 1][101];\r\n        for (int i = 0; i <= n ; ++i)\r\n            for (int j = 0; j <=100; ++j)\r\n                f[i][j] = INT_MAX;\r\n        for (int i = 0; i <= 100; ++i)\r\n            f[0][i] = 0;\r\n        for (int i = 1; i <=n; ++i)\r\n            for (int  j = 0; j <= 100;++j)\r\n                if (f[i-1][j] != INT_MAX)\r\n                for (int k = 0; k <= 100; ++k)\r\n                    if (abs(j-k) <= target)\r\n                    if (f[i][k] > f[i-1][j] + abs(A[i-1]-k))\r\n                        f[i][k] = f[i-1][j] + abs(A[i-1]-k);  \r\n        int ans = INT_MAX;\r\n        for (int i = 0; i <= 100; ++i)\r\n            if (f[n][i] < ans)\r\n                ans = f[n][i];\r\n        return ans; \r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param A: An integer array.\r\n    # @param target: An integer.\r\n    def MinAdjustmentCost(self, A, target):\r\n        # write your code here\r\n        f = [[ sys.maxint for j in xrange(101)] for i in xrange(len(A)+1)]\r\n        for i in xrange(101):\r\n            f[0][i] = 0\r\n        n = len(A)\r\n        for i in xrange(1,n+1):\r\n            for j in xrange(101):\r\n                if f[i-1][j] != sys.maxint:\r\n                    for k in xrange(101):\r\n                        if abs(j-k) <= target:\r\n                            f[i][k] = min(f[i][k], f[i-1][j] + abs(A[i-1]-k))\r\n        ans = f[n][100]\r\n        for i in xrange(101):\r\n            if f[n][i] < ans:\r\n                ans = f[n][i]       \r\n\r\n        return ans\r\n                \r\n"}]},{"id":170,"unique_name":"k-sum","title":"k数和","description":"<p>给定n个不同的正整数，整数k（k &lt; = n）以及一个目标数字。　   </p><p>在这n个数里面找出K个数，使得这K个数的和等于目标数字，求问有多少种方案？</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A: an integer array.\r\n     * @param k: a positive integer (k <= length(A))\r\n     * @param target: a integer\r\n     * @return an integer\r\n     */\r\n    public int  kSum(int A[], int k, int target) {\r\n        int n = A.length;\r\n        int[][][] f = new int[n + 1][k + 1][target + 1];\r\n        for (int i = 0; i < n + 1; i++) {\r\n            f[i][0][0] = 1;\r\n        }\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= k && j <= i; j++) {\r\n                for (int t = 1; t <= target; t++) {\r\n                    f[i][j][t] = 0;\r\n                    if (t >= A[i - 1]) {\r\n                        f[i][j][t] = f[i - 1][j - 1][t - A[i - 1]];\r\n                    }\r\n                    f[i][j][t] += f[i - 1][j][t];\r\n                } // for t\r\n            } // for j\r\n        } // for i\r\n        return f[n][k][target];\r\n    }\r\n}"},{"language":"cpp","code":"\r\nclass Solution {\r\npublic:\r\n    int ans[105][1005];\r\n    int kSum(vector<int> A, int K, int target) {\r\n        ans[0][0] = 1;\r\n        for(int i = 0; i < A.size(); ++i)\r\n            for(int j = K; j > 0; j--)\r\n                for(int k = target; k >= A[i]; k--) {\r\n                    ans[j][k] += ans[j - 1][k - A[i]];\r\n                    if(ans[j][k] > 2147483647)\r\n                        return -1;\r\n                }\r\n        return ans[K][target];\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n\r\n    def kSum(self, A, k, target):\r\n        ans = [[[0 for i in range(target + 1)] for j in range(k + 1)] for K in range(len(A) + 1)]\r\n        \r\n        ans[0][0][0] = 1\r\n        for I in range(len(A)):\r\n            item = A[I]\r\n            for J in range(target + 1):\r\n                for K in range(k + 1):\r\n                    tk = k - K\r\n                    tj = target - J\r\n                    ans[I + 1][tk][tj] = ans[I][tk][tj]\r\n                    if tk - 1 >= 0 and tj - item >= 0:\r\n                        ans[I + 1][tk][tj] += ans[I][tk - 1][tj - item]\r\n        return ans[len(A)][k][target]"},{"language":"javascript","code":"/**\n * @param A: An integer array\n * @param k: A positive integer (k <= length(A))\n * @param target: An integer\n * @return: An integer\n */\nconst kSum = function (A, k, target) {\n    var n = A.length;\n    var f = new Array(n + 1);\n    var i, j, p;\n    for (i = 0; i < n + 1; i++) {\n        f[i] = new Array(k + 1);\n        for (j = 0; j < k + 1; j++) {\n            f[i][j] = new Array(target + 1);\n            for (p = 0; p < target + 1; p++) {\n                f[i][j][p] = 0;\n            }\n        }\n    }\n    for (i = 0; i < n + 1; i++) {\n        f[i][0][0] = 1;\n    }\n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= k && j <= i; j++) {\n            for (t = 1; t <= target; t++) {\n                f[i][j][t] = 0;\n                if (t >= A[i - 1]) {\n                    f[i][j][t] = f[i - 1][j - 1][t - A[i - 1]];\n                }\n                f[i][j][t] += f[i - 1][j][t];\n            }\n        }\n    }\n    return f[n][k][target];\n}"}]},{"id":157,"unique_name":"longest-increasing-subsequence","title":"最长上升子序列","description":"给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: The integer array\r\n     * @return: The length of LIS (longest increasing subsequence)\r\n     */\r\n   \r\n    \r\n    public int longestIncreasingSubsequence(int[] nums) {\r\n        int []f = new int[nums.length];\r\n        int max = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            f[i] = 1;\r\n            for (int j = 0; j < i; j++) {\r\n                if (nums[j] < nums[i]) {\r\n                    f[i] = f[i] > f[j] + 1 ? f[i] : f[j] + 1;\r\n                }\r\n            }\r\n            if (f[i] > max) {\r\n                max = f[i];\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\n\r\n\r\n// O(nlogn) Binary Search\r\npublic class Solution {\r\n    /**\r\n     * @param nums: The integer array\r\n     * @return: The length of LIS (longest increasing subsequence)\r\n     */\r\n    public int longestIncreasingSubsequence(int[] nums) {\r\n        int[] minLast = new int[nums.length + 1];\r\n        minLast[0] = Integer.MIN_VALUE;\r\n        for (int i = 1; i <= nums.length; i++) {\r\n            minLast[i] = Integer.MAX_VALUE;\r\n        }\r\n        \r\n        for (int i = 0; i < nums.length; i++) {\r\n            // find the first number in minLast >= nums[i]\r\n            int index = binarySearch(minLast, nums[i]);\r\n            minLast[index] = nums[i];\r\n        }\r\n        \r\n        for (int i = nums.length; i >= 1; i--) {\r\n            if (minLast[i] != Integer.MAX_VALUE) {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n    \r\n    // find the first number > num\r\n    private int binarySearch(int[] minLast, int num) {\r\n        int start = 0, end = minLast.length - 1;\r\n        while (start + 1 < end) {\r\n            int mid = (end - start) / 2 + start;\r\n            if (minLast[mid] < num) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        return end;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: The integer array\r\n     * @return: The length of LIS (longest increasing subsequence)\r\n     */\r\n    int longestIncreasingSubsequence(vector<int> nums) {\r\n        int f[nums.size()];\r\n        int max = 0;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            f[i] = 1;\r\n            for (int j = 0; j < i; j++) {\r\n                if (nums[j] < nums[i]) {\r\n                    f[i] = f[i] > f[j] + 1 ? f[i] : f[j] + 1;\r\n                }\r\n            }\r\n            if (f[i] > max) {\r\n                max = f[i];\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: The integer array\r\n    @return: The length of LIS (longest increasing subsequence)\r\n    \"\"\"\r\n    def longestIncreasingSubsequence(self, nums):\r\n        # write your code here\r\n        if nums is None or not nums:\r\n            return 0\r\n        dp = [1] * len(nums)\r\n        for curr, val in enumerate(nums):\r\n            for prev in xrange(curr):\r\n                if nums[prev] < val:\r\n                    dp[curr] = max(dp[curr], dp[prev] + 1)\r\n        return max(dp)"},{"language":"javascript","code":"/**\n * @param nums: An integer array\n * @return: The length of LIS (longest increasing subsequence)\n */\nconst longestIncreasingSubsequence = function (nums) {\n    var f = new Array(nums.length);\n    var max = 0;\n    var i, j;\n    for (i = 0; i < nums.length; i++) {\n        f[i] = 1;\n        for (j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                f[i] = f[i] > f[j] + 1 ? f[i] : f[j] + 1;\n            }\n        }\n        if (f[i] > max) {\n            max = f[i];\n        }\n    }\n    return max;\n}"}]},{"id":15,"unique_name":"word-break-ii","title":"单词拆分II","description":"给一字串s和单词的字典dict,在字串中增加空格来构建一个句子，并且所有单词都来自字典。\n返回所有有可能的句子。","solutions":[{"language":"java","code":"// version 1:\npublic class Solution {\n    private void search(int index, String s, List<Integer> path,\n                   boolean[][] isWord, boolean[] possible,\n                   List<String> result) {\n        if (!possible[index]) {\n            return;\n        }\n        \n        if (index == s.length()) {\n            StringBuilder sb = new StringBuilder();\n            int lastIndex = 0;\n            for (int i = 0; i < path.size(); i++) {\n                sb.append(s.substring(lastIndex, path.get(i)));\n                if (i != path.size() - 1) sb.append(\" \");\n                lastIndex = path.get(i);\n            }\n            result.add(sb.toString());\n            return;\n        }\n        \n        for (int i = index; i < s.length(); i++) {\n            if (!isWord[index][i]) {\n                continue;\n            }\n            path.add(i + 1);\n            search(i + 1, s, path, isWord, possible, result);\n            path.remove(path.size() - 1);\n        }\n    }\n    \n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        ArrayList<String> result = new ArrayList<String>();\n        if (s.length() == 0) {\n            return result;\n        }\n        \n        boolean[][] isWord = new boolean[s.length()][s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i; j < s.length(); j++) {\n                String word = s.substring(i, j + 1);\n                isWord[i][j] = wordDict.contains(word);\n            }\n        }\n        \n        boolean[] possible = new boolean[s.length() + 1];\n        possible[s.length()] = true;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = i; j < s.length(); j++) {\n                if (isWord[i][j] && possible[j + 1]) {\n                    possible[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        List<Integer> path = new ArrayList<Integer>();\n        search(0, s, path, isWord, possible, result);\n        return result;\n    }\n}\n\n// version 2:\n\npublic class Solution {\n    public ArrayList<String> wordBreak(String s, Set<String> dict) {\n        // Note: The Solution object is instantiated only once and is reused by each test case.\n        Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\n        return wordBreakHelper(s,dict,map);\n    }\n\n    public ArrayList<String> wordBreakHelper(String s, Set<String> dict, Map<String, ArrayList<String>> memo){\n        if(memo.containsKey(s)) return memo.get(s);\n        ArrayList<String> result = new ArrayList<String>();\n        int n = s.length();\n        if(n <= 0) return result;\n        for(int len = 1; len <= n; ++len){\n            String subfix = s.substring(0,len);\n            if(dict.contains(subfix)){\n                if(len == n){\n                    result.add(subfix);\n                }else{\n                    String prefix = s.substring(len);\n                    ArrayList<String> tmp = wordBreakHelper(prefix, dict, memo);\n                    for(String item:tmp){\n                        item = subfix + \" \" + item;\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        memo.put(s, result);\n        return result;\n    }\n}\n\n\n//version：高频题班\npublic class Solution {\n    Map<String, List<String>> done = new HashMap<>();\n    Set<String> dict;\n\n    public List<String> wordBreak(String s, Set<String> dict) {\n        this.dict = dict;\n        done.put(\"\", new ArrayList<>());\n        done.get(\"\").add(\"\");\n\n        return dfs(s);\n    }\n\n    List<String> dfs(String s) {\n        if (done.containsKey(s)) {\n            return done.get(s);\n        }\n        List<String> ans = new ArrayList<>();\n\n        for (int len = 1; len <= s.length(); len++) {  //将s 分割成s1 s2  其中s1长度为len\n            String s1 = s.substring(0, len);\n            String s2 = s.substring(len);\n\n            if (dict.contains(s1)) {\n                List<String> s2_res = dfs(s2);\n                for (String item : s2_res) {\n                    if (item == \"\") {\n                        ans.add(s1);\n                    } else {\n                        ans.add(s1 + \" \" + item);\n                    }\n                }\n            }\n        }\n        done.put(s, ans);\n        return ans;\n    }\n}"}]},{"id":138,"unique_name":"scramble-string","title":"攀爬字符串","description":"给定一个字符串 `S1`，将其递归地分割成两个非空子字符串,从而将其表示为二叉树。\r\n\r\n下面是`s1 = \"great\"`的一个可能表达：\r\n\r\n        great\r\n       /    \\\r\n      gr    eat\r\n     / \\    /  \\\r\n    g   r  e   at\r\n               / \\\r\n              a   t\r\n\r\n在攀爬字符串的过程中，我们可以选择其中任意一个非叶节点，然后交换该节点的两个儿子。\r\n\r\n例如，我们选择了 `\"gr\"` 节点，并将该节点的两个儿子进行交换，从而产生了攀爬字符串 `\"rgeat\"`。\r\n\r\n\r\n        rgeat\r\n       /    \\\r\n      rg    eat\r\n     / \\    /  \\\r\n    r   g  e   at\r\n               / \\\r\n              a   t\r\n\r\n我们认为， `\"rgeat\"` 是 `\"great\"` 的一个攀爬字符串.\r\n\r\n类似地，如果我们继续将其节点 `\"eat\"` 和 `\"at\"` 进行交换，就会产生新的攀爬字符串 `\"rgtae\"`。\r\n\r\n        rgtae\r\n       /    \\\r\n      rg    tae\r\n     / \\    /  \\\r\n    r   g  ta  e\r\n           / \\\r\n          t   a\r\n\r\n同样地，`\"rgtae\"` 也是 `\"great\"`的一个攀爬字符串。\r\n\r\n给定两个相同长度的字符串`s1` 和 `s2`，判定 `s2` 是否为 `s1` 的攀爬字符串。","solutions":[{"language":"java","code":"// 记忆化搜索\r\npublic class Solution {\r\n    /**\r\n     * @param s1 A string\r\n     * @param s2 Another string\r\n     * @return whether s2 is a scrambled string of s1\r\n     */\r\n    HashMap<String, Boolean> hash = new HashMap<String, Boolean>();\r\n    \r\n    public boolean isScramble(String s1, String s2) {\r\n        // Write your code here\r\n        if (s1.length() != s2.length())\r\n            return false;\r\n            \r\n        if (hash.containsKey(s1 + \"#\" + s2))\r\n            return hash.get(s1 + \"#\" + s2);\r\n        \r\n        int n = s1.length();\r\n        if (n == 1) {\r\n            return s1.charAt(0) == s2.charAt(0);\r\n        }\r\n        for (int k = 1; k < n; ++k) {\r\n            if (isScramble(s1.substring(0, k), s2.substring(0, k)) &&\r\n                isScramble(s1.substring(k, n), s2.substring(k, n)) ||\r\n                isScramble(s1.substring(0, k), s2.substring(n - k, n)) &&\r\n                isScramble(s1.substring(k, n), s2.substring(0, n - k))\r\n                ) {\r\n                hash.put(s1 + \"#\" + s2, true);\r\n                return true;\r\n            }\r\n        }\r\n        hash.put(s1 + \"#\" + s2, false);\r\n        return false;\r\n    }\r\n}\r\n\r\n// 递推\r\npublic class Solution {\r\n    /**\r\n     * @param s1 A string\r\n     * @param s2 Another string\r\n     * @return whether s2 is a scrambled string of s1\r\n     */\r\n    public boolean isScramble(String s1, String s2) {\r\n        // Write your code here\r\n        if (s1.length() != s2.length())\r\n            return false;\r\n        int n = s1.length();\r\n        boolean[][][] dp = new boolean[n][n][n+1];\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = 0; j < n; ++j)\r\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\r\n            \r\n        for (int len = 2; len <= n; ++len)\r\n            for (int x = 0; x < n && x + len <= n; ++x)\r\n                for (int y = 0; y < n && y + len <=n; ++y)\r\n                    for (int k= 1; k < len; ++k)\r\n                    dp[x][y][len] |= dp[x][y][k] && dp[x + k][y + k][len - k]\r\n                    || dp[x][y + len - k][k] && dp[x + k][y][len - k];\r\n    \r\n        return dp[0][0][n];\r\n    }\r\n}\r\n\r\n// 普通搜索\r\npublic class Solution {\r\n    /**\r\n     * @param s1 A string\r\n     * @param s2 Another string\r\n     * @return whether s2 is a scrambled string of s1\r\n     */\r\n    public boolean isScramble(String s1, String s2) {\r\n        // Write your code here\r\n        if (s1.length() != s2.length()) {\r\n            return false;\r\n        }\r\n        \r\n        if (s1.length() == 0 || s1.equals(s2)) {\r\n            return true;\r\n        }\r\n        \r\n        if (!isValid(s1, s2)) {\r\n            return false;\r\n        }// Base Cases\r\n        \r\n        \r\n        for (int i = 1; i < s1.length(); i++) {\r\n            String s11 = s1.substring(0, i);\r\n            String s12 = s1.substring(i, s1.length());\r\n            String s21 = s2.substring(0, i);\r\n            String s22 = s2.substring(i, s2.length());\r\n            String s23 = s2.substring(0, s2.length() - i);\r\n            String s24 = s2.substring(s2.length() - i, s2.length());\r\n            \r\n            if (isScramble(s11, s21) && isScramble(s12, s22)) return true;\r\n            if (isScramble(s11, s24) && isScramble(s12, s23)) return true;// cut \r\n            \r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \r\n    private boolean isValid(String s1, String s2) {\r\n        char[] arr1 = s1.toCharArray();\r\n        char[] arr2 = s2.toCharArray();\r\n        Arrays.sort(arr1);\r\n        Arrays.sort(arr2);\r\n        if (!(new String(arr1)).equals(new String(arr2))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// 记忆化搜索\r\npublic class Solution {\r\n    /**\r\n     * @param s1 A string\r\n     * @param s2 Another string\r\n     * @return whether s2 is a scrambled string of s1\r\n     */\r\n     \r\n     private boolean checkScramble(String s1,int start1, String s2, int start2, int k, int [][][]visit) {\r\n\t\tif(visit[start1][start2][k] == 1)\r\n            return true;\r\n        if(visit[start1][start2][k] ==-1)\r\n            return false;\r\n        \r\n        \r\n        if (s1.length() != s2.length()) {\r\n            visit[start1][start2][k] = -1;\r\n            return false;\r\n        }\r\n        \r\n        if (s1.length() == 0 || s1.equals(s2)) {\r\n            visit[start1][start2][k] = 1;\r\n            return true;\r\n        }\r\n        \r\n        if (!isValid(s1, s2)) {\r\n            visit[start1][start2][k] = -1;\r\n            return false;\r\n        }// Base Cases\r\n        \r\n        \r\n        for (int i = 1; i < s1.length(); i++) {\r\n            String s11 = s1.substring(0, i);\r\n            String s12 = s1.substring(i, s1.length());\r\n            \r\n            String s21 = s2.substring(0, i);\r\n            String s22 = s2.substring(i, s2.length());\r\n            \r\n            String s23 = s2.substring(0, s2.length() - i);\r\n            String s24 = s2.substring(s2.length() - i, s2.length());\r\n            \r\n            if (checkScramble(s11,start1, s21, start2, i, visit) && checkScramble(s12, start1+i, s22, start2+i,k-i, visit))  {\r\n                visit[start1][start2][k] = 1;\r\n                return true;\r\n            }\r\n            \r\n            if (checkScramble(s11,start1, s24, start2+k-i, i, visit) && checkScramble(s12,start1+i, s23,start2, k-i, visit))\r\n            {\r\n                visit[start1][start2][k] = 1;\r\n                return true;\r\n            }\r\n        }\r\n        visit[start1][start2][k] = -1;\r\n        return false;\r\n    }\r\n    public boolean isScramble(String s1, String s2) {\r\n        int len = s1.length();\r\n        int [][][] visit = new int[len][len][len + 1];\r\n        return checkScramble(s1,0,s2,0, len, visit);\r\n    }\r\n    \r\n    \r\n    private boolean isValid(String s1, String s2) {\r\n        char[] arr1 = s1.toCharArray();\r\n        char[] arr2 = s2.toCharArray();\r\n        Arrays.sort(arr1);\r\n        Arrays.sort(arr2);\r\n        if (!(new String(arr1)).equals(new String(arr2))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param s1 A string\r\n     * @param s2 Another string\r\n     * @return whether s2 is a scrambled string of s1\r\n     */\r\n    \r\n    bool isScramble(string s1, string s2) {\r\n        // Start typing your C/C++ solution below\r\n        // DO NOT write int main() function\r\n        \r\n        if (s1 == s2)\r\n            return true;\r\n        \r\n        int size = s1.size();\r\n        \r\n        int value1=0, value2=0;\r\n        for (int i=0; i<size; ++i) {\r\n            value1 += (s1[i]-'a');\r\n            value2 += (s2[i]-'a');\r\n        }\r\n        if (value1 != value2)\r\n            return false; \r\n        \r\n        for (int i=1; i<size;i++) {\r\n            if (isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.\r\nsubstr(i), s2.substr(i)))\r\n                return true;\r\n            if (isScramble(s1.substr(0,i), s2.substr(size-i)) && isScramble(\r\ns1.substr(i), s2.substr(0,size-i)))\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n};\r\n\r\n\r\nclass Solution {\r\npublic:\r\n    bool sameCharset(string &s1, string &s2) {\r\n        if (s1.length() != s2.length()) {\r\n            return false;\r\n        }\r\n        \r\n        unordered_map<char, int> count;\r\n        for (int i = 0; i < s1.length(); i++) {\r\n            if (count.find(s1[i]) == count.end()) {\r\n                count[s1[i]] = 1;\r\n            } else {\r\n                count[s1[i]]++;\r\n            }\r\n        }\r\n        for (int i = 0; i < s2.length(); i++) {\r\n            if (count.find(s2[i]) == count.end()) {\r\n                return false;\r\n            } else {\r\n                count[s2[i]]--;\r\n                if (count[s2[i]] < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }   \r\n}\r\n    \r\nbool memoSearch(unordered_map<string, bool> &hash,\r\n                    string s1, string s2) {\r\n        string key = s1 + \" \" + s2;\r\n        if (s1 == s2) {\r\n            hash[key] = true;\r\n            return true;\r\n        }\r\n        if (hash.find(key) != hash.end()) {\r\n            return hash[key];\r\n        }\r\n        \r\n        if (!sameCharset(s1, s2)) {\r\n            hash[key] = false;\r\n            return false;\r\n        }\r\n        \r\n        int size = s1.length();\r\n        for (int i = 1; i < size; i++) {\r\n            if (memoSearch(hash, s1.substr(0, i), s2.substr(0, i)) && \r\n                    memoSearch(hash, s1.substr(i, size - i), s2.substr(i, size - i))) {\r\n                hash[key] = true;\r\n                return true;\r\n            }\r\n            if (memoSearch(hash, s1.substr(0, i), s2.substr(size - i, i)) &&\r\n                    memoSearch(hash, s1.substr(i, size - i), s2.substr(0, size - i))) {\r\n                hash[key] = true;\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        hash[key] = false;\r\n        return false;\r\n    }\r\n    \r\n    bool isScramble(string s1, string s2) {\r\n        unordered_map<string, bool> hash;\r\n        return memoSearch(hash, s1, s2);\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @return a boolean\r\n    def isScramble(self, s1, s2):\r\n        if len(s1)!=len(s2): return False\r\n        if s1==s2: return True\r\n        l1=list(s1); l2=list(s2)\r\n        l1.sort();l2.sort()\r\n        if l1!=l2: return False\r\n        length=len(s1)\r\n        for i in range(1,length):\r\n            if self.isScramble(s1[:i],s2[:i]) and self.isScramble(s1[i:],s2[i:]): return True\r\n            if self.isScramble(s1[:i],s2[length-i:]) and self.isScramble(s1[i:],s2[:length-i]): return True\r\n        return False\r\n"}]},{"id":132,"unique_name":"unique-binary-search-trees-ii","title":"不同的二叉查找树 II","description":"<p><span style=\"color: rgb(113, 113, 113); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\">给出n，生成所有由1...n为节点组成的不同的二叉查找树</span><br></p>","solutions":[{"language":"java","code":"public class Solution {\n    public ArrayList<TreeNode> generateTrees(int n) {\n        return generate(1, n);\n    }\n    \n    private ArrayList<TreeNode> generate(int start, int end){\n        ArrayList<TreeNode> rst = new ArrayList<TreeNode>();   \n    \n        if(start > end){\n            rst.add(null);\n            return rst;\n        }\n     \n        for(int i=start; i<=end; i++){\n            ArrayList<TreeNode> left = generate(start, i-1);\n            ArrayList<TreeNode> right = generate(i+1, end);\n            for(TreeNode l: left){\n                for(TreeNode r: right){\n                    // should new a root here because it need to \n                    // be different for each tree\n                    TreeNode root = new TreeNode(i);  \n                    root.left = l;\n                    root.right = r;\n                    rst.add(root);\n                }\n            }\n        }\n        return rst;\n    }\n}"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @paramn n: An integer\n     * @return: A list of root\n     */\n    vector<TreeNode *> generate(int beg, int end)\n    {\n        vector<TreeNode* > ret;\n        if (beg > end)\n        {\n            ret.push_back(NULL);\n            return ret;\n        }\n        \n        for(int i = beg; i <= end; i++)\n        {\n            vector<TreeNode* > leftTree = generate(beg, i - 1);\n            vector<TreeNode* > rightTree = generate(i + 1, end);\n            for(int j = 0; j < leftTree.size(); j++)\n                for(int k = 0; k < rightTree.size(); k++)\n                {\n                    TreeNode *node = new TreeNode(i + 1);\n                    ret.push_back(node);\n                    node->left = leftTree[j];\n                    node->right = rightTree[k];              \n                }           \n        }\n        \n        return ret;\n    }\n    vector<TreeNode *> generateTrees(int n) {\n        // write your code here\n        return generate(0,n-1);\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\nclass Solution:\n    # @paramn n: An integer\n    # @return: A list of root\n    def generateTrees(self, n):\n        # write your code here\n        return self.dfs(1, n)\n        \n    def dfs(self, start, end):\n        if start > end: return [None]\n        res = []\n        for rootval in range(start, end+1):\n            LeftTree = self.dfs(start, rootval-1)\n            RightTree = self.dfs(rootval+1, end)\n            for i in LeftTree:\n                for j in RightTree:\n                    root = TreeNode(rootval)\n                    root.left = i\n                    root.right = j\n                    res.append(root)\n        return res\n"}]},{"id":131,"unique_name":"unique-binary-search-trees","title":"不同的二叉查找树","description":"给出 *n*，问由 1...*n* 为节点组成的不同的二叉查找树有多少种？","solutions":[{"language":"java","code":"public class Solution {\r\n/*\r\nThe case for 3 elements example\r\nCount[3] = Count[0]*Count[2]  (1 as root)\r\n              + Count[1]*Count[1]  (2 as root)\r\n              + Count[2]*Count[0]  (3 as root)\r\n\r\nTherefore, we can get the equation:\r\nCount[i] = ∑ Count[0...k] * [ k+1....i]     0<=k<i-1  \r\n\r\n*/\r\n    public int numTrees(int n) {\r\n        int[] count = new int[n + 2];\r\n        count[0] = 1;\r\n        count[1] = 1;\r\n        \r\n        for(int i = 2; i <= n; i++){\r\n            for(int j = 0; j < i; j++){\r\n                count[i] += count[j] * count[i - j - 1];\r\n            }\r\n        }\r\n        return count[n];\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @paramn n: An integer\r\n     * @return: An integer\r\n     */\r\n    int numTrees(int n) {\r\n        // write your code here\r\n        int f[n + 1];\r\n        memset(f, 0, sizeof(int) * (n + 1));\r\n        f[0] = 1;\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 0; j < i; j++) {\r\n                f[i] += f[j] * f[i - 1 - j];\r\n            }\r\n        }\r\n        return f[n];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @paramn n: An integer\r\n    # @return: An integer\r\n    def numTrees(self, n):\r\n        # write your code here\r\n        dp = [1, 1, 2]\r\n        if n <= 2:\r\n            return dp[n]\r\n        else:\r\n            dp += [0 for i in range(n-2)]\r\n            for i in range(3, n + 1):\r\n                for j in range(1, i+1):\r\n                    dp[i] += dp[j-1] * dp[i-j]\r\n            return dp[n]\r\n"},{"language":"javascript","code":"/**\n * @param n: An integer\n * @return: An integer\n */\nconst numTrees = function (n) {\n    var count, i, j;\n    count = new Array(n + 2);\n    count[0] = 1;\n    count[1] = 1;\n    for (i = 2; i <= n; i++) {\n        count[i] = 0;\n        for (j = 0; j < i; j++) {\n            count[i] += count[j] * count[i - j - 1];\n        }\n    }\n    return count[n];\n}"}]},{"id":60,"unique_name":"edit-distance","title":"编辑距离","description":"<p>给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。</p><p>你总共三种操作方法：</p><p></p><ul><li><span style=\"line-height: 1.42857143;\">插入一个字符</span></li><li><span style=\"line-height: 1.42857143;\">删除一个字符</span></li><li><span style=\"line-height: 1.42857143;\">替换一个字符</span><br></li></ul><p></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int minDistance(String word1, String word2) {\r\n        int n = word1.length();\r\n        int m = word2.length();\r\n        \r\n        int[][] dp = new int[n+1][m+1];\r\n        for(int i=0; i< m+1; i++){\r\n            dp[0][i] = i; \r\n        }\r\n        for(int i=0; i<n+1; i++){\r\n            dp[i][0] = i;\r\n        }\r\n        \r\n        \r\n        for(int i = 1; i<n+1; i++){\r\n            for(int j=1; j<m+1; j++){\r\n                if(word1.charAt(i-1) == word2.charAt(j-1)){\r\n                    dp[i][j] = dp[i-1][j-1];\r\n                }else{\r\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));\r\n                }\r\n            }\r\n        }\r\n        return dp[n][m];\r\n    }\r\n}\r\n\r\n// 动态规划班版本\r\npublic class Solution {\r\n    /**\r\n     * @param word1 & word2: Two string.\r\n     * @return: The minimum number of steps.\r\n     */\r\n    public int minDistance(String word1, String word2) {\r\n        char[] s1 = word1.toCharArray();   \r\n        char[] s2 = word2.toCharArray();\r\n        int i, j;\r\n        int m = s1.length;\r\n        int n = s2.length;\r\n        \r\n        int[][] f = new int[m + 1][n + 1];\r\n        \r\n        // commented part is for outputting solution\r\n        // 'I', 'D', 'R', 'S'\r\n        //char[][] pi = new char[m + 1][n + 1];\r\n        for (i = 0; i <= m; ++i) {\r\n            for (j = 0; j <= n; ++j) {\r\n                if (i == 0) {\r\n                    f[i][j] = j;\r\n                    continue;\r\n                }\r\n                \r\n                if (j == 0) {\r\n                    f[i][j] = i;\r\n                    continue;\r\n                }\r\n                \r\n                // i > 0, j > 0\r\n                \r\n                // +1, important!\r\n                    //                       delete        insert         replace\r\n                f[i][j] = Math.min(Math.min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1;\r\n                /*if (f[i][j] == f[i - 1][j] + 1) {\r\n                    pi[i][j] = 'D';\r\n                }\r\n                else {\r\n                    if (f[i][j] == f[i][j - 1] + 1) {\r\n                        pi[i][j] = 'I';\r\n                    }\r\n                    else {\r\n                        pi[i][j] = 'R';\r\n                    }\r\n                }*/\r\n                \r\n                if (s1[i - 1] == s2[j - 1]) {\r\n                    f[i][j] = Math.min(f[i][j], f[i - 1][j - 1]);\r\n                  //  pi[i][j] = 'S';\r\n                }\r\n            }\r\n        }\r\n        \r\n        /*i = m;\r\n        j = n;\r\n        \r\n        while (i > 0 || j > 0) {\r\n            if (pi[i][j] == 'D') {\r\n                System.out.println(\"Delete A's \" + i + \"-th letter from A\");\r\n                --i;\r\n                continue;\r\n            }\r\n            \r\n            if (pi[i][j] == 'I') {\r\n                System.out.println(\"Insert B's \" + j + \"-th letter of B to A\");\r\n                --j;\r\n                continue;\r\n            }\r\n            \r\n            if (pi[i][j] == 'R') {\r\n                System.out.println(\"Replace the A's \" + i + \"-th letter to B's \" + j + \"-th letter\");\r\n                --i;\r\n                --j;\r\n                continue;\r\n            }\r\n            \r\n            if (pi[i][j] == 'S') {\r\n                --i;\r\n                --j;\r\n                continue;\r\n            }\r\n        }*/\r\n        \r\n        return f[m][n];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param word1 & word2: Two string.\r\n     * @return: The minimum number of steps.\r\n     */\r\n    int minDistance(string word1, string word2) {\r\n        // write your code here\r\n        int row = word1.length() + 1;\r\n        int col = word2.length() + 1;\r\n        vector<vector<int> > f(row, vector<int>(col));\r\n        for (int i = 0; i < row; i++)\r\n            f[i][0] = i;\r\n        for (int i = 0; i < col; i++)\r\n            f[0][i] = i;\r\n        for (int i = 1; i < row; i++)\r\n            for (int j = 1; j < col; j++){\r\n                if (word1[i-1] == word2[j-1])\r\n                    f[i][j] = f[i-1][j-1];\r\n                else\r\n                    f[i][j] = f[i-1][j-1] + 1;\r\n                f[i][j] = min(f[i][j], min(f[i-1][j]+1, f[i][j-1]+1));\r\n            }\r\n\r\n        return f[row-1][col-1];\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution: \r\n    # @param word1 & word2: Two string.\r\n    # @return: The minimum number of steps.\r\n    def minDistance(self, word1, word2):\r\n        # write your code here\r\n        len1 = len(word1)\r\n        len2 = len(word2)\r\n        f = [[0] * (len2 + 1) for i in range(len1 + 1)] \r\n        for i in range(len1 + 1):\r\n            f[i][0] = i\r\n        for j in range(len2 + 1):\r\n            f[0][j] = j\r\n\r\n        for i in range(1, len1 + 1):\r\n            for j in range(1, len2 + 1):\r\n                if word2[j - 1] == word1[i - 1]:\r\n                    f[i][j] = f[i - 1][j - 1]\r\n                else:\r\n                    f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1]) + 1\r\n                    \t\r\n        return f[len1][len2]\r\n"}]},{"id":42,"unique_name":"distinct-subsequences","title":"不同的子序列","description":"<p>给出字符串S和字符串T，计算S的不同的子序列中T出现的个数。</p><p>子序列字符串是原始字符串通过删除一些(或零个)产生的一个新的字符串，并且对剩下的字符的相对位置没有影响。(比如，<b><font color=\"#e76363\">“ACE”</font></b>是<font color=\"#e76363\"><b>“ABCDE”</b></font>的子序列字符串,而<font color=\"#e76363\"><b>“AEC”</b></font>不是)。&nbsp;</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int numDistinct(String S, String T) {\r\n        if (S == null || T == null) {\r\n            return 0;\r\n        }\r\n\r\n        int[][] nums = new int[S.length() + 1][T.length() + 1];\r\n\r\n        for (int i = 0; i <= S.length(); i++) {\r\n            nums[i][0] = 1;\r\n        }\r\n        for (int i = 1; i <= S.length(); i++) {\r\n            for (int j = 1; j <= T.length(); j++) {\r\n                nums[i][j] = nums[i - 1][j];\r\n                if (S.charAt(i - 1) == T.charAt(j - 1)) {\r\n                    nums[i][j] += nums[i - 1][j - 1];\r\n                }\r\n            }\r\n        }\r\n        return nums[S.length()][T.length()];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:    \n    /**\n     * @param S, T: Two string.\n     * @return: Count the number of distinct subsequences\n     */\n    int numDistinct(string &S, string &T) {\n        // write your code here\n        vector<vector<int>> t(T.length()+1,vector<int>(S.length()+1));\n        for(int i=0;i<=T.length();i++) t[i][0]=0;\n        for(int i=0;i<=S.length();i++) t[0][i]=0;\n        for(int i=1;i<=S.length();i++)\n        {\n            if(T[0]==S[i-1])\n                t[1][i]=t[1][i-1]+1;\n            else\n                t[1][i]=t[1][i-1];    \n        }\n        \n        \n        for(int i=2;i<=T.length();i++)\n        {\n            for(int j=1; j<=S.length();j++)\n            {\n                if(T[i-1]==S[j-1])\n                    t[i][j]=t[i-1][j-1]+t[i][j-1];\n                else\n                    t[i][j]=t[i][j-1];\n            }\n        }\n        return t[T.length()][S.length()];\n    }\n};\n\n"},{"language":"python","code":"class Solution: \n    # @param S, T: Two string.\n    # @return: Count the number of distinct subsequences\n    def numDistinct(self, S, T):\n        # write your code here\n        dp = [[0 for j in range(len(T) + 1)] for i in range(len(S) + 1)]\n        for i in range(len(S) + 1):\n   \t\t\tdp[i][0] = 1\n        for i in xrange(len(S)):\n            for j in xrange(len(T)):\n                if S[i] == T[j]:\n                    dp[i+1][j+1] = dp[i][j+1] + dp[i][j]\n                else:\n                    dp[i+1][j+1] = dp[i][j + 1]\n        return dp[len(S)][len(T)]\n                \n"}]},{"id":69,"unique_name":"minimum-path-sum","title":"最小路径和","description":"<p><span style=\"line-height: 1.42857143;\">给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</span><br></p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int minPathSum(int[][] grid) {\r\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        int M = grid.length;\r\n        int N = grid[0].length;\r\n        int[][] sum = new int[M][N];\r\n\r\n        sum[0][0] = grid[0][0];\r\n\r\n        for (int i = 1; i < M; i++) {\r\n            sum[i][0] = sum[i - 1][0] + grid[i][0];\r\n        }\r\n\r\n        for (int i = 1; i < N; i++) {\r\n            sum[0][i] = sum[0][i - 1] + grid[0][i];\r\n        }\r\n\r\n        for (int i = 1; i < M; i++) {\r\n            for (int j = 1; j < N; j++) {\r\n                sum[i][j] = Math.min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];\r\n            }\r\n        }\r\n\r\n        return sum[M - 1][N - 1];\r\n    }\r\n}\r\n\r\n// 方法二\r\npublic class Solution {\r\n    /**\r\n     * @param grid: a list of lists of integers.\r\n     * @return: An integer, minimizes the sum of all numbers along its path\r\n     */\r\n    public int minPathSum(int[][] A) {\r\n        if (A == null || A.length == 0 || A[0].length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int m = A.length, n = A[0].length;\r\n        int[][] f = new int[2][n];\r\n        int old, now = 0;\r\n        \r\n        for (int i = 0; i < m; ++i) {\r\n            old = now;\r\n            now = 1 - now;\r\n            for (int j = 0; j < n; ++j) {\r\n                int min = -1;\r\n                if (i > 0 && (min == -1 || f[old][j] < min)) {\r\n                    min = f[old][j];\r\n                }\r\n                if (j > 0 && (min == -1 || f[now][j-1] < min)) {\r\n                    min = f[now][j-1];\r\n                }\r\n                \r\n                if (min == -1) {\r\n                    min = 0;\r\n                }\r\n                \r\n                f[now][j] = min + A[i][j];\r\n            }\r\n        }\r\n        \r\n        return f[now][n-1];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param grid: a list of lists of integers.\r\n     * @return: An integer, minimizes the sum of all numbers along its path\r\n     */\r\n    int minPathSum(vector<vector<int> > &grid) {\r\n        // write your code here\r\n        int f[1000][1000];\r\n        if (grid.size() == 0 || grid[0].size() == 0)\r\n            return 0;\r\n        f[0][0] = grid[0][0];\r\n        for(int i = 1; i < grid.size(); i++)\r\n            f[i][0] = f[i-1][0] + grid[i][0];\r\n        for(int i = 1; i < grid[0].size(); i++)\r\n            f[0][i] = f[0][i-1] + grid[0][i];\r\n        for(int i = 1; i < grid.size(); i++)\r\n            for(int j = 1; j < grid[0].size(); j++)\r\n                f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j];\r\n                \r\n        return f[grid.size()-1][grid[0].size()-1];\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param grid: a list of lists of integers.\r\n    @return: An integer, minimizes the sum of all numbers along its path\r\n    \"\"\"\r\n    def minPathSum(self, grid):\r\n        for i in range(len(grid)):\r\n            for j in range(len(grid[0])):\r\n                if i == 0 and j > 0:\r\n                    grid[i][j] += grid[i][j-1]\r\n                elif j == 0 and i > 0:\r\n                    grid[i][j] += grid[i-1][j]\r\n                elif i > 0 and j > 0:\r\n                    grid[i][j] += min(grid[i-1][j], grid[i][j-1])\r\n        return grid[len(grid) - 1][len(grid[0]) - 1]\r\n"}]},{"id":162,"unique_name":"backpack","title":"背包问题","description":"<p>在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]</p>","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param m: An integer m denotes the size of a backpack\n     * @param A: Given n items with size A[i]\n     * @return: The maximum size\n     */\n    public int backPack(int m, int[] A) {\n        boolean f[][] = new boolean[A.length + 1][m + 1];\n        for (int i = 0; i <= A.length; i++) {\n            for (int j = 0; j <= m; j++) {\n                f[i][j] = false;\n            }\n        }\n        f[0][0] = true;\n        for (int i = 1; i <= A.length; i++) {\n            for (int j = 0; j <= m; j++) {\n                f[i][j] = f[i - 1][j];\n                if (j >= A[i-1] && f[i-1][j - A[i-1]]) {\n                    f[i][j] = true;\n                }\n            } // for j\n        } // for i\n        \n        for (int i = m; i >= 0; i--) {\n            if (f[A.length][i]) {\n                return i;\n            }\n        }\n        \n        return 0;\n    }\n}\n\n\n// O(m) 空间复杂度的解法\npublic class Solution {\n    /**\n     * @param m: An integer m denotes the size of a backpack\n     * @param A: Given n items with size A[i]\n     * @return: The maximum size\n     */\n    public int backPack(int m, int[] A) {\n        int f[] = new int[m + 1];\n\n        for (int i = 0; i < A.length; i++) {\n            for (int j = m; j >= A[i]; j--) {\n                f[j] = Math.max(f[j], f[j - A[i]] + A[i]);\n            } \n        }\n        return f[m];\n    }\n}"},{"language":"cpp","code":"\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param m: An integer m denotes the size of a backpack\r\n     * @param A: Given n items with size A[i]\r\n     * @return: The maximum size\r\n     */\r\n    int backPack(int m, vector<int> A) {\r\n        bool f[m + 1];\r\n        for (int i = 0; i <= m; i++) {\r\n            f[i] = false;\r\n        }\r\n        f[0] = true;\r\n        for (int j = 0; j < A.size(); j++) {\r\n            for (int i = m; i >= A[j]; i--) {\r\n                f[i] = f[i] || f[i - A[j]];\r\n            } // for j\r\n        } // for i\r\n        \r\n        for (int i = m; i >= 0; i--) {\r\n            if (f[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param m: An integer m denotes the size of a backpack\r\n    # @param A: Given n items with size A[i]\r\n    # @return: The maximum size\r\n    def backPack(self, m, A):\r\n        # write your code here\r\n        n = len(A)\r\n        dp = [0 for x in range(m+1)]\r\n        dp[0] = 1\r\n        ans = 0\r\n        for item in A:\r\n            for i in range(m,-1,-1):\r\n                if i-item >=0 and dp[i-item] > 0:\r\n                    ans = max(ans,i)\r\n                    dp[i] = 1\r\n        return ans    \r\n"},{"language":"javascript","code":"/**\n * @param m: An integer m denotes the size of a backpack\n * @param A: Given n items with size A[i]\n * @return: The maximum size\n */\nconst backPack = function (m, A) {\n    var f = new Array(m + 1);\n    var i, j;\n    for (i = 0; i < m + 1; i++) {\n        f[i] = 0;\n    }\n    for (i = 0; i < A.length; i++) {\n        for (j = m; j >= A[i]; j--) {\n            f[j] = Math.max(f[j], f[j - A[i]] + A[i]);\n        } \n    }\n    return f[m];\n}"}]},{"id":158,"unique_name":"longest-common-subsequence","title":"最长公共子序列","description":"<p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A, B: Two strings.\r\n     * @return: The length of longest common subsequence of A and B.\r\n     */\r\n    public int longestCommonSubsequence(String A, String B) {\r\n        int n = A.length();\r\n\t    int m = B.length();\r\n        int f[][] = new int[n + 1][m + 1];\r\n        for(int i = 1; i <= n; i++){\r\n            for(int j = 1; j <= m; j++){\r\n                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\r\n                if(A.charAt(i - 1) == B.charAt(j - 1))\r\n                    f[i][j] = f[i - 1][j - 1] + 1;\r\n            }\r\n        }\r\n        return f[n][m];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param A, B: Two strings.\n     * @return: The length of longest common subsequence of A and B.\n     */\n    int longestCommonSubsequence(string A, string B) {\n        // write your code here\n        /* state function: \n            dp[i+1][j+1] = dp[i][j]    A[i] = B[j]\n                         = max(dp[i-1][j], dp[i][j-1])\n            dp[0][j] = dp[i][0] = 0\n        */                         \n        \n        int len_a = A.size();\n        int len_b = B.size();\n        if(len_a == 0 || len_b == 0) {\n            return 0;\n        }\n    \n        int **dp = (int **)malloc((len_a+1) * sizeof(int *));\n        for (int i = 0; i < len_a + 1; i++)\n            dp[i] = (int *)malloc((len_b+1) * sizeof(int));\n        \n        /*\n        vector<vector<int> > dp;\n        for(int i = 0; i < len_a+1; i ++) {\n            vector<int> one(len_b+1, 0);\n            dp.push_back(one);\n        }\n        */\n    \n        for(int i = 0; i < len_a+1; i ++) {\n            dp[i][0] = 0;\n        }\n        for(int j = 0; j < len_b+1; j ++) {\n            dp[0][j] = 0;\n        }\n        \n        for(int i = 1; i < len_a+1; i ++) {\n            for(int j = 1; j < len_b+1; j ++) {\n                if(A[i-1] == B[j-1]) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else {\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        \n        return dp[len_a][len_b];\n    }\n};\n\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A, B: Two strings.\r\n    @return: The length of longest common subsequence of A and B.\r\n    \"\"\"\r\n    def longestCommonSubsequence(self, A, B):\r\n        n, m = len(A), len(B)\r\n        f = [[0] * (n + 1) for i in range(m + 1)]\r\n        for i in range(n):\r\n            for j in range(m):\r\n                f[i + 1][j + 1] = max(f[i][j + 1], f[i + 1][j])\r\n                if A[i] == B[j]:\r\n                    f[i + 1][j + 1] = f[i][j] + 1\r\n        return f[n][m]\r\n"}]},{"id":160,"unique_name":"interleaving-string","title":"交叉字符串","description":"<p><span style=\"font-family: 宋体; font-size: 10.5pt; line-height: 13.5pt;\">给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。</span></p><p class=\"MsoNormal\" style=\"margin: 0pt; padding: 0pt; line-height: 16.5pt;\"><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean isInterleave(String s1, String s2, String s3) {\r\n        if (s1.length() + s2.length() != s3.length()) {\r\n            return false;\r\n        }\r\n        \r\n        boolean [][] interleaved = new boolean[s1.length() + 1][s2.length() + 1];\r\n        interleaved[0][0] = true;\r\n        \r\n        for (int i = 1; i <= s1.length(); i++) {\r\n            if(s3.charAt(i - 1) == s1.charAt(i - 1) && interleaved[i - 1][0])\r\n                interleaved[i][0] = true;\r\n        }\r\n        \r\n        for (int j = 1; j <= s2.length(); j++) {\r\n            if(s3.charAt(j - 1) == s2.charAt(j - 1) && interleaved[0][j - 1])\r\n                interleaved[0][j] = true;\r\n        }\r\n        \r\n        for (int i = 1; i <= s1.length(); i++) {\r\n            for (int j = 1; j <= s2.length(); j++) {\r\n                if(((s3.charAt(i + j - 1) == s1.charAt(i - 1) && interleaved[i - 1][j]))\r\n                    || ((s3.charAt(i + j - 1)) == s2.charAt(j - 1) && interleaved[i][j - 1]))\r\n                interleaved[i][j] = true;\r\n            }\r\n        }\r\n        \r\n        return interleaved[s1.length()][s2.length()];\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * Determine whether s3 is formed by interleaving of s1 and s2.\r\n     * @param s1, s2, s3: As description.\r\n     * @return: true of false.\r\n     */\r\n    bool isInterleave(string s1, string s2, string s3) {\r\n        if (s1.length() + s2.length() != s3.length()) {\r\n            return false;\r\n        }\r\n        \r\n        bool interleave[s1.length() + 1][s2.length() + 1];\r\n        interleave[0][0] = true;\r\n        for (int i = 1; i <= s1.length(); i++) {\r\n            interleave[i][0] = interleave[i - 1][0] && s1[i - 1] == s3[i - 1];\r\n        }\r\n        for (int i = 1; i <= s2.length(); i++) {\r\n            interleave[0][i] = interleave[0][i - 1] && s2[i - 1] == s3[i - 1];\r\n        }\r\n        \r\n        for (int i = 1; i <= s1.length(); i++) {\r\n            for (int j = 1; j <= s2.length(); j++) {\r\n                interleave[i][j] = false;\r\n                if (s1[i - 1] == s3[i + j - 1]) {\r\n                    interleave[i][j] = interleave[i][j] || interleave[i - 1][j];\r\n                }\r\n                if (s2[j - 1] == s3[i + j - 1]) {\r\n                    interleave[i][j] = interleave[i][j] || interleave[i][j - 1];\r\n                }\r\n            }\r\n        }\r\n        \r\n        return interleave[s1.length()][s2.length()];\r\n     }\r\n};\r\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @params s1, s2, s3: Three strings as description.\n    @return: return True if s3 is formed by the interleaving of\n             s1 and s2 or False if not.\n    @hint: you can use [[True] * m for i in range (n)] to allocate a n*m matrix.\n    \"\"\"\n    def isInterleave(self, s1, s2, s3):\n        # write your code here\n        if s1 is None or s2 is None or s3 is None:\n            return False\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        interleave = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        interleave[0][0] = True\n        for i in range(len(s1)):\n            interleave[i + 1][0] = s1[:i + 1] == s3[:i + 1]\n        for i in range(len(s2)):\n            interleave[0][i + 1] = s2[:i + 1] == s3[:i + 1]\n\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                interleave[i + 1][j + 1] = False\n                if s1[i] == s3[i + j + 1]:\n                    interleave[i + 1][j + 1] = interleave[i][j + 1]\n                if s2[j] == s3[i + j + 1]:\n                    interleave[i + 1][j + 1] |= interleave[i + 1][j]\n        return interleave[len(s1)][len(s2)]"}]},{"id":720,"unique_name":"minimum-partition","title":"最小划分","description":"给出一个正整数数组，写一个程序把这个整数数组分成S1跟S2两部分，使S1中的和跟S2中的和的绝对值最小。如果有一个一个整数数组 `S` 有 `n` 个数，如果Subset1有 `m` 个数，Subset2必须有 `n-m` 个数并且 `abs(sum(Subset1) – sum(Subset2))` 应该最小","solutions":[{"language":"java","code":"public class Solution {\n    public int findMin(int[] arr) {\n        int sum = 0;\n        for(int i = 0; i < arr.length; i++){\n            sum += arr[i];\n        }\n        boolean[] dp = new boolean[sum / 2 + 1];\n        dp[0] = true;\n        int min = Integer.MAX_VALUE;\n        for(int num : arr){\n            for(int j = sum / 2; j >= num; j--){\n                dp[j] |= dp[j - num];\n            }\n        }\n        \n        int i = 0;\n        for (i = dp.length - 1; i >= 0; i--) {\n            if (dp[i]) {\n                break;\n            }\n        }\n        \n        return sum - 2 * i;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param : the given array\n     * @return: the minimum difference between their sums \n     */\n    int findMin(vector<int> &nums) {\n        // write your code here\n        int n = nums.size();\n        if (n == 0) return 0;\n        if (n == 1) return nums[0];\n        int sum = 0;\n\n        for (int i = 0; i < n ; ++i) \n            sum += nums[i];\n        \n        vector<int> dp(sum / 2 + 1);\n        dp[0] = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = sum / 2; j >= nums[i]; --j)\n                dp[j] = dp[j - nums[i]] + nums[i] > dp[j] ? dp[j - nums[i]] + nums[i] : dp[j];\n        return abs(sum - 2 * dp[sum / 2]);\n    }\n};"}]},{"id":730,"unique_name":"counting-bits","title":"数 1","description":"给以 **非负** 整数 num. 对所有满足 `0 ≤ i ≤ num` 条件的数字 i 均需要计算其二进制表示 1 的个数并以数组的形式返回","solutions":[{"language":"java","code":"public class Solution {\n    public int[] countBits(int num) {\n        int[] f = new int[num+1];\n        int i;\n        f[0] = 0;\n        for (i=1; i<=num; ++i) {\n            f[i] = f[i&(i-1)] + 1;\n        }\n        \n        return f;\n    }\n}"}]},{"id":281,"unique_name":"submatrix-sum","title":"和为零的子矩阵","description":"给定一个整数矩阵，请找出一个子矩阵，使得其数字之和等于0.输出答案时，请返回左上数字和右下数字的坐标。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param matrix an integer matrix\r\n     * @return the coordinate of the left-up and right-down number\r\n     */\r\n    public int[][] submatrixSum(int[][] matrix) {\r\n        int[][] result = new int[2][2];\r\n        int M = matrix.length;\r\n        if (M == 0) return result;\r\n        int N = matrix[0].length;\r\n        if (N == 0) return result;\r\n        // pre-compute: sum[i][j] = sum of submatrix [(0, 0), (i, j)]\r\n        int[][] sum = new int[M+1][N+1];\r\n        for (int j=0; j<=N; ++j) sum[0][j] = 0;\r\n        for (int i=1; i<=M; ++i) sum[i][0] = 0;\r\n        for (int i=0; i<M; ++i) {\r\n            for (int j=0; j<N; ++j)\r\n                sum[i+1][j+1] = matrix[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j];\r\n        }\r\n        for (int l=0; l<M; ++l) {\r\n            for (int h=l+1; h<=M; ++h) {\r\n                Map<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n                for (int j=0; j<=N; ++j) {\r\n                    int diff = sum[h][j] - sum[l][j];\r\n                    if (map.containsKey(diff)) {\r\n                        int k = map.get(diff);\r\n                        result[0][0] = l;   result[0][1] = k;\r\n                        result[1][0] = h-1; result[1][1] = j-1;\r\n                        return result;\r\n                    } else {\r\n                        map.put(diff, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param matrix an integer matrix\n     * @return the coordinate of the left-up and right-down number\n     */\n    vector<int> subarraySum(vector<int>& nums) {\n\n        map<int,int> mp;\n        mp[0] = -1;\n        vector<int> results;\n        results.push_back(-1);\n        results.push_back(-1);\n        int sum = 0, len = nums.size();\n        for (int i = 0; i < len; ++i) {\n            sum += nums[i];\n            if  (mp.find(sum) != mp.end()) {\n                results[0] = mp[sum] + 1;\n                results[1] = i;\n                return results;\n            }\n            mp[sum] = i;\n        }\n        return results;\n    }\n    \n    vector<vector<int>> submatrixSum(vector<vector<int>>& matrix) {\n        // Write your code here\n        vector<vector<int>> result;\n        vector<int> tmp(2, 1);\n        result.push_back(tmp);\n        result.push_back(tmp);\n        int n = matrix.size();\n        int m = matrix[0].size();    \n        vector<vector<int>> sum = matrix;\n        for (int j = 0; j < m; ++j)\n            for (int i = 1; i < n; ++i)\n                sum[i][j] += sum[i-1][j];\n\n        vector<int> A;\n        for (int j = 0; j < m; ++j)\n            A.push_back(0);\n\n        for (int x1 = 0; x1 < n; ++x1)\n            for (int x2 = x1; x2 < n; ++x2) {\n                for (int j = 0; j < m; ++j)\n                    if (x1 == 0)    \n                        A[j] = sum[x2][j];\n                    else\n                        A[j] = sum[x2][j] - sum[x1-1][j];\n\n                    vector<int> r = subarraySum(A);\n                    if (r[0] != -1) {\n                        result[0][0] = x1;\n                        result[0][1] = r[0];\n                        result[1][0] = x2;\n                        result[1][1] = r[1];\n                        //matrix[1][1] = 1000;\n                        return result;\n                    }\n        }\n        //matrix[1][1] = 1000;\n        return result;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param {int[][]} matrix an integer matrix\n    # @return {int[][]} the coordinate of the left-up and right-down number\n    def submatrixSum(self, matrix):\n        # Write your code here\n        lenM = len(matrix)\n        lenN = len(matrix[0])\n\n        # for i in xrange()\n\n        if lenM == lenN == 1 and matrix[0][0] == 0: return [[0, 0], [0, 0]]\n        f = [[0 for x in xrange(lenN+1)] for y in xrange(lenM+1)]\n\n        for i in xrange(1, lenM+1):\n            for j in xrange(1, lenN+1):\n                f[i][j] = f[i-1][j] + f[i][j-1] - f[i-1][j-1] + matrix[i-1][j-1]\n                for m in xrange(i):\n                    for n in xrange(j):\n                        if f[i][j] == f[i][n] - f[m][n] + f[m][j]:\n                            return [[m, n], [i-1, j-1]]"}]},{"id":276,"unique_name":"kth-smallest-number-in-sorted-matrix","title":"排序矩阵中的从小到大第k个数","description":"在一个排序矩阵中找从小到大的第 *k* 个整数。\r\n\r\n排序矩阵的定义为：每一行递增，每一列也递增。","solutions":[{"language":"java","code":"class Pair {\r\n    public int x, y, val;\r\n    public Pair(int x, int y, int val) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.val = val;\r\n    }\r\n}\r\nclass PairComparator implements Comparator<Pair> {\r\n    public int compare(Pair a, Pair b) {\r\n        return a.val - b.val;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param matrix: a matrix of integers\r\n     * @param k: an integer\r\n     * @return: the kth smallest number in the matrix\r\n     */\r\n    public int kthSmallest(int[][] matrix, int k) {\r\n        // write your code here\r\n        int[] dx = new int[]{0, 1};\r\n        int[] dy = new int[]{1, 0};\r\n        int n = matrix.length;\r\n        int m = matrix[0].length;\r\n        boolean[][] hash = new boolean[n][m];\r\n        PriorityQueue<Pair> minHeap = new PriorityQueue<Pair>(k, new PairComparator());\r\n        minHeap.add(new Pair(0, 0, matrix[0][0]));\r\n\r\n        for(int i = 0; i < k - 1; i ++){\r\n            Pair cur = minHeap.poll();\r\n            for(int j = 0; j < 2; j ++){\r\n                int next_x = cur.x + dx[j];\r\n                int next_y = cur.y + dy[j];\r\n                Pair next_Pair = new Pair(next_x, next_y, 0);\r\n                if(next_x < n && next_y < m && !hash[next_x][next_y]){\r\n                    hash[next_x][next_y] = true;\r\n                    next_Pair.val = matrix[next_x][next_y];\r\n                    minHeap.add(next_Pair);\r\n                }\r\n            }\r\n        }\r\n        return minHeap.peek().val;\r\n    }\r\n}\r\n\r\n//  二分法\r\nclass ResultType {\r\n    public int num;\r\n    public boolean exists;\r\n    public ResultType(boolean e, int n) {\r\n        exists = e;\r\n        num = n;\r\n    }\r\n}\r\npublic class Solution {\r\n    /**\r\n     * @param matrix: a matrix of integers\r\n     * @param k: an integer\r\n     * @return: the kth smallest number in the matrix\r\n     */\r\n    \r\n    public ResultType check(int value, int[][] matrix) {\r\n        int n = matrix.length;\r\n        int m = matrix[0].length;\r\n        \r\n        boolean exists = false;\r\n        int num = 0;\r\n        int i = n - 1, j = 0;\r\n        while (i >= 0 && j < m) {\r\n            if (matrix[i][j] == value)\r\n                exists = true;\r\n                \r\n            if (matrix[i][j] <= value) {\r\n                num += i + 1;\r\n                j += 1;\r\n            } else {\r\n                i -= 1;\r\n            }\r\n        }\r\n        \r\n        return new ResultType(exists, num);\r\n    }\r\n    \r\n    public int kthSmallest(int[][] matrix, int k) {\r\n        // write your code here\r\n        int n = matrix.length;\r\n        int m = matrix[0].length;\r\n        \r\n        int left = matrix[0][0];\r\n        int right = matrix[n - 1][m - 1];\r\n        \r\n        // left + 1 < right\r\n        while (left <= right) {\r\n            int mid = left + (right - left) / 2;\r\n            ResultType type = check(mid, matrix);\r\n            if (type.exists && type.num == k) {\r\n                return mid;\r\n            } else if (type.num < k) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param matrix: a matrix of integers\r\n     * @param k: an integer\r\n     * @return: the kth smallest number in the matrix\r\n     */\r\n    int kthSmallest(vector<vector<int> > &matrix, int k) {\r\n        // write your code here\r\n        int val, ind;\r\n        vector<int> index, nums, top, last;\r\n        int m = matrix.size(), n = matrix[0].size();\r\n        for (int i=0; i<m; ++i) heapAdd(nums, index, matrix[i][0], i);\r\n        for (int i=0; i<m; ++i) last.push_back(0);\r\n        while (top.size()<k) {\r\n            heapGet(nums, index, val, ind);\r\n            heapDel(nums, index);\r\n            if (last[ind]!=n-1) {\r\n                ++last[ind];\r\n                heapAdd(nums, index, matrix[ind][last[ind]], ind);\r\n            }\r\n            top.push_back(val);\r\n        }\r\n        return top.back();\r\n    }\r\nprivate:\r\n    void heapAdd(vector<int> &nums, vector<int> &index, int val, int ind) {\r\n        nums.push_back(val);\r\n        index.push_back(ind);\r\n        int n = nums.size()-1;\r\n        while (n>0 && nums[n]<nums[(n-1)/2]) {\r\n            swap(nums[n], nums[(n-1)/2]);\r\n            swap(index[n], index[(n-1)/2]);\r\n            n = (n-1)/2;\r\n        }\r\n    }\r\n    void heapGet(vector<int> &nums, vector<int> &index, int &val, int &ind) {\r\n        val = nums[0];\r\n        ind = index[0];\r\n    }\r\n    void heapDel(vector<int> &nums, vector<int> &index) {\r\n        int n = nums.size()-1;\r\n        nums[0] = nums[n];\r\n        index[0] = index[n];\r\n        nums.pop_back();\r\n        index.pop_back();\r\n        n = 0;\r\n        while (n*2+1<nums.size()) {\r\n            int t = n*2+1;\r\n            if (t+1<nums.size() && nums[t+1]<nums[t]) ++t;\r\n            if (nums[n]<=nums[t]) break;\r\n            swap(nums[n], nums[t]);\r\n            swap(index[n], index[t]);\r\n            n = t;\r\n        }\r\n    }\r\n};\r\n"},{"language":"python","code":"// Version 1 using heapq\r\n\r\nimport heapq\r\n\r\nclass Solution:\r\n  \r\n    def kthSmallest(self, matrix, k):\r\n        # Write your code here\r\n        m, n = len(matrix), len(matrix[0])\r\n        visited = [[False] * n for _ in range(m)]\r\n        queue = [(matrix[0][0], 0, 0)]\r\n        result = None\r\n        visited[0][0] = True\r\n        for _ in range(k):\r\n            result, i, j = heapq.heappop(queue)\r\n            if i + 1 < m and not visited[i + 1][j]:\r\n                visited[i + 1][j] = True\r\n                heapq.heappush(queue, (matrix[i + 1][j], i + 1, j))\r\n            if j + 1 < n and not visited[i][j + 1]:\r\n                visited[i][j + 1] = True\r\n                heapq.heappush(queue, (matrix[i][j + 1], i, j + 1))\r\n        return result\r\n\r\n\r\n\r\n// Version 2 \r\nclass Solution:\r\n    # @param matrix: a matrix of integers\r\n    # @param k: an integer\r\n    # @return: the kth smallest number in the matrix\r\n    def kthSmallest(self, matrix, k):\r\n        # write your code here\r\n        ind = 0\r\n        val = 0\r\n        index = []\r\n        nums = [] \r\n        top = [] \r\n        last = []\r\n        m = len(matrix)\r\n        n = len(matrix[0])\r\n        for i in xrange(m): self.heapAdd(nums, index, matrix[i][0], i)\r\n        for i in xrange(m): last.append(0)\r\n        while len(top)<k:\r\n            val = nums[0]\r\n            ind = index[0]\r\n            self.heapDel(nums, index)\r\n            if last[ind]!=n-1:\r\n                last[ind] += 1\r\n                self.heapAdd(nums, index, matrix[ind][last[ind]], ind)\r\n            top.append(val)\r\n        return top[len(top)-1]\r\n\r\n    def heapAdd(self, nums, index, val, ind):\r\n        nums.append(val)\r\n        index.append(ind)\r\n        n = len(nums)-1\r\n        while n>0 and nums[n]<nums[(n-1)/2]:\r\n            nums[n], nums[(n-1)/2] = nums[(n-1)/2], nums[n]\r\n            index[n], index[(n-1)/2] = index[(n-1)/2], index[n]\r\n            n = (n-1)/2\r\n\r\n    def heapDel(self, nums, index):\r\n        n = len(nums)-1\r\n        if n>=0: nums[0] = nums[n]\r\n        if n>=0: index[0] = index[n]\r\n        if len(nums)>0: nums.pop()\r\n        if len(index)>0: index.pop()\r\n        n = 0\r\n        while n*2+1<len(nums):\r\n            t = n*2+1\r\n            if t+1<len(nums) and nums[t+1]<nums[t]: t += 1\r\n            if nums[n]<=nums[t]: break\r\n            nums[n], nums[t] = nums[t], nums[n]\r\n            index[n], index[t] = index[t], index[n]\r\n            n = t"}]},{"id":432,"unique_name":"matrix-zigzag-traversal","title":"矩阵的之字型遍历","description":"给你一个包含 *m* x *n* 个元素的矩阵 (*m* 行, *n* 列), 求该矩阵的之字型遍历。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param matrix: a matrix of integers\n     * @return: an array of integers\n     */ \n    public int[] printZMatrix(int[][] matrix) {\n        // write your code here\n        int x, y, dx, dy, count, m, n;\n        x = y = 0;\n        count = 1;\n        dx = -1; dy = 1;\n        m = matrix.length;\n        n = matrix[0].length;\n        int[] z = new int[m*n];\n        z[0] = matrix[0][0];\n        while (count<m*n) {\n            if (x+dx>=0 && y+dy>=0 && x+dx<m && y+dy<n) {\n                x += dx; y += dy;\n            }\n            else\n                if (dx==-1 && dy ==1) {\n                    if (y+1<n) ++y; else ++x;\n                    dx = 1; dy = -1;\n                }\n                else {\n                    if (x+1<m) ++x; else ++y;\n                    dx = -1; dy = 1;\n                }\n            z[count] = matrix[x][y]; ++count;\n        }\n        return z;\n    }\n}\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param matrix: a matrix of integers\n     * @return: a vector of integers\n     */\n    vector<int> printZMatrix(vector<vector<int> > &matrix) {\n        // write your code here\n        vector<int> z;\n        if (matrix.size()==0) return z;\n        else\n            if (matrix[0].size()==0) return z;\n        int x, y, dx, dy, count, m, n;\n        x = y = 0;\n        count = 1;\n        dx = -1; dy = 1; \n        m = matrix.size();\n        n = matrix[0].size();\n        z.push_back(matrix[0][0]);\n        while (count<m*n) {\n            if (x+dx>=0 && y+dy>=0 && x+dx<m && y+dy<n) {\n                x += dx; y += dy;   \n            }        \n            else\n                if (dx==-1 && dy == 1) {\n                    if (y+1<n) ++y; else ++x;\n                    dx = 1; dy = -1;\n                }\n                else {\n                    if (x+1<m) ++x; else ++y;\n                    dx = -1; dy = 1;                \n                }\n            z.push_back(matrix[x][y]); ++count;       \n        }\n        return z;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param: a matrix of integers\n    # @return: a list of integers\n    def printZMatrix(self, matrix):\n        if len(matrix) == 0:\n            return []\n            \n        x, y = 0, 0\n        n, m = len(matrix), len(matrix[0])\n        rows, cols = range(n), range(m)\n        \n        dx = [1, -1]\n        dy = [-1, 1]\n        direct = 1\n        \n        result = []\n        for i in xrange(len(matrix) * len(matrix[0])):\n            result.append(matrix[x][y])\n            \n            nextX = x + dx[direct]\n            nextY = y + dy[direct]\n            if nextX not in rows or nextY not in cols:\n                if direct == 1:\n                    if nextY >= m:\n                        nextX, nextY = x + 1, y\n                    else:\n                        nextX, nextY = x, y + 1\n                else:\n                    if nextX >= n:\n                        nextX, nextY = x, y + 1\n                    else:\n                        nextX, nextY = x + 1, y\n                direct = 1 - direct\n            x, y = nextX, nextY\n        return result"}]},{"id":294,"unique_name":"search-a-2d-matrix-ii","title":"搜索二维矩阵 II","description":"<p><span style=\"line-height: 1.42857143;\">写出一个高效的算法来搜索m×n矩阵中的值，返回这个值出现的次数。</span></p><p><span style=\"line-height: 1.42857143;\">这个矩阵具有以下特性：</span><br></p><p><ul><li><span style=\"line-height: 1.42857143;\">每行中的整数从左到右是排序的。</span><br></li><li><span style=\"line-height: 1.42857143;\">每一列的整数从上到下是排序的。</span><br></li><li><span style=\"line-height: 1.42857143;\">在每一行或每一列中没有重复的整数。</span></li></ul></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param matrix: A list of lists of integers\r\n     * @param: A number you want to search in the matrix\r\n     * @return: An integer indicate the occurrence of target in the given matrix\r\n     */\r\n    public int searchMatrix(int[][] matrix, int target) {\r\n        // check corner case\r\n        if (matrix == null || matrix.length == 0) {\r\n            return 0;\r\n        }\r\n        if (matrix[0] == null || matrix[0].length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        // from bottom left to top right\r\n        int n = matrix.length;\r\n        int m = matrix[0].length;\r\n        int x = n - 1;\r\n        int y = 0;\r\n        int count = 0;\r\n        \r\n        while (x >= 0 && y < m) {\r\n            if (matrix[x][y] < target) {\r\n                y++;\r\n            } else if (matrix[x][y] > target) {\r\n                x--;\r\n            } else {\r\n                count++;\r\n                x--;\r\n                y++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param matrix: A list of lists of integers\r\n     * @param: A number you want to search in the matrix\r\n     * @return: An integer indicate the occurrence of target in the given matrix\r\n     */\r\n    public int searchMatrix(int[][] matrix, int target) {\r\n        // write your code here\r\n        int r = matrix.length - 1;\r\n        int c = 0;\r\n        int ans = 0;\r\n        while (r >= 0 && c < matrix[0].length) {\r\n            if (target == matrix[r][c]) {\r\n                ans++;\r\n                r--;\r\n                c++;\r\n                continue;\r\n            }\r\n            if (target < matrix[r][c]) {\r\n                r--;\r\n            } else {\r\n                c++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param matrix: A list of lists of integers\r\n     * @param target: An integer you want to search in matrix\r\n     * @return: An integer indicate the total occurrence of target in the given matrix\r\n     */\r\n    int searchMatrix(vector<vector<int> > &matrix, int target) {\r\n        // write your code here\r\n        if (matrix.empty())\r\n        {\r\n            return 0;\r\n        }\r\n        int m = matrix.size();\r\n        int n = matrix[0].size();\r\n        int i = m - 1;\r\n        int j = 0;\r\n        int occur = 0;\r\n        while (i >= 0 && j < n)\r\n        {\r\n            if (matrix[i][j] == target)\r\n            {\r\n                ++occur;\r\n            }\r\n            if (matrix[i][j] < target)\r\n            {\r\n                ++j;\r\n            }\r\n            else\r\n            {\r\n                --i;\r\n            }\r\n        }\r\n        return occur;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param matrix: An list of lists of integers\r\n    @param target: An integer you want to search in matrix\r\n    @return: An integer indicates the total occurrence of target in the given matrix\r\n    \"\"\"\r\n    def searchMatrix(self, matrix, target):\r\n        if matrix == [] or matrix[0] == []:\r\n            return 0\r\n            \r\n        row, column = len(matrix), len(matrix[0])\r\n        i, j = row - 1, 0\r\n        count = 0\r\n        while i >= 0 and j < column:\r\n            if matrix[i][j] == target:\r\n                count += 1\r\n                i -= 1\r\n                j += 1\r\n            elif matrix[i][j] < target:\r\n                j += 1\r\n            elif matrix[i][j] > target:\r\n                i -= 1\r\n        return count\r\n"}]},{"id":58,"unique_name":"search-a-2d-matrix","title":"搜索二维矩阵","description":"写出一个高效的算法来搜索 *m* × *n*矩阵中的值。\r\n\r\n这个矩阵具有以下特性：\r\n\r\n- 每行中的整数从左到右是排序的。\r\n- 每行的第一个数大于上一行的最后一个整数。","solutions":[{"language":"java","code":"// Binary Search Twice\r\npublic class Solution {\r\n    public boolean searchMatrix(int[][] matrix, int target) {\r\n        if (matrix == null || matrix.length == 0) {\r\n            return false;\r\n        }\r\n        if (matrix[0] == null || matrix[0].length == 0) {\r\n            return false;\r\n        }\r\n        \r\n        int row = matrix.length;\r\n        int column = matrix[0].length;\r\n        \r\n        // find the row index, the last number <= target \r\n        int start = 0, end = row - 1;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (matrix[mid][0] == target) {\r\n                return true;\r\n            } else if (matrix[mid][0] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        if (matrix[end][0] <= target) {\r\n            row = end;\r\n        } else if (matrix[start][0] <= target) {\r\n            row = start;\r\n        } else {\r\n            return false;\r\n        }\r\n        \r\n        // find the column index, the number equal to target\r\n        start = 0;\r\n        end = column - 1;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (matrix[row][mid] == target) {\r\n                return true;\r\n            } else if (matrix[row][mid] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        if (matrix[row][start] == target) {\r\n            return true;\r\n        } else if (matrix[row][end] == target) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// Binary Search Once\r\npublic class Solution {\r\n    /**\r\n     * @param matrix, a list of lists of integers\r\n     * @param target, an integer\r\n     * @return a boolean, indicate whether matrix contains target\r\n     */\r\n    public boolean searchMatrix(int[][] matrix, int target) {\r\n        // write your code here\r\n        if(matrix == null || matrix.length == 0){\r\n            return false;\r\n        }\r\n        \r\n        if(matrix[0] == null || matrix[0].length == 0){\r\n            return false;\r\n        }\r\n        \r\n        int row = matrix.length;\r\n        int column = matrix[0].length;\r\n        \r\n        int start = 0, end = row * column - 1;\r\n        while(start <= end){\r\n            int mid = start + (end - start) / 2;\r\n            int number = matrix[mid / column][mid % column];\r\n            if(number == target){\r\n                return true;\r\n            }else if(number > target){\r\n                end = mid - 1;\r\n            }else{\r\n                start = mid + 1;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n        \r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param matrix, a list of lists of integers\r\n     * @param target, an integer\r\n     * @return a boolean, indicate whether matrix contains target\r\n     */\r\n    bool searchMatrix(vector<vector<int> > &matrix, int target) {\r\n        int n = matrix.size();\r\n        if (n == 0) {\r\n            return false;\r\n        }\r\n        \r\n        int m = matrix[0].size();\r\n        if (m == 0) {\r\n            return false;\r\n        }\r\n        \r\n        int start = 0, end = n * m - 1;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            int row = mid / m;\r\n            int col = mid % m;\r\n            \r\n            if (matrix[row][col] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (matrix[start / m][start % m] == target) {\r\n            return true;\r\n        }\r\n        \r\n        if (matrix[end / m][end % m] == target) {\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param matrix, a list of lists of integers\r\n    @param target, an integer\r\n    @return a boolean, indicate whether matrix contains target\r\n    \"\"\"\r\n    def searchMatrix(self, matrix, target):\r\n        if len(matrix) == 0:\r\n            return False\r\n            \r\n        n, m = len(matrix), len(matrix[0])\r\n        start, end = 0, n * m - 1\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            x, y = mid / m, mid % m\r\n            if matrix[x][y] < target:\r\n                start = mid\r\n            else:\r\n                end = mid\r\n        x, y = start / m, start % m\r\n        if matrix[x][y] == target:\r\n            return True\r\n        \r\n        x, y = end / m, end % m\r\n        if matrix[x][y] == target:\r\n            return True\r\n        \r\n        return False"}]},{"id":59,"unique_name":"set-matrix-zeroes","title":"矩阵归零","description":"给定一个m×n矩阵，如果一个元素是0，则将其所在行和列全部元素变成0。\r\n\r\n需要在原矩阵上完成操作。\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n     // using O(m+n) is easy, to enable O(1), we have to use the space within the matrix   \r\n    public void setZeroes(int[][] matrix) {\r\n        if(matrix == null || matrix.length == 0)\r\n            return;\r\n        \r\n        int rows = matrix.length;\r\n        int cols = matrix[0].length;\r\n        \r\n        boolean empty_row0 = false;\r\n        boolean empty_col0 = false;\r\n        for(int i = 0; i < cols; i++){\r\n            if(matrix[0][i] == 0){\r\n                empty_row0 = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        for(int i = 0; i < rows; i++){\r\n            if(matrix[i][0] == 0){\r\n                empty_col0 = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        for(int i = 1; i < rows; i++) {\r\n            for(int j =1; j<cols; j++){\r\n                if(matrix[i][j] == 0){\r\n                    matrix[0][j] = 0;\r\n                    matrix[i][0] = 0;\r\n                }\r\n            }\r\n        }\r\n        \r\n        for(int i = 1; i<rows; i++) {\r\n            for (int j=1; j< cols; j++) {\r\n                if(matrix[0][j] == 0 || matrix[i][0] == 0)\r\n                    matrix[i][j] = 0;\r\n            }\r\n        }\r\n      \r\n        if(empty_row0){\r\n            for(int i = 0; i < cols; i++){\r\n                matrix[0][i] = 0;\r\n            }           \r\n        }\r\n        \r\n        if(empty_col0){\r\n            for(int i = 0; i < rows; i++){\r\n                matrix[i][0] = 0;\r\n            }           \r\n        }\r\n\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param matrix: A list of lists of integers\n     * @return: Void\n     */\n    void setZeroes(vector<vector<int> > &matrix) {\n        // write your code here\n        if (matrix.size()==0)\n            return ;\n        int m = matrix.size(), n = matrix[0].size();\n        bool row0 = false, col0 = false;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i == 0 || j == 0) && matrix[i][j] == 0) {\n                    row0 |= i == 0;\n                    col0 |= j == 0;\n                }\n                else {\n                    matrix[i][0] = matrix[i][j] == 0 ? 0 : matrix[i][0];\n                    matrix[0][j] = matrix[i][j] == 0 ? 0 : matrix[0][j];                                        \n                }\n            }\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                matrix[i][j] = matrix[i][0] == 0 || matrix[0][j] == 0 ? 0 : matrix[i][j];\n            }\n        }\n        \n        for (int i = 0; i < m && col0; i++) {\n            matrix[i][0] = 0;\n        }\n        for (int j = 0; j < n && row0; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param matrix: A list of lists of integers\n    @return: Nothing\n    \"\"\"\n    def setZeroes(self, matrix):\n        # write your code here\n        if len(matrix)==0:\n            return\n        rownum = len(matrix)\n        colnum = len(matrix[0])\n        row = [False for i in range(rownum)]\n        col = [False for i in range(colnum)]\n        for i in range(rownum):\n            for j in range(colnum):\n                if matrix[i][j] == 0:\n                    row[i] = True\n                    col[j] = True\n        for i in range(rownum):\n            for j in range(colnum):\n                if row[i] or col[j]:\n                    matrix[i][j] = 0\n"}]},{"id":83,"unique_name":"rotate-image","title":"旋转图像","description":"<p><span style=\"line-height: 1.42857143;\">给定一个N×N的二维矩阵表示图像，90度顺时针旋转图像。</span><br></p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public void rotate(int[][] matrix) {\r\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\r\n            return;\r\n        }\r\n\r\n        int length = matrix.length;\r\n\r\n        for (int i = 0; i < length / 2; i++) {\r\n            for (int j = 0; j < (length + 1) / 2; j++){\r\n                int tmp = matrix[i][j];\r\n                matrix[i][j] = matrix[length - j - 1][i];\r\n                matrix[length -j - 1][i] = matrix[length - i - 1][length - j - 1];\r\n                matrix[length - i - 1][length - j - 1] = matrix[j][length - i - 1];\r\n                matrix[j][length - i - 1] = tmp;\r\n            }\r\n        }   \r\n    }\r\n}\r\n\r\n\r\n// version: 高频题班\r\n//方法一\r\npublic class Solution {\r\n    /**\r\n     * @param matrix: A list of lists of integers\r\n     * @return: Void\r\n     */\r\n    public void rotate(int[][] matrix) {\r\n        // write your code here\r\n        int n = matrix.length;\r\n        for (int r = 0; r < (n + 1) / 2; r++) {\r\n            for (int c = 0; c < n / 2; c++) {\r\n                int tmp = matrix[r][c];\r\n                matrix[r][c] = matrix[n - 1 - c][r];\r\n                matrix[n - 1 - c][r] = matrix[n - 1 - r][n - 1 - c];\r\n                matrix[n - 1 - r][n - 1 - c] = matrix[c][n - 1 - r];\r\n                matrix[c][n - 1 - r] = tmp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//方法二：\r\npublic class Solution {\r\n    /**\r\n     * @param matrix: A list of lists of integers\r\n     * @return: Void\r\n     */\r\n    public void rotate(int[][] matrix) {\r\n        // write your code here\r\n        int n = matrix.length;\r\n        for (int r = 0; r < n / 2; r++) {\r\n            for (int c = 0; c < n; c++) {\r\n                int tmp = matrix[r][c];\r\n                matrix[r][c] = matrix[n - r - 1][c];\r\n                matrix[n - r - 1][c] = tmp;\r\n            }\r\n        }\r\n        for (int r = 0; r < n; r++) {\r\n            for (int c = r; c < n; c++) {\r\n                int tmp = matrix[r][c];\r\n                matrix[r][c] = matrix[c][r];\r\n                matrix[c][r] = tmp;\r\n            }\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param matrix: A list of lists of integers\r\n     * @return: Void\r\n     */\r\n    void rotate(vector<vector<int> > &matrix, size_t topleft, size_t bottomright)\r\n    {\r\n        for (size_t i = 0; i < bottomright - topleft; ++i)\r\n        {\r\n            int tmp = matrix[topleft][topleft + i];\r\n            matrix[topleft][topleft + i] = matrix[bottomright - i][topleft];\r\n            matrix[bottomright - i][topleft] = matrix[bottomright][bottomright - i];\r\n            matrix[bottomright][bottomright - i] = matrix[topleft + i][bottomright];\r\n            matrix[topleft + i][bottomright] = tmp;\r\n        }\r\n    }\r\n    void rotate(vector<vector<int> > &matrix) {\r\n        // write your code here\r\n        if (matrix.size() <= 0)\r\n            return ;\r\n        size_t topleft = 0, bottomright = matrix.size() - 1;\r\n        while (topleft < bottomright)\r\n        {\r\n            rotate(matrix, topleft, bottomright);\r\n            ++topleft; --bottomright;\r\n        }\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param matrix: A list of lists of integers\r\n    @return: Nothing\r\n    \"\"\"\r\n    def rotate(self, matrix):\r\n        # write your code here\r\n        n = len(matrix)\r\n        for i in range(n):\r\n            for j in range(i+1, n):\r\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\r\n        for i in range(n):\r\n            matrix[i].reverse()\r\n"}]},{"id":576,"unique_name":"minimum-subtree","title":"最小子树","description":"给一棵二叉树, 找到和为最小的子树, 返回其根节点。","solutions":[{"language":"java","code":"// version 1 : traverse + divide conquer\r\npublic class Solution {\r\n    private TreeNode subtree = null;\r\n    private int subtreeSum = Integer.MAX_VALUE;\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the root of the minimum subtree\r\n     */\r\n    public TreeNode findSubtree(TreeNode root) {\r\n        helper(root);\r\n        return subtree;\r\n    }\r\n    \r\n    private int helper(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        int sum = helper(root.left) + helper(root.right) + root.val;\r\n        if (sum <= subtreeSum) {\r\n            subtreeSum = sum;\r\n            subtree = root;\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n\r\n// version 2: Pure divide conquer\r\nclass ResultType {\r\n    public TreeNode minSubtree;\r\n    public int sum, minSum;\r\n    public ResultType(TreeNode minSubtree, int minSum, int sum) {\r\n        this.minSubtree = minSubtree;\r\n        this.minSum = minSum;\r\n        this.sum = sum;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the root of the minimum subtree\r\n     */\r\n    public TreeNode findSubtree(TreeNode root) {\r\n        ResultType result = helper(root);\r\n        return result.minSubtree;\r\n    }\r\n    \r\n    public ResultType helper(TreeNode node) {\r\n        if (node == null) {\r\n            return new ResultType(null, Integer.MAX_VALUE, 0);\r\n        }\r\n        \r\n        ResultType leftResult = helper(node.left);\r\n        ResultType rightResult = helper(node.right);\r\n        \r\n        ResultType result = new ResultType(\r\n            node,\r\n            leftResult.sum + rightResult.sum + node.val,\r\n            leftResult.sum + rightResult.sum + node.val\r\n        );\r\n        \r\n        if (leftResult.minSum <= result.minSum) {\r\n            result.minSum = leftResult.minSum;\r\n            result.minSubtree = leftResult.minSubtree;\r\n        }\r\n        \r\n        if (rightResult.minSum <= result.minSum) {\r\n            result.minSum = rightResult.minSum;\r\n            result.minSubtree = rightResult.minSubtree;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the minimun weight node\r\n     */\r\n    TreeNode* findSubtree(TreeNode* root) {\r\n        // Write your code here\r\n        helper(root);\r\n        return result;\r\n    }\r\n\r\n    int helper(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return 0;\r\n        }\r\n        int left_weight = helper(root->left);\r\n        int right_weight = helper(root->right);\r\n\r\n        if (left_weight + right_weight + root->val <= minumun_weight) {\r\n            minumun_weight = left_weight + right_weight + root->val;\r\n            result = root;\r\n        }\r\n        return left_weight + right_weight + root->val;\r\n    }\r\n\r\nprivate:\r\n    TreeNode* result = nullptr;\r\n    int minumun_weight = INT_MAX;\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {TreeNode} root the root of binary tree\r\n    # @return {int} the minimun weight node\r\n    import sys\r\n    minumun_weight = sys.maxint\r\n    result = None\r\n\r\n    def findSubtree(self, root):\r\n        # Write your code here\r\n        self.helper(root)\r\n\r\n        return self.result\r\n\r\n    def helper(self, root):\r\n        if root is None:\r\n            return 0\r\n\r\n        left_weight = self.helper(root.left)\r\n        right_weight = self.helper(root.right)\r\n        \r\n        if left_weight + right_weight + root.val <= self.minumun_weight:\r\n            self.minumun_weight = left_weight + right_weight + root.val\r\n            self.result = root\r\n\r\n        return left_weight + right_weight + root.val"}]},{"id":722,"unique_name":"concatenated-string-with-uncommon-characters-of-two-strings","title":"连接两个字符串中的不同字符","description":"给出两个字符串, 你需要修改第一个字符串，将所有与第二个字符串中相同的字符删除, 并且第二个字符串中不同的字符与第一个字符串的不同字符连接","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : the 1st string\n     * @param : the 2nd string\n     * @return: uncommon characters of given strings\n     */\n    public String concatenetedString(String s1, String s2) {\n        if(s1 == null){\n            return s2;\n        }\n        if(s2 == null){\n            return s1;\n        }\n        \n        int[] map = new int[126];\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s2.length(); i++){\n            map[s2.charAt(i)] = 1;\n        }\n        \n        for(int i = 0; i < s1.length(); i++){\n            if(map[s1.charAt(i)] == 0){\n                sb.append(s1.charAt(i));\n            }else{\n                map[s1.charAt(i)] = 2;\n            }\n        }\n        \n        for(int i = 0; i < s2.length(); i++){\n            if(map[s2.charAt(i)] == 1){\n                sb.append(s2.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n};"},{"language":"python","code":"class Solution:\n  def concatenetedString(self, s1, s2):\n    result = [a for a in s1 if a not in s2] + [b for b in s2 if b not in s1]\n    return ''.join(result)"}]},{"id":485,"unique_name":"top-k-frequent-words-ii","title":"最常使用的K个单词II","description":"在实时数据流中找到最常使用的k个单词.\n实现*TopK*类中的三个方法:\n`TopK(k)`, 构造方法\n`add(word)`, 增加一个新单词\n`topk()`, 得到当前最常使用的k个单词.","solutions":[{"language":"java","code":"import java.util.NavigableSet;\r\n\r\npublic class TopK {\r\n    private Map<String, Integer> words = null;\r\n    private NavigableSet<String> topk = null;\r\n    private int k;\r\n\r\n    private Comparator<String> myComparator = new Comparator<String>() {\r\n        public int compare(String left, String right) {\r\n            if (left.equals(right))\r\n                return 0;\r\n\r\n            int left_count = words.get(left);\r\n            int right_count = words.get(right);\r\n            if (left_count != right_count) {\r\n                return right_count - left_count;\r\n            }\r\n            return left.compareTo(right);\r\n        }\r\n    };\r\n\r\n    public TopK(int k) {\r\n        // initialize your data structure here\r\n        this.k = k;\r\n        words = new HashMap<String, Integer>();\r\n        topk = new TreeSet<String>(myComparator);\r\n    }\r\n\r\n    public void add(String word) {\r\n        // Write your code here\r\n        if (words.containsKey(word)) {\r\n            if (topk.contains(word))\r\n                topk.remove(word);\r\n            words.put(word, words.get(word) + 1);\r\n        } else {\r\n            words.put(word, 1);\r\n        }\r\n\r\n        topk.add(word);\r\n        if (topk.size() > k) {\r\n            topk.pollLast();\r\n        }\r\n    }\r\n\r\n    public List<String> topk() {\r\n        // Write your code here\r\n        List<String> results = new ArrayList<String>();\r\n        Iterator it = topk.iterator();\r\n        while(it.hasNext()) {\r\n             String str = (String)it.next();\r\n             results.add(str);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"map<string, int> words;\r\nclass cmp {\r\n    public:\r\n    bool operator () (const string& a, const string& b) {\r\n        int a_count = words[a];\r\n        int b_count = words[b];\r\n        if (a_count != b_count)\r\n            return a_count > b_count;\r\n        return a < b;\r\n    }\r\n};\r\n\r\nclass TopK {\r\nprivate:\r\n    set<string, cmp> q;\r\n    int k;\r\npublic:\r\n    TopK(int k) {\r\n        // initialize your data structure here\r\n        this->k = k;\r\n    }\r\n\r\n    void add(string& word) {\r\n        // Write your code here\r\n        if (words.find(word) == words.end()) {\r\n            words[word] = 1;\r\n        } else {\r\n            if (q.find(word) != q.end())\r\n                q.erase(q.find(word));\r\n            words[word] += 1;\r\n        }\r\n        q.insert(word);\r\n        if (q.size() > k)\r\n            q.erase(--q.end());\r\n    }\r\n\r\n    vector<string> topk() {\r\n        // Write your code here\r\n        vector<string> topk;\r\n        set<string, cmp>::iterator it = q.begin();\r\n        int i = 0;\r\n        for (int i = 0; i < k && it != q.end(); ++i, ++it) {\r\n            topk.push_back(*it);\r\n        }\r\n        return topk;\r\n    }\r\n};\r\n"},{"language":"python","code":"def cmp_words(a, b):\r\n    if a[1] != b[1]:\r\n        return b[1] - a[1]\r\n    return cmp(a[0], b[0])\r\n\r\nclass HashHeap:\r\n    \r\n    def __init__(self):\r\n        self.heap = [0]\r\n        self.hash = {}\r\n        \r\n    def add(self, key, value):\r\n        self.heap.append((key, value))\r\n        self.hash[key] = self.heap[0] + 1\r\n        self.heap[0] += 1\r\n        self._siftup(self.heap[0])\r\n        \r\n    def remove(self, key):\r\n        index = self.hash[key]\r\n        self._swap(index, self.heap[0])\r\n        del self.hash[self.heap[self.heap[0]][0]]\r\n        self.heap.pop()\r\n        self.heap[0] -= 1\r\n        if index <= self.heap[0]:\r\n            index = self._siftup(index)\r\n            self._siftdown(index)\r\n        \r\n    def hasKey(self, key):\r\n        return key in self.hash\r\n        \r\n    def min(self):\r\n        return 0 if self.heap[0] == 0 else self.heap[1][1]\r\n    \r\n    def _swap(self, a, b):\r\n        self.heap[a], self.heap[b] = self.heap[b], self.heap[a]\r\n        self.hash[self.heap[a][0]] = a\r\n        self.hash[self.heap[b][0]] = b\r\n        \r\n    def _siftup(self, index):\r\n        while index != 1:\r\n            if cmp_words(self.heap[index], self.heap[index / 2]) < 0:\r\n                break\r\n            self._swap(index, index / 2)\r\n            index = index / 2\r\n        return index\r\n        \r\n    def _siftdown(self, index):\r\n        size = self.heap[0]\r\n        while index < size:\r\n            t = index\r\n            if index * 2 <= size and cmp_words(self.heap[t], self.heap[index * 2]) < 0:\r\n                t = index * 2\r\n            if index * 2 + 1 <= size and cmp_words(self.heap[t], self.heap[index * 2 + 1]) < 0:\r\n                t = index * 2 + 1\r\n            if t == index:\r\n                break\r\n            self._swap(index, t)\r\n            index = t\r\n        return index\r\n\r\n    def size(self):\r\n        return self.heap[0]\r\n\r\n    def pop(self):\r\n        key, value = self.heap[1]\r\n        self.remove(key)\r\n        return value\r\n\r\n\r\nclass TopK:\r\n\r\n    # @param {int} k an integer\r\n    def __init__(self, k):\r\n        # initialize your data structure here\r\n        self.k = k\r\n        self.top_k = HashHeap()\r\n        self.counts = {}\r\n        \r\n    # @param {str} word a string\r\n    def add(self, word):\r\n        # Write your code here\r\n        if word not in self.counts:\r\n            self.counts[word] = 1\r\n        else:\r\n            self.counts[word] += 1\r\n        \r\n        if self.top_k.hasKey(word):\r\n            self.top_k.remove(word)\r\n        \r\n        self.top_k.add(word, self.counts[word])\r\n\r\n        if self.top_k.size() > self.k:\r\n            self.top_k.pop()\r\n            \r\n\r\n    # @return {str[]} the current top k frequent word\r\n    def topk(self):\r\n        # Write your code here\r\n        topk = self.top_k.heap[1:]\r\n        topk.sort(cmp=cmp_words)\r\n        return [ele[0] for ele in topk]\r\n"}]},{"id":540,"unique_name":"flatten-nested-list-iterator","title":"摊平嵌套的列表","description":"给你一个嵌套的列表，实现一个迭代器将其摊平。\r\n一个列表的每个元素可能是整数或者一个列表。","solutions":[{"language":"java","code":"import java.util.Iterator;\r\n\r\npublic class NestedIterator implements Iterator<Integer> {\r\n\r\n    private Stack<NestedInteger> stack;\r\n    \r\n    private void pushListToStack(List<NestedInteger> nestedList) {\r\n        Stack<NestedInteger> temp = new Stack<>();\r\n        for (NestedInteger nested : nestedList) {\r\n            temp.push(nested);\r\n        }\r\n        \r\n        while (!temp.isEmpty()) {\r\n            stack.push(temp.pop());\r\n        }\r\n    }\r\n    \r\n    public NestedIterator(List<NestedInteger> nestedList) {\r\n        stack = new Stack<>();\r\n        pushListToStack(nestedList);\r\n    }\r\n\r\n    // @return {int} the next element in the iteration\r\n    @Override\r\n    public Integer next() {\r\n        if (!hasNext()) {\r\n            return null;\r\n        }\r\n        return stack.pop().getInteger();\r\n    }\r\n\r\n    // @return {boolean} true if the iteration has more element or false\r\n    @Override\r\n    public boolean hasNext() {\r\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\r\n            pushListToStack(stack.pop().getList());\r\n        }\r\n        \r\n        return !stack.isEmpty();\r\n    }\r\n    \r\n    @Override\r\n    public void remove() {}\r\n}"},{"language":"cpp","code":"class NestedIterator {\r\npublic:\r\n    stack<NestedInteger> st;\r\n    NestedIterator(vector<NestedInteger> &nestedList) {\r\n        for (int i = nestedList.size() - 1; i >= 0; i--) {\r\n            st.push(nestedList[i]);\r\n        }\r\n    }\r\n\r\n    int next() {\r\n        int ans =  st.top().getInteger();\r\n        st.pop();\r\n        return ans;\r\n    }\r\n\r\n    bool hasNext() {\r\n        while (!st.empty()) {\r\n            if (st.top().isInteger()) {\r\n                return true;\r\n            }\r\n            vector<NestedInteger>  nestedList = st.top().getList();\r\n            st.pop();\r\n            for (int i = nestedList.size() - 1; i >= 0; i--) {\r\n                st.push(nestedList[i]);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\n"},{"language":"python","code":"# \"\"\"\r\n# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n# \"\"\"\r\n#class NestedInteger(object):\r\n#    def isInteger(self):\r\n#        \"\"\"\r\n#        @return {boolean} True if this NestedInteger holds a single integer,\r\n#        rather than a nested list.\r\n#        \"\"\"\r\n#\r\n#    def getInteger(self):\r\n#        \"\"\"\r\n#        @return {int} the single integer that this NestedInteger holds,\r\n#        if it holds a single integer\r\n#        Return None if this NestedInteger holds a nested list\r\n#        \"\"\"\r\n#\r\n#    def getList(self):\r\n#        \"\"\"\r\n#        @return {NestedInteger[]} the nested list that this NestedInteger holds,\r\n#        if it holds a nested list\r\n#        Return None if this NestedInteger holds a single integer\r\n#        \"\"\"\r\n\r\nclass NestedIterator(object):\r\n\r\n    def __init__(self, nestedList):\r\n        # Initialize your data structure here.\r\n        self.stack = [[nestedList, 0]]\r\n        \r\n    # @return {int} the next element in the iteration\r\n    def next(self):\r\n        # Write your code here\r\n        self.hasNext()\r\n        nestedList, i = self.stack[-1]\r\n        self.stack[-1][1] += 1\r\n        return nestedList[i].getInteger()\r\n        \r\n    # @return {boolean} true if the iteration has more element or false\r\n    def hasNext(self):\r\n        # Write your code here\r\n        s = self.stack\r\n        while s:\r\n            nestedList, i = s[-1]\r\n            if i == len(nestedList):\r\n                s.pop()\r\n            else:\r\n                x = nestedList[i]\r\n                if x.isInteger():\r\n                    return True\r\n                s[-1][1] += 1\r\n                s.append([x.getList(), 0])\r\n        return False\r\n\r\n# Your NestedIterator object will be instantiated and called as such:\r\n# i, v = NestedIterator(nestedList), []\r\n# while i.hasNext(): v.append(i.next())"}]},{"id":484,"unique_name":"nested-list-weight-sum","title":"嵌套列表的加权和","description":"给一个嵌套的整数列表, 返回列表中所有整数由它们的深度加权后的总和. 每一个元素可能是一个整数或一个列表(其元素也可能是整数或列表)","solutions":[{"language":"java","code":"// 递归\r\n/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * public interface NestedInteger {\r\n *\r\n *     // @return true if this NestedInteger holds a single integer,\r\n *     // rather than a nested list.\r\n *     public boolean isInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds,\r\n *     // if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     public Integer getInteger();\r\n *\r\n *     // @return the nested list that this NestedInteger holds,\r\n *     // if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     public List<NestedInteger> getList();\r\n * }\r\n */\r\npublic class Solution {\r\n    \r\n    public int depthSum(List<NestedInteger> nestedList) {\r\n        return helper(nestedList, 1);\r\n    }\r\n \r\n    public int helper(List<NestedInteger> nestedList, int depth){\r\n        if (nestedList == null || nestedList.size() == 0)\r\n            return 0;\r\n\r\n        int sum = 0;\r\n        for(NestedInteger ele : nestedList) {\r\n            if (ele.isInteger()) {\r\n                sum += ele.getInteger() * depth;\r\n            } else {\r\n                sum += helper(ele.getList(), depth + 1);\r\n            }\r\n        }\r\n \r\n        return sum;\r\n    }\r\n}\r\n\r\n// 非递归\r\n/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * public interface NestedInteger {\r\n *\r\n *     // @return true if this NestedInteger holds a single integer,\r\n *     // rather than a nested list.\r\n *     public boolean isInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds,\r\n *     // if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     public Integer getInteger();\r\n *\r\n *     // @return the nested list that this NestedInteger holds,\r\n *     // if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     public List<NestedInteger> getList();\r\n * }\r\n */\r\npublic class Solution {\r\n    public int depthSum(List<NestedInteger> nestedList) {\r\n        // Write your code here\r\n        if (nestedList == null || nestedList.size() == 0) {\r\n            return 0;\r\n        }\r\n        int sum = 0;\r\n        Queue<NestedInteger> queue = new LinkedList<NestedInteger>();\r\n        for (NestedInteger nestedInt : nestedList) {\r\n            queue.offer(nestedInt);\r\n        }\r\n\r\n        int depth = 0;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            depth++;\r\n            for (int i = 0; i < size; i++) {\r\n                NestedInteger nestedInt = queue.poll();\r\n                if (nestedInt.isInteger()) {\r\n                    sum += nestedInt.getInteger() * depth;\r\n                } else {\r\n                    for (NestedInteger innerInt : nestedInt.getList()) {\r\n                        queue.offer(innerInt);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *   public:\r\n *     // Return true if this NestedInteger holds a single integer,\r\n *     // rather than a nested list.\r\n *     bool isInteger() const;\r\n *\r\n *     // Return the single integer that this NestedInteger holds,\r\n *     // if it holds a single integer\r\n *     // The result is undefined if this NestedInteger holds a nested list\r\n *     int getInteger() const;\r\n *\r\n *     // Return the nested list that this NestedInteger holds,\r\n *     // if it holds a nested list\r\n *     // The result is undefined if this NestedInteger holds a single integer\r\n *     const vector<NestedInteger> &getList() const;\r\n * };\r\n */\r\nclass Solution {\r\nprivate:\r\n    int sum = 0, depth = 1;\r\npublic:\r\n    int depthSum(const vector<NestedInteger>& nestedList) {\r\n        // Write your code here\r\n        for (auto i : nestedList) {\r\n            if (i.isInteger())\r\n                sum = sum + i.getInteger() * depth;\r\n            else {\r\n                depth++;\r\n                depthSum(i.getList());\r\n                depth--;\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n};\r\n"},{"language":"python","code":"# \"\"\"\r\n# This is the interface that allows for creating nested lists.\r\n# You should not implement it, or speculate about its implementation\r\n# \"\"\"\r\n#class NestedInteger(object):\r\n#    def isInteger(self):\r\n#        \"\"\"\r\n#        @return {boolean} True if this NestedInteger holds a single integer,\r\n#        rather than a nested list.\r\n#        \"\"\"\r\n#\r\n#    def getInteger(self):\r\n#        \"\"\"\r\n#        @return {int} the single integer that this NestedInteger holds,\r\n#        if it holds a single integer\r\n#        Return None if this NestedInteger holds a nested list\r\n#        \"\"\"\r\n#\r\n#    def getList(self):\r\n#        \"\"\"\r\n#        @return {NestedInteger[]} the nested list that this NestedInteger holds,\r\n#        if it holds a nested list\r\n#        Return None if this NestedInteger holds a single integer\r\n#        \"\"\"\r\n\r\nclass Solution(object):\r\n    # @param {NestedInteger[]} nestedList a list of NestedInteger Object\r\n    # @return {int} an integer\r\n    def depthSum(self, nestedList):\r\n        # Write your code here\r\n        if len(nestedList) == 0:\r\n            return 0\r\n        stack = []\r\n        sum = 0\r\n        for n in nestedList:\r\n            stack.append((n, 1))\r\n        while stack:\r\n            next, d = stack.pop(0)\r\n            if next.isInteger():\r\n               sum += d * next.getInteger()\r\n            else:\r\n                for i in next.getList():\r\n                    stack.append((i, d+1))\r\n        return sum\r\n"}]},{"id":29,"unique_name":"word-ladder","title":"单词接龙","description":"<p><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">给出两个单词（start和end）和一个字典，找到从start到end的最短转换序列</span></p><p><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">比如：</span><br></p><h4 style=\"margin-top:0.0000pt; margin-right:0.0000pt; margin-bottom:0.0000pt; margin-left:0.0000pt; mso-para-margin-right:0.0000gd; mso-para-margin-left:0.0000gd; text-indent:0.0000pt; mso-char-indent-count:0.0000; text-autospace:ideograph-numeric; mso-pagination:widow-orphan; \"><ol><li><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">每次只能改变一个字母。</span><br></li><li><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">变换过程中的中间单词必须在字典中出现。</span></li></ol></h4>","solutions":[{"language":"java","code":"// version: LintCode ( Set<String> )\r\npublic class Solution {\r\n    public int ladderLength(String start, String end, Set<String> dict) {\r\n        if (dict == null) {\r\n            return 0;\r\n        }\r\n\r\n        if (start.equals(end)) {\r\n            return 1;\r\n        }\r\n        \r\n        dict.add(start);\r\n        dict.add(end);\r\n\r\n        HashSet<String> hash = new HashSet<String>();\r\n        Queue<String> queue = new LinkedList<String>();\r\n        queue.offer(start);\r\n        hash.add(start);\r\n        \r\n        int length = 1;\r\n        while(!queue.isEmpty()) {\r\n            length++;\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                String word = queue.poll();\r\n                for (String nextWord: getNextWords(word, dict)) {\r\n                    if (hash.contains(nextWord)) {\r\n                        continue;\r\n                    }\r\n                    if (nextWord.equals(end)) {\r\n                        return length;\r\n                    }\r\n                    \r\n                    hash.add(nextWord);\r\n                    queue.offer(nextWord);\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // replace character of a string at given index to a given character\r\n    // return a new string\r\n    private String replace(String s, int index, char c) {\r\n        char[] chars = s.toCharArray();\r\n        chars[index] = c;\r\n        return new String(chars);\r\n    }\r\n    \r\n    // get connections with given word.\r\n    // for example, given word = 'hot', dict = {'hot', 'hit', 'hog'}\r\n    // it will return ['hit', 'hog']\r\n    private ArrayList<String> getNextWords(String word, Set<String> dict) {\r\n        ArrayList<String> nextWords = new ArrayList<String>();\r\n        for (char c = 'a'; c <= 'z'; c++) {\r\n            for (int i = 0; i < word.length(); i++) {\r\n                if (c == word.charAt(i)) {\r\n                    continue;\r\n                }\r\n                String nextWord = replace(word, i, c);\r\n                if (dict.contains(nextWord)) {\r\n                    nextWords.add(nextWord);\r\n                }\r\n            }\r\n        }\r\n        return nextWords;\r\n    }\r\n}\r\n\r\n// version: LeetCode\r\npublic class Solution {\r\n    public int ladderLength(String start, String end, List<String> wordList) {\r\n        Set<String> dict = new HashSet<>();\r\n        for (String word : wordList) {\r\n            dict.add(word);\r\n        }\r\n        \r\n        if (start.equals(end)) {\r\n            return 1;\r\n        }\r\n        \r\n        HashSet<String> hash = new HashSet<String>();\r\n        Queue<String> queue = new LinkedList<String>();\r\n        queue.offer(start);\r\n        hash.add(start);\r\n        \r\n        int length = 1;\r\n        while (!queue.isEmpty()) {\r\n            length++;\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                String word = queue.poll();\r\n                for (String nextWord: getNextWords(word, dict)) {\r\n                    if (hash.contains(nextWord)) {\r\n                        continue;\r\n                    }\r\n                    if (nextWord.equals(end)) {\r\n                        return length;\r\n                    }\r\n                    \r\n                    hash.add(nextWord);\r\n                    queue.offer(nextWord);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n\r\n    // replace character of a string at given index to a given character\r\n    // return a new string\r\n    private String replace(String s, int index, char c) {\r\n        char[] chars = s.toCharArray();\r\n        chars[index] = c;\r\n        return new String(chars);\r\n    }\r\n    \r\n    // get connections with given word.\r\n    // for example, given word = 'hot', dict = {'hot', 'hit', 'hog'}\r\n    // it will return ['hit', 'hog']\r\n    private ArrayList<String> getNextWords(String word, Set<String> dict) {\r\n        ArrayList<String> nextWords = new ArrayList<String>();\r\n        for (char c = 'a'; c <= 'z'; c++) {\r\n            for (int i = 0; i < word.length(); i++) {\r\n                if (c == word.charAt(i)) {\r\n                    continue;\r\n                }\r\n                String nextWord = replace(word, i, c);\r\n                if (dict.contains(nextWord)) {\r\n                    nextWords.add(nextWord);\r\n                }\r\n            }\r\n        }\r\n        return nextWords;\r\n    }\r\n}"},{"language":"cpp","code":"// version LintCode\r\nclass Solution {\r\npublic:\r\n    /**\r\n      * @param start, a string\r\n      * @param end, a string\r\n      * @param dict, a set of string\r\n      * @return an integer\r\n      */\r\n    int ladderLength(string start, string end, unordered_set<string> &dict) {\r\n        if (start == end) {\r\n            return 1;\r\n        }\r\n        int n = start.size();\r\n        if (n < 1 || n != end.size()) {\r\n            return 0;\r\n        }\r\n \r\n        queue<string> Q;\r\n        Q.push(start);\r\n        dict.erase(start);\r\n        int length = 2;\r\n \r\n        while (!Q.empty()) {\r\n            int size = Q.size();\r\n            for (int i = 0; i < size; i++) {\r\n                string word = Q.front(); Q.pop();\r\n                for (int i = 0; i < n; i++) {\r\n                    char oldChar = word[i];\r\n                    for (char c = 'a'; c <= 'z'; c++) {\r\n                        if (c == oldChar) continue;\r\n                        word[i] = c;\r\n                        if (word == end) {\r\n                            return length;\r\n                        }\r\n                        if (dict.find(word) != dict.end()) {\r\n                            Q.push(word);\r\n                            dict.erase(word);\r\n                        }\r\n                    }\r\n                    word[i] = oldChar;\r\n                }\r\n            } // for size\r\n            length++;\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n\r\n\r\n// version LeetCode\r\nclass Solution {\r\npublic:\r\n    int ladderLength(string start, string end, vector<string>& wordList) {\r\n        if (start == end) {\r\n            return 1;\r\n        }\r\n        \r\n        int n = start.size();\r\n        if (n < 1 || n != end.size()) {\r\n            return 0;\r\n        }\r\n \r\n        unordered_set<string> dict;\r\n        for (int i = 0; i < wordList.size(); i++) {\r\n            dict.insert(wordList[i]);\r\n        }\r\n\r\n        queue<string> Q;\r\n        Q.push(start);\r\n        dict.erase(start);\r\n        int length = 2;\r\n \r\n        while (!Q.empty()) {\r\n            int size = Q.size();\r\n            for (int i = 0; i < size; i++) {\r\n                string word = Q.front(); Q.pop();\r\n                for (int i = 0; i < n; i++) {\r\n                    char oldChar = word[i];\r\n                    for (char c = 'a'; c <= 'z'; c++) {\r\n                        if (c == oldChar) continue;\r\n                        word[i] = c;\r\n                        if (dict.find(word) != dict.end()) {\r\n                            if (word == end) {\r\n                                return length;\r\n                            }\r\n                            Q.push(word);\r\n                            dict.erase(word);\r\n                        }\r\n                    }\r\n                    word[i] = oldChar;\r\n                }\r\n            } // for size\r\n            length++;\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n"},{"language":"python","code":"// version: LintCode\r\nimport collections\r\nclass Solution:\r\n    # @param start, a string\r\n    # @param end, a string\r\n    # @param dict, a set of string\r\n    # @return an integer\r\n    def ladderLength(self, start, end, dict):\r\n        # write your code here\r\n        dict.add(end)\r\n        wordLen = len(start)\r\n        queue = collections.deque([(start, 1)])\r\n        while queue:\r\n            curr = queue.popleft()\r\n            currWord = curr[0]; currLen = curr[1]\r\n            if currWord == end: return currLen\r\n            for i in xrange(wordLen):\r\n                part1 = currWord[:i]; part2 = currWord[i+1:]\r\n                for j in 'abcdefghijklmnopqrstuvwxyz':\r\n                    if currWord[i] != j:\r\n                        nextWord = part1 + j + part2\r\n                        if nextWord in dict:\r\n                            queue.append((nextWord, currLen + 1))\r\n                            dict.remove(nextWord)\r\n        return 0\r\n\r\n// version LeetCode\r\nimport collections\r\nclass Solution:\r\n    # @param start, a string\r\n    # @param end, a string\r\n    # @param dict, a set of string\r\n    # @return an integer\r\n    def ladderLength(self, start, end, wordList):\r\n        wordSet = set([])\r\n        for word in wordList:\r\n            wordSet.add(word)\r\n\r\n        wordLen = len(start)\r\n        queue = collections.deque([(start, 1)])\r\n        while queue:\r\n            currWord, currLen = queue.popleft()\r\n            if currWord == end:\r\n                return currLen\r\n            for i in xrange(wordLen):\r\n                part1 = currWord[:i]\r\n                part2 = currWord[i+1:]\r\n                for j in 'abcdefghijklmnopqrstuvwxyz':\r\n                    if currWord[i] != j:\r\n                        nextWord = part1 + j + part2\r\n                        if nextWord in wordSet:\r\n                            queue.append((nextWord, currLen + 1))\r\n                            wordSet.remove(nextWord)\r\n        return 0"}]},{"id":84,"unique_name":"permutations-ii","title":"带重复元素的排列","description":"给出一个具有重复数字的列表，找出列表所有不同的排列。","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: A list of unique permutations.\r\n     */\r\n    public List<List<Integer>> permuteUnique(int[] nums) {\r\n    \r\n        ArrayList<List<Integer>> results = new ArrayList<List<Integer>>();\r\n    \r\n        if (nums == null) {\r\n            return results;\r\n        }\r\n    \r\n        if(nums.length == 0) {\r\n            results.add(new ArrayList<Integer>());\r\n            return results;\r\n        }\r\n\r\n        Arrays.sort(nums);\r\n        ArrayList<Integer> list = new ArrayList<Integer>();\r\n        int[] visited = new int[nums.length];\r\n        for ( int i = 0; i < visited.length; i++){\r\n            visited[i] = 0;\r\n        }\r\n     \r\n        helper(results, list, visited, nums);    \r\n        return results;\r\n    }\r\n    \r\n    \r\n    public void helper(ArrayList<List<Integer>> results, \r\n                   ArrayList<Integer> list, int[] visited, int[] nums) {\r\n        \r\n        if(list.size() == nums.length) {\r\n            results.add(new ArrayList<Integer>(list));\r\n            return;\r\n        }\r\n        \r\n        for(int i = 0; i < nums.length; i++) {\r\n            if ( visited[i] == 1 || ( i != 0 && nums[i] == nums[i - 1]\r\n            && visited[i-1] == 0)){\r\n                continue;\r\n            }\r\n            /*\r\n            上面的判断主要是为了去除重复元素影响。\r\n            比如，给出一个排好序的数组，[1,2,2]，那么第一个2和第二2如果在结果中互换位置，\r\n            我们也认为是同一种方案，所以我们强制要求相同的数字，原来排在前面的，在结果\r\n            当中也应该排在前面，这样就保证了唯一性。所以当前面的2还没有使用的时候，就\r\n            不应该让后面的2使用。\r\n            */\r\n            visited[i] = 1;\r\n            list.add(nums[i]);\r\n            helper(results, list, visited, nums);\r\n            list.remove(list.size() - 1);\r\n            visited[i] = 0;\r\n        }\r\n     } \r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\nprivate:\r\n    void helper(vector<vector<int> > &results,\r\n                vector<int> &permutation,\r\n                vector<int> &nums,\r\n                bool used[]) {\r\n        if (nums.size() == permutation.size()) {\r\n            results.push_back(permutation);\r\n            return;\r\n        }\r\n\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            if (used[i]) {\r\n                continue;\r\n            }\r\n            if (i > 0 && used[i - 1] == false && nums[i] == nums[i-1]) {\r\n                continue;\r\n            }\r\n\r\n            used[i] = true;\r\n            permutation.push_back(nums[i]);\r\n            helper(results, permutation, nums, used);\r\n            permutation.pop_back();\r\n            used[i] = false;\r\n        }\r\n    }\r\n\r\npublic:\r\n    vector<vector<int> > permuteUnique(vector<int> &nums) {\r\n        vector<vector<int> > results;\r\n        vector<int> permutation;\r\n        bool used[nums.size()];\r\n\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            used[i] = false;\r\n        }\r\n\r\n        sort(nums.begin(), nums.end());\r\n\r\n        helper(results, permutation, nums, used);\r\n        return results;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers.\r\n    @return: A list of unique permutations.\r\n    \"\"\"\r\n    def permuteUnique(self, nums):\r\n        # write your code here\r\n        def _permute(result, temp, nums):\r\n            if nums == []:\r\n                result += [temp]\r\n            else:\r\n                for i in range(len(nums)):\r\n                    if i > 0 and nums[i] == nums[i-1]:\r\n                        continue\r\n                    _permute(result, temp + [nums[i]], nums[:i] + nums[i+1:])\r\n        if nums is None:\r\n            return []\r\n\r\n        if len(nums) == 0:\r\n            return [[]]\r\n\r\n        result = []\r\n        _permute(result, [], sorted(nums))\r\n        return result"}]},{"id":85,"unique_name":"permutations","title":"全排列","description":"给定一个数字列表，返回其所有可能的排列。","solutions":[{"language":"java","code":"public class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n         List<List<Integer>> results = new ArrayList<>();\n         if (nums == null) {\n             return results; \n         }\n         \n         if (nums.length == 0) {\n            results.add(new ArrayList<Integer>());\n            return results;\n         }\n\n         List<Integer> permutation = new ArrayList<Integer>();\n         Set<Integer> set = new HashSet<>();\n         helper(nums, permutation, set, results);\n         \n         return results;\n    }\n    \n    // 1. 找到所有以permutation 开头的排列\n    public void helper(int[] nums,\n                       List<Integer> permutation,\n                       Set<Integer> set,\n                       List<List<Integer>> results) {\n        // 3. 递归的出口\n        if (permutation.size() == nums.length) {\n            results.add(new ArrayList<Integer>(permutation));\n            return;\n        }\n\n                \n        // [3] => [3,1], [3,2], [3,4] ...\n        for (int i = 0; i < nums.length; i++) {\n            if (set.contains(nums[i])) {\n                continue;\n            }\n            \n            permutation.add(nums[i]);\n            set.add(nums[i]);\n            helper(nums, permutation, set, results);\n            set.remove(nums[i]);\n            permutation.remove(permutation.size() - 1);\n        }\n        \n    }\n}\n\n// Non-Recursion\nclass Solution {\n    /**\n     * @param nums: A list of integers.\n     * @return: A list of permutations.\n     */\n    public List<List<Integer>> permute(int[] nums) {\n        ArrayList<List<Integer>> permutations\n             = new ArrayList<List<Integer>>();\n        if (nums == null) {\n            \n            return permutations;\n        }\n\n        if (nums.length == 0) {\n            permutations.add(new ArrayList<Integer>());\n            return permutations;\n        }\n        \n        int n = nums.length;\n        ArrayList<Integer> stack = new ArrayList<Integer>();\n        \n        stack.add(-1);\n        while (stack.size() != 0) {\n            Integer last = stack.get(stack.size() - 1);\n            stack.remove(stack.size() - 1);\n            \n            // increase the last number\n            int next = -1;\n            for (int i = last + 1; i < n; i++) {\n                if (!stack.contains(i)) {\n                    next = i;\n                    break;\n                }\n            }\n            if (next == -1) {\n                continue;\n            }\n            \n            // generate the next permutation\n            stack.add(next);\n            for (int i = 0; i < n; i++) {\n                if (!stack.contains(i)) {\n                    stack.add(i);\n                }\n            }\n            \n            // copy to permutations set\n            ArrayList<Integer> permutation = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                permutation.add(nums[stack.get(i)]);\n            }\n            permutations.add(permutation);\n        }\n        \n        return permutations;\n    }\n}"},{"language":"cpp","code":"// version 2: Recursion\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: A list of permutations.\r\n     */\r\n    vector<vector<int> > permute(vector<int> nums) {\r\n        \r\n        vector<vector<int> > res;\r\n        int n = nums.size();\r\n        if (n == 0) {\r\n            res.push_back(vector<int>());\r\n            return res;\r\n        }\r\n\r\n        helper(res, nums, n - 1);\r\n        \r\n        return res;\r\n    }\r\n    \r\n    void helper(vector<vector<int> > &res, vector<int> nums, int n){\r\n        \r\n        if(n == 0){\r\n            res.push_back(nums);\r\n        }\r\n        \r\n        for(int i = 0 ; i <= n; i++){\r\n            swap(nums[i], nums[n]);\r\n            helper(res, nums, n - 1);\r\n            swap(nums[i], nums[n]);\r\n        }\r\n    }\r\n};\r\n\r\n\r\n// version 1: Non-Recursion\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: A list of permutations.\r\n     */\r\n    vector<vector<int> > permute(vector<int> nums) {\r\n        vector<vector<int> > permutations;\r\n        if (nums.size() == 0) {\r\n            permutations.push_back(vector<int>());\r\n            return permutations;\r\n        }\r\n        \r\n        int n = nums.size();\r\n        vector<int> stack;\r\n        bool inStack[n];\r\n        for (int i = 0; i < n; i++) {\r\n            inStack[i] = false;\r\n        }\r\n        \r\n        stack.push_back(-1);\r\n        while (stack.size() != 0) {\r\n            // pop the last \r\n            int last = stack[stack.size() - 1];\r\n            stack.pop_back();\r\n            if (last != -1) {\r\n                inStack[last] = false;\r\n            }\r\n            \r\n            // increase the last, find the next bigger & avaiable number\r\n            int next = -1;\r\n            for (int i = last + 1; i < n; i++) {\r\n                if (inStack[i] == false) {\r\n                    next = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (next == -1) {\r\n                continue;\r\n            }\r\n            \r\n            // generate the next permutation\r\n            stack.push_back(next);\r\n            inStack[next] = true;\r\n            for (int i = 0; i < n; i++) {\r\n                if (!inStack[i]) {\r\n                    stack.push_back(i);\r\n                    inStack[i] = true;\r\n                }\r\n            }\r\n            \r\n            // generate real permutation from index\r\n            vector<int> permutation;\r\n            for (int i = 0; i < n; i++) {\r\n                permutation.push_back(nums[stack[i]]);\r\n            }\r\n            permutations.push_back(permutation);\r\n        }\r\n        \r\n        return permutations;\r\n    }\r\n};"},{"language":"python","code":"# Recursion\r\nclass Solution:\r\n    \"\"\"\r\n    @param nums: A list of Integers.\r\n    @return: A list of permutations.\r\n    \"\"\"\r\n    def permute(self, nums):\r\n        # write your code here\r\n        def _permute(result, temp, nums):\r\n            if nums == []:\r\n                result += [temp]\r\n            else:\r\n                for i in range(len(nums)):\r\n                    _permute(result, temp + [nums[i]], nums[:i] + nums[i+1:])\r\n\r\n        if nums is None:\r\n            return []\r\n        \r\n        if nums is []:\r\n            return [[]]\r\n\r\n        result = []\r\n        _permute(result, [], sorted(nums))\r\n        return result\r\n\r\n\r\n# Non-Recursion\r\nclass Solution:\r\n    \"\"\"\r\n    @param nums: A list of Integers.\r\n    @return: A list of permutations.\r\n    \"\"\"\r\n    def permute(self, nums):\r\n        if nums is None:\r\n            return []\r\n        if nums == []:\r\n            return [[]]\r\n        nums = sorted(nums)\r\n        permutation = []\r\n        stack = [-1]\r\n        permutations = []\r\n        while len(stack):\r\n            index = stack.pop()\r\n            index += 1\r\n            while index < len(nums):\r\n                if nums[index] not in permutation:\r\n                    break\r\n                index += 1\r\n            else:\r\n                if len(permutation):\r\n                    permutation.pop()\r\n                continue\r\n\r\n            stack.append(index)\r\n            stack.append(-1)\r\n            permutation.append(nums[index])\r\n            if len(permutation) == len(nums):\r\n                permutations.append(list(permutation))\r\n        return permutations"}]},{"id":6,"unique_name":"max-points-on-a-line","title":"最多有多少个点在一条直线上","description":"给出二维平面上的n个点，求最多有多少点在同一条直线上。","solutions":[{"language":"java","code":"public class Solution {\r\n    public  int maxPoints(Point[] points) {\r\n        if (points == null || points.length == 0) {\r\n            return 0;\r\n        }  \r\n\r\n        HashMap<Double, Integer> map=new HashMap<Double, Integer>();\r\n        int max = 1;\r\n\r\n        for(int i = 0 ; i < points.length; i++) {\r\n            // shared point changed, map should be cleared and server the new point\r\n            map.clear();\r\n\r\n            // maybe all points contained in the list are same points,and same points' k is \r\n            // represented by Integer.MIN_VALUE\r\n            map.put((double)Integer.MIN_VALUE, 1);\r\n\r\n            int dup = 0;\r\n            for(int j = i + 1; j < points.length; j++) {\r\n                if (points[j].x == points[i].x && points[j].y == points[i].y) {\r\n                    dup++;\r\n                    continue;\r\n                }\r\n\r\n                // look 0.0+(double)(points[j].y-points[i].y)/(double)(points[j].x-points[i].x)\r\n                // because (double)0/-1 is -0.0, so we should use 0.0+-0.0=0.0 to solve 0.0 !=-0.0\r\n                // problem\r\n\r\n                // if the line through two points are parallel to y coordinator, then K(slop) is \r\n                // Integer.MAX_VALUE\r\n                double key=points[j].x - points[i].x == 0 ? \r\n                    Integer.MAX_VALUE :\r\n                    0.0 + (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);\r\n\r\n                if (map.containsKey(key)) {\r\n                    map.put(key, map.get(key) + 1);\r\n                } else {\r\n                    map.put(key, 2);\r\n                }\r\n            }\r\n\r\n            for (int temp: map.values()) {\r\n                // duplicate may exist\r\n                if (temp + dup > max) {\r\n                    max = temp + dup;\r\n                }\r\n            }\r\n\r\n        }\r\n        return max;\r\n    }\r\n}\r\n\r\n\r\n// version 2:\r\n/**\r\n * Definition for a point.\r\n * class Point {\r\n *     int x;\r\n *     int y;\r\n *     Point() { x = 0; y = 0; }\r\n *     Point(int a, int b) { x = a; y = b; }\r\n * }\r\n */\r\nclass Line {\r\n    public double a, b, c;\r\n    public Line(double a, double b, double c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    \r\n    public Line(int x1, int y1, int x2, int y2) {\r\n        if (x1 == x2) {\r\n            if (x1 == 0) {\r\n                a = 1;\r\n                b = 0;\r\n                c = 0;\r\n            } else {\r\n                a = 1.0 / x1;\r\n                b = 0;\r\n                c = 1;\r\n            }\r\n        } else if (y1 == y2) {\r\n            if (y1 == 0) {\r\n                a = 0;\r\n                b = 1;\r\n                c = 0;\r\n            } else {\r\n                a = 0;\r\n                b = 1.0 / y1;\r\n                c = 1;\r\n            }\r\n        } else {\r\n            if (x1 * y2 == x2 * y1) {\r\n                a = 1;\r\n                b = - 1.0 * (y1 - y2) / (x1 - x2);\r\n                c = 0;\r\n           } else {\r\n                a = 1.0 * (y1 - y2) / (x2 * y1 - x1 * y2);\r\n                b = 1.0 * (x1 - x2) / (x1 * y2 - x2 * y1);\r\n                c = 1;\r\n            }\r\n        }\r\n    }\r\n    \r\n    public String toString() {\r\n        return Double.toString(a) + \" \" + Double.toString(b) + \" \" + Double.toString(c);\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    \r\n    public int maxPoints(Point[] points) {\r\n        if (points.length < 2) {\r\n            return points.length;\r\n        }\r\n        \r\n        HashMap<String, Integer> hash = new HashMap<String, Integer>();\r\n        for (int i = 0; i < points.length; i++) {\r\n            for (int j = i + 1; j < points.length; j++) {\r\n                Line line = new Line(points[i].x, points[i].y,\r\n                                     points[j].x, points[j].y);\r\n                String key = line.toString();\r\n                if (hash.containsKey(key)) {\r\n                    hash.put(key, hash.get(key) + 1);\r\n                } else {\r\n                    hash.put(key, 1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        int max = 0;\r\n        String maxKey = \"\";\r\n        for (String key: hash.keySet()) {\r\n            if (hash.get(key) > max) {\r\n                max = hash.get(key);\r\n                maxKey = key;\r\n                \r\n            }\r\n        }\r\n        String[] params = maxKey.split(\" \");\r\n        double a = Double.parseDouble(params[0]);\r\n        double b = Double.parseDouble(params[1]);\r\n        double c = Double.parseDouble(params[2]);\r\n        \r\n        int count = 0;\r\n        for (int i = 0; i < points.length; i++) {\r\n            if (Math.abs(a * points[i].x + b * points[i].y - c) < 1e-6) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param points an array of point\r\n     * @return an integer\r\n     */\r\n    public int maxPoints(Point[] points) {\r\n        // Write your code here\r\n        if (points == null) {\r\n            return 0;\r\n        }\r\n        int ans = 0;\r\n        for (int i = 0; i < points.length; i++) {\r\n            Map<String, Integer> slope = new HashMap<>();\r\n            int maxPoints = 0, overlap = 0, vertical = 0;\r\n\r\n            for (int j = i + 1; j < points.length; j++) {\r\n                if (points[i].x == points[j].x) {\r\n                    if (points[i].y == points[j].y) {\r\n                        overlap++;\r\n                    } else {\r\n                        vertical++;\r\n                    }\r\n                    continue;\r\n                }\r\n                int dx = points[i].x - points[j].x;\r\n                int dy = points[i].y - points[j].y;\r\n                int tmp = gcd(dx, dy);\r\n                dx /= tmp;\r\n                dy /= tmp;\r\n                String k = dy + \"/\" + dx;\r\n\r\n                if (!slope.containsKey(k)) {\r\n                    slope.put(k, 0);\r\n                }\r\n                slope.put(k, slope.get(k) + 1);\r\n                maxPoints = Math.max(maxPoints, slope.get(k));\r\n            }\r\n            maxPoints = Math.max(maxPoints, vertical);\r\n            ans = Math.max(ans, maxPoints + overlap + 1);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    int gcd(int a, int b) {\r\n        if (b == 0) {\r\n            return a;\r\n        } else {\r\n            return gcd(b, a % b);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition for a point.\r\n * struct Point {\r\n *     int x;\r\n *     int y;\r\n *     Point() : x(0), y(0) {}\r\n *     Point(int a, int b) : x(a), y(b) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param points an array of point\r\n     * @return an integer\r\n     */\r\n    int maxPoints(vector<Point>& points) {\r\n        // Write your code here\r\n        unordered_map<float,int> mp;\r\n\t\tint maxNum = 0;\r\n\t\tfor(int i = 0; i < points.size(); i++)\r\n\t\t{\r\n\t\t\tmp.clear();\r\n\t\t\tmp[INT_MIN] = 0;\r\n\t\t\tint duplicate = 1;\r\n\t\t\tfor(int j = 0; j < points.size(); j++)\r\n\t\t\t{\r\n\t\t\t\tif(j == i) continue;\r\n\t\t\t\tif(points[i].x == points[j].x && points[i].y == points[j].y)\r\n\t\t\t\t{\r\n\t\t\t\t\tduplicate++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tfloat k = points[i].x == points[j].x ? INT_MAX : (float)(points[j].y - points[i].y)/(points[j].x - points[i].x);\r\n\t\t\t\tmp[k]++;\r\n\t\t\t}\r\n\t\t\tunordered_map<float, int>::iterator it = mp.begin();\r\n\t\t\tfor(; it != mp.end(); it++)\r\n\t\t\t\tif(it->second + duplicate > maxNum)\r\n\t\t\t\t\tmaxNum = it->second + duplicate;\r\n\t\t}\r\n\t\treturn maxNum;\r\n    }\r\n};\r\n"},{"language":"python","code":"# Definition for a point.\r\n# class Point:\r\n#     def __init__(self, a=0, b=0):\r\n#         self.x = a\r\n#         self.y = b\r\n\r\nclass Solution:\r\n    # @param {int[]} points an array of point\r\n    # @return {int} an integer\r\n    def maxPoints(self, points):\r\n        # Write your code here\r\n        len_points = len(points)\r\n        if len_points <= 1:\r\n            return len_points\r\n        max_count = 0\r\n        for index1 in range(0, len_points):\r\n            p1 = points[index1]\r\n            gradients = {}\r\n            infinite_count = 0\r\n            duplicate_count = 0\r\n            for index2 in range(index1, len_points):\r\n                p2 = points[index2]\r\n                dx = p2.x - p1.x\r\n                dy = p2.y - p1.y\r\n                if 0 == dx and 0 == dy:\r\n                    duplicate_count += 1\r\n                if 0 == dx:\r\n                    infinite_count += 1\r\n                else:\r\n                    g = float(dy) / dx\r\n                    gradients[g] = (gradients[g] + 1 if gradients.has_key(g) else 1)\r\n            if infinite_count > max_count:\r\n                max_count = infinite_count\r\n            for k, v in gradients.items():\r\n                v += duplicate_count\r\n                if v > max_count:\r\n                    max_count = v\r\n        return max_count\r\n"}]},{"id":5,"unique_name":"evaluate-reverse-polish-notation","title":"逆波兰表达式求值","description":"求逆波兰表达式的值。\r\n\r\n在逆波兰表达法中，其有效的运算符号包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰计数表达。","solutions":[{"language":"java","code":"public class Solution {\r\n    public int evalRPN(String[] tokens) {\r\n        Stack<Integer> s = new Stack<Integer>();\r\n        String operators = \"+-*/\";\r\n        for(String token : tokens){\r\n            if(!operators.contains(token)){\r\n                s.push(Integer.valueOf(token));\r\n                continue;\r\n            }\r\n\r\n            int a = s.pop();\r\n            int b = s.pop();\r\n            if(token.equals(\"+\")) {\r\n                s.push(b + a);\r\n            } else if(token.equals(\"-\")) {\r\n                s.push(b - a);\r\n            } else if(token.equals(\"*\")) {\r\n                s.push(b * a);\r\n            } else {\r\n                s.push(b / a);\r\n            }\r\n        }\r\n        return s.pop();\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    int evalRPN(vector<string> &tokens) {\n        int x, y;\n        auto token = tokens.back();  tokens.pop_back();\n        if (is_operator(token))  {\n            y = evalRPN(tokens);\n            x = evalRPN(tokens);\n            if (token[0] == '+')       x += y;\n            else if (token[0] == '-')  x -= y;\n            else if (token[0] == '*')  x *= y;\n            else                       x /= y;\n        } else  {\n            size_t i;\n            x = stoi(token, &i);\n        }\n        return x;\n    }\nprivate:\n    bool is_operator(const string &op) {\n        return op.size() == 1 && string(\"+-*/\").find(op) != string::npos;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param tokens, a list of string\n    # @return an integer\n    def evalRPN(self, tokens):\n        stack = []\n        for i in tokens:\n            if i not in ('+', '-', '*', '/'):\n                stack.append(int(i))\n            else:\n                op2 = stack.pop()\n                op1 = stack.pop()\n                if i == '+': stack.append(op1 + op2)\n                elif i == '-': stack.append(op1 - op2)\n                elif i == '*': stack.append(op1 * op2)\n                else: stack.append(int(op1 * 1.0 / op2))\n        return stack[0]\n"}]},{"id":66,"unique_name":"valid-number","title":"有效数字","description":"给定一个字符串，验证其是否为数字。","solutions":[{"language":"java","code":"// Non-regex version\r\n\r\npublic class Solution {\r\n    public boolean isNumber(String s) {\r\n        int len = s.length();\r\n        int i = 0, e = len - 1;\r\n        while (i <= e && Character.isWhitespace(s.charAt(i))) i++;\r\n        if (i > len - 1) return false;\r\n        while (e >= i && Character.isWhitespace(s.charAt(e))) e--;\r\n        // skip leading +/-\r\n        if (s.charAt(i) == '+' || s.charAt(i) == '-') i++;\r\n        boolean num = false; // is a digit\r\n        boolean dot = false; // is a '.'\r\n        boolean exp = false; // is a 'e'\r\n        while (i <= e) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                num = true;\r\n            }\r\n            else if (c == '.') {\r\n                if(exp || dot) return false;\r\n                dot = true;\r\n            }\r\n            else if (c == 'e') {\r\n                if(exp || num == false) return false;\r\n                exp = true;\r\n                num = false;\r\n            }\r\n            else if (c == '+' || c == '-') {\r\n                if (s.charAt(i - 1) != 'e') return false;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n            i++;\r\n        }\r\n        return num;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    bool isNumber(const string &s) {\n        enum InputType {\n            INVALID,    // 0\n            SPACE,      // 1\n            SIGN,       // 2\n            DIGIT,      // 3\n            DOT,        // 4\n            EXPONENT,   // 5\n            NUM_INPUTS  // 6\n        };\n        const int transitionTable[][NUM_INPUTS] = {\n                -1, 0, 3, 1, 2, -1, // next states for state 0\n                -1, 8, -1, 1, 4, 5,     // next states for state 1\n                -1, -1, -1, 4, -1, -1,     // next states for state 2\n                -1, -1, -1, 1, 2, -1,     // next states for state 3\n                -1, 8, -1, 4, -1, 5,     // next states for state 4\n                -1, -1, 6, 7, -1, -1,     // next states for state 5\n                -1, -1, -1, 7, -1, -1,     // next states for state 6\n                -1, 8, -1, 7, -1, -1,     // next states for state 7\n                -1, 8, -1, -1, -1, -1,     // next states for state 8\n        };\n\n        int state = 0;\n        for (const char c : s) {\n            InputType inputType = INVALID;\n            if (isspace(c))\n                inputType = SPACE;\n            else if (c == '+' || c == '-')\n                inputType = SIGN;\n            else if (isdigit(c))\n                inputType = DIGIT;\n            else if (c == '.')\n                inputType = DOT;\n            else if (c == 'e' || c == 'E')\n                inputType = EXPONENT;\n\n            // Get next state from current state and input symbol\n            state = transitionTable[state][inputType];\n\n            // Invalid input\n            if (state == -1) return false;\n        }\n        // If the current state belongs to one of the accepting (final) states,\n        // then the number is valid\n        return state == 1 || state == 4 || state == 7 || state == 8;\n\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param s, a string\n    # @return a boolean\n    # @finite automation\n    def isNumber(self, s):\n        INVALID=0; SPACE=1; SIGN=2; DIGIT=3; DOT=4; EXPONENT=5;\n        #0invalid,1space,2sign,3digit,4dot,5exponent,6num_inputs\n        transitionTable=[[-1,  0,  3,  1,  2, -1],    #0 no input or just spaces \n                         [-1,  8, -1,  1,  4,  5],    #1 input is digits \n                         [-1, -1, -1,  4, -1, -1],    #2 no digits in front just Dot \n                         [-1, -1, -1,  1,  2, -1],    #3 sign \n                         [-1,  8, -1,  4, -1,  5],    #4 digits and dot in front \n                         [-1, -1,  6,  7, -1, -1],    #5 input 'e' or 'E' \n                         [-1, -1, -1,  7, -1, -1],    #6 after 'e' input sign \n                         [-1,  8, -1,  7, -1, -1],    #7 after 'e' input digits \n                         [-1,  8, -1, -1, -1, -1]]    #8 after valid input input space\n        state=0; i=0\n        while i<len(s):\n            inputtype = INVALID\n            if s[i]==' ': inputtype=SPACE\n            elif s[i]=='-' or s[i]=='+': inputtype=SIGN\n            elif s[i] in '0123456789': inputtype=DIGIT\n            elif s[i]=='.': inputtype=DOT\n            elif s[i]=='e' or s[i]=='E': inputtype=EXPONENT\n            \n            state=transitionTable[state][inputtype]\n            if state==-1: return False\n            else: i+=1\n        return state == 1 or state == 4 or state == 7 or state == 8\n"}]},{"id":68,"unique_name":"merge-two-sorted-lists","title":"合并两个排序链表","description":"将两个排序链表合并为一个新的排序链表","solutions":[{"language":"java","code":"public class Solution {\r\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\r\n        ListNode dummy = new ListNode(0);\r\n        ListNode lastNode = dummy;\r\n        \r\n        while (l1 != null && l2 != null) {\r\n            if (l1.val < l2.val) {\r\n                lastNode.next = l1;\r\n                l1 = l1.next;\r\n            } else {\r\n                lastNode.next = l2;\r\n                l2 = l2.next;\r\n            }\r\n            lastNode = lastNode.next;\r\n        }\r\n        \r\n        if (l1 != null) {\r\n            lastNode.next = l1;\r\n        } else {\r\n            lastNode.next = l2;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n    题意：合并两个有序链表\r\n    模拟一轮归并排序\r\n    */\r\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        ListNode *dummy = new ListNode(0);\r\n        ListNode *tmp = dummy;\r\n        while (l1 != NULL && l2 != NULL) {\r\n            if (l1->val < l2->val) {\r\n                tmp->next = l1;\r\n                l1 = l1->next;\r\n            } else {\r\n                tmp->next = l2;\r\n                l2 = l2->next;\r\n            }\r\n            tmp = tmp->next;\r\n        }\r\n        if (l1 != NULL) tmp->next = l1;\r\n        else tmp->next = l2;\r\n        return dummy->next;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    '''\r\n    题意：合并两个有序链表\r\n    '''\r\n    def mergeTwoLists(self, l1, l2):\r\n        dummy = ListNode(0)\r\n        tmp = dummy\r\n        while l1 != None and l2 != None:\r\n            if l1.val < l2.val:\r\n                tmp.next = l1\r\n                l1 = l1.next\r\n            else:\r\n                tmp.next = l2\r\n                l2 = l2.next\r\n            tmp = tmp.next\r\n        if l1 != None:\r\n            tmp.next = l1\r\n        else:\r\n            tmp.next = l2\r\n        return dummy.next"}]},{"id":75,"unique_name":"insert-interval","title":"插入区间","description":"<p>给出一个<font color=\"#e76363\"><b>无重叠的</b></font><span style=\"line-height: 1.42857143;\">按照区间起始端点排序的区间列表。</span></p><p>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<font color=\"#e76363\"><b>不重叠</b></font>（如果有必要的话，可以合并区间）。</p>","solutions":[{"language":"java","code":"public class Solution {\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        if (newInterval == null || intervals == null) {\n            return intervals;\n        }\n\n        List<Interval> results = new ArrayList<Interval>();\n        int insertPos = 0;\n\n        for (Interval interval : intervals) {\n            if (interval.end < newInterval.start) {\n                results.add(interval);\n                insertPos++;\n            } else if (interval.start > newInterval.end) {\n                results.add(interval);\n            } else {\n                newInterval.start = Math.min(interval.start, newInterval.start);\n                newInterval.end = Math.max(interval.end, newInterval.end);\n            }\n        }\n\n        results.add(insertPos, newInterval);\n\n        return results;\n    }\n}\n\n// version: 高频题班\nclass Solution {\n    /**\n     * Insert newInterval into intervals.\n     *\n     * @param intervals:   Sorted interval list.\n     * @param newInterval: A new interval.\n     * @return: A new sorted interval list.\n     */\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        // write your code here\n        List<Interval> ans = new ArrayList<>();\n        \n        int idx = 0;\n        while (idx < intervals.size() && intervals.get(idx).start < newInterval.start) {\n            idx++;\n        }\n        intervals.add(idx, newInterval);\n\n        Interval last = null;\n        for (Interval item : intervals) {\n            if (last == null || last.end < item.start) {\n                ans.add(item);\n                last = item;\n            } else {\n                last.end = Math.max(last.end, item.end); // Modify the element already in list\n            }\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n  /**\r\n   * Insert newInterval into intervals.\r\n   * @param intervals: Sorted interval list.\r\n   * @param newInterval: new interval.\r\n   * @return: A new interval list.\r\n   */\r\n  vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\r\n    // write your code here\r\n    vector<Interval> ans;\r\n    int st;\r\n    for (st = 0; st < intervals.size() && intervals[st].start < newInterval.start; st++) { \r\n      ans.push_back(intervals[st]);\r\n    } \r\n      \r\n    if (!ans.empty() && ans.back().end >= newInterval.start) { \r\n      ans.back().end = max(ans.back().end, newInterval.end);\r\n    } else { \r\n      ans.push_back(newInterval);    \r\n     } \r\n     \r\n    for (int i = st; i < intervals.size(); i++) { \r\n      if (ans.back().end >= intervals[i].start) { \r\n        ans.back().end = max(ans.back().end, intervals[i].end);\r\n      } else { \r\n        ans.push_back(intervals[i]);\r\n      } \r\n    } \r\n    return ans;  \r\n  }\r\n};\r\n"},{"language":"python","code":"from lintcode import Interval\r\n\r\n\"\"\"\r\nDefinition of an interval.\r\nclass Interval(object):\r\n    def __init__(self, start, end):\r\n        self.start = start\r\n        self.end = end\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    Insert a new interval into a sorted non-overlapping interval list.\r\n    @param intevals: Sorted non-overlapping interval list\r\n    @param newInterval: The new interval.\r\n    @return: A new sorted non-overlapping interval list with the new interval.\r\n    \"\"\"\r\n    def insert(self, intervals, newInterval):\r\n        results = []\r\n        insertPos = 0\r\n        for interval in intervals:\r\n            if interval.end < newInterval.start:\r\n                results.append(interval)\r\n                insertPos += 1\r\n            elif interval.start > newInterval.end:\r\n                results.append(interval)\r\n            else:\r\n                newInterval.start = min(interval.start, newInterval.start)\r\n                newInterval.end = max(interval.end, newInterval.end)\r\n        results.insert(insertPos, newInterval)\r\n        return results"}]},{"id":765,"unique_name":"repeated-dna","title":"重复 ","description":"所有的DNA由一系列缩写的核苷酸 `A`, `C`, `G` 和 `T`组成. \n比如; `\"ACGAATTCCG\"`. 在研究 DNA 时, 有时候鉴别出 DNA 中的重复序列是很有用的. \n写一个函数来找到所有在 DNA 中出现超过一次且长度为 `10个字母` 的序列(子串).","solutions":[{"language":"java","code":"//高频班version\npublic class Solution {\n    /**\n     * @param s: a string represent DNA sequences\n     * @return: all the 10-letter-long sequences \n     */\n    public List<String> findRepeatedDna(String s) {\n        // write your code here\n        Set one = new HashSet();\n        Set two = new HashSet();\n        for (int i = 0; i < s.length() - 9; i++) {\n            String tmp = s.substring(i, i + 10);\n            if (!one.add(tmp)) {\n                two.add(tmp);\n            }\n        }\n        return new ArrayList(two);\n    }\n}"}]},{"id":412,"unique_name":"count-1-in-binary","title":"二进制中有多少个1 ","description":"计算在一个 32 位的整数的二进制表示中有多少个 `1`.","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param num: an integer\n     * @return: an integer, the number of ones in num\n     */\n    public int countOnes(int num) {\n        int count = 0;\n        while (num != 0) {\n            num = num & (num - 1);\n            count++;\n        }\n        return count;\n    }\n};\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param num: an integer\n     * @return: an integer, the number of ones in num\n     */\n    int countOnes(int num) {\n        // write your code here\n        int total = 0;\n        for (int i = 0; i < 32; ++i) {\n            total += num & 1;\n            num >>= 1;\n        }\n        return total;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param num: an integer\n    # @return: an integer, the number of ones in num\n    def countOnes(self, num):\n        # write your code here\n        total = 0\n        for i in xrange(32):\n            total += num & 1\n            num >>= 1\n        return total\n"}]},{"id":129,"unique_name":"gray-code","title":"格雷编码","description":"格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个二进制的差异。\r\n\r\n给定一个非负整数 `n` ，表示该代码中所有二进制的总数，请找出其格雷编码顺序。一个格雷编码顺序必须以 `0` 开始，并覆盖所有的 2<sup>n</sup> 个整数。","solutions":[{"language":"java","code":"public class Solution {\r\n    public ArrayList<Integer> grayCode(int n) {\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        if (n <= 1) {\r\n            for (int i = 0; i <= n; i++){\r\n                result.add(i);\r\n            }\r\n            return result;\r\n        }\r\n        result = grayCode(n - 1);\r\n        ArrayList<Integer> r1 = reverse(result);\r\n        int x = 1 << (n-1);\r\n        for (int i = 0; i < r1.size(); i++) {\r\n            r1.set(i, r1.get(i) + x);\r\n        }\r\n        result.addAll(r1);\r\n        return result;\r\n    }\r\n    \r\n    public ArrayList<Integer> reverse (ArrayList<Integer> r) {\r\n        ArrayList<Integer> rev = new ArrayList<Integer>();\r\n        for (int i = r.size() - 1; i >= 0; i--) {\r\n            rev.add(r.get(i));\r\n        }\r\n        return rev;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n a number\n     * @return Gray code\n     */\n    vector<int> grayCode(int n) {\n        // Write your code here\n        vector<int> result;\n        const size_t size = 1 << n; // 2^n\n        result.reserve(size);\n        for (size_t i = 0; i < size; ++i)\n            result.push_back(binary_to_gray(i));\n        return result;\n    }\nprivate:\n    static unsigned int binary_to_gray(unsigned int n) {\n        return n ^ (n >> 1);\n    }\n};\n"},{"language":"python","code":"class Solution:\r\n    # @param {int} n a number\r\n    # @return {int[]} Gray code\r\n    def grayCode(self, n):\r\n        if n == 0:\r\n            return [0]\r\n        \r\n        result = self.grayCode(n - 1)\r\n        seq = list(result)\r\n        for i in reversed(result):\r\n            seq.append((1 << (n - 1)) | i)\r\n            \r\n        return seq"}]},{"id":328,"unique_name":"subtree","title":"子树","description":"有两个不同大小的二叉树： `T1` 有上百万的节点； `T2` 有好几百的节点。请设计一种算法，判定 `T2` 是否为 `T1`的子树。\n","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param T1, T2: The roots of binary tree.\r\n     * @return: True if T2 is a subtree of T1, or false.\r\n     */\r\n    public boolean isSubtree(TreeNode T1, TreeNode T2) {\r\n        if (T2 == null) {\r\n            return true;\r\n        }\r\n        if (T1 == null) {\r\n            return false;\r\n        }\r\n        \r\n        if (isEqual(T1, T2)) {\r\n            return true;\r\n        }\r\n        if (isSubtree(T1.left, T2) || isSubtree(T1.right, T2)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    private boolean isEqual(TreeNode T1, TreeNode T2) {\r\n        if (T1 == null || T2 == null) {\r\n            return T1 == T2;\r\n        }\r\n        if (T1.val != T2.val) {\r\n            return false;\r\n        }\r\n        return isEqual(T1.left, T2.left) && isEqual(T1.right, T2.right);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param T1, T2: The roots of binary tree.\n     * @return: True if T2 is a subtree of T1, or false.\n     */\n    bool flag;\n    bool check(TreeNode *T1, TreeNode *T2) {\n        if (T1 == NULL && T2 != NULL)\n            return false;\n        if (T1 != NULL && T2 == NULL)\n            return false;\n\n        if (T1 == NULL && T2 == NULL)\n            return true;\n        if (T1->val != T2->val)\n            return false;\n        \n        return check(T1->left, T2->left) && check(T1->right, T2->right);\n    }\n\n    void dfs(TreeNode *T1, TreeNode *T2) {\n        //if (flag) return;\n        if (check(T1, T2)) {\n            flag = true;\n            return;\n        }\n        if (T1 == NULL)            \n            return;\n    \n        dfs(T1->left, T2);\n        dfs(T1->right, T2);\n        \n    }\n    bool isSubtree(TreeNode *T1, TreeNode *T2) {\n        // write your code here\n        flag = false;\n        dfs(T1, T2);\n        return flag;\n    }\n};"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\nclass Solution:\n    # @param T1, T2: The roots of binary tree.\n    # @return: True if T2 is a subtree of T1, or false.\n    def get(self, root, rt):\n        if root is None:\n            rt.append(\"#\")\n            return\n\n        rt.append(str(root.val))\n        self.get(root.left, rt)\n        self.get(root.right, rt)\n\n    def isSubtree(self, T1, T2):\n        # write your code here\n        rt = []\n        self.get(T1, rt)\n        t1 = ','.join(rt)\n\n        rt = []\n        self.get(T2, rt)\n        t2 = ','.join(rt)\n\n        return t1.find(t2) != -1"}]},{"id":415,"unique_name":"convert-sorted-array-to-binary-search-tree-with-minimal-height","title":"把排序数组转换为高度最小的二叉搜索树","description":"给一个排序数组（从小到大），将其转换为一棵高度最小的排序二叉树。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */ \r\npublic class Solution {\r\n    /**\r\n     * @param A: an integer array\r\n     * @return: a tree node\r\n     */\r\n    public TreeNode sortedArrayToBST(int[] A) {  \r\n        // write your code here\r\n        int len = A.length;\r\n        TreeNode root = null;  \r\n        root = recursion(A, 1, len, root);\r\n        A = null;\r\n        return root;  \r\n    }  \r\n    public TreeNode recursion(int[] array, int lhs, int rhs, TreeNode root)  \r\n    {  \r\n        if(lhs <= rhs)  \r\n        {  \r\n            int mid = (lhs + rhs + 1) >> 1;  \r\n            root = new TreeNode(array[mid-1]);  \r\n            root.left = recursion(array, lhs, mid - 1, root.left);  \r\n            root.right = recursion(array, mid + 1, rhs, root.right);  \r\n        }  \r\n        return root;  \r\n    }  \r\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param A: A sorted (increasing order) array\r\n     * @return: A tree node\r\n     */\r\n    TreeNode *sortedArrayToBST(vector<int> &A) {\r\n        // write your code here\r\n        if (A.size() == 0)\r\n            return NULL;\r\n        int len = A.size();\r\n        return buildTree(A, 0, len-1);\r\n    }\r\n    \r\n    TreeNode *buildTree(vector<int> &A, int start, int end) {\r\n        if (start > end) return NULL;\r\n        int mid = start + (end - start)/2;\r\n\r\n        TreeNode *root = new TreeNode(A[mid]);\r\n        root->left = buildTree(A, start, mid-1);\r\n        root->right = buildTree(A, mid+1, end);\r\n        return root;\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param A: a list of integer\n    @return: a tree node\n    \"\"\"\n    def sortedArrayToBST(self, A):\n        return self.convert(A, 0, len(A) - 1)\n        \n    def convert(self, A, start, end):\n        if start > end:\n            return None\n        if start == end:\n            return TreeNode(A[start])\n        \n        mid = (start + end) / 2\n        root = TreeNode(A[mid])\n        root.left = self.convert(A, start, mid - 1)\n        root.right = self.convert(A, mid + 1, end)\n        return root"}]},{"id":416,"unique_name":"print-numbers-by-recursion","title":"用递归打印数字","description":"用递归的方法找到从1到最大的N位整数。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n: An integer.\r\n     * return : An array storing 1 to the largest number with n digits.\r\n     */\r\n    public List<Integer> numbersByRecursion(int n) {\r\n        // write your code here\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        num(n, 0, res);\r\n        return res;\r\n    }\r\n    \r\n    public void num(int n, int ans,ArrayList<Integer> res){\r\n        \r\n        if(n == 0){\r\n            if(ans > 0){\r\n                res.add(ans);\r\n            }\r\n            return;\r\n        }\r\n        \r\n        int i;\r\n        for(i = 0; i <= 9; i++){\r\n            num(n - 1, ans * 10 + i, res);\r\n        }\r\n        \r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n: An integer.\r\n     * return : An array storing 1 to the largest number with n digits.\r\n     */\r\n    vector<int> numbersByRecursion(int n) {\r\n        // write your code here\r\n        vector<int> result;\r\n        num(n, 0, result);\r\n        return result;\r\n    }\r\n    void num(int n, int ans, vector<int> &result){\r\n        if(n == 0){\r\n            if(ans > 0){\r\n                result.push_back(ans);\r\n            }\r\n            return;\r\n        }\r\n        for(int i = 0; i <= 9; i ++){\r\n            num(n - 1, ans * 10 + i, result);\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param n: An integer.\r\n    # return : A list of integer storing 1 to the largest number with n digits.\r\n    def numbersByRecursion(self, n):\r\n        # write your code here\r\n        top = pow(10, n)\r\n        rt = []\r\n        for i in xrange(1, top):\r\n            rt.append(i)\r\n        return rt"}]},{"id":504,"unique_name":"flatten-list","title":"平面列表","description":"给定一个列表，该列表中的每个要素要么是个列表，要么是整数。将其变成一个只包含整数的简单列表。","solutions":[{"language":"java","code":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * public interface NestedInteger {\r\n *\r\n *     // @return true if this NestedInteger holds a single integer,\r\n *     // rather than a nested list.\r\n *     public boolean isInteger();\r\n *\r\n *     // @return the single integer that this NestedInteger holds,\r\n *     // if it holds a single integer\r\n *     // Return null if this NestedInteger holds a nested list\r\n *     public Integer getInteger();\r\n *\r\n *     // @return the nested list that this NestedInteger holds,\r\n *     // if it holds a nested list\r\n *     // Return null if this NestedInteger holds a single integer\r\n *     public List<NestedInteger> getList();\r\n * }\r\n */\r\npublic class Solution {\r\n\r\n    // @param nestedList a list of NestedInteger\r\n    // @return a list of integer\r\n    public List<Integer> flatten(List<NestedInteger> nestedList) {\r\n        // Write your code here\r\n        List<Integer> result = new ArrayList<Integer>();\r\n        for (NestedInteger ele : nestedList)\r\n            if (ele.isInteger())\r\n                result.add(ele.getInteger());\r\n            else\r\n                result.addAll(flatten(ele.getList()));\r\n        return result;\r\n    }\r\n}\r\n\r\n//non-recursive version\r\npublic class Solution {\r\n\r\n    // @param nestedList a list of NestedInteger\r\n    // @return a list of integer\r\n    public List<Integer> flatten(List<NestedInteger> nestedList) {\r\n        boolean isFlat = true;\r\n        List<NestedInteger> ls = nestedList;\r\n        while (isFlat) {\r\n            isFlat = false;\r\n            List<NestedInteger> newLs = new ArrayList<>();\r\n            for (NestedInteger ni : ls) {\r\n                if (ni.isInteger()) {\r\n                    newLs.add(ni);\r\n                } else {\r\n                    newLs.addAll(ni.getList());\r\n                    isFlat = true;\r\n                }\r\n            }\r\n            ls = newLs;\r\n        }\r\n        List<Integer> r = new ArrayList<>();\r\n        for (NestedInteger ni : ls) {\r\n            r.add(ni.getInteger());\r\n        }\r\n        return r;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * // This is the interface that allows for creating nested lists.\r\n * // You should not implement it, or speculate about its implementation\r\n * class NestedInteger {\r\n *   public:\r\n *     // Return true if this NestedInteger holds a single integer,\r\n *     // rather than a nested list.\r\n *     bool isInteger() const;\r\n *\r\n *     // Return the single integer that this NestedInteger holds,\r\n *     // if it holds a single integer\r\n *     // The result is undefined if this NestedInteger holds a nested list\r\n *     int getInteger() const;\r\n *\r\n *     // Return the nested list that this NestedInteger holds,\r\n *     // if it holds a nested list\r\n *     // The result is undefined if this NestedInteger holds a single integer\r\n *     const vector<NestedInteger> &getList() const;\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    // @param nestedList a list of NestedInteger\r\n    // @return a list of integer\r\n    vector<int> flatten(vector<NestedInteger> &nestedList) {\r\n        // Write your code here\r\n        vector<int> result;\r\n        for (auto ele : nestedList)\r\n            if (ele.isInteger())\r\n                result.push_back(ele.getInteger());\r\n            else {\r\n                vector<NestedInteger> sub_list = ele.getList();\r\n                vector<int> temp = flatten(sub_list);\r\n                result.insert(result.end(), temp.begin(), temp.end());\r\n            }\r\n\r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution(object):\r\n\r\n    # @param nestedList a list, each element in the list \r\n    # can be a list or integer, for example [1,2,[1,2]]\r\n    # @return {int[]} a list of integer\r\n    def flatten(self, nestedList):\r\n        # Write your code here\r\n        if isinstance(nestedList, int):\r\n            return [nestedList]\r\n\r\n        result = []\r\n        for ele in nestedList:\r\n            result.extend(self.flatten(ele))\r\n\r\n        return result\r\n        \r\n"}]},{"id":48,"unique_name":"convert-sorted-list-to-binary-search-tree","title":"排序列表转换为二分查找树","description":"<p>给出一个所有元素以升序排序的单链表，将它转换成一棵高度平衡的二分查找树</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    private ListNode current;\r\n\r\n    private int getListLength(ListNode head) {\r\n        int size = 0;\r\n\r\n        while (head != null) {\r\n            size++;\r\n            head = head.next;\r\n        }\r\n\r\n        return size;\r\n    }\r\n\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        int size;\r\n\r\n        current = head;\r\n        size = getListLength(head);\r\n\r\n        return sortedListToBSTHelper(size);\r\n    }\r\n\r\n    public TreeNode sortedListToBSTHelper(int size) {\r\n        if (size <= 0) {\r\n            return null;\r\n        }\r\n\r\n        TreeNode left = sortedListToBSTHelper(size / 2);\r\n        TreeNode root = new TreeNode(current.val);\r\n        current = current.next;\r\n        TreeNode right = sortedListToBSTHelper(size - 1 - size / 2);\r\n\r\n        root.left = left;\r\n        root.right = right;\r\n\r\n        return root;\r\n    }\r\n}"},{"language":"cpp","code":"// version 1: (Recommend)\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: The first node of linked list.\r\n     * @return: a tree node\r\n     */\r\n    TreeNode *sortedListToBST(ListNode *head) {\r\n        if (head == NULL) {\r\n            return NULL;\r\n        }\r\n        int size = getListSize(head);\r\n        return convertHelper(head, size);\r\n    }\r\n    \r\n    int getListSize(ListNode *head) {\r\n        int size = 0;\r\n        while (head != NULL) {\r\n            head = head->next;\r\n            size++;\r\n        }\r\n        return size;\r\n    }\r\n    \r\n    TreeNode *convertHelper(ListNode *&head, int size) {\r\n        if (size == 0) {\r\n            return NULL;\r\n        }\r\n        \r\n        TreeNode *root = new TreeNode(0);\r\n        root->left = convertHelper(head, size / 2);\r\n        root->val = head->val; head = head->next;\r\n        root->right = convertHelper(head, size - size / 2 - 1);\r\n        return root;\r\n    }\r\n};\r\n\r\n// version 2:\r\nstruct ResultType {\r\n    TreeNode *tree;\r\n    ListNode *next;\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: The first node of linked list.\r\n     * @return: a tree node\r\n     */\r\n    TreeNode *sortedListToBST(ListNode *head) {\r\n        if (head == NULL) {\r\n            return NULL;\r\n        }\r\n        \r\n        int size = getListSize(head);\r\n        ResultType result = convertHelper(head, size);\r\n        return result.tree;\r\n    }\r\n    \r\n    int getListSize(ListNode *head) {\r\n        int size = 0;\r\n        while (head != NULL) {\r\n            head = head->next;\r\n            size++;\r\n        }\r\n        return size;\r\n    }\r\n    \r\n    ResultType convertHelper(ListNode *head, int size) {\r\n        ResultType result;\r\n        \r\n        if (size == 1) {\r\n            result.tree = new TreeNode(head->val);\r\n            result.next = head->next;\r\n            return result;\r\n        }\r\n        \r\n        ResultType left = convertHelper(head, size / 2);\r\n        result.tree = new TreeNode(left.next->val);\r\n        result.tree->left = left.tree;\r\n        if (left.next->next == NULL || size - size / 2 - 1 == 0) {\r\n            result.tree->right = NULL;\r\n            result.next = left.next->next;\r\n            return result;\r\n        }\r\n        ResultType right = convertHelper(left.next->next, size - size / 2 - 1);\r\n        result.tree->right = right.tree;\r\n        result.next = right.next;\r\n        return result;\r\n    }\r\n};\r\n"}]},{"id":149,"unique_name":"validate-binary-search-tree","title":"验证二叉查找树","description":"给定一个二叉树，判断它是否是合法的二叉查找树(BST)\r\n\r\n一棵BST定义为：\r\n\r\n* 节点的左子树中的值要**严格**小于该节点的值。\r\n* 节点的右子树中的值要**严格**大于该节点的值。\r\n* 左右子树也必须是二叉查找树。\r\n* 一个节点的树也是二叉查找树。","solutions":[{"language":"java","code":"// version 1 Traverse\r\npublic class Solution {\r\n    private int lastVal = Integer.MIN_VALUE;\r\n    private boolean firstNode = true;\r\n    public boolean isValidBST(TreeNode root) {\r\n        if (root == null) {\r\n            return true;\r\n        }\r\n        if (!isValidBST(root.left)) {\r\n            return false;\r\n        }\r\n        if (!firstNode && lastVal >= root.val) {\r\n            return false;\r\n        }\r\n        firstNode = false;\r\n        lastVal = root.val;\r\n        if (!isValidBST(root.right)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// version 2  Divide and Conquer\r\nclass ResultType {\r\n    boolean is_bst;\r\n    int maxValue, minValue;\r\n    \r\n    ResultType(boolean is_bst, int maxValue, int minValue) {\r\n        this.is_bst = is_bst;\r\n        this.maxValue = maxValue;\r\n        this.minValue = minValue;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: True if the binary tree is BST, or false\r\n     */\r\n    public boolean isValidBST(TreeNode root) {\r\n        ResultType r = validateHelper(root);\r\n        return r.is_bst;\r\n    }\r\n    \r\n    private ResultType validateHelper(TreeNode root) {\r\n        if (root == null) {\r\n            return new ResultType(true, Integer.MIN_VALUE, Integer.MAX_VALUE);\r\n        }\r\n        \r\n        ResultType left = validateHelper(root.left);\r\n        ResultType right = validateHelper(root.right);\r\n        \r\n        if (!left.is_bst || !right.is_bst) {\r\n            // if is_bst is false then minValue and maxValue are useless\r\n            return new ResultType(false, 0, 0);\r\n        }\r\n        \r\n        if (root.left != null && left.maxValue >= root.val || \r\n              root.right != null && right.minValue <= root.val) {\r\n            return new ResultType(false, 0, 0);\r\n        }\r\n        \r\n        return new ResultType(true,\r\n                              Math.max(root.val, right.maxValue),\r\n                              Math.min(root.val, left.minValue));\r\n    }\r\n}\r\n\r\n// version 3  Divide and Conquer\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: True if the binary tree is BST, or false\r\n     */\r\n    public boolean isValidBST(TreeNode root) {\r\n        // write your code here\r\n        return divConq(root, Long.MIN_VALUE, Long.MAX_VALUE);\r\n    }\r\n    \r\n    private boolean divConq(TreeNode root, long min, long max){\r\n        if (root == null){\r\n            return true;\r\n        }\r\n        if (root.val <= min || root.val >= max){\r\n            return false;\r\n        }\r\n        return divConq(root.left, min, Math.min(max, root.val)) && \r\n                divConq(root.right, Math.max(min, root.val), max);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"// version 1: traverse\r\nclass Solution {\r\nprivate:\r\n    TreeNode *lastNode = NULL;\r\npublic:\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: True if the binary tree is BST, or false\r\n     */\r\n    bool isValidBST(TreeNode *root) {\r\n        if (root == NULL) {\r\n            return true;\r\n        }\r\n        if (!isValidBST(root->left)) {\r\n            return false;\r\n        }\r\n        if (lastNode != NULL && lastNode->val >= root->val) {\r\n            return false;\r\n        }\r\n        lastNode = root;\r\n        return isValidBST(root->right);\r\n    }\r\n};\r\n\r\n// traverse 2: divide & conquer\r\nclass ResultType {\r\npublic:\r\n    bool isBST;\r\n    TreeNode *maxNode, *minNode;\r\n    ResultType() {\r\n        this->isBST = true;\r\n        this->maxNode = NULL;\r\n        this->minNode = NULL;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: True if the binary tree is BST, or false\r\n     */\r\n    bool isValidBST(TreeNode *root) {\r\n        ResultType result = helper(root);\r\n        return result.isBST;\r\n    }\r\n    \r\n    ResultType helper(TreeNode *root) {\r\n        ResultType result;\r\n        if (root == NULL) {\r\n            return result;\r\n        }\r\n        \r\n        ResultType left = helper(root->left);\r\n        ResultType right = helper(root->right);\r\n        \r\n        if (!left.isBST || !right.isBST) {\r\n            result.isBST = false;\r\n            return result;\r\n        }\r\n        \r\n        if (left.maxNode != NULL && left.maxNode->val >= root->val) {\r\n            result.isBST = false;\r\n            return result;\r\n        }\r\n        \r\n        if (right.minNode != NULL && right.minNode->val <= root->val) {\r\n            result.isBST = false;\r\n            return result;\r\n        }\r\n        \r\n        result.isBST = true;\r\n        result.minNode = left.minNode == NULL ? root : left.minNode;\r\n        result.maxNode = right.maxNode == NULL ? root : right.maxNode;\r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: True if the binary tree is BST, or false\r\n    \"\"\"\r\n    def isValidBST(self, root):\r\n        self.lastVal = None\r\n        self.isBST = True\r\n        self.validate(root)\r\n        return self.isBST\r\n\r\n    def validate(self, root):\r\n        if root is None:\r\n            return\r\n        self.validate(root.left)\r\n        if self.lastVal is not None and self.lastVal >= root.val:\r\n            self.isBST = False\r\n            return\r\n        self.lastVal = root.val\r\n        self.validate(root.right)"}]},{"id":47,"unique_name":"balanced-binary-tree","title":"平衡二叉树","description":"<p>给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。&nbsp;<br></p>","solutions":[{"language":"java","code":"// Version 1: with ResultType\r\n/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\nclass ResultType {\r\n    public boolean isBalanced;\r\n    public int maxDepth;\r\n    public ResultType(boolean isBalanced, int maxDepth) {\r\n        this.isBalanced = isBalanced;\r\n        this.maxDepth = maxDepth;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: True if this Binary tree is Balanced, or false.\r\n     */\r\n    public boolean isBalanced(TreeNode root) {\r\n        return helper(root).isBalanced;\r\n    }\r\n    \r\n    private ResultType helper(TreeNode root) {\r\n        if (root == null) {\r\n            return new ResultType(true, 0);\r\n        }\r\n        \r\n        ResultType left = helper(root.left);\r\n        ResultType right = helper(root.right);\r\n        \r\n        // subtree not balance\r\n        if (!left.isBalanced || !right.isBalanced) {\r\n            return new ResultType(false, -1);\r\n        }\r\n        \r\n        // root not balance\r\n        if (Math.abs(left.maxDepth - right.maxDepth) > 1) {\r\n            return new ResultType(false, -1);\r\n        }\r\n        \r\n        return new ResultType(true, Math.max(left.maxDepth, right.maxDepth) + 1);\r\n    }\r\n}\r\n\r\n// Version 2: without ResultType\r\npublic class Solution {\r\n    public boolean isBalanced(TreeNode root) {\r\n        return maxDepth(root) != -1;\r\n    }\r\n\r\n    private int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n\r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n        if (left == -1 || right == -1 || Math.abs(left-right) > 1) {\r\n            return -1;\r\n        }\r\n        return Math.max(left, right) + 1;\r\n    }\r\n}"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    int depth(TreeNode *root) {\n        if (root == NULL) {\n            return 0;\n        }\n        int left = depth(root->left);\n        int right = depth(root->right);\n        if (left == -1 || right == -1 || abs(left - right) > 1) {\n            return -1;\n        }\n        return max(left, right) + 1;\n    }\n\n    /**\n     * @param root: The root of binary tree.\n     * @return: True if this Binary tree is Balanced, or false.\n     */\n    bool isBalanced(TreeNode *root) {\n        return depth(root) != -1;\n    }\n};\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: True if this Binary tree is Balanced, or false.\r\n    \"\"\"\r\n    def isBalanced(self, root):\r\n        balanced, _ = self.validate(root)\r\n        return balanced\r\n        \r\n    def validate(self, root):\r\n        if root is None:\r\n            return True, 0\r\n            \r\n        balanced, leftHeight = self.validate(root.left)\r\n        if not balanced:\r\n            return False, 0\r\n        balanced, rightHeight = self.validate(root.right)\r\n        if not balanced:\r\n            return False, 0\r\n            \r\n        return abs(leftHeight - rightHeight) <= 1, max(leftHeight, rightHeight) + 1"}]},{"id":181,"unique_name":"binary-tree-inorder-traversal","title":"二叉树的中序遍历","description":"<p>给出一棵二叉树,返回其中序遍历</p>","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: Inorder in ArrayList which contains node values.\r\n     */\r\n    public ArrayList<Integer> inorderTraversal(TreeNode root) {\r\n        Stack<TreeNode> stack = new Stack<TreeNode>();\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        TreeNode curt = root;\r\n        while (curt != null || !stack.empty()) {\r\n            while (curt != null) {\r\n                stack.add(curt);\r\n                curt = curt.left;\r\n            }\r\n            curt = stack.pop();\r\n            result.add(curt.val);\r\n            curt = curt.right;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <vector>\r\n#include \"lintcode.h\"\r\n\r\nusing namespace std;\r\n\r\n/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    /**\r\n     * @param root: The root of binary tree.\r\n     * @return: Inorder in vector which contains node values.\r\n     */\r\npublic:\r\n    vector<int> inorder;\r\n\r\n    void traverse(TreeNode *root) {\r\n        if (root == NULL) {\r\n            return;\r\n        }\r\n        traverse(root->left);\r\n        inorder.push_back(root->val);\r\n        traverse(root->right);\r\n    }\r\n\r\n    vector<int> inorderTraversal(TreeNode *root) {\r\n        inorder.clear();\r\n        traverse(root);\r\n        return inorder;\r\n        // write your code here\r\n    }\r\n};\r\n"},{"language":"python","code":"from lintcode import *\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: Inorder in ArrayList which contains node values.\r\n    \"\"\"\r\n    def inorderTraversal(self, root):\r\n        if root is None:\r\n            return []\r\n        return self.inorderTraversal(root.left) + [root.val]\\\r\n            + self.inorderTraversal(root.right)"}]},{"id":11,"unique_name":"binary-tree-preorder-traversal","title":"二叉树的前序遍历","description":"<p>给出一棵二叉树，返回其节点值的前序遍历。</p>","solutions":[{"language":"java","code":"Version 0: Non-Recursion (Recommend)\r\n/**\r\n * Definition for binary tree\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public List<Integer> preorderTraversal(TreeNode root) {\r\n        Stack<TreeNode> stack = new Stack<TreeNode>();\r\n        List<Integer> preorder = new ArrayList<Integer>();\r\n        \r\n        if (root == null) {\r\n            return preorder;\r\n        }\r\n        \r\n        stack.push(root);\r\n        while (!stack.empty()) {\r\n            TreeNode node = stack.pop();\r\n            preorder.add(node.val);\r\n            if (node.right != null) {\r\n                stack.push(node.right);\r\n            }\r\n            if (node.left != null) {\r\n                stack.push(node.left);\r\n            }\r\n        }\r\n        \r\n        return preorder;\r\n    }\r\n}\r\n\r\n//Version 1: Traverse\r\npublic class Solution {\r\n    public ArrayList<Integer> preorderTraversal(TreeNode root) {\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        traverse(root, result);\r\n        return result;\r\n    }\r\n    // 把root为跟的preorder加入result里面\r\n    private void traverse(TreeNode root, ArrayList<Integer> result) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n\r\n        result.add(root.val);\r\n        traverse(root.left, result);\r\n        traverse(root.right, result);\r\n    }\r\n}\r\n\r\n//Version 2: Divide & Conquer\r\npublic class Solution {\r\n    public ArrayList<Integer> preorderTraversal(TreeNode root) {\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        // null or leaf\r\n        if (root == null) {\r\n            return result;\r\n        }\r\n\r\n        // Divide\r\n        ArrayList<Integer> left = preorderTraversal(root.left);\r\n        ArrayList<Integer> right = preorderTraversal(root.right);\r\n\r\n        // Conquer\r\n        result.add(root.val);\r\n        result.addAll(left);\r\n        result.addAll(right);\r\n        return result;\r\n    }\r\n}"},{"language":"cpp","code":"#include <vector>\r\n#include \"lintcode.h\"\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> preorder;\r\n\r\n    void traverse(TreeNode *root) {\r\n        if (root == NULL) {\r\n            return;\r\n        }\r\n        preorder.push_back(root->val);\r\n        traverse(root->left);\r\n        traverse(root->right);\r\n    }\r\n\r\n    vector<int> preorderTraversal(TreeNode *root) {\r\n        preorder.clear();\r\n        traverse(root);\r\n        return preorder;\r\n    }\r\n};\r\n"},{"language":"python","code":"# Version 0: Recursion \r\n\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: Preorder in ArrayList which contains node values.\r\n    \"\"\"\r\n    def preorderTraversal(self, root):\r\n        self.results = []\r\n        self.traverse(root)\r\n        return self.results\r\n        \r\n    def traverse(self, root):\r\n        if root is None:\r\n            return\r\n        self.results.append(root.val)\r\n        self.traverse(root.left)\r\n        self.traverse(root.right)\r\n\r\n# Version 1: Non-Recursion  \r\n\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of binary tree.\r\n    @return: Preorder in list which contains node values.\r\n    \"\"\"\r\n    def preorderTraversal(self, root):\r\n        if root is None:\r\n            return []\r\n        stack = [root]\r\n        preorder = []\r\n        while stack:\r\n            node = stack.pop()\r\n            preorder.append(node.val)\r\n            if node.right:\r\n                stack.append(node.right)\r\n            if node.left:\r\n                stack.append(node.left)\r\n        return preorder"}]},{"id":134,"unique_name":"restore-ip-addresses","title":"恢复IP地址","description":"给一个由数字组成的字符串。求出其可能恢复为的所有IP地址。","solutions":[{"language":"java","code":"public class Solution {\r\n    public ArrayList<String> restoreIpAddresses(String s) {\r\n        ArrayList<String> result = new ArrayList<String>();\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        \r\n        if(s.length() <4 || s.length() > 12)\r\n            return result;\r\n        \r\n        helper(result, list, s , 0);\r\n        return result;\r\n    }\r\n    \r\n    public void helper(ArrayList<String> result, ArrayList<String> list, String s, int start){\r\n        if(list.size() == 4){\r\n            if(start != s.length())\r\n                return;\r\n            \r\n            StringBuffer sb = new StringBuffer();\r\n            for(String tmp: list){\r\n                sb.append(tmp);\r\n                sb.append(\".\");\r\n            }\r\n            sb.deleteCharAt(sb.length()-1);\r\n            result.add(sb.toString());\r\n            return;\r\n        }\r\n        \r\n        for(int i=start; i<s.length() && i < start+3; i++){\r\n            String tmp = s.substring(start, i+1);\r\n            if(isvalid(tmp)){\r\n                list.add(tmp);\r\n                helper(result, list, s, i+1);\r\n                list.remove(list.size()-1);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private boolean isvalid(String s){\r\n        if(s.charAt(0) == '0')\r\n            return s.equals(\"0\"); // to eliminate cases like \"00\", \"10\"\r\n        int digit = Integer.valueOf(s);\r\n        return digit >= 0 && digit <= 255;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param s the IP string\r\n     * @return All possible valid IP addresses\r\n     */\r\n    \r\n    bool ok(string x) {\r\n        if (x.size() != 1 && x[0] == '0') return 0;\r\n        int res = 0;\r\n        for (auto i : x) {\r\n            res = res * 10 + i - '0';\r\n        }\r\n        return res < 256;\r\n    }\r\n    \r\n    vector<string> restoreIpAddresses(string& s) {\r\n        // Write your code here\r\n        vector<string> res;\r\n        for (int i = 1; i <= 3; i++) {\r\n            for (int j = 1; j <= 3; j++) {\r\n                for (int k = 1; k <= 3; k++) {\r\n                    for (int l = 1; l <= 3; l++) {\r\n                        if (i + j + k + l == s.size()) {\r\n                            string a(s.begin() + 0, s.begin() + i),\r\n                                   b(s.begin() + i, s.begin() + i + j),\r\n                                   c(s.begin() + i + j, s.begin() + i + j + k),\r\n                                   d(s.begin() + i + j + k, s.begin() + i + j + k + l);\r\n                            if (ok(a) && ok(b) && ok(c) && ok(d)) {\r\n                                res.push_back(a + \".\" + b + \".\" + c + \".\" + d);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param s, a string\r\n    # @return a list of strings\r\n    def restoreIpAddresses(self, s):\r\n        def dfs(s, sub, ips, ip):\r\n            if sub == 4:                                        # should be 4 parts\r\n                if s == '':\r\n                    ips.append(ip[1:])                          # remove first '.'\r\n                return\r\n            for i in range(1, 4):                               # the three ifs' order cannot be changed!\r\n                if i <= len(s):                                 # if i > len(s), s[:i] will make false!!!!\r\n                    if int(s[:i]) <= 255:\r\n                        dfs(s[i:], sub+1, ips, ip+'.'+s[:i])\r\n                    if s[0] == '0': break                       # make sure that res just can be '0.0.0.0' and remove like '00'\r\n        ips = []\r\n        dfs(s, 0, ips, '')\r\n        return ips\r\n"}]},{"id":108,"unique_name":"generate-parentheses","title":"生成括号","description":"给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。","solutions":[{"language":"java","code":"public class Solution {\r\n    public ArrayList<String> generateParenthesis(int n) {\r\n        ArrayList<String> result = new ArrayList<String>();\r\n        if (n <= 0) {\r\n            return result;\r\n        }\r\n        helper(result, \"\", n, n);\r\n        return result;\r\n    }\r\n    \r\n\tpublic void helper(ArrayList<String> result,\r\n\t                   String paren, // current paren\r\n\t                   int left,     // how many left paren we need to add\r\n\t                   int right) {  // how many right paren we need to add\r\n\t\tif (left == 0 && right == 0) {\r\n\t\t\tresult.add(paren);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        if (left > 0) {\r\n\t\t    helper(result, paren + \"(\", left - 1, right);\r\n        }\r\n        \r\n        if (right > 0 && left < right) {\r\n\t\t    helper(result, paren + \")\", left, right - 1);\r\n        }\r\n\t}\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param n n pairs\n     * @return All combinations of well-formed parentheses\n     */\n    vector<string> generateParenthesis(int n) {\n        // Write your code here\n        vector<string> res;\n        string s;\n        helper(s,res,0,0,n);\n        return res;\n    }\n    void helper(string s,vector<string> &res,int l,int r,int n){\n        if(r==n){\n            res.push_back(s);\n        }\n        else if(l==n){\n            s+=')';\n            helper(s,res,l,r+1,n);\n        }\n        else{\n            if(l>r)\n                helper(s+')',res,l,r+1,n);\n            helper(s+'(',res,l+1,r,n);\n        }\n    }\n};"},{"language":"python","code":"class Solution:\n    # @param an integer\n    # @return a list of string\n    # @draw a decision tree when n == 2, and you can understand it!\n    def helpler(self, l, r, item, res):\n        if r < l:\n            return\n        if l == 0 and r == 0:\n            res.append(item)\n        if l > 0:\n            self.helpler(l - 1, r, item + '(', res)\n        if r > 0:\n            self.helpler(l, r - 1, item + ')', res)\n    \n    def generateParenthesis(self, n):\n        if n == 0:\n            return []\n        res = []\n        self.helpler(n, n, '', res)\n        return res"}]},{"id":10,"unique_name":"binary-tree-postorder-traversal","title":"二叉树的后序遍历","description":"<p>给出一棵二叉树，返回其节点值的后序遍历。</p>","solutions":[{"language":"java","code":"//Recursive\r\npublic ArrayList<Integer> postorderTraversal(TreeNode root) {\r\n    ArrayList<Integer> result = new ArrayList<Integer>();\r\n\r\n    if (root == null) {\r\n        return result;\r\n    }\r\n\r\n    result.addAll(postorderTraversal(root.left));\r\n    result.addAll(postorderTraversal(root.right));\r\n    result.add(root.val);\r\n\r\n    return result;   \r\n}\r\n\r\n//Iterative\r\npublic ArrayList<Integer> postorderTraversal(TreeNode root) {\r\n    ArrayList<Integer> result = new ArrayList<Integer>();\r\n    Stack<TreeNode> stack = new Stack<TreeNode>();\r\n    TreeNode prev = null; // previously traversed node\r\n    TreeNode curr = root;\r\n\r\n    if (root == null) {\r\n        return result;\r\n    }\r\n\r\n    stack.push(root);\r\n    while (!stack.empty()) {\r\n        curr = stack.peek();\r\n        if (prev == null || prev.left == curr || prev.right == curr) { // traverse down the tree\r\n            if (curr.left != null) {\r\n                stack.push(curr.left);\r\n            } else if (curr.right != null) {\r\n                stack.push(curr.right);\r\n            }\r\n        } else if (curr.left == prev) { // traverse up the tree from the left\r\n            if (curr.right != null) {\r\n                stack.push(curr.right);\r\n            }\r\n        } else { // traverse up the tree from the right\r\n            result.add(curr.val);\r\n            stack.pop();\r\n        }\r\n        prev = curr;\r\n    }\r\n\r\n    return result;\r\n}"},{"language":"cpp","code":"// non-recursion version \r\n\r\n/**\r\n * Definition for binary tree\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<int> postorderTraversal(TreeNode *root) {\r\n        vector<int> result;\r\n        stack<TreeNode *> myStack;\r\n        \r\n        TreeNode *current = root, *lastVisited = NULL;\r\n        while (current != NULL || !myStack.empty()) {\r\n            while (current != NULL) {\r\n                myStack.push(current);\r\n                current = current->left;\r\n            }\r\n            current = myStack.top(); \r\n            if (current->right == NULL || current->right == lastVisited) {\r\n                myStack.pop();\r\n                result.push_back(current->val);\r\n                lastVisited = current;\r\n                current = NULL;\r\n            } else {\r\n                current = current->right;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"from lintcode import TreeNode\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: Postorder in ArrayList which contains node values.\n    \"\"\"\n    result = []\n    \n    def traverse(self, root):\n        if root is None:\n            return\n        self.traverse(root.left)\n        self.traverse(root.right)\n        self.results.append(root.val) \n\n\n\n    def postorderTraversal(self, root):\n        self.results = []\n        self.traverse(root)\n        return self.results\n        # write your code here\n\n"}]},{"id":80,"unique_name":"n-queens-ii","title":"N皇后问题 II","description":"<p>根据n皇后问题，现在返回n皇后不同的解决方案的数量而不是具体的放置布局。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public static int sum;\r\n    public int totalNQueens(int n) {\r\n        sum = 0;\r\n        int[] usedColumns = new int[n];\r\n        placeQueen(usedColumns, 0);\r\n        return sum;\r\n    }\r\n    public void placeQueen(int[] usedColumns, int row) {\r\n        int n = usedColumns.length;\r\n        \r\n        if (row == n) {\r\n            sum ++;\r\n            return;\r\n        }\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (isValid(usedColumns, row, i)) {\r\n                usedColumns[row] = i;\r\n                placeQueen(usedColumns, row + 1);\r\n            }\r\n        }\r\n    }\r\n    public boolean isValid(int[] usedColumns, int row, int col) {\r\n        for (int i = 0; i < row; i++) {\r\n            if (usedColumns[i] == col) {\r\n                return false;\r\n            }\r\n            if ((row - i) == Math.abs(col-usedColumns[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int sum;\r\n    \r\n    bool canPut(int row, int col, vector<int> &cols) {\r\n        for (int i = 0; i < row; i++) {\r\n            if (cols[i] - i == col - row) {\r\n                return false;\r\n            }\r\n            if (cols[i] + i == col + row) {\r\n                return false;\r\n            }\r\n            if (cols[i] == col) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    void dfs(int n, int k, vector<int> &cols) {\r\n        if (k == n) {\r\n            sum++;\r\n            return;\r\n        }\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (!canPut(k, i, cols)) {\r\n                continue;\r\n            }\r\n            cols[k] = i;\r\n            dfs(n, k + 1, cols);\r\n        }\r\n    }\r\n    \r\n    int totalNQueens(int n) {\r\n        vector<int> cols(n);\r\n        \r\n        sum = 0;\r\n        dfs(n, 0, cols);\r\n        return sum;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    Calculate the total number of distinct N-Queen solutions\n    @param n: The number of queens.\n    @return: The total number of distinct solutions.\n    \"\"\"\n    total = 0\n    n = 0\n\n    def attack(self, row, col):\n        for c, r in self.cols.iteritems():\n            if c - r == col - row or c + r == col + row:\n                return True\n        return False\n\n    def search(self, row):\n        if row == self.n:\n            self.total += 1\n            return\n        for col in range(self.n):\n            if col in self.cols:\n                continue\n            if self.attack(row, col):\n                continue\n            self.cols[col] = row\n            self.search(row + 1)\n            del self.cols[col]\n\n    def totalNQueens(self, n):\n        self.n = n\n        self.cols = {}\n        self.search(0)\n        return self.total"},{"language":"javascript","code":"const totalNQueens = function (n) {\n    var cols, sum;\n    function canPut(row, col) {\n        var i;\n        for (i = 0; i < row; i++) {\n            if (cols[i] - i === col - row) {\n                return false;\n            }\n            if (cols[i] + i === col + row) {\n                return false;\n            }\n            if (cols[i] === col) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function dfs(n, k) {\n        var i;\n        if (k === n) {\n            sum++;\n            return;\n        }\n        for (i = 0; i < n; i++) {\n            if (!canPut(k, i)) {\n                continue;\n            }\n            cols[k] = i;\n            dfs(n, k + 1);\n        }\n    }\n    cols = new Array(n);\n    sum = 0;\n    dfs(n, 0);\n    return sum;\n}"}]},{"id":81,"unique_name":"n-queens","title":"N皇后问题","description":"<p><span style=\"line-height: 1.42857143;\">n皇后问题是将n个皇后放置在n*n的棋盘上，皇后彼此之间不能相互攻击。</span><br></p><p>给定一个整数n，返回所有不同的n皇后问题的解决方案。</p><p>每个解决方案包含一个明确的n皇后放置布局，其中“Q”和“.”分别表示一个女王和一个空位置。</p>","solutions":[{"language":"java","code":"class Solution {\n    /**\n     * Get all distinct N-Queen solutions\n     * @param n: The number of queens\n     * @return: All distinct solutions\n     * For example, A string '...Q' shows a queen on forth position\n     */\n    List<List<String>> solveNQueens(int n) {\n        List<List<String>> results = new ArrayList<>();\n        if (n <= 0) {\n            return results;\n        }\n        \n        search(results, new ArrayList<Integer>(), n);\n        return results;\n    }\n    \n    /*\n     * results store all of the chessboards\n     * cols store the column indices for each row\n     */\n    private void search(List<List<String>> results,\n                        List<Integer> cols,\n                        int n) {\n        if (cols.size() == n) {\n            results.add(drawChessboard(cols));\n            return;\n        }\n        \n        for (int colIndex = 0; colIndex < n; colIndex++) {\n            if (!isValid(cols, colIndex)) {\n                continue;\n            }\n            cols.add(colIndex);\n            search(results, cols, n);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    \n    private List<String> drawChessboard(List<Integer> cols) {\n        List<String> chessboard = new ArrayList<>();\n        for (int i = 0; i < cols.size(); i++) {\n            StringBuilder sb = new StringBuilder();\n            for (int j = 0; j < cols.size(); j++) {\n                sb.append(j == cols.get(i) ? 'Q' : '.');\n            }\n            chessboard.add(sb.toString());\n        }\n        return chessboard;\n    }\n    \n    private boolean isValid(List<Integer> cols, int column) {\n        int row = cols.size();\n        for (int rowIndex = 0; rowIndex < cols.size(); rowIndex++) {\n            if (cols.get(rowIndex) == column) {\n                return false;\n            }\n            if (rowIndex + cols.get(rowIndex) == row + column) {\n                return false;\n            }\n            if (rowIndex - cols.get(rowIndex) == row - column) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * Get all distinct N-Queen solutions\r\n     * @param n: The number of queens\r\n     * @return: All distinct solutions\r\n     * For example, A string '...Q' shows a queen on forth position\r\n     */\r\n    vector<vector<string> > solveNQueens(int n) {\r\n        // write your code here\r\n        vector<vector<string> > result;\r\n        if( n <= 0 )\r\n        {\r\n            return result;\r\n        }\r\n        vector<int> cols;\r\n        search(n, cols, result);\r\n        return result;\r\n    }\r\n    \r\n    void search(int n, vector<int> &cols, vector<vector<string> > &result)\r\n    {\r\n        if(cols.size() == n)\r\n        {\r\n            result.push_back(drawResult(cols, n));\r\n            return;\r\n        }\r\n        for(int col = 0; col < n; col++)\r\n        {\r\n            if(!isValid(cols, col))\r\n            {\r\n                continue;\r\n            }\r\n            cols.push_back(col);\r\n            search(n, cols, result);\r\n            cols.pop_back();\r\n        }\r\n    }\r\n    bool isValid(vector<int> &cols, int col)\r\n    {\r\n        int row = cols.size();\r\n        for(int i = 0; i < row; ++i)\r\n        {\r\n            if(cols[i] == col)\r\n            {\r\n                return false;\r\n            }\r\n            if(i - cols[i] == row - col)\r\n            {\r\n                return false;\r\n            }\r\n            if(i + cols[i] == row + col)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    vector<string> drawResult(vector<int> &cols, int n)\r\n    {\r\n        vector<string> result;\r\n        for(int i = 0; i < cols.size(); ++i)\r\n        {\r\n            string temp(n, '.');\r\n            temp[cols[i]] = 'Q';\r\n            result.push_back(temp);\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    Get all distinct N-Queen solutions\r\n    @param n: The number of queens.\r\n    @return: All distinct solutions.\r\n    \"\"\"\r\n    n = 0\r\n    results = []\r\n    cols = {}\r\n\r\n    def attack(self, row, col):\r\n        for c, r in self.cols.iteritems():\r\n            if c - r == col - row or c + r == col + row:\r\n                return True\r\n        return False\r\n\r\n    def search(self, row):\r\n        if row == self.n:\r\n            result = []\r\n            for i in range(self.n):\r\n                r = ['.'] * self.n\r\n                r[self.cols[i]] = 'Q'\r\n                result.append(''.join(r))\r\n            self.results.append(result)\r\n            return\r\n\r\n        for col in range(self.n):\r\n            if col in self.cols:\r\n                continue\r\n            if self.attack(row, col):\r\n                continue\r\n            self.cols[col] = row\r\n            self.search(row + 1)\r\n            del self.cols[col]\r\n            \r\n    def solveNQueens(self, n):\r\n        self.n = n\r\n        self.search(0)\r\n        return self.results\r\n"}]},{"id":137,"unique_name":"subsets-ii","title":"带重复元素的子集","description":"给定一个可能具有重复数字的列表，返回其所有可能的子集","solutions":[{"language":"java","code":"// return List<List<Integer>>\r\nclass Solution {\r\n    /**\r\n     * @param nums: A set of numbers.\r\n     * @return: A list of lists. All valid subsets.\r\n     */\r\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\r\n        // write your code here\r\n        List<List<Integer>> results = new ArrayList<List<Integer>>();\r\n        if (nums == null) return results;\r\n        \r\n        if (nums.length == 0) {\r\n            results.add(new ArrayList<Integer>());\r\n            return results;\r\n        }\r\n        Arrays.sort(nums);\r\n\r\n        List<Integer> subset = new ArrayList<Integer>();\r\n        helper(nums, 0, subset, results);\r\n        \r\n        return results;\r\n        \r\n        \r\n    }\r\n    public void helper(int[] nums, int startIndex, List<Integer> subset, List<List<Integer>> results){\r\n        results.add(new ArrayList<Integer>(subset));\r\n        for(int i=startIndex; i<nums.length; i++){\r\n            if (i != startIndex && nums[i]==nums[i-1]) {\r\n                continue;\r\n            }\r\n            subset.add(nums[i]);\r\n            helper(nums, i+1, subset, results);\r\n            subset.remove(subset.size()-1);\r\n        }\r\n    }\r\n}\r\n\r\n// return ArrayList<ArrayList<Integer>> \r\nclass Solution {\r\n    /**\r\n     * @param nums: A set of numbers.\r\n     * @return: A list of lists. All valid subsets.\r\n     */\r\n    public ArrayList<ArrayList<Integer>> subsetsWithDup(int[] nums) {\r\n        // write your code here\r\n        ArrayList<ArrayList<Integer>> results = new ArrayList<>();\r\n        if (nums == null) return results;\r\n        \r\n        if (nums.length == 0) {\r\n            results.add(new ArrayList<Integer>());\r\n            return results;\r\n        }\r\n        Arrays.sort(nums);\r\n\r\n        ArrayList<Integer> subset = new ArrayList<>();\r\n        helper(nums, 0, subset, results);\r\n        \r\n         return results;\r\n        \r\n        \r\n    }\r\n    public void helper(int[] nums, int startIndex, ArrayList<Integer> subset, ArrayList<ArrayList<Integer>> results){\r\n        results.add(new ArrayList<Integer>(subset));\r\n        for(int i=startIndex; i<nums.length; i++){\r\n            if (i != startIndex && nums[i]==nums[i-1]) {\r\n                continue;\r\n            }\r\n            subset.add(nums[i]);\r\n            helper(nums, i+1, subset, results);\r\n            subset.remove(subset.size()-1);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\n\r\nclass Solution {\r\npublic:\r\n    vector<vector<int> > result;\r\n    bool equls( vector<int> a, vector<int> b){\r\n        if (a.size() != b.size())\r\n            return false;\r\n        int cnt = a.size();\r\n        for (int i = 0; i < cnt;++i)\r\n            if (a[i]!=b[i]) return false;\r\n        return true;\r\n    }\r\n    void dfs(vector<int> tmp, int x , vector<int> nums) {\r\n        if (x == nums.size()) {\r\n            int cnt = result.size();\r\n            for ( int i = 0; i  < cnt ; ++i)\r\n                if ( equls(result[i], tmp) )\r\n                        return ;\r\n            result.push_back(tmp);\r\n            return ;\r\n        }\r\n        dfs(tmp, x + 1, nums);\r\n        tmp.push_back(nums[x]);\r\n        dfs(tmp, x + 1, nums);\r\n    }\r\n    vector<vector<int> > subsetsWithDup(vector<int> &nums){\r\n        sort(nums.begin(), nums.end());\r\n    \tvector<int> tmp;\r\n    \tdfs(tmp, 0 , nums) ;\r\n    \t// write your code here\r\n    \treturn result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    def subsetsWithDup(self, S):\r\n        # write your code here\r\n        S.sort()\r\n        p = [[S[x] for x in range(len(S)) if i>>x&1] for i in range(2**len(S))]\r\n        func = lambda x,y:x if y in x else x + [y]\r\n        p = reduce(func, [[], ] + p)\r\n        return list(reversed(p))\r\n"}]},{"id":616,"unique_name":"add-strings","title":"大整数加法","description":"以字符串的形式给出两个非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的和。 ","solutions":[{"language":"java","code":"public class Solution {\r\n    public String addStrings(String num1, String num2) {\r\n        String res = \"\";\r\n        int m = num1.length(), n = num2.length(), i = m - 1, j = n - 1, flag = 0;\r\n        while(i >= 0 || j >= 0){\r\n            int a, b; \r\n            if(i >= 0){\r\n                a = num1.charAt(i--) - '0';\r\n            }\r\n            else{\r\n                a = 0;\r\n            }\r\n            if(j >= 0){\r\n                b = num2.charAt(j--) - '0';\r\n            }\r\n            else{\r\n                b = 0;\r\n            }\r\n            int sum = a + b + flag;\r\n            res =(char)(sum % 10 + '0') + res;\r\n            flag = sum / 10;\r\n        }\r\n        return flag == 1 ? \"1\" + res: res; \r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"// 方法一\r\nclass Solution {\r\npublic:\r\n    string addStrings(string num1, string num2) {\r\n        int len1 = num1.length();\r\n        int len2 = num2.length();\r\n        int i,j;\r\n        string res;\r\n        string num = \"0123456789\";\r\n        int sum, flag = 0;\r\n        \r\n        for( i = len1 - 1, j = len2 - 1; i >=0 && j >= 0; i--,j--){\r\n            sum = (num1[i]-'0') + (num2[j] - '0') + flag;\r\n            flag = sum / 10;\r\n            sum = sum % 10;\r\n            res +=num[sum];\r\n        }\r\n        //处理剩下的部分\r\n        for(; i>= 0; i--){\r\n            sum = (num1[i]- '0') + flag;\r\n            flag = sum / 10;\r\n            sum = sum % 10;\r\n            res +=num[sum];\r\n        }\r\n        for(; j >= 0; j--){\r\n            sum = (num2[j] - '0') + flag;\r\n            flag = sum / 10;\r\n            sum = sum % 10;\r\n            res +=num[sum];\r\n        }\r\n        //注意最后是否有进位1\r\n        if(flag == 1){\r\n            res +=\"1\";\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n// 方法二\r\nclass Solution {\r\npublic:\r\n    string addStrings(string num1, string num2) {\r\n        string res = \"\";\r\n        int m = num1.size(), n = num2.size(), i = m - 1, j = n - 1, flag = 0;\r\n        while (i >= 0 || j >= 0) {\r\n            int a, b;\r\n            if(i >= 0){\r\n                a = num1[i--] - '0';\r\n            }\r\n            else{\r\n                a = 0;\r\n            }\r\n            if( j >= 0){\r\n                b = num2[j--] - '0';\r\n            }\r\n            else{\r\n                b = 0;\r\n            }\r\n            int sum = a + b + flag;\r\n            res.insert(res.begin(), sum % 10 + '0');\r\n            flag = sum / 10;\r\n        }\r\n        return flag ? \"1\" + res : res;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    def addStrings(self, num1, num2):\r\n        \"\"\"\r\n        :type num1: str\r\n        :type num2: str\r\n        :rtype: str\r\n        \"\"\"\r\n        res = \"\"\r\n        m = len(num1)\r\n        n = len(num2)\r\n        i = m - 1\r\n        j = n - 1\r\n        flag = 0\r\n        while i >=0 or j >= 0:\r\n            a = int(num1[i]) if i >=0 else 0\r\n            i = i - 1\r\n            b = int(num2[j]) if j >=0 else 0\r\n            j = j - 1\r\n            sum = a + b + flag\r\n            res = str(sum % 10 ) + res;\r\n            flag = sum / 10\r\n        return res if flag == 0 else (str(flag)+ res)\r\n        "}]},{"id":655,"unique_name":"guess-number-game","title":"猜数游戏","description":"我们正在玩猜数游戏。 游戏如下：\n我从 **1** 到 **n** 选择一个数字。 你需要猜我选择了哪个号码。\n每次你猜错了，我会告诉你这个数字是高还是低。\n你调用一个预定义的接口 `guess(int num)`，它会返回 3 个可能的结果(-1，1或0):","solutions":[{"language":"java","code":"// version: 高频题班\r\n\r\n/* The guess API is defined in the parent class GuessGame.\r\n   @param num, your guess\r\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\r\n      int guess(int num); */\r\n\r\npublic class Solution extends GuessGame {\r\n    /**\r\n     * @param n an integer\r\n     * @return the number you guess\r\n     */\r\n    public int guessNumber(int n) {\r\n        // Write your code here\r\n        int l = 1, r = n;\r\n        while (l <= r) {\r\n            int mid = l + (r - l) / 2;\r\n            int res = guess(mid);\r\n            if (res == 0) {\r\n                return mid;\r\n            }\r\n            \r\n            if (res == -1) {\r\n                r = mid - 1;\r\n            } else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}"},{"language":"cpp","code":"\r\nclass Solution {\r\npublic:\r\n  /**\r\n   * @param n an integer\r\n   * @return the number you guess\r\n   */\r\n  int guessNumber(int n) {\r\n    // Write your code here\r\n    int l = 1, r = n;\r\n    while (l <= r) {\r\n      int mid = l + (r - l) / 2;\r\n      int res = guess(mid);\r\n      if (res == 0) {\r\n        return mid;\r\n      }\r\n      \r\n      if (res == -1) {\r\n        r = mid - 1;\r\n      } else {\r\n        l = mid + 1;\r\n      }\r\n    }\r\n  }\r\n};\r\n"},{"language":"python","code":"# The guess API is already defined for you.\r\n# @param num, your guess\r\n# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\r\n# you can call GuessGame.guess(num)\r\n\r\nclass Solution:\r\n    # @param {int} n an integer\r\n    # @return {int} the number you guess\r\n    def guessNumber(self, n):\r\n        # Write your code here\r\n        l, r = 1, n\r\n        while l <= r:\r\n            mid = l + (r - l) / 2\r\n            res = Guess.guess(mid)\r\n            if res == 0:\r\n                return mid\r\n            if res == -1:\r\n\t\t\t\tr = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return -1"}]},{"id":546,"unique_name":"valid-word-abbreviation","title":"检查缩写字","description":"给定一个**非空字符串** `word` 和缩写 `abbr`，返回字符串是否可以和给定的缩写匹配。\n比如一个 `“word”` 的字符串仅包含以下有效缩写：\n```\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n```","solutions":[{"language":"java","code":"public class Solution {\r\n    public boolean validWordAbbreviation(String word, String abbr) {\r\n        int i = 0, j = 0;\r\n        while (i < word.length() && j < abbr.length()) {\r\n            if (word.charAt(i) == abbr.charAt(j)) {\r\n                i++;\r\n                j++;\r\n            } else if ((abbr.charAt(j) > '0') && (abbr.charAt(j) <= '9')) {     //notice that 0 cannot be included\r\n                int start = j;\r\n                while (j < abbr.length() && Character.isDigit(abbr.charAt(j))) {\r\n                    j++;\r\n                }\r\n                i += Integer.valueOf(abbr.substring(start, j));\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return (i == word.length()) && (j == abbr.length());\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    bool validWordAbbreviation(string word, string abbr) {\r\n        int i = 0, j = 0;\r\n        while (i < word.length() && j < abbr.length()) {\r\n            if (word.at(i) == abbr.at(j)) {\r\n                i++;\r\n                j++;\r\n            } else if ((abbr.at(j) > '0') && (abbr.at(j) <= '9')) { //notice that 0 cannot be included\r\n                int start = j;\r\n                while (j < abbr.length() && ((abbr.at(j) >= '0') && (abbr.at(j) <= '9'))) {\r\n                    j++;\r\n                }\r\n                i += atoi(abbr.substr(start, j).c_str());\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return (i == word.length()) && (j == abbr.length());\r\n    }\r\n};"}]},{"id":617,"unique_name":"word-squares","title":"单词矩阵","description":"给出一系列 **不重复的单词**，找出所有用这些单词能构成的 `单词平方`。\n一系列的单词构成了一个有效的单词矩阵, 如果从第 k 行读出来的单词和第 k 列读出来的单词相同(0 <= k < max(numRows, numColumns))，那么就是一个单词平方.\n例如，单词序列为 `[\"ball\",\"area\",\"lead\",\"lady\"]` ,可以构成一个单词矩阵因为对于每一行和每一列读出来的单词都是相同的。\n```\nb a l l\na r e a\nl e a d\nl a d y\n```","solutions":[{"language":"java","code":"public class Solution {\n     class TrieNode {\n        List<String> startWith;\n        TrieNode[] children;\n\n        TrieNode() {\n            startWith = new ArrayList<>();\n            children = new TrieNode[26];\n        }\n    }\n\n    class Trie {\n        TrieNode root;\n\n        Trie(String[] words) {\n            root = new TrieNode();\n            for (String w : words) {\n                TrieNode cur = root;\n                for (char ch : w.toCharArray()) {\n                    int idx = ch - 'a';\n                    if (cur.children[idx] == null)\n                        cur.children[idx] = new TrieNode();\n                    cur.children[idx].startWith.add(w);\n                    cur = cur.children[idx];\n                }\n            }\n        }\n\n        List<String> findByPrefix(String prefix) {\n            List<String> ans = new ArrayList<>();\n            TrieNode cur = root;\n            for (char ch : prefix.toCharArray()) {\n                int idx = ch - 'a';\n                if (cur.children[idx] == null)\n                    return ans;\n\n                cur = cur.children[idx];\n            }\n            ans.addAll(cur.startWith);\n            return ans;\n        }\n    }\n\n    public List<List<String>> wordSquares(String[] words) {\n        List<List<String>> ans = new ArrayList<>();\n        if (words == null || words.length == 0)\n            return ans;\n        int len = words[0].length();\n        Trie trie = new Trie(words);\n        List<String> ansBuilder = new ArrayList<>();\n        for (String w : words) {\n            ansBuilder.add(w);\n            search(len, trie, ans, ansBuilder);\n            ansBuilder.remove(ansBuilder.size() - 1);\n        }\n\n        return ans;\n    }\n\n    private void search(int len, Trie tr, List<List<String>> ans,\n            List<String> ansBuilder) {\n        if (ansBuilder.size() == len) {\n            ans.add(new ArrayList<>(ansBuilder));\n            return;\n        }\n\n        int idx = ansBuilder.size();\n        StringBuilder prefixBuilder = new StringBuilder();\n        for (String s : ansBuilder)\n            prefixBuilder.append(s.charAt(idx));\n        List<String> startWith = tr.findByPrefix(prefixBuilder.toString());\n        for (String sw : startWith) {\n            ansBuilder.add(sw);\n            search(len, tr, ans, ansBuilder);\n            ansBuilder.remove(ansBuilder.size() - 1);\n        }\n    }\n}\n\n// version: 高频题班\npublic class Solution {\n    /**\n     * @param words a set of words without duplicates\n     * @return all word squares\n     */\n    int wordLen;\n    Map<String, List<String>> hash = new HashMap<>();\n    List<String> squares = new ArrayList<>();\n    List<List<String>> ans = new ArrayList<>();\n\n    void initPrefix(String[] words) {\n        for (String item : words) {\n            hash.putIfAbsent(\"\", new ArrayList<>());\n            hash.get(\"\").add(item);\n\n            String pre = \"\";\n            for (char c : item.toCharArray()) {\n                pre += c;\n                hash.putIfAbsent(pre, new ArrayList<>());\n                hash.get(pre).add(item);\n            }\n        }\n    }\n\n    boolean checkPrefix(int l, String nextWord) {\n        for (int j = l + 1; j < wordLen; j++) {\n            String pre = \"\";\n            for (int k = 0; k < l; k++) {\n                pre = pre + squares.get(k).charAt(j);\n            }\n            pre += nextWord.charAt(j);\n            if (!hash.containsKey(pre)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    void dfs(int l) {\n        if (l == wordLen) {\n            ans.add(new ArrayList<>(squares));\n            return;\n        }\n        String pre = \"\";\n        for (int i = 0; i < l; i++)\n            pre += squares.get(i).charAt(l);\n        List<String> w = hash.get(pre);\n\n        for (String item : w) {\n            if (!checkPrefix(l, item)) {\n                continue;\n            }\n            squares.add(item);\n            dfs(l + 1);\n            squares.remove(squares.size() - 1);\n        }\n    }\n\n    public List<List<String>> wordSquares(String[] words) {\n        // Write your code here\n        if (words.length == 0) {\n            return ans;\n        }\n        initPrefix(words);\n        wordLen = words[0].length();\n        dfs(0);\n        return ans;\n    }\n}"},{"language":"cpp","code":"\r\nclass Solution {\r\npublic:\r\n  /**\r\n   * @param words a set of words without duplicates\r\n   * @return all word squares\r\n   */\r\n  int wordLen;\r\n  unordered_map<string, vector<string> > prefix;\r\n  vector<string> squares;\r\n  vector<vector<string> > ans;\r\n  \r\n  void initPrefix(vector<string>& words) {\r\n    for (int i = 0; i < words.size(); i++) {\r\n      string item = words[i];\r\n      prefix[\"\"].push_back(item);\r\n      for (int j = 0; j < item.length(); j++)\r\n        prefix[item.substr(0, j + 1)].push_back(item);\r\n    }\r\n  }\r\n  \r\n  bool checkPrefix(int l, string nextWord) {\r\n    for (int j = l + 1; j < wordLen; j++) {\r\n      string pre;\r\n      for (int k = 0; k < l; k++) { \r\n        pre += squares[k][j];\r\n      } \r\n      pre += nextWord[j];\r\n      if (prefix[pre].size() == 0) {\r\n        return false;\r\n      } \r\n    }\r\n    return true;\r\n  }\r\n  \r\n  void dfs(int l) {\r\n    if (l == wordLen) {\r\n      ans.push_back(squares);\r\n      return;\r\n    }\r\n    string pre;\r\n    for (int i = 0; i < l; i++)\r\n      pre += squares[i][l];\r\n    vector<string> w = prefix[pre];\r\n    \r\n    for (int i = 0; i < w.size(); i++) {\r\n      if (!checkPrefix(l, w[i])) {\r\n        continue;\r\n      } \r\n      squares.push_back(w[i]);\r\n      dfs(l + 1);\r\n      squares.pop_back();\r\n    }\r\n  }\r\n  \r\n  vector<vector<string>> wordSquares(vector<string>& words) {\r\n    // Write your code here\r\n    if (words.size() == 0) {\r\n      return ans;\r\n    }\r\n    initPrefix(words);\r\n    wordLen = words[0].length();\r\n    dfs(0);\r\n    return ans;\r\n  }\r\n};\r\n\r\n//Trie树\r\nclass Solution {\r\npublic:\r\n    struct TrieNode {\r\n        vector<int> indexs;\r\n        vector<TrieNode*> children;\r\n        TrieNode(): children(26, nullptr) {}\r\n    };\r\n    TrieNode* buildTrie(vector<string>& words) {\r\n        TrieNode *root = new TrieNode();\r\n        for (int i = 0; i < words.size(); ++i) {\r\n            TrieNode *t = root;\r\n            for (int j = 0; j < words[i].size(); ++j) {\r\n                if (!t->children[words[i][j] - 'a']) {\r\n                    t->children[words[i][j] - 'a'] = new TrieNode();\r\n                }\r\n                t = t->children[words[i][j] - 'a'];\r\n                t->indexs.push_back(i);\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n    vector<vector<string> > wordSquares(vector<string>& words) {\r\n        TrieNode *root = buildTrie(words);\r\n        vector<vector<string>> res;\r\n        if(words.size() == 0){\r\n            return res;\r\n        }\r\n        vector<string> out(words[0].size());\r\n        for (string word : words) {\r\n            out[0] = word;\r\n            helper(words, 1, root, out, res);\r\n        }\r\n        return res;\r\n    }\r\n    void helper(vector<string>& words, int level, TrieNode* root, vector<string>& out, vector<vector<string>>& res) {\r\n        if (level >= words[0].size()) {\r\n            res.push_back(out);\r\n            return;\r\n        }\r\n        string str = \"\";\r\n        for (int i = 0; i < level; ++i) {\r\n            str += out[i][level];\r\n        }\r\n        TrieNode *t = root;\r\n        for (int i = 0; i < str.size(); ++i) {\r\n            if (!t->children[str[i] - 'a']) return;\r\n            t = t->children[str[i] - 'a'];\r\n        }\r\n        for (int idx : t->indexs) {\r\n            out[level] = words[idx];\r\n            helper(words, level + 1, root, out, res);\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {string[]} words a set of words without duplicates\r\n    # @return {string[][]} all word squares\r\n    def wordSquares(self, words):\r\n        l = len(words)\r\n        if l == 0:\r\n            return []\r\n        trie = self.build_trie(words)\r\n        res = []\r\n        self.dfs(trie, res, [], 0, len(words[0]), '')\r\n        return res\r\n    \r\n    \r\n    def collect_trie(self, trie, res, item):\r\n        if (not trie):\r\n            if (len(item) > 0):\r\n                res.append(item)\r\n            return\r\n            \r\n        for c in trie:\r\n            self.collect_trie(trie[c], res, item + c)\r\n\r\n             \r\n    def add_word(self, trie, word, start):\r\n        if (start == len(word)):\r\n            return\r\n        if (word[start] not in trie):\r\n            trie[word[start]] = {}\r\n        self.add_word(trie[word[start]], word, start + 1)\r\n        \r\n\r\n    def build_trie(self, words):\r\n        trie = {}\r\n        for word in words:\r\n            self.add_word(trie, word, 0)\r\n        return trie\r\n        \r\n    def get_words(self, trie, prefix):\r\n        for c in prefix:\r\n            if c not in trie:\r\n                return []\r\n            trie = trie[c]\r\n        res = []\r\n        self.collect_trie(trie, res, prefix)\r\n        return res\r\n            \r\n\r\n    def dfs(self, trie, res, item, chari, l, prefix):\r\n        cands = self.get_words(trie, prefix)\r\n        for cand in cands:\r\n            if (len(item) == l - 1):\r\n                res.append(list(item + [cand]))\r\n                continue\r\n         \r\n            newprefix = ''.join([word[chari + 1] for word in (item + [cand])])\r\n            self.dfs(trie, res, item + [cand], chari + 1, l, newprefix)\r\n            "}]},{"id":574,"unique_name":"maximum-average-subarray","title":"最大平均值子数组","description":"给出一个整数数组，有正有负。找到这样一个子数组，他的长度大于等于 `k`，且平均值最大。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums an array with positive and negative numbers\r\n     * @param k an integer\r\n     * @return the maximum average\r\n     */\r\n    public double maxAverage(int[] nums, int k) {\r\n        // Write your code here\r\n        double l = Integer.MAX_VALUE, r = Integer.MIN_VALUE;\r\n        for (int i = 0; i < nums.length; ++i) {\r\n            if (nums[i] < l)\r\n                l = nums[i];\r\n            if (nums[i] > r)\r\n                r = nums[i];\r\n        }\r\n        \r\n       \r\n        while (r - l >= 1e-6) {\r\n            double mid = (l + r) / 2.0;\r\n\r\n            if (check_valid(nums, mid, k)) {\r\n                l = mid;\r\n            }\r\n            else {\r\n                r = mid;\r\n            }\r\n        }\r\n\r\n        return l;\r\n    }\r\n    \r\n    private boolean check_valid(int nums[], double mid, int k) {\r\n        int n = nums.length;\r\n        double min_pre = 0;\r\n        double[] sum = new double[n + 1];\r\n        sum[0] = 0; \r\n        for (int i = 1; i <= n; ++i) {\r\n            sum[i] = sum[i - 1] + nums[i - 1] - mid;\r\n            if (i >= k && sum[i] - min_pre >= 0) {\r\n                return true;\r\n            }\r\n            if (i >= k)\r\n                min_pre = Math.min(min_pre, sum[i - k + 1]);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums an array with positive and negative numbers\r\n     * @param k an integer\r\n     * @return the maximum average\r\n     */\r\n    double maxAverage(vector<int>& nums, int k) {\r\n        // Write your code here\r\n        double l = 2147483647, r = -2147483648;\r\n        int n = nums.size();\r\n        for (int i = 0; i < n; ++i) {\r\n            if (nums[i] < l)\r\n                l = nums[i];\r\n            if (nums[i] > r)\r\n                r = nums[i];\r\n        }\r\n\r\n        double sum[1000000] = {0};\r\n        sum[0] = 0;\r\n        while (r - l >= 1e-6) {\r\n            double mid = (l + r) / 2.0;\r\n\r\n            double min_pre = 0;\r\n            bool check = false;\r\n            for (int i = 1; i <= n; ++i) {\r\n                sum[i] = sum[i - 1] + nums[i - 1] - mid;\r\n                if (i >= k && sum[i] - min_pre >= 0) {\r\n                    check = true;\r\n                    break;\r\n                }\r\n                if (i >= k)\r\n                    min_pre = min(min_pre, sum[i - k + 1]);\r\n            }\r\n            if (check)\r\n                l = mid;\r\n            else\r\n                r = mid;\r\n        }\r\n\r\n        return l;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums an array with positive and negative numbers\r\n    # @param {int} k an integer\r\n    # @return {double} the maximum average\r\n    def maxAverage(self, nums, k):\r\n        # Write your code here\r\n        l, r = min(nums), max(nums)\r\n        n = len(nums)\r\n        prefix = [0] * (n + 1)\r\n        while r - l >= 1e-6:\r\n            mid, check = (l + r) / 2.0, False\r\n            min_pre = 0\r\n            for i in xrange(1, n + 1):\r\n                prefix[i] = prefix[i - 1] + nums[i - 1] - mid;\r\n                if i >= k and prefix[i] >= min_pre:\r\n                    check = True\r\n                    break\r\n                if i >= k:\r\n                    min_pre = min(min_pre, prefix[i - k + 1])\r\n\r\n            if check:\r\n                l = mid\r\n            else:\r\n                r = mid\r\n        return l"}]},{"id":596,"unique_name":"sequence-reconstruction","title":"序列重构","description":"判断是否序列 `org` 能唯一地由 `seqs`重构得出. `org`是一个由从1到n的正整数排列而成的序列，1 ≤ n ≤ 10^4。 重构表示组合成`seqs`的一个最短的父序列 (意思是，一个最短的序列使得所有 `seqs`里的序列都是它的子序列). \r\n判断是否有且仅有一个能从 `seqs`重构出来的序列，并且这个序列是`org`。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param org a permutation of the integers from 1 to n\r\n     * @param seqs a list of sequences\r\n     * @return true if it can be reconstructed only one or false\r\n     */\r\n    public boolean sequenceReconstruction(int[] org, int[][] seqs) {\r\n        // Write your code here\r\n        Map<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();\r\n        Map<Integer, Integer> indegree = new HashMap<Integer, Integer>();\r\n\t\t\r\n        for (int num : org) {\r\n            map.put(num, new HashSet<Integer>());\r\n            indegree.put(num, 0);\r\n        }\r\n\r\n        int n = org.length;\r\n        int count = 0;\r\n        for (int[] seq : seqs) {\r\n            count += seq.length;\r\n            if (seq.length >= 1 && (seq[0] <= 0 || seq[0] > n))\r\n                return false;\r\n            for (int i = 1; i < seq.length; i++) {\r\n                if (seq[i] <= 0 || seq[i] > n)\r\n                    return false;\r\n                if (map.get(seq[i - 1]).add(seq[i]))\r\n                    indegree.put(seq[i], indegree.get(seq[i]) + 1);\r\n            }\r\n        }\r\n\r\n        // case: [1], []\r\n        if (count < n)\r\n            return false;\r\n\t\t\r\n        Queue<Integer> q = new ArrayDeque<Integer>();\r\n        for (int key : indegree.keySet()) \r\n            if (indegree.get(key) == 0)\r\n                q.add(key);\r\n\t\t\r\n        int cnt = 0;\r\n        while (q.size() == 1) {\r\n            int ele = q.poll();\r\n            for (int next : map.get(ele)) {\r\n                indegree.put(next, indegree.get(next) - 1);\r\n                if (indegree.get(next) == 0) q.add(next);\r\n            }\r\n            if (ele != org[cnt]) {\r\n                return false;\r\n            }\r\n            cnt++;\r\n        }\r\n\t\t\r\n        return cnt == org.length;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param org a permutation of the integers from 1 to n\r\n     * @param seqs a list of sequences\r\n     * @return true if it can be reconstructed only one or false\r\n     */\r\n    bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {\r\n        // Write your code here\r\n        unordered_map<int, int> pos, pre;\r\n        for (int i = 0; i < org.size(); ++i) pos[org[i]] = i;\r\n        for (auto& seq : seqs) {\r\n            for (int i = 0; i < seq.size(); ++i) {\r\n                if (pos.find(seq[i]) == pos.end()) {\r\n                    return false;\r\n                }\r\n                if (i > 0 && pos[seq[i - 1]] >= pos[seq[i]]) {\r\n                    return false;\r\n                }\r\n                if (pre.find(seq[i]) == pre.end()) {\r\n                    pre[seq[i]] = (i > 0) ? pos[seq[i - 1]] : -1;\r\n                } else {\r\n                    pre[seq[i]] = max(pre[seq[i]], (i > 0) ? pos[seq[i - 1]] : -1);\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < org.size(); ++i) {\r\n            if (pre[org[i]] != i - 1) \r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} org a permutation of the integers from 1 to n\r\n    # @param {int[][]} seqs a list of sequences\r\n    # @return {boolean} true if it can be reconstructed only one or false\r\n    def sequenceReconstruction(self, org, seqs):\r\n        # Write your code here\r\n        from collections import defaultdict\r\n        edges = defaultdict(list)\r\n        indegrees = defaultdict(int)\r\n        nodes = set()\r\n        for seq in seqs:\r\n            nodes |= set(seq)\r\n            for i in xrange(len(seq)):\r\n                if i == 0:\r\n                    indegrees[seq[i]] += 0\r\n                if i < len(seq) - 1:\r\n                    edges[seq[i]].append(seq[i + 1])\r\n                    indegrees[seq[i + 1]] += 1\r\n\r\n        cur = [k for k in indegrees if indegrees[k] == 0]\r\n        res = []\r\n\r\n        while len(cur) == 1:\r\n            cur_node = cur.pop()\r\n            res.append(cur_node)\r\n            for node in edges[cur_node]:\r\n                indegrees[node] -= 1\r\n                if indegrees[node] == 0:\r\n                    cur.append(node)\r\n        if len(cur) > 1:\r\n            return False\r\n        return len(res) == len(nodes) and res == org"}]},{"id":599,"unique_name":"flatten-2d-vector","title":"摊平二维向量","description":"设计一个迭代器来实现摊平二维向量的功能","solutions":[{"language":"java","code":"public class Vector2D implements Iterator<Integer> {\n    Stack<List<Integer>> stack = new Stack<>();\n    Stack<Integer> stackj;\n    \n    void pushListListToStack(List<List<Integer>> vec2d) {\n    Stack<List<Integer>> temp = new Stack<>();\n        for (List<Integer> nested : vec2d) {\n            temp.push(nested);\n        }\n        \n        while (!temp.isEmpty()) {\n            stack.push(temp.pop());\n        }\n    }\n    \n    void pushListToStack(List<Integer> vec) {\n    Stack<Integer> temp = new Stack<>();\n        for (Integer nested : vec) {\n            temp.push(nested);\n        }\n        \n        while (!temp.isEmpty()) {\n            stackj.push(temp.pop());\n        }\n    }\n    \n    public Vector2D(List<List<Integer>> vec2d) {\n        pushListListToStack(vec2d);\n        // Initialize your data structure here\n        stackj = new Stack<>();\n    }\n\n    public Integer next() {\n        // Write your code here\n        if(!hasNext()) {\n            return null;\n        }\n        return stackj.pop();\n    }\n\n    public boolean hasNext() { // 准备下一个元素\n        // Write your code here\n        while (stackj.isEmpty() && !stack.isEmpty())\n            pushListToStack(stack.pop());\n        return !stackj.isEmpty();\n    }\n    \n    public void remove() {}\n}"},{"language":"cpp","code":"class Vector2D {\r\npublic:\r\n    Vector2D(vector<vector<int>>& vec2d) {\r\n        // Initialize your data structure here\r\n        begin = vec2d.begin();\r\n        end = vec2d.end();\r\n        pos = 0;\r\n    }\r\n\r\n    int next() {\r\n        // Write your code here\r\n        hasNext();\r\n        return (*begin)[pos++];\r\n    }\r\n\r\n    bool hasNext() {\r\n        // Write your code here\r\n        while (begin != end && pos == (*begin).size())\r\n            begin++, pos = 0;\r\n        return begin != end;\r\n    }\r\n\r\nprivate:\r\n    vector<vector<int>>::iterator begin, end;\r\n    int pos;\r\n};\r\n\r\n/**\r\n * Your Vector2D object will be instantiated and called as such:\r\n * Vector2D i(vec2d);\r\n * while (i.hasNext()) cout << i.next();\r\n */"},{"language":"python","code":"class Vector2D(object):\r\n\r\n    # @param vec2d {List[List[int]]}\r\n    def __init__(self, vec2d):\r\n        # Initialize your data structure here\r\n        self.row, self.col, self.vec2d = 0, 0, vec2d\r\n        \r\n\r\n    # @return {int} a next element\r\n    def next(self):\r\n        # Write your code here\r\n        self.col += 1\r\n        return self.vec2d[self.row][self.col - 1]\r\n        \r\n\r\n    # @return {boolean} true if it has next element\r\n    # or false\r\n    def hasNext(self):\r\n        # Write your code here\r\n        while self.row < len(self.vec2d) and \\\r\n            self.col >= len(self.vec2d[self.row]):\r\n            self.row, self.col = self.row + 1, 0\r\n        return self.row < len(self.vec2d)\r\n        \r\n\r\n# Your Vector2D object will be instantiated and called as such:\r\n# i, v = Vector2D(vec2d), []\r\n# while i.hasNext(): v.append(i.next())"}]},{"id":600,"unique_name":"smallest-rectangle-enclosing-black-pixels","title":"包裹黑色像素点的最小矩形","description":"一个由二进制矩阵表示的图，`0` 表示白色像素点，`1` 表示黑色像素点。黑色像素点是联通的，即只有一块黑色区域。像素是水平和竖直连接的，给一个黑色像素点的坐标 `(x, y)` ，返回囊括所有黑色像素点的矩阵的最小面积。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param image a binary matrix with '0' and '1'\r\n     * @param x, y the location of one of the black pixels\r\n     * @return an integer\r\n     */\r\n    public int minArea(char[][] image, int x, int y) {\r\n        if (image == null || image.length == 0 || image[0].length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int n = image.length;\r\n        int m = image[0].length;\r\n        \r\n        int left = findLeft(image, 0, y);\r\n        int right = findRight(image, y, m - 1);\r\n        int top = findTop(image, 0, x);\r\n        int bottom = findBottom(image, x, n - 1);\r\n\r\n        return (right - left + 1) * (bottom - top + 1);\r\n    }\r\n    \r\n    private int findLeft(char[][] image, int start, int end) {\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (isEmptyColumn(image, mid)) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (isEmptyColumn(image, start)) {\r\n            return end;\r\n        }\r\n        \r\n        return start;\r\n    }\r\n    \r\n    private int findRight(char[][] image, int start, int end) {\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (isEmptyColumn(image, mid)) {\r\n                end = mid;\r\n            } else {\r\n                start = mid;\r\n            }\r\n        }\r\n        \r\n        if (isEmptyColumn(image, end)) {\r\n            return start;\r\n        }\r\n        \r\n        return end;\r\n    }\r\n    \r\n    private int findTop(char[][] image, int start, int end) {\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (isEmptyRow(image, mid)) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (isEmptyRow(image, start)) {\r\n            return end;\r\n        }\r\n        \r\n        return start;\r\n    }\r\n    \r\n    private int findBottom(char[][] image, int start, int end) {\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (isEmptyRow(image, mid)) {\r\n                end = mid;\r\n            } else {\r\n                start = mid;\r\n            }\r\n        }\r\n        \r\n        if (isEmptyRow(image, end)) {\r\n            return start;\r\n        }\r\n        \r\n        return end;\r\n    }\r\n    \r\n    private boolean isEmptyColumn(char[][] image, int col) {\r\n        for (int i = 0; i < image.length; i++) {\r\n            if (image[i][col] == '1') {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    private boolean isEmptyRow(char[][] image, int row) {\r\n        for (int j = 0; j < image[0].length; j++) {\r\n            if (image[row][j] == '1') {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param image a binary matrix with '0' and '1'\r\n     * @param x, y the location of one of the black pixels\r\n     * @return an integer\r\n     */\r\n    int minArea(vector<vector<char>>& image, int x, int y) {\r\n        // Write your code here\r\n        int m = image.size();\r\n        if (m == 0)\r\n            return 0;\r\n        int n = image[0].size();\r\n        if (n == 0)\r\n            return 0;\r\n\r\n        int start = y;\r\n        int end = n - 1;\r\n        int mid;\r\n        while (start < end) {\r\n            mid = start + (end - start) / 2 + 1;\r\n            if (checkColumn(image, mid)) {\r\n                start = mid;\r\n            } else {\r\n                end = mid - 1;\r\n            }\r\n        }\r\n        int right = start;\r\n        \r\n        start = 0;\r\n        end = y;\r\n        while (start < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (checkColumn(image, mid)) {\r\n                end = mid;\r\n            } else {\r\n                start = mid + 1;\r\n            }\r\n        }\r\n        int left = start;\r\n        \r\n        start = x;\r\n        end = m - 1;\r\n        while (start < end) {\r\n            mid = start + (end - start) / 2 + 1;\r\n            if (checkRow(image, mid)) {\r\n                start = mid;\r\n            } else {\r\n                end = mid - 1;\r\n            }\r\n        }\r\n        int down = start;\r\n        \r\n        start = 0;\r\n        end = x;\r\n        while (start < end) {\r\n            mid = start + (end - start) / 2;\r\n            if (checkRow(image, mid)) {\r\n                end = mid;\r\n            } else {\r\n                start = mid + 1;\r\n            }\r\n        }\r\n        int up = start;\r\n        \r\n        return (right - left + 1) * (down - up + 1);\r\n    }\r\n    \r\n    bool checkColumn(vector<vector<char>>& image, int col) {\r\n        for (int i = 0; i < image.size(); i++) {\r\n            if (image[i][col] == '1') {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    bool checkRow(vector<vector<char>>& image, int row) {\r\n        for (int j = 0; j < image[0].size(); j++) {\r\n            if (image[row][j] == '1') {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    # @param image {List[List[str]]}  a binary matrix with '0' and '1'\r\n    # @param x, y {int} the location of one of the black pixels\r\n    # @return an integer\r\n    def minArea(self, image, x, y):\r\n        # Write your code here\r\n        m = len(image)\r\n        if m == 0:\r\n            return 0\r\n        n = len(image[0])\r\n        if n == 0:\r\n            return 0\r\n\r\n        start = y\r\n        end = n - 1\r\n        while start < end:\r\n            mid = start + (end - start) / 2 + 1\r\n            if self.checkColumn(image, mid):\r\n                start = mid\r\n            else:\r\n                end = mid - 1\r\n\r\n        right = start\r\n\r\n        start = 0\r\n        end = y\r\n        while start < end:\r\n            mid = start + (end - start) / 2\r\n            if self.checkColumn(image, mid):\r\n                end = mid\r\n            else:\r\n                start = mid + 1\r\n\r\n        left = start\r\n        \r\n        start = x\r\n        end = m - 1\r\n        while start < end:\r\n            mid = start + (end - start) / 2 + 1\r\n            if self.checkRow(image, mid):\r\n                start = mid\r\n            else:\r\n                end = mid - 1\r\n\r\n        down = start\r\n        \r\n        start = 0\r\n        end = x\r\n        while start < end:\r\n            mid = start + (end - start) / 2\r\n            if self.checkRow(image, mid):\r\n                end = mid\r\n            else:\r\n                start = mid + 1\r\n\r\n        up = start\r\n        \r\n        return (right - left + 1) * (down - up + 1)\r\n\r\n    def checkColumn(self, image, col):\r\n        for i in xrange(len(image)):\r\n            if image[i][col] == '1':\r\n                return True\r\n        return False\r\n\r\n    def checkRow(self, image, row):\r\n        for j in xrange(len(image[0])):\r\n            if image[row][j] == '1':\r\n                return True\r\n        return False"}]},{"id":572,"unique_name":"binary-tree-longest-consecutive-sequence","title":"二叉树最长连续序列","description":"给一棵二叉树，找到最长连续路径的长度。\n这条路径是指 任何的节点序列中的起始节点到树中的任一节点都必须遵循 父-子 联系。最长的连续路径必须是从父亲节点到孩子节点（`不能逆序`）。\n","solutions":[{"language":"java","code":"// version 1: Traverse + Divide Conquer\r\npublic class Solution {\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the length of the longest consecutive sequence path\r\n     */\r\n    public int longestConsecutive(TreeNode root) {\r\n        return helper(root, null, 0);\r\n    }\r\n    \r\n    private int helper(TreeNode root, TreeNode parent, int lengthWithoutRoot) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        int length = (parent != null && parent.val + 1 == root.val)\r\n            ? lengthWithoutRoot + 1\r\n            : 1;\r\n        int left = helper(root.left, root, length);\r\n        int right = helper(root.right, root, length);\r\n        return Math.max(length, Math.max(left, right));\r\n    }\r\n}\r\n\r\n// version 2: Another Traverse + Divide Conquer \r\npublic class Solution {\r\n    private int longest;\r\n    \r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the length of the longest consecutive sequence path\r\n     */\r\n    public int longestConsecutive(TreeNode root) {\r\n        longest = 0;\r\n        helper(root);\r\n        return longest;\r\n    }\r\n    \r\n    private int helper(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        int left = helper(root.left);\r\n        int right = helper(root.right);\r\n        \r\n        int subtreeLongest = 1; // at least we have root\r\n        if (root.left != null && root.val + 1 == root.left.val) {\r\n            subtreeLongest = Math.max(subtreeLongest, left + 1);\r\n        }\r\n        if (root.right != null && root.val + 1 == root.right.val) {\r\n            subtreeLongest = Math.max(subtreeLongest, right + 1);\r\n        }\r\n        \r\n        if (subtreeLongest > longest) {\r\n            longest = subtreeLongest;\r\n        }\r\n        return subtreeLongest;\r\n    }\r\n}\r\n\r\n// version 3: Divide Conquer\r\npublic class Solution {\r\n    private class ResultType {\r\n        int maxInSubtree;\r\n        int maxFromRoot;\r\n        public ResultType(int maxInSubtree, int maxFromRoot) {\r\n            this.maxInSubtree = maxInSubtree;\r\n            this.maxFromRoot = maxFromRoot;\r\n        }\r\n    }\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the length of the longest consecutive sequence path\r\n     */\r\n    public int longestConsecutive(TreeNode root) {\r\n        return helper(root).maxInSubtree;\r\n    }\r\n    \r\n    private ResultType helper(TreeNode root) {\r\n        if (root == null) {\r\n            return new ResultType(0, 0);\r\n        }\r\n        \r\n        ResultType left = helper(root.left);\r\n        ResultType right = helper(root.right);\r\n        \r\n        // 1 is the root itself.\r\n        ResultType result = new ResultType(0, 1);\r\n        \r\n        if (root.left != null && root.val + 1 == root.left.val) {\r\n            result.maxFromRoot = Math.max(\r\n                result.maxFromRoot,\r\n                left.maxFromRoot + 1\r\n            );\r\n        }\r\n        \r\n        if (root.right != null && root.val + 1 == root.right.val) {\r\n            result.maxFromRoot = Math.max(\r\n                result.maxFromRoot,\r\n                right.maxFromRoot + 1\r\n            );\r\n        }\r\n        \r\n        result.maxInSubtree = Math.max(\r\n            result.maxFromRoot,\r\n            Math.max(left.maxInSubtree, right.maxInSubtree)\r\n        );\r\n        \r\n        return result;\r\n    }\r\n}"}]},{"id":513,"unique_name":"build-post-office-ii","title":"邮局的建立 II","description":"给出一个二维的网格，每一格可以代表墙 `2` ，房子 `1`，以及空 `0` (用数字0,1,2来表示)，在网格中找到一个位置去建立邮局，使得所有的房子到邮局的距离和是最小的。\n返回所有房子到邮局的最小距离和，如果没有地方建立邮局，则返回`-1`.","solutions":[{"language":"java","code":"class Coordinate {\r\n    int x, y;\r\n    public Coordinate(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    public int EMPTY = 0;\r\n    public int HOUSE = 1;\r\n    public int WALL = 2;\r\n    public int[][] grid;\r\n    public int n, m;\r\n    public int[] deltaX = {0, 1, -1, 0};\r\n    public int[] deltaY = {1, 0, 0, -1};\r\n    \r\n    private List<Coordinate> getCoordinates(int type) {\r\n        List<Coordinate> coordinates = new ArrayList<>();\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                if (grid[i][j] == type) {\r\n                    coordinates.add(new Coordinate(i, j));\r\n                }\r\n            }\r\n        }\r\n        \r\n        return coordinates;\r\n    }\r\n    \r\n    private void setGrid(int[][] grid) {\r\n        n = grid.length;\r\n        m = grid[0].length;\r\n        this.grid = grid;\r\n    }\r\n    \r\n    private boolean inBound(Coordinate coor) {\r\n        if (coor.x < 0 || coor.x >= n) {\r\n            return false;\r\n        }\r\n        if (coor.y < 0 || coor.y >= m) {\r\n            return false;\r\n        }\r\n        return grid[coor.x][coor.y] == EMPTY;\r\n    }\r\n\r\n    /**\r\n     * @param grid a 2D grid\r\n     * @return an integer\r\n     */\r\n    public int shortestDistance(int[][] grid) {\r\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        // set n, m, grid\r\n        setGrid(grid);\r\n        \r\n        List<Coordinate> houses = getCoordinates(HOUSE);\r\n        int[][] distanceSum = new int[n][m];;\r\n        int[][] visitedTimes = new int[n][m];;\r\n        for (Coordinate house : houses) {\r\n            bfs(house, distanceSum, visitedTimes);\r\n        }\r\n        \r\n        int shortest = Integer.MAX_VALUE;\r\n        List<Coordinate> empties = getCoordinates(EMPTY);\r\n        for (Coordinate empty : empties) {\r\n            if (visitedTimes[empty.x][empty.y] != houses.size()) {\r\n                continue;\r\n            }\r\n            \r\n            shortest = Math.min(shortest, distanceSum[empty.x][empty.y]);\r\n        }\r\n        \r\n        if (shortest == Integer.MAX_VALUE) {\r\n            return -1;\r\n        }\r\n        return shortest;\r\n    }\r\n    \r\n    private void bfs(Coordinate start,\r\n                     int[][] distanceSum,\r\n                     int[][] visitedTimes) {\r\n        Queue<Coordinate> queue = new LinkedList<>();\r\n        boolean[][] hash = new boolean[n][m];\r\n        \r\n        queue.offer(start);\r\n        hash[start.x][start.y] = true;\r\n        \r\n        int steps = 0;\r\n        while (!queue.isEmpty()) {\r\n            steps++;\r\n            int size = queue.size();\r\n            for (int temp = 0; temp < size; temp++) {\r\n                Coordinate coor = queue.poll();\r\n                for (int i = 0; i < 4; i++) {\r\n                    Coordinate adj = new Coordinate(\r\n                        coor.x + deltaX[i],\r\n                        coor.y + deltaY[i]\r\n                    );\r\n                    if (!inBound(adj)) {\r\n                        continue;\r\n                    }\r\n                    if (hash[adj.x][adj.y]) {\r\n                        continue;\r\n                    }\r\n                    queue.offer(adj);\r\n                    hash[adj.x][adj.y] = true;\r\n                    distanceSum[adj.x][adj.y] += steps;\r\n                    visitedTimes[adj.x][adj.y]++;\r\n                } // direction\r\n            } // for temp\r\n        } // while\r\n    }\r\n}"},{"language":"cpp","code":"class node {\r\npublic:\r\n    \r\n    node(){}\r\n    node(int xx, int yy, int dist) {\r\n        x = xx;\r\n        y = yy;\r\n        dis = dist;\r\n    }\r\n    int x, y, dis;\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param grid a 2D grid\r\n     * @return an integer\r\n     */\r\n    int dx[4] = {1,0,-1,0};\r\n    int dy[4] = {0,1,0,-1};\r\n    \r\n    bool valid(int nx, int ny, int n, int m, vector<vector<int>>& grid, vector<vector<bool>>& flag) {\r\n        if(0 <= nx && nx < n && 0 <= ny && ny < m) {\r\n            if(grid[nx][ny] == 0 && flag[nx][ny] == false) {\r\n                return  true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    void bfs(node now, vector<vector<int>>& grid, vector<vector<int>>& dis, vector<vector<int>>& visit_num, int n, int m) {\r\n        queue<node> q;\r\n        q.push(now);\r\n        vector<vector<bool> > flag(n, vector<bool>(m)) ;\r\n        \r\n        \r\n        while(!q.empty()) {\r\n            now = q.front();\r\n            q.pop();\r\n            visit_num[now.x][now.y]++;\r\n        \r\n            for(int i = 0; i < 4; i++) {\r\n                int nx = now.x + dx[i];\r\n                int ny = now.y + dy[i];\r\n                if (valid(nx, ny, n, m, grid, flag)) {\r\n                    dis[nx][ny] = dis[nx][ny] + now.dis + 1;\r\n                    flag[nx][ny] = true;\r\n                    q.push(node(nx, ny, now.dis+1));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int shortestDistance(vector<vector<int>>& grid) {\r\n        // Write your code here\r\n        if(grid.size() == 0)\r\n            return 0;\r\n        int n = grid.size();\r\n        int m = grid[0].size();\r\n        vector<vector<int>> dis(n, vector<int>(m, 0));\r\n        vector<vector<int> > visit_num(n, vector<int>(m)) ;\r\n        \r\n        int house_num = 0;\r\n        for (int i = 0; i < grid.size(); i++) {\r\n            for (int j = 0; j < grid[i].size(); j++) \r\n            if (grid[i][j] == 1) {\r\n                house_num++;\r\n                bfs(node(i,j,0), grid, dis, visit_num, n, m);\r\n            }\r\n        }\r\n        \r\n        int ans = INT_MAX;\r\n        for (int i = 0; i < grid.size(); i++) {\r\n            for(int j = 0; j < grid[i].size(); j++) \r\n            if (grid[i][j] == 0 && visit_num[i][j] == house_num){\r\n                ans = min(ans, dis[i][j]);\r\n            }\r\n        }\r\n        \r\n        return ans == INT_MAX ? -1 : ans;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[][]} grid a 2D grid\r\n    # @return {int} an integer\r\n    def shortestDistance(self, grid):\r\n        # Write your code here\r\n        if not grid:\r\n            return 0\r\n        m = len(grid)\r\n        n = len(grid[0])\r\n        \r\n        dist = [[sys.maxint for j in range(n)] for i in range(m)]\r\n        reachable_count = [[0 for j in range(n)] for i in range(m)]\r\n        min_dist = sys.maxint\r\n        \r\n        buildings = 0\r\n        \r\n        for i in range(m):\r\n            for j in range(n):\r\n                if grid[i][j] == 1:\r\n                    self.bfs(grid, i, j, dist, m, n, reachable_count)\r\n                    buildings += 1\r\n  \r\n        for i in range(m):\r\n            for j in range(n):\r\n                if reachable_count[i][j] == buildings and dist[i][j] < min_dist:\r\n                    min_dist = dist[i][j]\r\n        return min_dist if min_dist != sys.maxint else -1\r\n        \r\n    def bfs(self, grid, i, j, dist, m, n, reachable_count):\r\n        visited = [[False for y in range(n)] for x in range(m)]\r\n        visited[i][j] = True\r\n        q = collections.deque([(i,j, 0)])\r\n        \r\n        while q:\r\n            i, j, l = q.popleft()\r\n            if dist[i][j] == sys.maxint:\r\n                dist[i][j] = 0\r\n            dist[i][j] += l\r\n\r\n            for x, y in ((1, 0), (-1, 0), (0, 1), (0, -1)):\r\n                nx, ny = i+x, j+y\r\n\r\n                if nx > -1 and nx < m and ny > -1 and ny < n and not visited[nx][ny]:\r\n                    visited[nx][ny] = True\r\n                    if grid[nx][ny] == 0:\r\n                        q.append((nx, ny, l+1))\r\n                        reachable_count[nx][ny] += 1 "}]},{"id":454,"unique_name":"super-ugly-number","title":"超级丑数","description":"写一个程序来找第 *n* 个超级丑数。\r\n\r\n超级丑数的定义是正整数并且所有的质数因子都在所给定的一个大小为 *k* 的质数集合内。\r\n\r\n比如给你 4 个质数的集合 `[2, 7, 13, 19]`, 那么 `[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]` 是前 12 个超级丑数。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n a positive integer\r\n     * @param primes the given prime list\r\n     * @return the nth super ugly number\r\n     */\r\n    public int nthSuperUglyNumber(int n, int[] primes) {\r\n        int[] times = new int[primes.length];\r\n        int[] uglys = new int[n];\r\n        uglys[0] = 1;\r\n\r\n        for (int i = 1; i < n; i++) {\r\n            int min = Integer.MAX_VALUE;\r\n            for (int j = 0; j < primes.length; j++) {\r\n                min = Math.min(min, primes[j] * uglys[times[j]]);\r\n            }\r\n            uglys[i] = min;\r\n\r\n            for (int j = 0; j < times.length; j++) {\r\n                if (uglys[times[j]] * primes[j] == min) {\r\n                    times[j]++;\r\n                }\r\n            }\r\n        }\r\n        return uglys[n - 1];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n a positive integer\r\n     * @param primes the given prime list\r\n     * @return the nth super ugly number\r\n     */\r\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\r\n        int len = primes.size();  \r\n        vector<int> times(len, 0);  \r\n        vector<int> uglys(n, INT_MAX);  \r\n        uglys[0] = 1;  \r\n        for (int i = 1; i < n; ++i) {  \r\n            for (int j = 0; j < len; ++j)  \r\n               uglys[i] = min(uglys[i],uglys[times[j]] * primes[j]);\r\n  \r\n            for(int j = 0; j < len; ++j)  \r\n                if (uglys[i] == uglys[times[j]] * primes[j]) {  \r\n                    ++times[j];  \r\n                }\r\n        }\r\n        return uglys[n-1];\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n a positive integer\r\n    # @param {int[]} primes the given prime list\r\n    # @return {int} the nth super ugly number\r\n    def nthSuperUglyNumber(self, n, primes):\r\n        import heapq\r\n        length = len(primes)\r\n        times = [0] * length\r\n        uglys = [1]\r\n        minlist = [(primes[i] * uglys[times[i]], i) for i in xrange(len(times))]\r\n        heapq.heapify(minlist)\r\n\r\n        while len(uglys) < n:\r\n            (umin, min_times) = heapq.heappop(minlist)\r\n            times[min_times] += 1\r\n            if umin != uglys[-1]:\r\n                uglys.append(umin)\r\n            heapq.heappush(minlist, (primes[min_times] * uglys[times[min_times]], min_times))\r\n\r\n        return uglys[-1] \r\n"}]},{"id":248,"unique_name":"building-outline","title":"大楼轮廓","description":"水平面上有 *N* 座大楼，每座大楼都是矩阵的形状，可以用一个三元组表示 `(start, end, height)`，分别代表其在x轴上的起点，终点和高度。大楼之间从远处看可能会重叠，求出 *N* 座大楼的外轮廓线。\n\n外轮廓线的表示方法为若干三元组，每个三元组包含三个数字 (start, end, height)，代表这段轮廓的起始位置，终止位置和高度。\n\n![](https://lintcode-media.s3.amazonaws.com/problem/jiuzhang3.jpg)\n","solutions":[{"language":"java","code":"import java.util.*;\n\npublic class Solution {\n\n  class HashHeap {\n    ArrayList<Integer> heap;\n    String mode;\n    int size_t;\n    HashMap<Integer, Node> hash;\n\n    class Node {\n      public Integer id;\n      public Integer num;\n\n      Node(Node now) {\n        id = now.id;\n        num = now.num;\n      }\n\n      Node(Integer first, Integer second) {\n\n        this.id = first;\n        this.num = second;\n      }\n    }\n\n    public HashHeap(String mod) {\n      // TODO Auto-generated constructor stub\n      heap = new ArrayList<Integer>();\n      mode = mod;\n      hash = new HashMap<Integer, Node>();\n      size_t = 0;\n    }\n\n    public int peek() {\n      return heap.get(0);\n    }\n\n    public int size() {\n      return size_t;\n    }\n\n    public Boolean isEmpty() {\n      return (heap.size() == 0);\n    }\n\n    int parent(int id) {\n      if (id == 0) {\n        return -1;\n      }\n      return (id - 1) / 2;\n    }\n\n    int lson(int id) {\n      return id * 2 + 1;\n    }\n\n    int rson(int id) {\n      return id * 2 + 2;\n    }\n\n    boolean comparesmall(int a, int b) {\n      if (a <= b) {\n        if (mode == \"min\")\n          return true;\n        else\n          return false;\n      } else {\n        if (mode == \"min\")\n          return false;\n        else\n          return true;\n      }\n\n    }\n\n    void swap(int idA, int idB) {\n      int valA = heap.get(idA);\n      int valB = heap.get(idB);\n\n      int numA = hash.get(valA).num;\n      int numB = hash.get(valB).num;\n      hash.put(valB, new Node(idA, numB));\n      hash.put(valA, new Node(idB, numA));\n      heap.set(idA, valB);\n      heap.set(idB, valA);\n    }\n\n    public Integer poll() {\n      size_t--;\n      Integer now = heap.get(0);\n      Node hashnow = hash.get(now);\n      if (hashnow.num == 1) {\n        swap(0, heap.size() - 1);\n        hash.remove(now);\n        heap.remove(heap.size() - 1);\n        if (heap.size() > 0) {\n          siftdown(0);\n        }\n      } else {\n        hash.put(now, new Node(0, hashnow.num - 1));\n      }\n      return now;\n    }\n\n    public void add(int now) {\n      size_t++;\n      if (hash.containsKey(now)) {\n        Node hashnow = hash.get(now);\n        hash.put(now, new Node(hashnow.id, hashnow.num + 1));\n\n      } else {\n        heap.add(now);\n        hash.put(now, new Node(heap.size() - 1, 1));\n      }\n\n      siftup(heap.size() - 1);\n    }\n\n    public void delete(int now) {\n      size_t--;\n      Node hashnow = hash.get(now);\n      int id = hashnow.id;\n      int num = hashnow.num;\n      if (hashnow.num == 1) {\n\n        swap(id, heap.size() - 1);\n        hash.remove(now);\n        heap.remove(heap.size() - 1);\n        if (heap.size() > id) {\n          siftup(id);\n          siftdown(id);\n        }\n      } else {\n        hash.put(now, new Node(id, num - 1));\n      }\n    }\n\n    void siftup(int id) {\n      while (parent(id) > -1) {\n        int parentId = parent(id);\n        if (comparesmall(heap.get(parentId), heap.get(id)) == true) {\n          break;\n        } else {\n          swap(id, parentId);\n        }\n        id = parentId;\n      }\n    }\n\n    void siftdown(int id) {\n      while (lson(id) < heap.size()) {\n        int leftId = lson(id);\n        int rightId = rson(id);\n        int son;\n        if (rightId >= heap.size()\n            || (comparesmall(heap.get(leftId), heap.get(rightId)) == true)) {\n          son = leftId;\n        } else {\n          son = rightId;\n        }\n        if (comparesmall(heap.get(id), heap.get(son)) == true) {\n          break;\n        } else {\n          swap(id, son);\n        }\n        id = son;\n      }\n    }\n  }\n\n  class Edge {\n    int pos;\n    int height;\n    boolean isStart;\n\n    public Edge(int pos, int height, boolean isStart) {\n      this.pos = pos;\n      this.height = height;\n      this.isStart = isStart;\n    }\n\n  }\n\n  class EdgeComparator implements Comparator<Edge> {\n    @Override\n    public int compare(Edge arg1, Edge arg2) {\n      Edge l1 = (Edge) arg1;\n      Edge l2 = (Edge) arg2;\n      if (l1.pos != l2.pos)\n        return compareInteger(l1.pos, l2.pos);\n      if (l1.isStart && l2.isStart) {\n        return compareInteger(l2.height, l1.height);\n      }\n      if (!l1.isStart && !l2.isStart) {\n        return compareInteger(l1.height, l2.height);\n      }\n      return l1.isStart ? -1 : 1;\n    }\n\n    int compareInteger(int a, int b) {\n      return a <= b ? -1 : 1;\n    }\n  }\n\n  List<List<Integer>> output(List<List<Integer>> res) {\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\n    if (res.size() > 0) {\n      int pre = res.get(0).get(0);\n      int height = res.get(0).get(1);\n      for (int i = 1; i < res.size(); i++) {\n        List<Integer> now = new ArrayList<Integer>();\n        int id = res.get(i).get(0);\n        if (height > 0) {\n          now.add(pre);\n          now.add(id);\n          now.add(height);\n          ans.add(now);\n        }\n        pre = id;\n        height = res.get(i).get(1);\n      }\n    }\n    return ans;\n  }\n\n  public List<List<Integer>> buildingOutline(int[][] buildings) {\n    // write your code here\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\n\n    if (buildings == null || buildings.length == 0\n        || buildings[0].length == 0) {\n      return res;\n    }\n    ArrayList<Edge> edges = new ArrayList<Edge>();\n    for (int[] building : buildings) {\n      Edge startEdge = new Edge(building[0], building[2], true);\n      edges.add(startEdge);\n      Edge endEdge = new Edge(building[1], building[2], false);\n      edges.add(endEdge);\n    }\n    Collections.sort(edges, new EdgeComparator());\n\n    HashHeap heap = new HashHeap(\"max\");\n\n    List<Integer> now = null;\n    for (Edge edge : edges) {\n      if (edge.isStart) {\n        if (heap.isEmpty() || edge.height > heap.peek()) {\n          now = new ArrayList<Integer>(Arrays.asList(edge.pos,\n              edge.height));\n          res.add(now);\n        }\n        heap.add(edge.height);\n      } else {\n        heap.delete(edge.height);\n        if (heap.isEmpty() || edge.height > heap.peek()) {\n          if (heap.isEmpty()) {\n            now = new ArrayList<Integer>(Arrays.asList(edge.pos, 0));\n          } else {\n            now = new ArrayList<Integer>(Arrays.asList(edge.pos,\n                heap.peek()));\n          }\n          res.add(now);\n        }\n      }\n    }\n    return output(res);\n  }\n\n}"},{"language":"cpp","code":"struct Node {\r\n    int x, h, isLeft;\r\n    Node(int _x, int _h, int _isLeft):x(_x), h(_h),isLeft(_isLeft){}\r\n    bool operator <(const Node &a) const {\r\n        return x < a.x || x == a.x && isLeft < a.isLeft;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param buildings: A list of lists of integers\r\n     * @return: Find the outline of those buildings\r\n     */\r\n\r\n    vector<vector<int> > buildingOutline(vector<vector<int> > &buildings) {\r\n        // write your code here\r\n        multiset<int> s;\r\n        vector<vector<int> > result;\r\n        vector<Node> p;        \r\n        int len = buildings.size();\r\n        if (len == 0)\r\n            return result;\r\n        \r\n        for (int i = 0; i < len; ++i) {\r\n            p.push_back(Node(buildings[i][0], buildings[i][2], 1));\r\n            p.push_back(Node(buildings[i][1], buildings[i][2], 0));\r\n        }\r\n\r\n        \r\n        sort(p.begin(), p.end());\r\n        \r\n        len = 2 * len;\r\n        int last = 0, size = 0;\r\n        for (int i = 0; i < len; ++i) {\r\n            if (s.empty())\r\n                last = p[i].x;\r\n            \r\n            if (!s.empty() && (*s.rbegin()) <= p[i].h && last < p[i].x) {\r\n                vector<int> tmp;\r\n                if (size > 0 && result[size - 1][2] == (*s.rbegin()) && result[size - 1][1] == last) {\r\n                    result[size -1][1] = p[i].x;\r\n                } else {      \r\n                    tmp.push_back(last);\r\n                    tmp.push_back(p[i].x);\r\n                    tmp.push_back(*s.rbegin());\r\n                    result.push_back(tmp);\r\n                    size ++;\r\n                }\r\n                last = p[i].x;\r\n            }\r\n            if (p[i].isLeft == 1)\r\n                s.insert(p[i].h);\r\n            else\r\n                s.erase(s.lower_bound(p[i].h));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"class HashHeap:\n    \n    def __init__(self):\n        self.heap = [0]\n        self.hash = {}\n        \n    def add(self, key, value):\n        self.heap.append((key, value))\n        self.hash[key] = self.heap[0] + 1\n        self.heap[0] += 1\n        self._siftup(self.heap[0])\n        \n    def remove(self, key):\n        index = self.hash[key]\n        self._swap(index, self.heap[0])\n        del self.hash[self.heap[self.heap[0]][0]]\n        self.heap.pop()\n        self.heap[0] -= 1\n        if index <= self.heap[0]:\n            index = self._siftup(index)\n            self._siftdown(index)\n        \n    def hasKey(self, key):\n        return key in self.hash\n        \n    def max(self):\n        return 0 if self.heap[0] == 0 else self.heap[1][1]\n    \n    def _swap(self, a, b):\n        self.heap[a], self.heap[b] = self.heap[b], self.heap[a]\n        self.hash[self.heap[a][0]] = a\n        self.hash[self.heap[b][0]] = b\n        \n    def _siftup(self, index):\n        while index != 1:\n            if self.heap[index][1] <= self.heap[index / 2][1]:\n                break\n            self._swap(index, index / 2)\n            index = index / 2\n        return index\n        \n    def _siftdown(self, index):\n        size = self.heap[0]\n        while index < size:\n            t = index\n            if index * 2 <= size and self.heap[t][1] < self.heap[index * 2][1]:\n                t = index * 2\n            if index * 2 + 1 <= size and self.heap[t][1] < self.heap[index * 2 + 1][1]:\n                t = index * 2 + 1\n            if t == index:\n                break\n            self._swap(index, t)\n            index = t\n        return index\n\nclass Solution:\n    # @param buildings: A list of lists of integers\n    # @return: A list of lists of integers\n    def buildingOutline(self, buildings):\n        if len(buildings) == 0:\n            return []\n            \n        begins = [(b[0], b[2], index) for index, b in enumerate(buildings)]\n        ends = [(b[1], b[2], index) for index, b in enumerate(buildings)]\n        heights = sorted(begins + ends, key=lambda x: x[0])\n        \n        hashheap = HashHeap()\n        y = {}\n        for x, height, index in heights:\n            if hashheap.hasKey(index):\n                hashheap.remove(index)\n            else:\n                hashheap.add(index, height)\n            y[x] = hashheap.max()\n        \n        temp = []\n        lastX, lastY = None, None\n        for x in sorted(y.keys()):\n            if lastX is not None and lastY != 0:\n                temp.append((lastX, x, lastY))\n            lastX, lastY = x, y[x]\n        \n        results = []\n        lastInterval = temp[0]\n        for start, end, height in temp[1:]:\n            if start == lastInterval[1] and height == lastInterval[2]:\n                lastInterval = lastInterval[0], end, height\n            else:\n                results.append(lastInterval)\n                lastInterval = (start, end, height)\n        results.append(lastInterval)\n        return results"}]},{"id":443,"unique_name":"data-stream-median","title":"数据流中位数","description":"数字是不断进入数组的，在每次添加一个新的数进入数组的同时返回当前新数组的中位数。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: the median of numbers\r\n     */\r\n    private PriorityQueue<Integer> maxHeap, minHeap;\r\n    private int numOfElements = 0;\r\n\r\n    public int[] medianII(int[] nums) {\r\n        // write your code here\r\n        Comparator<Integer> revCmp = new Comparator<Integer>() {\r\n            @Override\r\n            public int compare(Integer left, Integer right) {\r\n                return right.compareTo(left);\r\n            }\r\n        };\r\n        int cnt = nums.length;\r\n        maxHeap = new PriorityQueue<Integer>(cnt, revCmp);\r\n        minHeap = new PriorityQueue<Integer>(cnt);\r\n        int[] ans = new int[cnt];\r\n        for (int i = 0; i < cnt; ++i) {\r\n            addNumber(nums[i]);\r\n            ans[i] = getMedian();\r\n        }\r\n        return ans;\r\n    }\r\n    void addNumber(int value) {\r\n        maxHeap.add(value);\r\n        if (numOfElements%2 == 0) {\r\n            if (minHeap.isEmpty()) {\r\n                numOfElements++;\r\n                return;\r\n            }\r\n            else if (maxHeap.peek() > minHeap.peek()) {\r\n                Integer maxHeapRoot = maxHeap.poll();\r\n                Integer minHeapRoot = minHeap.poll();\r\n                maxHeap.add(minHeapRoot);\r\n                minHeap.add(maxHeapRoot);\r\n            }\r\n        }\r\n        else {\r\n            minHeap.add(maxHeap.poll());\r\n        }\r\n        numOfElements++;\r\n    }\r\n    int getMedian() {\r\n        return maxHeap.peek();\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: The median of numbers\r\n     */\r\n    priority_queue<int> maxHeap, minHeap; \r\n    vector<int> ans;\r\n    int numOfElements = 0;\r\n    vector<int> medianII(vector<int> &nums) {\r\n        // write your code here\r\n        int cnt = nums.size();\r\n        for (int i = 0; i < cnt; ++i) {\r\n\t\t    addNumber(nums[i]);   \r\n\t\t    ans.push_back(getMedian());\r\n\t\t}\r\n        return ans;\r\n    }\r\n    void addNumber(int value) {\r\n\t\tmaxHeap.push(value);\r\n\t\tif (numOfElements%2 == 0) {\r\n\t\t\tif (minHeap.empty()) {\r\n\t\t\t\tnumOfElements++;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse if (maxHeap.top() > -minHeap.top()) {\r\n\t\t\t\tint maxHeapRoot = maxHeap.top();\r\n\t\t\t    int minHeapRoot = -minHeap.top();\r\n                maxHeap.pop();\r\n                minHeap.pop();\r\n\t\t\t\tmaxHeap.push(minHeapRoot);\r\n\t\t\t\tminHeap.push(-maxHeapRoot);\r\n\t\t\t} \r\n\t\t} \r\n\t\telse {\r\n\t\t\tminHeap.push(-maxHeap.top());\r\n            maxHeap.pop();\r\n\t\t}\r\n\t\tnumOfElements++;\r\n\t}\r\n\tint getMedian() {\r\n\t\treturn maxHeap.top();\r\n\t}\r\n};\r\n\r\n"},{"language":"python","code":"import heapq\r\nclass Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers.\r\n    @return: The median of numbers\r\n    \"\"\"\r\n    \r\n    minHeap, maxHeap = [], []\r\n    numbers = 0\r\n    def medianII(self, nums):\r\n        ans = []\r\n        for item in nums:\r\n            self.add(item)\r\n            ans.append(self.getMedian())\r\n        return ans\r\n        \r\n    \r\n    def getMedian(self):\r\n        return -self.maxHeap[0]\r\n\r\n    def add(self, value):\r\n        if self.numbers % 2 == 0:\r\n            heapq.heappush(self.maxHeap, -value)\r\n        else:\r\n            heapq.heappush(self.minHeap, value)\r\n        self.numbers += 1\r\n        if len(self.minHeap)==0 or len(self.maxHeap)==0:\r\n            return\r\n\r\n        if -self.maxHeap[0] > self.minHeap[0]:\r\n            maxroot = -self.maxHeap[0]\r\n            minroot = self.minHeap[0]\r\n            heapq.heapreplace(self.maxHeap, -minroot)\r\n            heapq.heapreplace(self.minHeap, maxroot)\r\n            #print minroot, maxroot\r\n        \r\n\r\n"}]},{"id":759,"unique_name":"last-digit-by-factorial-divide","title":"阶乘除法的最后一位数","description":"给出两个数 `A` 和 `B`, 其中 `B >= A`. 我们需要计算结果 F 的最后一位数是什么, 其中F = `B! / A!`(1 <= A, B <= `10^18`, A 和 B 非常大)","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param A: the given number\n     * @param B: another number\n     * @return: the last digit of B! / A! \n     */\n    public int computeLastDigit(long A, long B) {\n        if(A == B) return 1;\n        long left = A+1;\n        long right = B;\n        int prod = 1;\n        for(long i=left;i<=right;i++){\n            int lastDigit = (int)i%10;\n            prod = (prod * lastDigit)%10;\n            if(prod == 0) return 0;\n        }\n        return prod;\n    }\n}"}]},{"id":725,"unique_name":"binary-tree-longest-path-with-same-value","title":"二叉树具有相同值的最长路径","description":"假设有一棵有 `N` 个节点的无向树, 编号为 `1` 到 `N`, 每一个节点都有一个int类型的值，不同的节点可以有相同的值。给一个长度为`N`的数组`A`，`A[j]`表示第`j + 1`个节点的值。再给一个长度为 `(N - 1) * 2` 的数组 `E`,对于任意的 `0 <= j <= N - 2` 都有 `E[2 * j], E[2 * j + 1]`表示节点 `E[2 * j]` 与节点 `E[2 * j + 1]`有边相连。返回具有相同值的节点构成的最长路劲的长度，路劲的长度为路径边的数量。","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : as indicated in the description\n     * @param : as indicated in the description\n     * @return: Return the number of edges on the longest path with same value.\n     */\n    public int ans = 0;\n    public int LongestPathWithSameValue(int[] A, int[] E) {\n        // write your code here\n        int len = A.length;\n        List<List<Integer>> ch = new ArrayList<>();\n        for (int i = 0; i <= len; i++){\n            ch.add(new ArrayList<>());\n        }\n        for (int i = 0; i < len - 1; i++){\n            ch.get(E[i*2]).add(E[i*2+1]);\n            ch.get(E[i*2+1]).add(E[i*2]);\n        }\n        int tmp = dfs(1,0,A,ch);\n        ans = Math.max(ans,tmp);\n        return ans - 1;\n    }\n    public int dfs(int index,int father,int[] A,List<List<Integer>> ch){\n        List<Integer> v = new ArrayList<>();\n        for (int son: ch.get(index)){\n            if (son != father){\n                if (A[son - 1] == A[index - 1]){\n                    v.add(dfs(son,index,A,ch));\n                }\n                else{\n                    dfs(son,index,A,ch);\n                }\n            }\n        }\n        v.add(0);\n        v.add(0);\n        Collections.sort(v);\n        Collections.reverse(v);\n        ans = Math.max(ans,v.get(0)+v.get(1)+1);\n        return v.get(0)+1;\n    }\n}"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: : as indicated in the description\n    @param: : as indicated in the description\n    @return: Return the number of edges on the longest path with same value.\n    \"\"\"\n\n    def LongestPathWithSameValue(self, A, E):\n        # write your code here\n        n = len(A)\n        ch = [[] for _ in xrange(n+1)]\n        for i in xrange(n-1):\n            ch[E[i*2]].append(E[i*2+1])\n            ch[E[i*2+1]].append(E[i*2])\n        A=[0]+A\n        self.ans = 0\n        tmp = self.dfs(1, 0, A, ch)\n        self.ans=max(self.ans, tmp)\n        return self.ans - 1\n    \n    def dfs(self, o, fa, A, ch):\n        v = []\n        for c in ch[o]:\n            if c != fa:\n                if A[c] == A[o]:\n                    v.append(self.dfs(c, o, A, ch))\n                else:\n                    self.dfs(c, o, A, ch)\n        v.append(0)\n        v.append(0)\n        v = sorted(v,reverse = True)\n        self.ans = max(self.ans, v[0]+v[1]+1)\n        return v[0] + 1"}]},{"id":684,"unique_name":"top-k-largest-numbers-ii","title":"前K大数 II","description":"实现一个数据结构，提供下面两个接口\r\n1.`add(number)` 添加一个元素\r\n2.`topk()` 返回前K大的数\r\n","solutions":[{"language":"java","code":"public class Solution {\n    private int maxSize;\n    private Queue<Integer> minheap;\n    public Solution(int k) {\n        minheap = new PriorityQueue<>();\n        maxSize = k;\n    }\n\n    public void add(int num) {\n        if (minheap.size() < maxSize) {\n            minheap.offer(num);\n            return;\n        }\n        \n        if (num > minheap.peek()) {\n            minheap.poll();\n            minheap.offer(num);\n        }\n    }\n\n    public List<Integer> topk() {\n        Iterator it = minheap.iterator();\n        List<Integer> result = new ArrayList<Integer>();\n        while (it.hasNext()) {\n            result.add((Integer) it.next());\n        }\n        Collections.sort(result, Collections.reverseOrder());\n        return result;\n    }\n};"},{"language":"cpp","code":"bool cmp(const int& a, const int& b) {\n    return a > b;\n}\n\nclass Solution {\nprivate:\n    priority_queue<int, vector<int>, greater<int>> queue;\n    int k;\n\npublic:\n    Solution(int k) {\n        // initialize your data structure here.\n        this->k = k;\n    }\n\n    void add(int num) {\n        // Write your code here\n        if (queue.size() < k) {\n            queue.push(num);\n        } else if (queue.top() < num) {\n            queue.pop();\n            queue.push(num);\n        }\n    }\n\n    vector<int> topk() {\n        // Write your code here\n        vector<int> topk;\n        int n = queue.size();\n        for (int i = 0; i < k && i < n ; ++i) {\n            topk.push_back(queue.top());\n            queue.pop();\n        }\n\n        for (int i = 0; i < n; ++i)\n            queue.push(topk[i]);\n        sort(topk.begin(), topk.end(), cmp);\n        return topk;\n    }\n};"},{"language":"python","code":"import heapq\n\nclass Solution:\n\n    # @param {int} k an integer\n    def __init__(self, k):\n        # initialize your data structure here.\n        self.k = k\n        self.nums = []\n        heapq.heapify(self.nums)\n        \n    # @param {int} num an integer\n    def add(self, num):\n        # Write your code here\n        if len(self.nums) < self.k:\n            heapq.heappush(self.nums, num)\n        elif num > self.nums[0]:\n            heapq.heappop(self.nums)\n            heapq.heappush(self.nums, num)\n\n    # @return {int[]} the top k largest numbers in array\n    def topk(self):\n        # Write your code here\n        return sorted(self.nums, reverse=True)"}]},{"id":455,"unique_name":"ugly-number-ii","title":"丑数 II","description":"设计一个算法，找出只含素因子`2`，`3`，`5` 的第 *n* 小的数。\n\n符合条件的数如：`1, 2, 3, 4, 5, 6, 8, 9, 10, 12...`\n","solutions":[{"language":"java","code":"// version 1: O(n) scan\r\nclass Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @return the nth prime number as description.\r\n     */\r\n    public int nthUglyNumber(int n) {\r\n        List<Integer> uglys = new ArrayList<Integer>();\r\n        uglys.add(1);\r\n        \r\n        int p2 = 0, p3 = 0, p5 = 0;\r\n        // p2, p3 & p5 share the same queue: uglys\r\n\r\n        for (int i = 1; i < n; i++) {\r\n            int lastNumber = uglys.get(i - 1);\r\n            while (uglys.get(p2) * 2 <= lastNumber) p2++;\r\n            while (uglys.get(p3) * 3 <= lastNumber) p3++;\r\n            while (uglys.get(p5) * 5 <= lastNumber) p5++;\r\n            \r\n            uglys.add(Math.min(\r\n                Math.min(uglys.get(p2) * 2, uglys.get(p3) * 3),\r\n                uglys.get(p5) * 5\r\n            ));\r\n        }\r\n\r\n        return uglys.get(n - 1);\r\n    }\r\n};\r\n\r\n// version 2 O(nlogn) HashMap + Heap\r\nclass Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @return the nth prime number as description.\r\n     */\r\n    public int nthUglyNumber(int n) {\r\n        // Write your code here\r\n        Queue<Long> Q = new PriorityQueue<Long>();\r\n        HashSet<Long> inQ = new HashSet<Long>();\r\n        Long[] primes = new Long[3];\r\n        primes[0] = Long.valueOf(2);\r\n        primes[1] = Long.valueOf(3);\r\n        primes[2] = Long.valueOf(5);\r\n        for (int i = 0; i < 3; i++) {\r\n            Q.add(primes[i]);\r\n            inQ.add(primes[i]);\r\n        }\r\n        Long number = Long.valueOf(1);\r\n        for (int i = 1; i < n; i++) {\r\n            number = Q.poll();\r\n            for (int j = 0; j < 3; j++) {\r\n                if (!inQ.contains(primes[j] * number)) {\r\n                    Q.add(number * primes[j]);\r\n                    inQ.add(number * primes[j]);\r\n                }\r\n            }\r\n        }\r\n        return number.intValue();\r\n    }\r\n};"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n     * @param n an integer\r\n     * @return the nth prime number as description.\r\n     */\r\n    int nthUglyNumber(int n) {\r\n        int *uglys = new int[n];\r\n        uglys[0] = 1;\r\n        int next = 1;\r\n        int *p2 = uglys;\r\n        int *p3 = uglys;\r\n        int *p5 = uglys;\r\n        while (next < n){\r\n            int m = min(min(*p2 * 2, *p3 * 3), *p5 * 5);\r\n            uglys[next] = m;\r\n            while (*p2 * 2 <= uglys[next])\r\n                *p2++;\r\n            while (*p3 * 3 <= uglys[next])\r\n                *p3++;\r\n            while (*p5 * 5 <= uglys[next])\r\n                *p5++;\r\n            next++;\r\n        }\r\n        int uglyNum = uglys[n - 1];\r\n        delete[] uglys;\r\n        return uglyNum;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param {int} n an integer.\r\n    @return {int} the nth prime number as description.\r\n    \"\"\"\r\n    def nthUglyNumber(self, n):\r\n        import heapq\r\n        if n <= 1:\r\n            return n\r\n\r\n        n -= 1\r\n        key = [2, 3, 5]\r\n        h = []\r\n        for i in range(3):\r\n            heapq.heappush(h, (key[i], i))\r\n\r\n        value = key[0]\r\n        while n > 0:\r\n            value, level = heapq.heappop(h)\r\n            while level < 3:\r\n                new_value = key[level] * value\r\n                heapq.heappush(h, (new_value, level))\r\n                level += 1\r\n            n -= 1\r\n        return value"},{"language":"javascript","code":"const nthUglyNumber = function (n) {\n    var res = [1];\n    var i, t, nxt;\n    while (res.length < n) {\n        t = res[res.length - 1];\n        nxt = t * 2;\n        for (i = 0; i < res.length; i++) {\n            if (res[i] * 2 > t) {\n                nxt = Math.min(res[i] * 2, nxt);\n            }\n        }\n        for (i = 0; i < res.length; i++) {\n            if (res[i] * 3 > t) {\n                nxt = Math.min(res[i] * 3, nxt);\n            }\n        }\n        for (i = 0; i < res.length; i++) {\n            if (res[i] * 5 > t) {\n                nxt = Math.min(res[i] * 5, nxt);\n            }\n        }\n        res.push(nxt);\n    }\n    return res[n - 1];\n}"}]},{"id":446,"unique_name":"product-of-array-exclude-itself","title":"数组剔除元素后的乘积","description":"<p>给定一个整数数组A。</p><p>定义B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]， 计算B的时候请不要使用除法。</p>","solutions":[{"language":"java","code":"import java.util.ArrayList;\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param nums: Given an integers array A\r\n     * @return: A Long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]\r\n     */\r\n    public ArrayList<Long> productExcludeItself(ArrayList<Integer> A) {\r\n        int len = A.size();\r\n        ArrayList<Long> B = new  ArrayList<Long>();\r\n        long[] f = new long[len];\r\n\r\n        long tmp = 1;\r\n        long now = 1;\r\n        f[len-1] = A.get(len-1);\r\n        int i ;\r\n        for ( i = len-2; i >= 0; --i)\r\n        {\r\n            f[i] = A.get(i);\r\n            f[i] = f[i] * f[i+1];\r\n        }\r\n\r\n        for ( i = 0; i < len; ++i) {\r\n\t\t\t\r\n            now = tmp;\r\n            if(i+1<len)\r\n                B.add( now * f[i+1] );\r\n            else\r\n                B.add( now );\r\n            now = A.get(i);\r\n            tmp = tmp * now;\r\n\r\n        }\r\n        return B;\r\n    }\r\n}"},{"language":"cpp","code":"#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param A: Given an integers array A\r\n     * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]\r\n     */\r\n    vector<long long> productExcludeItself(vector<int> &nums) {\r\n        vector<long long> B;\r\n        int len = nums.size();\r\n        long long f[len + 1];\r\n        \r\n        f[len] = 1;\r\n        for (int i = len-1; i >= 0; --i)\r\n            f[i] = f[i + 1] * nums[i];\r\n        long long tmp = 1; \r\n        for (int i = 0; i < len; ++i) {\r\n            B.push_back(tmp * f[i + 1] );\r\n            tmp *= nums[i];\r\n        }\r\n        return B;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A: Given an integers array A\r\n    @return: An integer array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]\r\n    \"\"\"\r\n    def productExcludeItself(self, A):\r\n        length ,B  = len(A) ,[]\r\n        f = [ 0 for i in xrange(length + 1)]\r\n        f[ length ] = 1\r\n        for i in xrange(length - 1 , 0 , -1):\r\n            f[ i ] = f[ i + 1 ] * A[ i ]\r\n        tmp = 1\r\n        for i in xrange(length):\r\n            B.append(tmp * f[ i + 1 ])\r\n            tmp *= A[ i ]\r\n        return B"}]},{"id":571,"unique_name":"strstr-ii","title":"字符串查找 II","description":"实现时间复杂度为 O(n + m)的方法 `strStr`。\n`strStr` 返回目标字串在源字串中第一次出现的第一个字符的位置. 目标字串的长度为 *m* , 源字串的长度为 *n* . 如果目标字串不在源字串中则返回 -1。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param source a source string\r\n     * @param target a target string\r\n     * @return an integer as index\r\n     */\r\n    public int strStr2(String source, String target) {\r\n        if(target == null) {\r\n            return -1;\r\n        }\r\n        int m = target.length();\r\n        if(m == 0 && source != null) {\r\n            return 0;\r\n        }\r\n        \r\n        if(source == null) {\r\n            return -1;\r\n        }\r\n        int n = source.length();\r\n        if(n == 0) {\r\n            return -1;\r\n        }\r\n\r\n        // mod could be any big integer\r\n        // just make sure mod * 33 wont exceed max value of int.\r\n        int mod = Integer.MAX_VALUE / 33;\r\n        int hash_target = 0;\r\n\r\n        // 33 could be something else like 26 or whatever you want\r\n        for (int i = 0; i < m; ++i) {\r\n            hash_target = (hash_target * 33 + target.charAt(i) - 'a') % mod;\r\n            if (hash_target < 0) {\r\n                hash_target += mod;\r\n            }\r\n        }\r\n\r\n        int m33 = 1;\r\n        for (int i = 0; i < m - 1; ++i) {\r\n            m33 = m33 * 33 % mod;\r\n        }\r\n\r\n        int value = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (i >= m) {\r\n                value = (value - m33 * (source.charAt(i - m) - 'a')) % mod;\r\n            }\r\n\r\n            value = (value * 33 + source.charAt(i) - 'a') % mod;\r\n            if (value < 0) {\r\n                value += mod;\r\n            }\r\n\r\n            if (i >= m - 1 && value == hash_target) {\r\n                // you have to double check by directly compare the string\r\n                if (target.equals(source.substring(i - m + 1, i + 1))) {\r\n                    return i - m + 1;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param source a source string\r\n     * @param target a target string\r\n     * @return an integer as index\r\n     */\r\n    int strStr2(const char* source, const char* target) {\r\n        // Write your code here\r\n        if (source == NULL || target == NULL) \r\n            return -1;\r\n        int m = strlen(target);\r\n        int n = strlen(source);\r\n\r\n        if (m == 0)\r\n            return 0;\r\n\r\n        int mod = rand() % 1000000 + 1000000;\r\n        int hash_target = 0;\r\n        int m26 = 1;\r\n\r\n        for (int i = 0; i < m; ++i) {\r\n            hash_target = (hash_target * 26 + target[i] - 'a') % mod;\r\n            if (hash_target < 0)\r\n                hash_target += mod;\r\n        }\r\n\r\n        for (int i = 0; i < m - 1; ++i)\r\n            m26 = m26 * 26 % mod;\r\n\r\n        int value = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (i >= m)\r\n                value = (value - m26 * (source[i - m] - 'a')) % mod;\r\n\r\n            value = (value * 26 + source[i] - 'a') % mod;\r\n            if (value < 0)\r\n                value += mod;\r\n\r\n            if (i >= m - 1 && value == hash_target) {\r\n                // you have to double check by directly compare the string\r\n                char sub[m];\r\n                memcpy(sub, &source[i - m + 1], m);\r\n                sub[m] = '\\0';\r\n                if (strcmp(target, sub) == 0) {\r\n                    return i - m + 1;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {string} source a source string\r\n    # @param {string} target a target string\r\n    # @return {int} an integer as index\r\n    def strStr2(self, source, target):\r\n        # Write your code here\r\n        if source is None or target is None:\r\n            return -1\r\n        m = len(target)\r\n        n = len(source)\r\n\r\n        if m == 0:\r\n            return 0\r\n\r\n        import random\r\n        mod = random.randint(1000000, 2000000)\r\n        hash_target = 0\r\n        m26 = 1\r\n\r\n        for i in xrange(m):\r\n            hash_target = (hash_target * 26 + ord(target[i]) - ord('a')) % mod\r\n            if hash_target < 0:\r\n                hash_target += mod\r\n\r\n        for i in xrange(m - 1):\r\n            m26 = m26 * 26 % mod\r\n\r\n        value = 0\r\n        for i in xrange(n):\r\n            if i >= m:\r\n                value = (value - m26 * (ord(source[i - m]) - ord('a'))) % mod\r\n\r\n            value = (value * 26 + ord(source[i]) - ord('a')) % mod\r\n            if value < 0:\r\n                value += mod\r\n\r\n            if i >= m - 1 and value == hash_target:\r\n                return i - m + 1\r\n\r\n        return -1"}]},{"id":602,"unique_name":"two-sum-unique-pairs","title":"两数之和 - 不同组成","description":"给一整数数组, 找到数组中有多少组 `不同的元素对` 有相同的和, 且和为给出的 target 值, 返回对数.","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param nums an array of integer\n     * @param target an integer\n     * @return an integer\n     */\n    public int twoSum6(int[] nums, int target) {\n        // Write your code here\n        if (nums == null || nums.length < 2)\n            return 0;\n\n        Arrays.sort(nums);\n        int cnt = 0;\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int v = nums[left] + nums[right];\n            if (v == target) {\n                cnt ++;\n                left ++;\n                right --;\n                while (left < right && nums[right] == nums[right + 1])\n                    right --;\n                while (left < right && nums[left] == nums[left - 1])\n                    left ++;\n            } else if (v > target) {\n                right --;\n            } else {\n                left ++;\n            }\n        }\n        return cnt;\n    }\n}\n\n//九章硅谷求职算法集训营版本\npublic class Solution {\n    /*\n     * @param nums an array of Integer\n     * @param target = nums[index1] + nums[index2]\n     * @return [index1 + 1, index2 + 1] (index1 < index2)\n     */\n    public int twoSum6(int[] A, int T) {\n        if (A == null || A.length <= 1) {\n            return 0;\n        }\n        \n        Arrays.sort(A);\n        int i, n = A.length;\n        int j = n - 1;\n        int res = 0;\n        \n        for (i = 0; i < n; ++i) {\n            // item1 should be the first among its duplicates\n            if (i > 0 && A[i] == A[i - 1]) {\n                continue;\n            }\n            \n            // item2 should be the last among its duplicates\n            while (j > i && A[j] > T - A[i]) {\n                --j;\n            }\n            \n            // this is to avoid that i==j, A[i]+A[j]=T, which does not count\n            if (j > i && A[j] == T - A[i]) {\n                ++res;\n            }\n        }\n        \n        return res;\n    }\n}"}]},{"id":679,"unique_name":"count-characters","title":"字符计数","description":"对一个字符串中的字符进行计数, 返回一个hashmap, key为字符, value是这个字符出现的次数.","solutions":[{"language":"java","code":"public class Solution {\r\n    /*\r\n     * @param : a string\r\n     * @return: a hash map\r\n     */\r\n    public Map<Character, Integer> countCharacters(String str) {\r\n        // Write your code here\r\n        Map<Character, Integer> map = new HashMap<Character, Integer>();\r\n        for (char c : str.toCharArray()) {\r\n            if (!map.containsKey(c)) {\r\n                map.put(c, 1);\r\n            } else {\r\n                map.put(c, map.get(c) + 1);\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n};"}]},{"id":486,"unique_name":"intersection-of-two-arrays-ii","title":"两数组的交 II","description":"计算两个数组的交","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums1 an integer array\r\n     * @param nums2 an integer array\r\n     * @return an integer array\r\n     */\r\n    public int[] intersection(int[] nums1, int[] nums2) {\r\n        // Write your code here\r\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n        for(int i = 0; i < nums1.length; ++i) {\r\n            if (map.containsKey(nums1[i]))\r\n                map.put(nums1[i], map.get(nums1[i]) + 1); \r\n            else\r\n                map.put(nums1[i], 1);\r\n        }\r\n\r\n        List<Integer> results = new ArrayList<Integer>();\r\n\r\n        for (int i = 0; i < nums2.length; ++i)\r\n            if (map.containsKey(nums2[i]) &&\r\n                map.get(nums2[i]) > 0) {\r\n                results.add(nums2[i]);\r\n                map.put(nums2[i], map.get(nums2[i]) - 1); \r\n            }\r\n\r\n        int result[] = new int[results.size()];\r\n        for(int i = 0; i < results.size(); ++i)\r\n            result[i] = results.get(i);\r\n\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums1 an integer array\r\n     * @param nums2 an integer array\r\n     * @return an integer array\r\n     */\r\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\r\n        // Write your code here\r\n        sort(nums1.begin(), nums1.end());\r\n        sort(nums2.begin(), nums2.end());\r\n\r\n        vector<int> intersect;\r\n        vector<int>::iterator it1 = nums1.begin(), it2 = nums2.begin();\r\n        while ((it1 != nums1.end()) && (it2 != nums2.end()))\r\n        {\r\n            if (*it1 < *it2) it1++;\r\n            else if (*it1 > *it2) it2++;\r\n            else \r\n            {\r\n                intersect.push_back(*it1); \r\n                it1++; it2++;\r\n            }\r\n        }\r\n\r\n        return intersect;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums1 an integer array\r\n    # @param {int[]} nums2 an integer array\r\n    # @return {int[]} an integer array\r\n    def intersection(self, nums1, nums2):\r\n        # Write your code here\r\n        counts = collections.Counter(nums1)\r\n        result = []\r\n\r\n        for num in nums2:\r\n            if counts[num] > 0:\r\n                result.append(num)\r\n                counts[num] -= 1\r\n\r\n        return result"}]},{"id":474,"unique_name":"intersection-of-two-arrays","title":"两数组的交","description":"返回两个数组的交","solutions":[{"language":"java","code":"// version 1: sort & merge\r\npublic class Solution {\r\n    /**\r\n     * @param nums1 an integer array\r\n     * @param nums2 an integer array\r\n     * @return an integer array\r\n     */\r\n    public int[] intersection(int[] nums1, int[] nums2) {\r\n        Arrays.sort(nums1);\r\n        Arrays.sort(nums2);\r\n        \r\n        int i = 0, j = 0;\r\n        int[] temp = new int[nums1.length];\r\n        int index = 0;\r\n        while (i < nums1.length && j < nums2.length) {\r\n            if (nums1[i] == nums2[j]) {\r\n                if (index == 0 || temp[index - 1] != nums1[i]) {\r\n                    temp[index++] = nums1[i];\r\n                }\r\n                i++;\r\n                j++;\r\n            } else if (nums1[i] < nums2[j]) {\r\n                i++;\r\n            } else {\r\n                j++;\r\n            }\r\n        }\r\n        \r\n        int[] result = new int[index];\r\n        for (int k = 0; k < index; k++) {\r\n            result[k] = temp[k];\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n// version 2: hash map\r\npublic class Solution {\r\n    /**\r\n     * @param nums1 an integer array\r\n     * @param nums2 an integer array\r\n     * @return an integer array\r\n     */\r\n    public int[] intersection(int[] nums1, int[] nums2) {\r\n        if (nums1 == null || nums2 == null) {\r\n            return null;\r\n        }\r\n        \r\n        HashSet<Integer> hash = new HashSet<>();\r\n        for (int i = 0; i < nums1.length; i++) {\r\n            hash.add(nums1[i]);\r\n        }\r\n        \r\n        HashSet<Integer> resultHash = new HashSet<>();\r\n        for (int i = 0; i < nums2.length; i++) {\r\n            if (hash.contains(nums2[i]) && !resultHash.contains(nums2[i])) {\r\n                resultHash.add(nums2[i]);\r\n            }\r\n        }\r\n        \r\n        int size = resultHash.size();\r\n        int[] result = new int[size];\r\n        int index = 0;\r\n        for (Integer num : resultHash) {\r\n            result[index++] = num;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n// version 3: sort & binary search\r\npublic class Solution {\r\n    /**\r\n     * @param nums1 an integer array\r\n     * @param nums2 an integer array\r\n     * @return an integer array\r\n     */\r\n    public int[] intersection(int[] nums1, int[] nums2) {\r\n        if (nums1 == null || nums2 == null) {\r\n            return null;\r\n        }\r\n        \r\n        HashSet<Integer> set = new HashSet<>();\r\n        \r\n        Arrays.sort(nums1);\r\n        for (int i = 0; i < nums2.length; i++) {\r\n            if (set.contains(nums2[i])) {\r\n                continue;\r\n            }\r\n            if (binarySearch(nums1, nums2[i])) {\r\n                set.add(nums2[i]);\r\n            }\r\n        }\r\n        \r\n        int[] result = new int[set.size()];\r\n        int index = 0;\r\n        for (Integer num : set) {\r\n            result[index++] = num;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    private boolean binarySearch(int[] nums, int target) {\r\n        if (nums == null || nums.length == 0) {\r\n            return false;\r\n        }\r\n        \r\n        int start = 0, end = nums.length - 1;\r\n        while (start + 1 < end) {\r\n            int mid = (end - start) / 2 + start;\r\n            if (nums[mid] == target) {\r\n                return true;\r\n            }\r\n            if (nums[mid] < target) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (nums[start] == target) {\r\n            return true;\r\n        }\r\n        if (nums[end] == target) {\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n}"},{"language":"cpp","code":"// sort & merge\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nums1 an integer array\r\n     * @param nums2 an integer array\r\n     * @return an integer array\r\n     */\r\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\r\n        // Write your code here\r\n        sort(nums1.begin(), nums1.end());\r\n        sort(nums2.begin(), nums2.end());\r\n\r\n        vector<int> intersect;\r\n        vector<int>::iterator it1 = nums1.begin(), it2 = nums2.begin();\r\n        while ((it1 != nums1.end()) && (it2 != nums2.end()))\r\n        {\r\n            if (*it1 < *it2) it1++;\r\n            else if (*it1 > *it2) it2++;\r\n            else \r\n            {\r\n                intersect.push_back(*it1); \r\n                it1++; it2++;\r\n            }\r\n        }\r\n\r\n        auto last = unique(intersect.begin(), intersect.end());\r\n        intersect.erase(last, intersect.end());\r\n        return intersect;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} nums1 an integer array\r\n    # @param {int[]} nums2 an integer array\r\n    # @return {int[]} an integer array\r\n    def intersection(self, nums1, nums2):\r\n        # Write your code here\r\n        return list(set(nums1) & set(nums2))"}]},{"id":193,"unique_name":"happy-number","title":"快乐数","description":"写一个算法来判断一个数是不是\"快乐数\"。\r\n\r\n一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。","solutions":[{"language":"java","code":"public class Solution {\r\n    private int getNextHappy(int n) {\r\n        int sum = 0;\r\n        while (n != 0) {\r\n            sum += (n % 10) * (n % 10);\r\n            n /= 10;\r\n        }\r\n        return sum;\r\n    }\r\n    \r\n    public boolean isHappy(int n) {\r\n        HashSet<Integer> hash = new HashSet<Integer>();\r\n        while (n != 1) {\r\n            if (hash.contains(n)) {\r\n                return false;\r\n            }\r\n            hash.add(n);\r\n            n = getNextHappy(n);\r\n        }\r\n        return true;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n an integer\r\n     * @return true if this is a happy number or false\r\n     */\r\n    bool isHappy(int n) {\r\n        // Write your code here\r\n        if (n < 1)\r\n            return false;\r\n        if (n == 1)\r\n            return true;\r\n        unordered_set<int> showedNums;\r\n        showedNums.insert(n);\r\n\r\n        while (true) {\r\n            int s = 0;\r\n            while (n) {\r\n                s += (n % 10) * (n % 10);\r\n                n = n / 10;\r\n            }\r\n\r\n            if (s == 1)\r\n                return true;\r\n            else if (showedNums.find(s) != showedNums.end())\r\n                return false;\r\n            n = s;\r\n            showedNums.insert(s);\r\n        }\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n an integer\r\n    # @return {boolean} true if this is a happy number or false\r\n    def isHappy(self, n):\r\n        # Write your code here\r\n        d = {}\r\n        while True:\r\n            d[n] = 1\r\n            n = sum([int(x) * int(x) for x in list(str(n))])\r\n            if n == 1 or n in d:\r\n                break\r\n        return n == 1"}]},{"id":279,"unique_name":"subarray-sum","title":"子数组之和","description":"给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: A list of integers includes the index of the first number\r\n     *          and the index of the last number\r\n     */\r\n    public ArrayList<Integer> subarraySum(int[] nums) {\r\n        // write your code here\r\n       \r\n        int len = nums.length;\r\n       \r\n        ArrayList<Integer> ans = new ArrayList<Integer>();\r\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n       \r\n        map.put(0, -1);\r\n       \r\n        int sum = 0;\r\n        for (int i = 0; i < len; i++) {\r\n            sum += nums[i];\r\n           \r\n            if (map.containsKey(sum)) {\r\n                ans.add(map.get(sum) + 1);\r\n                ans.add(i);\r\n                return ans;\r\n            }\r\n            \r\n            map.put(sum, i);\r\n        }\r\n       \r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: A list of integers includes the index of the first number \r\n     *          and the index of the last number\r\n     */\r\n    vector<int> subarraySum(vector<int> nums){\r\n        unordered_map<int, int> hash;\r\n        \r\n        int sum = 0;\r\n        hash[0] = -1;\r\n        for (int i = 0; i < nums.size(); i++) {\r\n            sum += nums[i];\r\n            if (hash.find(sum) != hash.end()) {\r\n                vector<int> result;\r\n                result.push_back(hash[sum] + 1);\r\n                result.push_back(i);\r\n                return result;\r\n            }\r\n            hash[sum] = i;\r\n        }\r\n        \r\n        vector<int> result;\r\n        return result;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers\r\n    @return: A list of integers includes the index of the first number \r\n             and the index of the last number\r\n    \"\"\"\r\n    def subarraySum(self, nums):\r\n        hs = {0:-1}\r\n        sum = 0\r\n        for i in range(len(nums)):\r\n            # if A[i] == 0:\r\n            #     return [i, i]\r\n            sum += nums[i]\r\n            if sum in hs:\r\n                return [hs[sum] + 1, i]\r\n            hs[sum] = i\r\n        return \r\n"}]},{"id":289,"unique_name":"rehashing","title":"重哈希","description":"哈希表容量的大小在一开始是不确定的。如果哈希表存储的元素太多（如超过容量的十分之一），我们应该将哈希表容量扩大一倍，并将所有的哈希值重新安排。假设你有如下一哈希表：\r\n\r\n`size=3`, `capacity=4`\r\n\r\n\t[null, 21, 14, null]\r\n\t       ↓    ↓\r\n\t       9   null\r\n\t       ↓\r\n\t      null\r\n\r\n\r\n哈希函数为：\r\n\r\n\tint hashcode(int key, int capacity) {\r\n\t    return key % capacity;\r\n\t}\r\n\r\n这里有三个数字9，14，21，其中21和9共享同一个位置因为它们有相同的哈希值1(21 % 4 = 9 % 4 = 1)。我们将它们存储在同一个链表中。\r\n\r\n重建哈希表，将容量扩大一倍，我们将会得到：\r\n\r\n`size=3`, `capacity=8`\r\n\r\n\tindex:   0    1    2    3     4    5    6   7\r\n\thash : [null, 9, null, null, null, 21, 14, null]\r\n\r\n给定一个哈希表，返回重哈希后的哈希表。","solutions":[{"language":"java","code":"/**\r\n * Definition for ListNode\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param hashTable: A list of The first node of linked list\r\n     * @return: A list of The first node of linked list which have twice size\r\n     */\r\n    public ListNode[] rehashing(ListNode[] hashTable) {\r\n        // write your code here\r\n        if (hashTable.length <= 0) {\r\n            return hashTable;\r\n        }\r\n        int newcapacity = 2 * hashTable.length;\r\n        ListNode[] newTable = new ListNode[newcapacity];\r\n        for (int i = 0; i < hashTable.length; i++) {\r\n            while (hashTable[i] != null) {\r\n                int newindex\r\n                 = (hashTable[i].val % newcapacity + newcapacity) % newcapacity;\r\n                if (newTable[newindex] == null) {\r\n                    newTable[newindex] = new ListNode(hashTable[i].val);\r\n                   // newTable[newindex].next = null;\r\n                } else {\r\n                    ListNode dummy = newTable[newindex];\r\n                    while (dummy.next != null) {\r\n                        dummy = dummy.next;\r\n                    }\r\n                    dummy.next = new ListNode(hashTable[i].val);\r\n                }\r\n                hashTable[i] = hashTable[i].next;\r\n            }\r\n        }\r\n        return newTable;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    void addlistnode(ListNode* node, int number) {\n        if (node->next != NULL)\n            addlistnode(node->next, number);\n        else\n            node->next = new ListNode(number);\n    }\n    void addnode(vector<ListNode*> &anshashTable, int number) {\n        int p = (number + anshashTable.size()) % anshashTable.size();\n        if (anshashTable[p] == NULL)\n            anshashTable[p] = new ListNode(number);\n        else\n            addlistnode(anshashTable[p], number);\n    }\n    vector<ListNode*> rehashing(vector<ListNode*> hashTable){\n        vector<ListNode*> anshashTable;\n        for(int i = 0; i < hashTable.size() * 2; i++)\n            anshashTable.push_back(NULL);\n        int HASH_SIZE = anshashTable.size();\n        for(int i = 0; i < hashTable.size(); i++) {\n            ListNode* p = hashTable[i];\n            while (p != NULL) {\n                addnode(anshashTable,p->val);\n                p = p->next;\n            }\n        }\n        return anshashTable;\n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    def addlistnode(self, node, number):\n        if node.next != None:\n            self.addlistnode(node.next, number)\n        else:\n            node.next = ListNode(number)\n\n    def addnode(self, anshashTable, number):\n        p = number % len(anshashTable)\n        if anshashTable[p] == None:\n            anshashTable[p] = ListNode(number)\n        else:\n            self.addlistnode(anshashTable[p], number)\n\n    def rehashing(self,hashTable):\n        HASH_SIZE = 2 * len(hashTable)\n        anshashTable = [None for i in range(HASH_SIZE)]\n        for item in hashTable:\n            p = item\n            while p != None:\n                self.addnode(anshashTable,p.val)\n                p = p.next\n        return anshashTable"}]},{"id":439,"unique_name":"hash-function","title":"哈希函数","description":"<p>在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一个大整数，比如：</p><p style=\"color: rgb(113, 113, 113); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\">hashcode(\"abcd\") = (ascii(a) * 33<span style=\"position: relative; font-size: 12px; line-height: 0; vertical-align: baseline; top: -0.5em;\">3</span>&nbsp;+&nbsp;<span style=\"line-height: 1.42857143;\">ascii(</span><span style=\"line-height: 1.42857143;\">b) * 33</span><span style=\"position: relative; font-size: 12px; line-height: 0; vertical-align: baseline; top: -0.5em;\">2</span><span style=\"line-height: 1.42857143;\">&nbsp;+&nbsp;</span><span style=\"line-height: 1.42857143;\">ascii(</span><span style=\"line-height: 1.42857143;\">c) *33 +&nbsp;</span><span style=\"line-height: 1.42857143;\">ascii(</span><span style=\"line-height: 1.42857143;\">d)) %&nbsp;</span>HASH_SIZE<span style=\"line-height: 1.42857143;\">&nbsp;</span></p><p style=\"color: rgb(113, 113, 113); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\"><span style=\"line-height: 1.42857143;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = (</span><span style=\"line-height: 1.42857143;\">97* 33</span><span style=\"font-size: 12px; line-height: 0; position: relative; vertical-align: baseline; top: -0.5em;\">3</span><span style=\"line-height: 1.42857143;\">&nbsp;</span><span style=\"line-height: 1.42857143;\">+ 98</span><span style=\"line-height: 1.42857143;\">&nbsp;* 33</span><span style=\"font-size: 12px; line-height: 0; position: relative; vertical-align: baseline; top: -0.5em;\">2</span><span style=\"line-height: 1.42857143;\">&nbsp;+ 99</span><span style=\"line-height: 1.42857143;\">&nbsp;* 33 +100</span><span style=\"line-height: 1.42857143;\">) % HASH_SIZE</span></p><p style=\"color: rgb(113, 113, 113); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\"><span style=\"line-height: 1.42857143;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&nbsp;</span>3595978 % HASH_SIZE</p><p>其中HASH_SIZE表示哈希表的大小(可以假设一个哈希表就是一个索引0 ~ HASH_SIZE-1的数组)。</p><p>给出一个字符串作为key和一个哈希表的大小，返回这个字符串的哈希值。</p>","solutions":[{"language":"java","code":"class Solution {\r\n    public int hashCode(char[] key,int HASH_SIZE) {\r\n        long ans = 0;\r\n        for(int i = 0; i < key.length;i++) {\r\n            ans = (ans * 33 + (int)(key[i])) % HASH_SIZE; \r\n        }\r\n\treturn (int)ans;\r\n    }\r\n};\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int hashCode(string key,int HASH_SIZE) {\r\n        int ans = 0;\r\n        for(int i = 0; i < key.size();i++) {\r\n            ans = (1LL * ans * 33 + key[i]) % HASH_SIZE; \r\n        }\r\n\treturn ans;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param key: A String you should hash\r\n    @param HASH_SIZE: An integer\r\n    @return an integer\r\n    \"\"\"\r\n    def hashCode(self, key, HASH_SIZE):\r\n        # write your code here\r\n        ans = 0\r\n        for x in key:\r\n            ans = (ans * 33 + ord(x)) % HASH_SIZE\r\n        return ans\r\n"}]},{"id":220,"unique_name":"majority-number-iii","title":"主元素 III","description":"<p>给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的<font color=\"#e76363\"><b>1/k</b></font>。<br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @param k: As described\r\n     * @return: The majority number\r\n     */\r\n    public int majorityNumber(ArrayList<Integer> nums, int k) {\r\n        // count at most k keys.\r\n        HashMap<Integer, Integer> counters = new HashMap<Integer, Integer>();\r\n        for (Integer i : nums) {\r\n            if (!counters.containsKey(i)) {\r\n                counters.put(i, 1);\r\n            } else {\r\n                counters.put(i, counters.get(i) + 1);\r\n            }\r\n            \r\n            if (counters.size() >= k) {\r\n                removeKey(counters);\r\n            }\r\n        }\r\n        \r\n        // corner case\r\n        if (counters.size() == 0) {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n        \r\n        // recalculate counters\r\n        for (Integer i : counters.keySet()) {\r\n            counters.put(i, 0);\r\n        }\r\n        for (Integer i : nums) {\r\n            if (counters.containsKey(i)) {\r\n                counters.put(i, counters.get(i) + 1);\r\n            }\r\n        }\r\n        \r\n        // find the max key\r\n        int maxCounter = 0, maxKey = 0;\r\n        for (Integer i : counters.keySet()) {\r\n            if (counters.get(i) > maxCounter) {\r\n                maxCounter = counters.get(i);\r\n                maxKey = i;\r\n            }\r\n        }\r\n        \r\n        return maxKey;\r\n    }\r\n    \r\n    private void removeKey(HashMap<Integer, Integer> counters) {\r\n        Set<Integer> keySet = counters.keySet();\r\n        List<Integer> removeList = new ArrayList<>();\r\n        for (Integer key : keySet) {\r\n            counters.put(key, counters.get(key) - 1);\r\n            if (counters.get(key) == 0) {\r\n                removeList.add(key);\r\n            }\r\n        }\r\n        for (Integer key : removeList) {\r\n            counters.remove(key);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"struct Candidate{\n    int val;\n    int count;\n    Candidate(int x = 0, int y = 0): val(x), count(y){}\n};\n\nclass Solution {\npublic:\n    /**\n     * @param nums: A list of integers\n     * @param k: As described\n     * @return: The majority number\n     */\n    int majorityNumber(vector<int> nums, int k) {\n        // write your code here\n        if(nums.size() == 0) return -1;\n        \n        int n = nums.size();\n        vector<Candidate> m(k - 1, Candidate() );\n        for(int i = 0; i < n; i++){\n            int l;\n            for(l = 0; l < k - 1; l++){\n                if(m[l].val == nums[i]){\n                    m[l].count++;\n                    break;\n                }\n            }\n            if(l == k - 1){\n                \n                for(l = 0; l < k - 1; l++){\n                    if(m[l].count == 0){\n                        m[l].val = nums[i];\n                        m[l].count++;\n                        break;\n                    }\n                }\n                \n                if(l == k - 1){\n                    for(l = 0; l < k - 1; l++){\n                        m[l].count--;\n                    }\n                }\n            }\n        }\n        \n        for(int j = 0; j < k - 1; j++){\n            m[j].count = 0;\n        }\n        \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < k - 1; j++){\n                if(nums[i] == m[j].val){\n                    m[j].count++;\n                }\n                if(m[j].count > n / k) return m[j].val;\n            }\n        }\n        \n        return -1;\n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param nums: A list of integers\n    @param k: As described\n    @return: The majority number\n    \"\"\"\n    def majorityNumber(self, nums, k):\n        counts = {}\n        max = 0\n        for num in nums:\n            counts[num] = counts.get(num, 0) + 1\n            if counts[num] > max:\n                max = counts[num]\n                majority = num\n        return majority\n"}]},{"id":126,"unique_name":"longest-substring-without-repeating-characters","title":"最长无重复字符的子串","description":"给定一个字符串，请找出其中无重复字符的最长子字符串。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param s: a string\r\n     * @return: an integer \r\n     */\r\n     //方法一：\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int[] map = new int[256]; // map from character's ASCII to its last occured index\r\n        \r\n        int j = 0;\r\n        int i = 0;\r\n        int ans = 0;\r\n        for (i = 0; i < s.length(); i++) {\r\n            while (j < s.length() && map[s.charAt(j)]==0) {\r\n                map[s.charAt(j)] = 1;\r\n                ans = Math.max(ans, j-i + 1);\r\n                j ++;\r\n            }\r\n            map[s.charAt(i)] = 0;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        // 题意为求不包含重复字符的最长子串\r\n        // left用以记录合法的最远左边界位置，last记录字符上一次出现的位置\r\n        int ans = 0, left = 0, len = s.length();\r\n        int last[255];\r\n        memset(last, -1, sizeof last);\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            // 上次出现位置在当前记录边界之后，即该子串中出现了重复字符，需调整left使得子串合法\r\n            if (last[s[i]] >= left) left = last[s[i]] + 1;\r\n            last[s[i]] = i;\r\n            ans = max(ans, i - left + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    def lengthOfLongestSubstring(self, s):\r\n        ans = 0\r\n        # left用于记录合法的左边界位置，last用于记录字符上一次出现的位置\r\n        left = 0\r\n        last = {}\r\n        for i in range(len(s)):\r\n            # 子串中出现重复字符，变更left至上一次s[i]出现位置之后，使得子串合法\r\n            if s[i] in last and last[s[i]] >= left:\r\n                left = last[s[i]] + 1\r\n            last[s[i]] = i\r\n            ans = max(ans, i - left + 1)\r\n        return ans"}]},{"id":695,"unique_name":"missing-string","title":"缺少的字符串","description":"给出两个字符串，你需要找到缺少的字符串","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param : a given string\n     * @param : another given string\n     * @return: An array of missing string\n     */\n    public List<String> missingString(String str1, String str2) {\n        // Write your code here\n        List<String> res = new ArrayList<>();\n        if (str1.length() > str2.length()) {\n            String temp = str1;\n            str1 = str2;\n            str2 = temp;\n        }\n        \n        String[] arr1 = str1.split(\" \");\n        String[] arr2 = str2.split(\" \");\n        Set<String> set = new HashSet<>();\n        \n        for (String str : arr1) {\n            set.add(str);\n        }\n        \n        for (String str : arr2) {\n            if (!set.contains(str)) {\n                res.add(str);\n            }\n        }\n        \n        return res;\n    }\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: : a given string\n    @param: : another given string\n    @return: An array of missing string\n    \"\"\"\n\n    def missingString(self, str1, str2):\n        result = []\n        dict = set(str2.split())\n        \n        for word in str1.split():\n            if word not in dict:\n                result.append(word)\n                \n        return result"}]},{"id":610,"unique_name":"sort-integers-map-reduce","title":"排序(Map Reduce)","description":"通过Map Reduce框架对整数进行排序","solutions":[{"language":"java","code":"/**\r\n * Definition of OutputCollector:\r\n * class OutputCollector<K, V> {\r\n *     public void collect(K key, V value);\r\n *         // Adds a key/value pair to the output buffer\r\n * }\r\n */\r\nclass Element {\r\n    public int row, col, val;\r\n    Element(int row, int col, int val) {\r\n        this.row = row;\r\n        this.col = col;\r\n        this.val = val;\r\n    }\r\n}\r\n\r\npublic class SortIntegers {\r\n\r\n    public static class Map {\r\n        public void map(int _, List<Integer> value,\r\n                        OutputCollector<String, List<Integer>> output) {\r\n            // Write your code here\r\n            // Output the results into output buffer.\r\n            // Ps. output.collect(String key, List<Integer> value);\r\n            Collections.sort(value);\r\n            output.collect(\"ignore_key\", value);\r\n        }\r\n    }\r\n        \r\n    public static class Reduce {\r\n        public void reduce(String key, List<List<Integer>> values,\r\n                           OutputCollector<String, List<Integer>> output) {\r\n            // Write your code here\r\n            // Output the results into output buffer.\r\n            // Ps. output.collect(String key, List<Integer> value);\r\n            List<Integer> results = new ArrayList<Integer>();\r\n            if (values.size() == 0) {\r\n                output.collect(key, results);\r\n                return;\r\n            }\r\n        \r\n            int total_size = 0;\r\n\r\n            Comparator<Element> ElementComparator = new Comparator<Element>() {\r\n                public int compare(Element left, Element right) {\r\n                    return left.val - right.val;\r\n                }\r\n            };\r\n\r\n            Queue<Element> Q = new PriorityQueue<Element>(\r\n                values.size(), ElementComparator);\r\n            \r\n            int k = values.size();\r\n            for (int i = 0; i < k; i++) {\r\n                if (values.get(i).size() > 0) {\r\n                    Element elem = new Element(i, 0, values.get(i).get(0));\r\n                    Q.add(elem);\r\n                }\r\n            }\r\n        \r\n            while (!Q.isEmpty()) {\r\n                Element elem = Q.poll();\r\n                results.add(elem.val);\r\n                if (elem.col + 1 < values.get(elem.row).size()) {\r\n                    elem.col += 1;\r\n                    elem.val = values.get(elem.row).get(elem.col);\r\n                    Q.add(elem);\r\n                }\r\n            }\r\n        \r\n            output.collect(key, results);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of Input:\r\n * template<class T>\r\n * class Input {\r\n * public:\r\n *     bool done(); \r\n *         // Returns true if the iteration has elements or false.\r\n *     void next();\r\n *         // Move to the next element in the iteration\r\n *         // Runtime error if the iteration has no more elements\r\n *     T value();\r\n *        // Get the current element, Runtime error if\r\n *        // the iteration has no more elements\r\n * }\r\n */\r\nclass SortIntegersMapper: public Mapper {\r\npublic:\r\n    void Map(int _, Input<vector<int>>* input) {\r\n        // Write your code here\r\n        // Please directly use func 'output' to output \r\n        // the results into output buffer.\r\n        // void output(string &key, vector<int>& value);\r\n        while (!input->done()) {\r\n            vector<int> value = input->value();\r\n            sort(value.begin(), value.end());\r\n            output(\"ignore_key\", value);\r\n            input->next();\r\n        }\r\n    }\r\n};\r\n\r\nclass Node {\r\npublic:\r\n    int row, col, val;\r\n    Node(int _r, int _c, int _v): row(_r), col(_c), val(_v){};\r\n    bool operator < (const Node& obj) const {\r\n        return val > obj.val;\r\n    }\r\n};\r\n\r\nclass SortIntegersReducer: public Reducer {\r\npublic:\r\n    void Reduce(string &key, vector<vector<int>>& input) {\r\n        // Write your code here\r\n        // Please directly use func 'output' to output \r\n        // the results into output buffer.\r\n        // void output(string &key, vector<int>& value);\r\n        vector<int> results;\r\n        if (input.size() == 0) {\r\n            output(key, results);\r\n            return;\r\n        }\r\n\r\n        int k = input.size();\r\n        priority_queue<Node> queue;\r\n\r\n        for (int i = 0; i < k; ++i) {\r\n            if (input[i].size() > 0)\r\n                queue.push(Node(i, 0, input[i][0]));\r\n        }\r\n\r\n        while (!queue.empty()) {\r\n            Node temp = queue.top();\r\n            queue.pop();\r\n            int row = temp.row;\r\n            int col = temp.col;\r\n            int val = temp.val;\r\n            results.push_back(val);\r\n            if (col + 1 < input[row].size())\r\n                queue.push(Node(row, col + 1, input[row][col + 1]));\r\n        }\r\n\r\n        output(key, results);\r\n    }\r\n};"},{"language":"python","code":"class SortIntegers:\r\n\r\n    # @param {int[]} nums a list of integer\r\n    def mapper(self, _, nums):\r\n        # Write your code here\r\n        # Please use 'yield key, value' here\r\n        for num in nums:\r\n            yield num / 10000, num\r\n\r\n\r\n    # @param key is from mapper\r\n    # @param values is a set of value with the same key\r\n    def reducer(self, key, values):\r\n        # Write your code here\r\n        # Please use 'yield key, value' here\r\n        values.sort()\r\n        yield key, values"}]},{"id":360,"unique_name":"word-count","title":"单词计数 (Map Reduce版本)","description":"使用 map reduce 来计算单词频率\r\nhttps://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html#Example%3A+WordCount+v1.0\r\n","solutions":[{"language":"java","code":"/**\r\n * Definition of OutputCollector:\r\n * class OutputCollector<K, V> {\r\n *     public void collect(K key, V value);\r\n *         // Adds a key/value pair to the output buffer\r\n * }\r\n */\r\npublic class WordCount {\r\n\r\n    public static class Map {\r\n        public void map(String key, String value, OutputCollector<String, Integer> output) {\r\n            // Write your code here\r\n            // Output the results into output buffer.\r\n            // Ps. output.collect(String key, int value);\r\n            StringTokenizer tokenizer = new StringTokenizer(value);\r\n            while (tokenizer.hasMoreTokens()) {\r\n                String word = tokenizer.nextToken();\r\n                output.collect(word, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static class Reduce {\r\n        public void reduce(String key, Iterator<Integer> values,\r\n                           OutputCollector<String, Integer> output) {\r\n            // Write your code here\r\n            // Output the results into output buffer.\r\n            // Ps. output.collect(String key, int value);\r\n            int sum = 0;\r\n            while (values.hasNext()) {\r\n                    sum += values.next();\r\n            }\r\n            output.collect(key, sum);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of Input:\r\n * template<class T>\r\n * class Input {\r\n * public:\r\n *     bool done(); \r\n *         // Returns true if the iteration has elements or false.\r\n *     void next();\r\n *         // Move to the next element in the iteration\r\n *         // Runtime error if the iteration has no more elements\r\n *     T value();\r\n *        // Get the current element, Runtime error if\r\n *        // the iteration has no more elements\r\n * }\r\n */\r\nclass WordCountMapper: public Mapper {\r\npublic:\r\n    void Map(Input<string>* input) {\r\n        // Write your code here\r\n        // Please directly use func 'output' to \r\n        // output the results into output buffer.\r\n        // void output(string &key, int value);\r\n        while (!input->done()) {\r\n            vector<string> words = split(input->value(), \" \");\r\n            for (string word : words) {\r\n                output(word, 1);\r\n            }\r\n            input->next();\r\n        }\r\n    }\r\n\r\n    vector<string> split(const string &str, string delim) {\r\n        vector<string> results;\r\n        int lastIndex = 0, index;\r\n        while ((index = str.find(delim, lastIndex)) != string::npos) {\r\n            results.push_back(str.substr(lastIndex, index - lastIndex));\r\n            lastIndex = index + delim.length();\r\n        }\r\n        if (lastIndex != str.length()) {\r\n            results.push_back(str.substr(lastIndex, str.length() - lastIndex));\r\n        }\r\n        return results;\r\n    }\r\n};\r\n\r\n\r\nclass WordCountReducer: public Reducer {\r\npublic:\r\n    void Reduce(string &key, Input<int>* input) {\r\n        // Write your code here\r\n        // Please directly use func 'output' to \r\n        // output the results into output buffer.\r\n        // void output(string &key, int value);\r\n        int sum = 0;\r\n        while (!input->done()) {\r\n            sum += input->value();\r\n            input->next();\r\n        }\r\n        output(key, sum);\r\n    }\r\n};"},{"language":"python","code":"class WordCount:\n\n    def mapper(self, _, line):\n        # Write your code here\n        for word in line.split():\n            yield word, 1\n\n\n    def reducer(self, key, values):\n        # Write your code here\n        yield key, sum(values)"}]},{"id":451,"unique_name":"swap-two-nodes-in-linked-list","title":"交换链表当中两个节点","description":"给你一个链表以及两个权值`v1`和`v2`，交换链表中权值为`v1`和`v2`的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。","solutions":[{"language":"java","code":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @oaram v1 an integer\r\n     * @param v2 an integer\r\n     * @return a new head of singly-linked list\r\n     */\r\n    public ListNode swapNodes(ListNode head, int v1, int v2) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        ListNode node1Prev = null, node2Prev = null;\r\n        ListNode cur = dummy;\r\n        while (cur.next != null) {\r\n            if (cur.next.val == v1) {\r\n                node1Prev = cur;\r\n            } else if (cur.next.val == v2) {\r\n                node2Prev = cur;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        \r\n        if (node1Prev == null || node2Prev == null) {\r\n            return head;\r\n        }\r\n        \r\n        if (node2Prev.next == node1Prev) {\r\n            // make sure node2Prev.next is not node1Prev\r\n            ListNode t = node1Prev;\r\n            node1Prev = node2Prev;\r\n            node2Prev = t;\r\n        }\r\n        \r\n        ListNode node1 = node1Prev.next;\r\n        ListNode node2 = node2Prev.next;\r\n        ListNode node2Next = node2.next;\r\n        if (node1Prev.next == node2Prev) {\r\n            node1Prev.next = node2;\r\n            node2.next = node1;\r\n            node1.next = node2Next;\r\n        } else {\r\n            node1Prev.next = node2;\r\n            node2.next = node1.next;\r\n            \r\n            node2Prev.next = node1;\r\n            node1.next = node2Next;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @oaram v1 an integer\r\n     * @param v2 an integer\r\n     * @return a new head of singly-linked list\r\n     */\r\n    public ListNode swapNodes(ListNode head, int v1, int v2) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        ListNode node1Prev = null, node2Prev = null;\r\n        ListNode cur = dummy;\r\n        while (cur.next != null) {\r\n            if (cur.next.val == v1) {\r\n                node1Prev = cur;\r\n            } else if (cur.next.val == v2) {\r\n                node2Prev = cur;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n        \r\n        if (node1Prev == null || node2Prev == null) {\r\n            return head;\r\n        }\r\n        \r\n        if (node2Prev.next == node1Prev) {\r\n            // make sure node2Prev.next is not node1Prev\r\n            ListNode t = node1Prev;\r\n            node1Prev = node2Prev;\r\n            node2Prev = t;\r\n        }\r\n        \r\n        ListNode node1 = node1Prev.next;\r\n        ListNode node2 = node2Prev.next;\r\n        ListNode node2Next = node2.next;\r\n        if (node1Prev.next == node2Prev) {\r\n            node1Prev.next = node2;\r\n            node2.next = node1;\r\n            node1.next = node2Next;\r\n        } else {\r\n            node1Prev.next = node2;\r\n            node2.next = node1.next;\r\n            \r\n            node2Prev.next = node1;\r\n            node1.next = node2Next;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}"},{"language":"python","code":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    # @param {ListNode} head, a ListNode\r\n    # @oaram {int} v1 an integer\r\n    # @param {int} v2 an integer\r\n    # @return {ListNode} a new head of singly-linked list\r\n    def swapNodes(self, head, v1, v2):\r\n        if head is None:\r\n            return None\r\n            \r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        \r\n        prev1, prev2 = self.findPrevs(dummy, v1, v2)\r\n        \r\n        if prev1 is None or prev2 is None:\r\n            return head\r\n            \r\n        if prev1 == prev2:\r\n            return head\r\n            \r\n        if prev1.next == prev2:\r\n            self.swapAdjcent(prev1)\r\n        elif prev2.next == prev1:\r\n            self.swapAdjcent(prev2)\r\n        else:\r\n            self.swapRemote(prev1, prev2)\r\n            \r\n        return dummy.next\r\n    \r\n    # head->...->prev1->v1->...->prev2->v2...\r\n    # return prev1 & prev2\r\n    def findPrevs(self, dummy, v1, v2):\r\n        prev1, prev2 = None, None\r\n        \r\n        node = dummy\r\n        while node.next is not None:\r\n            if node.next.val == v1:\r\n                prev1 = node\r\n            if node.next.val == v2:\r\n                prev2 = node\r\n            node = node.next\r\n        return prev1, prev2\r\n            \r\n    # dummy->head->..->prev->node1->node2->post...\r\n    # swap node1 & node2\r\n    def swapAdjcent(self, prev):\r\n        node1 = prev.next\r\n        node2 = node1.next\r\n        post = node2.next\r\n        \r\n        prev.next = node2\r\n        node2.next = node1\r\n        node1.next = post\r\n    \r\n    # dummy->head->..->prev1->node1->post1->...->prev2->node2->post2...\r\n    # swap node1 & node2\r\n    def swapRemote(self, prev1, prev2):\r\n        node1 = prev1.next\r\n        post1 = node1.next\r\n        \r\n        node2 = prev2.next\r\n        post2 = node2.next\r\n        \r\n        prev1.next = node2\r\n        node2.next = post1\r\n        \r\n        prev2.next = node1\r\n        node1.next = post2"}]},{"id":197,"unique_name":"remove-linked-list-elements","title":"删除链表中的元素","description":"删除链表中等于给定值`val`的所有节点。","solutions":[{"language":"java","code":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @param val an integer\r\n     * @return a ListNode\r\n     */\r\n    public ListNode removeElements(ListNode head, int val) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        head = dummy;\r\n        \r\n        while (head.next != null) {\r\n            if (head.next.val == val) {\r\n                head.next = head.next.next;\r\n            } else {\r\n                head = head.next;\r\n            }\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    /**\n     * @param head a ListNode\n     * @param val an integer\n     * @return a ListNode\n     */\n    ListNode *removeElements(ListNode *head, int val) {\n        ListNode dummy;\n        dummy.next = head;\n        head = &dummy;\n        \n        while (head->next != NULL) {\n            if (head->next->val == val) {\n                head->next = head->next->next;\n            } else {\n                head = head->next;\n            }\n        }\n        \n        return dummy.next;\n    }\n};\n"},{"language":"python","code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @param val, an integer\n    # @return a ListNode\n    def removeElements(self, head, val):\n        # Write your code here\n        if head == None:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        while head:\n            if head.val == val:\n                pre.next = head.next\n                head = pre\n            pre = head\n            head = head.next\n        return dummy.next                \n"}]},{"id":106,"unique_name":"swap-nodes-in-pairs","title":"两两交换链表中的节点","description":"给一个链表，两两交换其中的节点，然后返回交换后的链表。","solutions":[{"language":"java","code":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @return a ListNode\r\n     */\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        head = dummy;\r\n        while (head.next != null && head.next.next != null) {\r\n            ListNode n1 = head.next, n2 = head.next.next;\r\n            // head->n1->n2->...\r\n            // => head->n2->n1->...\r\n            head.next = n2;\r\n            n1.next = n2.next;\r\n            n2.next = n1;\r\n            \r\n            // move to next pair\r\n            head = n1;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    /**\n     * @param head a ListNode\n     * @return a ListNode\n     */\n    ListNode* swapPairs(ListNode* head) {\n        // Write your code here\n        if(head==NULL || head->next==NULL) return head;\n        ListNode *helper=new ListNode(0);\n        ListNode *ret=head;\n        ListNode *cur=helper;\n        while(ret  && ret->next) {\n            ListNode *next=ret->next->next;\n            cur->next=ret->next;\n            cur=cur->next;\n            cur->next=ret;\n            cur=cur->next;\n            cur->next=NULL;\n            ret=next;\n        }\n        if(ret) cur->next=ret;\n        return helper->next;\n    }\n};\n"},{"language":"python","code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def swapPairs(self, head):\n        # Write your code here\n        if head == None or head.next == None:\n            return head\n        dummy = ListNode(0); dummy.next = head\n        p = dummy\n        while p.next and p.next.next:\n            tmp = p.next.next\n            p.next.next = tmp.next\n            tmp.next = p.next\n            p.next = tmp\n            p = p.next.next\n        return dummy.next\n"}]},{"id":300,"unique_name":"palindrome-linked-list","title":"回文链表","description":"设计一种方式检查一个链表是否为回文链表。","solutions":[{"language":"java","code":"// This code would destroy the original structure of the linked list.\r\n// If you do not want to destroy the structure, you can reserve the second part back.\r\npublic class Solution {\r\n    /**\r\n     * @param head a ListNode\r\n     * @return a boolean\r\n     */\r\n    public boolean isPalindrome(ListNode head) {\r\n        if (head == null) {\r\n            return true;\r\n        }\r\n        \r\n        ListNode middle = findMiddle(head);\r\n        middle.next = reverse(middle.next);\r\n        \r\n        ListNode p1 = head, p2 = middle.next;\r\n        while (p1 != null && p2 != null && p1.val == p2.val) {\r\n            p1 = p1.next;\r\n            p2 = p2.next;\r\n        }\r\n        \r\n        return p2 == null;\r\n    }\r\n    \r\n    private ListNode findMiddle(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n    \r\n    private ListNode reverse(ListNode head) {\r\n        ListNode prev = null;\r\n        \r\n        while (head != null) {\r\n            ListNode temp = head.next;\r\n            head.next = prev;\r\n            prev = head;\r\n            head = temp;\r\n        }\r\n        \r\n        return prev;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isPalindrome(ListNode* head) {\r\n        if (head == NULL || head ->next == NULL) {\r\n            return true;\r\n        }\r\n        ListNode* mid = findmid(head);\r\n        mid->next = reverse(mid->next);\r\n        mid = mid->next;\r\n        while(head!=NULL && mid!=NULL) {\r\n            if(head->val != mid->val) {\r\n                return false;\r\n            }\r\n            head = head->next;\r\n            mid = mid->next;\r\n        }\r\n        return true;\r\n    }\r\n    ListNode * findmid(ListNode * now) {\r\n        ListNode* slow = now;\r\n        ListNode* fast = now ->next;\r\n        while(fast != NULL && fast->next != NULL) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n    ListNode * reverse(ListNode *now) {\r\n        ListNode * pre = NULL;\r\n        while(now!=NULL) {\r\n            ListNode *temp = now->next;\r\n            now->next = pre;\r\n            pre = now;\r\n            now = temp;\r\n        }\r\n        return pre;\r\n    }\r\n};"},{"language":"python","code":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    # @param head, a ListNode\r\n    # @return a boolean\r\n    def isPalindrome(self, head):\r\n        # Write your code here\r\n        if head is None:\r\n            return True\r\n\r\n        fast = slow = head\r\n        while fast.next and fast.next.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        p, last = slow.next, None\r\n        while p:\r\n            next = p.next\r\n            p.next = last\r\n            last, p = p, next\r\n\r\n        p1, p2 = last, head\r\n        while p1 and p1.val == p2.val:\r\n            p1, p2 = p1.next, p2.next\r\n\r\n        p, last = last, None\r\n        while p:\r\n            next = p.next\r\n            p.next = last\r\n            last, p = p, next\r\n            slow.next = last\r\n        return p1 is None\r\n"}]},{"id":414,"unique_name":"delete-node-in-the-middle-of-singly-linked-list","title":"在O(1)时间复杂度删除链表节点","description":"给定一个单链表中的一个等待被删除的节点(非表头或表尾)。请在在O(1)时间复杂度删除该链表节点。","solutions":[{"language":"java","code":"/**\r\n * Definition for ListNode.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int val) {\r\n *         this.val = val;\r\n *         this.next = null;\r\n *     }\r\n * }\r\n */ \r\npublic class Solution {\r\n    /**\r\n     * @param node: the node in the list should be deleted\r\n     * @return: nothing\r\n     */\r\n    public void deleteNode(ListNode node) {\r\n        // write your code here\r\n        if (node == null || node.next == null)\r\n            return;\r\n        ListNode next = node.next;\r\n        node.val = next.val;\r\n        node.next = next.next;\r\n        return;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param node: a node in the list should be deleted\r\n     * @return: nothing\r\n     */\r\n    void deleteNode(ListNode *node) {\r\n        // write your code here\r\n        if (node == NULL || node->next == NULL)\r\n            return;\r\n        ListNode* next = node->next;\r\n        node->val = next->val;\r\n        node->next = next->next;\r\n        return;\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of ListNode\r\nclass ListNode(object):\r\n\r\n    def __init__(self, val, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\"\"\"\r\nclass Solution:\r\n    # @param node: the node in the list should be deleted\r\n    # @return: nothing\r\n    def deleteNode(self, node):\r\n        # write your code here\r\n        if node is None or node.next is None:\r\n            return\r\n        next = node.next;\r\n        node.val = next.val\r\n        node.next = next.next\r\n        return"}]},{"id":302,"unique_name":"intersection-of-two-linked-lists","title":"两个链表的交叉","description":"请写一个程序，找到两个单链表最开始的交叉节点。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param headA: the first list\r\n     * @param headB: the second list\r\n     * @return: a ListNode \r\n     */\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        \r\n        // get the tail of list A.\r\n        ListNode node = headA;\r\n        while (node.next != null) {\r\n            node = node.next;\r\n        }\r\n        node.next = headB;\r\n        ListNode result = listCycleII(headA);\r\n        node.next = null;\r\n        return result;\r\n    }\r\n    \r\n    private ListNode listCycleII(ListNode head) {\r\n        ListNode slow = head, fast = head.next;\r\n        \r\n        while (slow != fast) {\r\n            if (fast == null || fast.next == null) {\r\n                return null;\r\n            }\r\n            \r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        slow = head;\r\n        fast = fast.next;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    /**\n     * @param headA: the first list\n     * @param headB: the second list\n     * @return: a ListNode\n     */\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // write your code here\n        if(headA == NULL || headB == NULL)\n            return NULL;\n        ListNode* iter1 = headA;\n        ListNode* iter2 = headB;\n        int len1 = 1;\n        while(iter1->next != NULL)\n        {\n            iter1 = iter1->next;\n            len1 ++;\n        }\n        int len2 = 1;\n        while(iter2->next != NULL)\n        {\n            iter2 = iter2->next;\n            len2 ++;\n        }\n        if(iter1 != iter2)\n            return NULL;\n        if(len1 > len2)\n        {\n            for(int i = 0; i < len1-len2; i ++)\n                headA = headA->next;\n        }\n        else if(len2 > len1)\n        {\n            for(int i = 0; i < len2-len1; i ++)\n                headB = headB->next;\n        }\n        while(headA != headB)\n        {\n            headA = headA->next;\n            headB = headB->next;\n        }\n        return headA;\n    }\n};\n"},{"language":"python","code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    # @param headA: the first list\n    # @param headB: the second list\n    # @return: a ListNode\n    def getIntersectionNode(self, headA, headB):\n        # Write your code here\n        lenA, lenB = 0, 0\n        node1, node2 = headA, headB\n        while node1 is not None:\n            lenA += 1\n            node1 = node1.next\n        while node2 is not None:\n            lenB += 1\n            node2 = node2.next\n        \n        node1, node2 = headA, headB\n        while lenA > lenB:\n            node1 = node1.next\n            lenA -= 1\n        while lenB > lenA:\n            node2 = node2.next\n            lenB -=1\n        while node1 is not node2:\n            node1 = node1.next\n            node2 = node2.next\n        return node1"}]},{"id":435,"unique_name":"nth-to-last-node-in-list","title":"链表倒数第n个节点","description":"<p>找到单链表倒数第n个节点，保证链表中节点的最少数量为n。</p>","solutions":[{"language":"java","code":"/**\n * Definition for ListNode.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int val) {\n *         this.val = val;\n *         this.next = null;\n *     }\n * }\n */ \npublic class Solution {\n    /**\n     * @param head: The first node of linked list.\n     * @param n: An integer.\n     * @return: Nth to last node of a singly linked list. \n     */\n    ListNode nthToLast(ListNode head, int n) {\n        if (head == null || n < 1) {\n            return null;\n        }\n\t\n        ListNode p1 = head;\n        ListNode p2 = head;\n        for (int j = 0; j < n - 1; ++j) {\n            if (p2 == null) {\n                return null;\n            }\n            p2 = p2.next;\n        }\n        while (p2.next != null) {   \n            p1 = p1.next;   \n            p2 = p2.next;\n\t    }\n\t    return p1;\n    }\n}\n\n"},{"language":"cpp","code":"/**\n * Definition of ListNode\n * class ListNode {\n * public:\n *     int val;\n *     ListNode *next;\n *     ListNode(int val) {\n *         this->val = val;\n *         this->next = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param head: The first node of linked list.\n     * @param n: An integer.\n     * @return: Nth to last node of a singly linked list. \n     */\n    ListNode *nthToLast(ListNode *head, int n) {\n        if (head == NULL|| n < 1) {\n            return NULL;\n        }\n\t\n        ListNode *p1 = head;\n        ListNode *p2 = head;\n        for (int j = 0; j < n - 1; ++j) {\n            if (p2 == NULL) {\n                return NULL;\n            }\n            p2 = p2->next;\n        }\n        while (p2->next != NULL) {   \n            p1 = p1->next;   \n            p2 = p2->next;\n\t    }\n\t    return p1;\n    }\n};\n\n\n\n"},{"language":"python","code":"\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param head: The first node of linked list.\n    @param n: An integer.\n    @return: Nth to last node of a singly linked list. \n    \"\"\"\n    def nthToLast(self, head, n):\n        if head is None or n < 1:\n            return None\n        cur = head.next\n        while cur is not None:\n            cur.pre = head\n            cur = cur.next\n            head = head.next\n        n -= 1\n        while n > 0:\n            head = head.pre\n            n -= 1\n        return head"}]},{"id":7,"unique_name":"sort-list","title":"链表排序","description":"在 O(*n* log *n*) 时间复杂度和常数级的空间复杂度下给链表排序。\r\n","solutions":[{"language":"java","code":"// version 1: Merge Sort\r\npublic class Solution {            \r\n    private ListNode findMiddle(ListNode head) {\r\n        ListNode slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }    \r\n\r\n    private ListNode merge(ListNode head1, ListNode head2) {\r\n        ListNode dummy = new ListNode(0);\r\n        ListNode tail = dummy;\r\n        while (head1 != null && head2 != null) {\r\n            if (head1.val < head2.val) {\r\n                tail.next = head1;\r\n                head1 = head1.next;\r\n            } else {\r\n                tail.next = head2;\r\n                head2 = head2.next;\r\n            }\r\n            tail = tail.next;\r\n        }\r\n        if (head1 != null) {\r\n            tail.next = head1;\r\n        } else {\r\n            tail.next = head2;\r\n        }\r\n\r\n        return dummy.next;\r\n    }\r\n\r\n    public ListNode sortList(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode mid = findMiddle(head);\r\n\r\n        ListNode right = sortList(mid.next);\r\n        mid.next = null;\r\n        ListNode left = sortList(head);\r\n\r\n        return merge(left, right);\r\n    }\r\n}\r\n\r\n// version 2: Quick Sort 1\r\npublic class Solution {\r\n    public ListNode sortList(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode mid = findMedian(head); // O(n)\r\n        \r\n        ListNode leftDummy = new ListNode(0), leftTail = leftDummy;\r\n        ListNode rightDummy = new ListNode(0), rightTail = rightDummy;\r\n        ListNode middleDummy = new ListNode(0), middleTail = middleDummy;\r\n        while (head != null) {\r\n            if (head.val < mid.val) {\r\n                leftTail.next = head;\r\n                leftTail = head;\r\n            } else if (head.val > mid.val) {\r\n                rightTail.next = head;\r\n                rightTail = head;\r\n            } else {\r\n                middleTail.next = head;\r\n                middleTail = head;\r\n            }\r\n            head = head.next;\r\n        }\r\n        \r\n        leftTail.next = null;\r\n        middleTail.next = null;\r\n        rightTail.next = null;\r\n        \r\n        ListNode left = sortList(leftDummy.next);\r\n        ListNode right = sortList(rightDummy.next);\r\n        \r\n        return concat(left, middleDummy.next, right);\r\n    }\r\n    \r\n    private ListNode findMedian(ListNode head) {\r\n        ListNode slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    }\r\n    \r\n    private ListNode concat(ListNode left, ListNode middle, ListNode right) {\r\n        ListNode dummy = new ListNode(0), tail = dummy;\r\n        \r\n        tail.next = left; tail = getTail(tail);\r\n        tail.next = middle; tail = getTail(tail);\r\n        tail.next = right; tail = getTail(tail);\r\n        return dummy.next;\r\n    }\r\n    \r\n    private ListNode getTail(ListNode head) {\r\n        if (head == null) {\r\n           return null;\r\n        } \r\n       \r\n        while (head.next != null) {\r\n            head = head.next;\r\n        }\r\n        return head;\r\n    }\r\n}\r\n\r\n// version 3: Quick Sort 2\r\n/**\r\n * Definition for ListNode.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int val) {\r\n *         this.val = val;\r\n *         this.next = null;\r\n *     }\r\n * }\r\n */ \r\nclass Pair {\r\n    public ListNode first, second; \r\n    public Pair(ListNode first, ListNode second) {\r\n        this.first = first;\r\n        this.second = second;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param head: The head of linked list.\r\n     * @return: You should return the head of the sorted linked list,\r\n                    using constant space complexity.\r\n     */\r\n    public ListNode sortList(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode mid = findMedian(head); // O(n)\r\n        Pair pair = partition(head, mid.val); // O(n)\r\n        \r\n        ListNode left = sortList(pair.first);\r\n        ListNode right = sortList(pair.second);\r\n        \r\n        getTail(left).next = right; // O(n)\r\n        \r\n        return left;\r\n    }\r\n    \r\n    // 1->2->3 return 2\r\n    // 1->2 return 1\r\n    private ListNode findMedian(ListNode head) {\r\n        ListNode slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    }\r\n    \r\n    // < value in the left, > value in the right\r\n    private Pair partition(ListNode head, int value) {\r\n        ListNode leftDummy = new ListNode(0), leftTail = leftDummy;\r\n        ListNode rightDummy = new ListNode(0), rightTail = rightDummy;\r\n        ListNode equalDummy = new ListNode(0), equalTail = equalDummy;\r\n        while (head != null) {\r\n            if (head.val < value) {\r\n                leftTail.next = head;\r\n                leftTail = head;\r\n            } else if (head.val > value) {\r\n                rightTail.next = head;\r\n                rightTail = head;\r\n            } else {\r\n                equalTail.next = head;\r\n                equalTail = head;\r\n            }\r\n            head = head.next;\r\n        }\r\n        \r\n        leftTail.next = null;\r\n        rightTail.next = null;\r\n        equalTail.next = null;\r\n        \r\n        if (leftDummy.next == null && rightDummy.next == null) {\r\n            ListNode mid = findMedian(equalDummy.next);\r\n            leftDummy.next = equalDummy.next;\r\n            rightDummy.next = mid.next;\r\n            mid.next = null;\r\n        } else if (leftDummy.next == null) {\r\n            leftTail.next = equalDummy.next;\r\n        } else {\r\n            rightTail.next = equalDummy.next;\r\n        }\r\n        \r\n        return new Pair(leftDummy.next, rightDummy.next);\r\n    }\r\n    \r\n    private ListNode getTail(ListNode head) {\r\n        if (head == null) {\r\n           return null;\r\n        } \r\n       \r\n        while (head.next != null) {\r\n            head = head.next;\r\n        }\r\n        return head;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: The first node of linked list.\r\n     * @return: You should return the head of the sorted linked list,\r\n                    using constant space complexity.\r\n     */\r\n    ListNode *sortList(ListNode *head) {\r\n        // write your code here\r\n        if(head == NULL) return head;\r\n        if(head -> next == NULL){\r\n            return head;\r\n        }\r\n        \r\n        ListNode* fast = head;\r\n        ListNode* slow = head;\r\n        while(fast -> next != NULL && fast -> next -> next != NULL){\r\n            fast = fast -> next;\r\n            fast = fast -> next;\r\n            slow = slow -> next;\r\n        }\r\n        \r\n        ListNode* mid = slow -> next;\r\n        slow -> next = NULL;\r\n        \r\n        ListNode* list1 = sortList(head);\r\n        ListNode* list2 = sortList(mid);\r\n        \r\n        ListNode* sorted = merge(list1 , list2);\r\n        return sorted;\r\n    }\r\n    ListNode* merge(ListNode* list1 , ListNode* list2){\r\n        if(list1 == NULL) return list2;\r\n        if(list2 == NULL) return list1;\r\n        \r\n        ListNode* head;\r\n        ListNode* tmp;\r\n        \r\n        if(list1 -> val < list2 -> val){\r\n            head = list1;\r\n            list1 = list1 -> next;\r\n        }else{\r\n            head = list2;\r\n            list2 = list2 -> next;\r\n        }\r\n        tmp = head;\r\n        \r\n        while(list1 != NULL && list2 != NULL){\r\n            if(list1 -> val < list2 -> val){\r\n                tmp -> next = list1;\r\n                tmp = list1;\r\n                list1 = list1 -> next;\r\n            }else{\r\n                tmp -> next = list2;\r\n                tmp = list2;\r\n                list2 = list2 -> next;\r\n            }\r\n        }\r\n        if(list1 != NULL) tmp -> next = list1;\r\n        if(list2 != NULL) tmp -> next = list2;\r\n        \r\n        return head;\r\n    }\r\n};\r\n\r\n\r\n\r\n"},{"language":"python","code":"from lintcode import ListNode\r\n\r\n\"\"\"\r\nDefinition of ListNode\r\nclass ListNode(object):\r\n\r\n    def __init__(self, val, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param head: The first node of the linked list.\r\n    @return: You should return the head of the sorted linked list,\r\n                  using constant space complexity.\r\n    \"\"\"\r\n    def sortList(self, head):\r\n        # write your code here\r\n        def merge(list1,list2):\r\n            if list1 == None:\r\n                return list2\r\n            if list2 == None:\r\n                return list1\r\n        \r\n            head = None\r\n            \r\n            if list1.val < list2.val:\r\n                head = list1\r\n                list1 = list1.next\r\n            else:\r\n                head = list2;\r\n                list2 = list2.next;\r\n            \r\n            tmp = head\r\n        \r\n            while list1 != None and list2 != None:\r\n                if list1.val < list2.val:\r\n                    tmp.next = list1\r\n                    tmp = list1\r\n                    list1 = list1.next\r\n                else:\r\n                    tmp.next = list2\r\n                    tmp = list2\r\n                    list2 = list2.next\r\n            \r\n            if list1 != None :\r\n                tmp.next = list1;\r\n            if list2 != None :\r\n                tmp.next = list2;\r\n            \r\n            return head;\r\n            \r\n        if head == None:\r\n            return head\r\n        if head.next == None:\r\n            return head\r\n            \r\n        fast = head\r\n        slow = head\r\n        \r\n        while fast.next != None and fast.next.next != None:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        mid = slow.next\r\n        slow.next = None\r\n        \r\n        list1 = self.sortList(head)\r\n        list2 = self.sortList(mid)\r\n        \r\n        sorted = merge(list1,list2)\r\n        \r\n        return sorted\r\n    \r\n    "}]},{"id":110,"unique_name":"remove-nth-node-from-end-of-list","title":"删除链表中倒数第n个节点","description":"<p><span style=\"line-height: 1.42857143;\">给定一个链表，删除链表中倒数第n个节点，返回链表的头节点。</span><br></p><p><br></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public ListNode removeNthFromEnd(ListNode head, int n) {\r\n        if (n <= 0) {\r\n            return null;\r\n        }\r\n        \r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        ListNode preDelete = dummy;\r\n        for (int i = 0; i < n; i++) {\r\n            if (head == null) {\r\n                return null;\r\n            }\r\n            head = head.next;\r\n        }\r\n        while (head != null) {\r\n            head = head.next;\r\n            preDelete = preDelete.next;\r\n        }\r\n        preDelete.next = preDelete.next.next;\r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n    题意：删除链表中倒数第n个结点，尽量只扫描一遍。\r\n    使用两个指针扫描，当第一个指针扫描到第N个结点后，\r\n    第二个指针从表头与第一个指针同时向后移动，\r\n    当第一个指针指向空节点时，另一个指针就指向倒数第n个结点了\r\n    */\r\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\r\n        ListNode *res = new ListNode(0);\r\n        res->next = head;\r\n        ListNode *tmp = res;\r\n        for (int i = 0; i < n; i++) {\r\n            head = head->next;\r\n        }\r\n        while (head != NULL) {\r\n            head = head->next;\r\n            tmp = tmp->next;\r\n        }\r\n        tmp->next = tmp->next->next;\r\n        return res->next;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    '''\r\n    题意：删除链表中倒数第n个结点，尽量只扫描一遍。\r\n    使用两个指针扫描，当第一个指针扫描到第N个结点后，\r\n    第二个指针从表头与第一个指针同时向后移动，\r\n    当第一个指针指向空节点时，另一个指针就指向倒数第n个结点了       \r\n    '''\r\n    def removeNthFromEnd(self, head, n):\r\n        res = ListNode(0)\r\n        res.next = head\r\n        tmp = res\r\n        for i in range(0, n):\r\n            head = head.next\r\n        while head != None:\r\n            head = head.next\r\n            tmp = tmp.next\r\n        tmp.next = tmp.next.next\r\n        return res.next"}]},{"id":8,"unique_name":"insertion-sort-list","title":"链表插入排序","description":"用插入排序对链表排序","solutions":[{"language":"java","code":"public class Solution {\r\n    public ListNode insertionSortList(ListNode head) {\r\n        ListNode dummy = new ListNode(0);\r\n        // 这个dummy的作用是，把head开头的链表一个个的插入到dummy开头的链表里\r\n        // 所以这里不需要dummy.next = head;\r\n\r\n        while (head != null) {\r\n            ListNode node = dummy;\r\n            while (node.next != null && node.next.val < head.val) {\r\n                node = node.next;\r\n            }\r\n            ListNode temp = head.next;\r\n            head.next = node.next;\r\n            node.next = head;\r\n            head = temp;\r\n        }\r\n\r\n        return dummy.next;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: The first node of linked list.\r\n     * @return: The head of linked list.\r\n     */\r\n    ListNode *insertionSortList(ListNode *head) {\r\n        ListNode *dummy = new ListNode(0);\r\n        // 这个dummy的作用是，把head开头的链表一个个的插入到dummy开头的链表里\r\n        // 所以这里不需要dummy->next = head;\r\n\r\n        while (head != NULL) {\r\n            ListNode *temp = dummy;\r\n            ListNode *next = head->next;\r\n            while (temp->next != NULL && temp->next->val < head->val) {\r\n                temp = temp->next;\r\n            }\r\n            head->next = temp->next;\r\n            temp->next = head;\r\n            head = next;\r\n        }\r\n        \r\n        return dummy->next;\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of ListNode\r\nclass ListNode(object):\r\n\r\n    def __init__(self, val, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param head: The first node of linked list.\r\n    @return: The head of linked list.\r\n    \"\"\" \r\n    def insertionSortList(self, head):\r\n        # write your code here\r\n        dummy = ListNode(0)\r\n\r\n        while head:\r\n            temp = dummy\r\n            next = head.next\r\n            while temp.next and temp.next.val < head.val:\r\n                temp = temp.next\r\n\r\n            head.next = temp.next\r\n            temp.next = head\r\n            head = next\r\n        \r\n        return dummy.next"}]},{"id":72,"unique_name":"rotate-list","title":"旋转链表","description":"<p><span style=\"line-height: 1.42857143;\">给定一个链表，</span><span style=\"line-height: 1.42857143;\">旋转链表，使得每个节点向右移动</span><span style=\"line-height: 1.42857143;\">k个位置，其中k是一个非负数</span></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    private int getLength(ListNode head) {\r\n        int length = 0;\r\n        while (head != null) {\r\n            length ++;\r\n            head = head.next;\r\n        }\r\n        return length;\r\n    }\r\n    \r\n    public ListNode rotateRight(ListNode head, int n) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        \r\n        int length = getLength(head);\r\n        n = n % length;\r\n        \r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        head = dummy;\r\n        \r\n        ListNode tail = dummy;\r\n        for (int i = 0; i < n; i++) {\r\n            head = head.next;\r\n        }\r\n        \r\n        while (head.next != null) {\r\n            tail = tail.next;\r\n            head = head.next;\r\n        }\r\n        \r\n        head.next = dummy.next;\r\n        dummy.next = tail.next;\r\n        tail.next = null;\r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: the list\r\n     * @param k: rotate to the right k places\r\n     * @return: the list after rotation\r\n     */\r\n    ListNode *rotateRight(ListNode *head, int k) {\r\n        if (head == NULL) {\r\n            return head;\r\n        }\r\n        \r\n        int len = 0;\r\n        for (ListNode *node = head; node != NULL; node = node->next) {\r\n            len++;\r\n        }\r\n        k = k % len;\r\n        \r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode *fast = head;\r\n        for (int i = 0; i < k; i++) {\r\n            fast = fast->next;\r\n        }\r\n        \r\n        ListNode *slow = head;\r\n        while (fast->next != NULL) {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        \r\n        fast->next = head;\r\n        head = slow->next;\r\n        slow->next = NULL;\r\n        \r\n        return head;\r\n    }\r\n};\r\n"},{"language":"python","code":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    # @param head: the list\r\n    # @param k: rotate to the right k places\r\n    # @return: the list after rotation\r\n    def rotateRight(self, head, k):\r\n        # write your code here\r\n        if head==None:\r\n            return head\r\n        curNode = head\r\n        size = 1\r\n        while curNode!=None:\r\n            size += 1\r\n            curNode = curNode.next\r\n        size -= 1\r\n        k = k%size\r\n        if k==0:\r\n            return head\r\n        len = 1\r\n        curNode = head\r\n        while len<size-k:\r\n            len += 1\r\n            curNode = curNode.next\r\n        newHead = curNode.next\r\n        curNode.next = None\r\n        curNode = newHead\r\n        while curNode.next!=None:\r\n            curNode = curNode.next\r\n        curNode.next = head\r\n        return newHead\r\n"}]},{"id":125,"unique_name":"add-two-numbers","title":"链表求和","description":"你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中`相反`的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。","solutions":[{"language":"java","code":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\r\n        if(l1 == null && l2 == null) {\r\n            return null;\r\n        }\r\n            \r\n        ListNode head = new ListNode(0);\r\n        ListNode point = head;\r\n        int carry = 0;\r\n        while(l1 != null && l2!=null){\r\n            int sum = carry + l1.val + l2.val;\r\n            point.next = new ListNode(sum % 10);\r\n            carry = sum / 10;\r\n            l1 = l1.next;\r\n            l2 = l2.next;\r\n            point = point.next;\r\n        }\r\n        \r\n        while(l1 != null) {\r\n            int sum =  carry + l1.val;\r\n            point.next = new ListNode(sum % 10);\r\n            carry = sum /10;\r\n            l1 = l1.next;\r\n            point = point.next;\r\n        }\r\n        \r\n        while(l2 != null) {\r\n            int sum =  carry + l2.val;\r\n            point.next = new ListNode(sum % 10);\r\n            carry = sum /10;\r\n            l2 = l2.next;\r\n            point = point.next;\r\n        }\r\n        \r\n        if (carry != 0) {\r\n            point.next = new ListNode(carry);\r\n        }\r\n        return head.next;\r\n    }\r\n}\r\n\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param l1: the first list\r\n     * @param l2: the second list\r\n     * @return: the sum list of l1 and l2\r\n     */\r\n    public ListNode addLists(ListNode l1, ListNode l2) {\r\n        // write your code here\r\n        ListNode dummy = new ListNode(0);\r\n        ListNode tail = dummy;\r\n\r\n        int carry = 0;\r\n        for (ListNode i = l1, j = l2; i != null || j != null; ) {\r\n            int sum = carry;\r\n            sum += (i != null) ? i.val : 0;\r\n            sum += (j != null) ? j.val : 0;\r\n\r\n            tail.next = new ListNode(sum % 10);\r\n            tail = tail.next;\r\n\r\n            carry = sum / 10;\r\n            i = (i == null) ? i : i.next;\r\n            j = (j == null) ? j : j.next;\r\n        }\r\n\r\n        if (carry != 0) {\r\n            tail.next = new ListNode(carry);\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\r\n        // 题意可以认为是实现高精度加法\r\n        ListNode *head = new ListNode(0);\r\n        ListNode *ptr = head;\r\n        int carry = 0;\r\n        while (true) {\r\n            if (l1 != NULL) {\r\n                carry += l1->val;\r\n                l1 = l1->next;\r\n            }\r\n            if (l2 != NULL) {\r\n                carry += l2->val;\r\n                l2 = l2->next;\r\n            }\r\n            ptr->val = carry % 10;\r\n            carry /= 10;\r\n            // 当两个表非空或者仍有进位时需要继续运算，否则退出循环\r\n            if (l1 != NULL || l2 != NULL || carry != 0) {\r\n                ptr = (ptr->next = new ListNode(0));\r\n            } else break;\r\n        }\r\n        return head;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    def addTwoNumbers(self, l1, l2):\r\n        head = ListNode(0)\r\n        ptr = head\r\n        carry  = 0\r\n        while True:\r\n            if l1 != None:\r\n                carry += l1.val\r\n                l1 = l1.next\r\n            if l2 != None:\r\n                carry += l2.val\r\n                l2 = l2.next\r\n            ptr.val = carry % 10\r\n            carry /= 10\r\n            # 运算未结束新建一个节点用于储存答案，否则退出循环\r\n            if l1 != None or l2 != None or carry != 0:\r\n                ptr.next = ListNode(0)\r\n                ptr = ptr.next\r\n            else: \r\n                break\r\n        return head"}]},{"id":141,"unique_name":"remove-duplicates-from-sorted-list-ii","title":"删除排序链表中的重复数字 II","description":"给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。\r\n","solutions":[{"language":"java","code":"\r\npublic class Solution {\r\n    public ListNode deleteDuplicates(ListNode head) {\r\n        if(head == null || head.next == null)\r\n            return head;\r\n        \r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        head = dummy;\r\n\r\n        while (head.next != null && head.next.next != null) {\r\n            if (head.next.val == head.next.next.val) {\r\n                int val = head.next.val;\r\n                while (head.next != null && head.next.val == val) {\r\n                    head.next = head.next.next;\r\n                }            \r\n            } else {\r\n                head = head.next;\r\n            }\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *deleteDuplicates(ListNode *head) {\n        ListNode *root = NULL;\n        ListNode **ppNext = &root;\n        while(head) {\n            if(head->next == NULL || head->next->val != head->val) {\n                *ppNext = head;\n                ppNext = &(head->next);\n                head = head->next;\n            } else {\n                int val = head->val;\n                do {\n                    head = head->next;\n                } while(head != NULL && head->val == val);\n            }\n        }\n        *ppNext = NULL;\n        return root;\n    }\n};"},{"language":"python","code":"class Solution:  \n    # @param head, a ListNode  \n    # @return a ListNode  \n    def deleteDuplicates(self, head):  \n        if None == head or None == head.next:  \n            return head  \n  \n        new_head = ListNode(-1)  \n        new_head.next = head  \n        parent = new_head  \n        cur = head  \n        while None != cur and None != cur.next:   ### check cur.next None  \n            if cur.val == cur.next.val:  \n                val = cur.val  \n                while None != cur and val == cur.val: ### check cur None  \n                    cur = cur.next  \n                parent.next = cur  \n            else:  \n                cur = cur.next  \n                parent = parent.next  \n  \n        return new_head.next \n"}]},{"id":140,"unique_name":"remove-duplicates-from-sorted-list","title":"删除排序链表中的重复元素","description":"给定一个排序链表，删除所有重复的元素每个元素只留下一个。","solutions":[{"language":"java","code":"public class Solution {\r\n    public ListNode deleteDuplicates(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        ListNode node = head;\r\n        while (node.next != null) {\r\n            if (node.val == node.next.val) {\r\n                node.next = node.next.next;\r\n            } else {\r\n                node = node.next;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of ListNode\n * class ListNode {\n * public:\n *     int val;\n *     ListNode *next;\n *     ListNode(int val) {\n *         this->val = val;\n *         this->next = NULL;\n *     }\n * }\n */\nclass Solution{\npublic:\n    /**\n     * @param head: The first node of linked list.\n     * @return: head node\n     */\n    ListNode *deleteDuplicates(ListNode *head) {\n        if (head == NULL) {\n            return NULL;\n        }\n\n        ListNode *node = head;\n        while (node->next != NULL) {\n            if (node->val == node->next->val) {\n                node->next = node->next->next;\n            } else {\n                node = node->next;\n            }\n        }\n        return head;\n    }\n};\n"},{"language":"python","code":"\n\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    # @param head, a ListNode\n    # @return a ListNode\n    def deleteDuplicates(self, head):\n        delflag = 1\n        flag = 1\n        p = head\n        while(p != None and p.next != None):\n            if p.val != p.next.val:\n                flag = 1\n                p = p.next\n            elif flag < delflag:\n                flag += 1;\n                p = p.next\n            else:\n                p.next = p.next.next\n        return head\n"}]},{"id":13,"unique_name":"linked-list-cycle-ii","title":"带环链表 II","description":"<p>给定一个链表，如果链表中存在环，则返回到链表中环的起始节点，如果没有环，返回null。</p>","solutions":[{"language":"java","code":"/**\r\n * Definition for ListNode.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int val) {\r\n *         this.val = val;\r\n *         this.next = null;\r\n *     }\r\n * }\r\n */ \r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next==null) {\r\n            return null;\r\n        }\r\n\r\n        ListNode fast, slow;\r\n        fast = head.next;\r\n        slow = head;\r\n        while (fast != slow) {\r\n            if(fast==null || fast.next==null)\r\n                return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        } \r\n        \r\n        while (head != slow.next) {\r\n            head = head.next;\r\n            slow = slow.next;\r\n        }\r\n        return head;\r\n    }\r\n}"},{"language":"cpp","code":"/**\n * Definition of ListNode\n * class ListNode {\n * public:\n *     int val;\n *     ListNode *next;\n *     ListNode(int val) {\n *         this->val = val;\n *         this->next = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param head: The first node of linked list.\n     * @return: the node where the cycle begins. \n     *           If there is no cycle, return null\n     */\n    ListNode *detectCycle(ListNode *head) {\n        // write your code here\n        ListNode* ptr1,* ptr2;\n        if(head == NULL)\n            return NULL;\n        ptr1 = head ;\n        ptr2 = head;\n\n        while(ptr2->next != NULL && ptr2->next->next != NULL)\n        {\n            ptr1 = ptr1->next;\n            ptr2 = ptr2->next->next;\n            if(ptr1 == ptr2)\n            {\n                ptr1 = head;\n                while(ptr1 != ptr2)\n                {\n                    ptr2 = ptr2->next;\n                    ptr1 = ptr1->next;\n                }\n                return ptr1;\n            }\n\n        }\n        return NULL;\n    }\n};\n\n\n\n"},{"language":"python","code":"from lintcode import ListNode\n\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param head: The first node of the linked list.\n    @return: the node where the cycle begins. \n                If there is no cycle, return null\n    \"\"\"\n    def detectCycle(self, head):\n        # write your code here\n        if head == None or head.next == None:\n            return None\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast == slow:\n                break\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n        return None\n\n"}]},{"id":14,"unique_name":"linked-list-cycle","title":"带环链表","description":"<p>给定一个链表，判断它是否有环。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    public Boolean hasCycle(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return false;\r\n        }\r\n\r\n        ListNode fast, slow;\r\n        fast = head.next;\r\n        slow = head;\r\n        while (fast != slow) {\r\n            if(fast==null || fast.next==null)\r\n                return false;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        } \r\n        return true;\r\n    }\r\n}"},{"language":"cpp","code":"/**\n * Definition of ListNode\n * class ListNode {\n * public:\n *     int val;\n *     ListNode *next;\n *     ListNode(int val) {\n *         this->val = val;\n *         this->next = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param head: The first node of linked list.\n     * @return: True if it has a cycle, or false\n     */\n    bool hasCycle(ListNode *head) {\n        // write your code here\n        ListNode *fast,*slow;\n        if(head==NULL) return false;\n        slow=head;\n        fast=head->next;\n        while(fast!=NULL && fast->next!=NULL)\n        {\n            if(slow==fast) return true;\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        return false;\n    }\n};\n\n\n\n"},{"language":"python","code":"from lintcode import ListNode\n\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param head: The first node of the linked list.\n    @return: True if it has a cycle, or false\n    \"\"\"\n    def hasCycle(self, head):\n        # write your code here\n        if head is None:\t\t\t\n            return False\t\t\n        p1 = head\t\t\n        p2 = head\t\t\n        while True:\n            if p1.next is not None:\n                p1=p1.next.next\n                p2=p2.next\n                if p1 is None or p2 is None:\n                    return False\n                elif p1 == p2:\n                    return True\n            else:\n                return False\n        return False\n\n"}]},{"id":12,"unique_name":"reorder-list","title":"重排链表","description":"给定一个单链表L: *L*<sub>0</sub>→*L*<sub>1</sub>→…→*L*<sub>n-1</sub>→*L*<sub>n</sub>,\r\n\r\n重新排列后为：*L*<sub>0</sub>→*L*<sub>n</sub>→*L*<sub>1</sub>→*L*<sub>n-1</sub>→*L*<sub>2</sub>→*L*<sub>n-2</sub>→…\r\n\r\n必须在不改变节点值的情况下进行原地操作。","solutions":[{"language":"java","code":"public class Solution {\r\n    private ListNode reverse(ListNode head) {\r\n        ListNode newHead = null;\r\n        while (head != null) {\r\n            ListNode temp = head.next;\r\n            head.next = newHead;\r\n            newHead = head;\r\n            head = temp;\r\n        }\r\n        return newHead;\r\n    }\r\n\r\n    private void merge(ListNode head1, ListNode head2) {\r\n        int index = 0;\r\n        ListNode dummy = new ListNode(0);\r\n        while (head1 != null && head2 != null) {\r\n            if (index % 2 == 0) {\r\n                dummy.next = head1;\r\n                head1 = head1.next;\r\n            } else {\r\n                dummy.next = head2;\r\n                head2 = head2.next;\r\n            }\r\n            dummy = dummy.next;\r\n            index ++;\r\n        }\r\n        if (head1 != null) {\r\n            dummy.next = head1;\r\n        } else {\r\n            dummy.next = head2;\r\n        }\r\n    }\r\n\r\n    private ListNode findMiddle(ListNode head) {\r\n        ListNode slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n    public void reorderList(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return;\r\n        }\r\n\r\n        ListNode mid = findMiddle(head);\r\n        ListNode tail = reverse(mid.next);\r\n        mid.next = null;\r\n\r\n        merge(head, tail);\r\n    }\r\n}"},{"language":"cpp","code":"/**\n * Definition of ListNode\n * class ListNode {\n * public:\n *     int val;\n *     ListNode *next;\n *     ListNode(int val) {\n *         this->val = val;\n *         this->next = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param head: The first node of linked list.\n     * @return: void\n     */\n    void reorderList(ListNode *head) {\n        // write your code here\n        if (head == NULL)\n            return;\n        \n        vector<ListNode*> nodes;\n        ListNode* iter = head;\n        while(iter != NULL)\n        {\n            nodes.push_back(iter);\n            iter = iter->next;\n        }\n        \n        int LEN = nodes.size();\n        int left = 0;\n        int right = LEN -1;\n        while(left < right)\n        {\n            nodes[left]->next = nodes[right];\n            nodes[right--]->next = nodes[++left];\n        }\n        nodes[left]->next = NULL;\n    }\n};\n\n\n\n"},{"language":"python","code":"from lintcode import ListNode\n\n\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param head: The first node of the linked list.\n    @return: nothing\n    \"\"\"\n    def reorderList(self, head):\n        # write your code here\n        if None == head or None == head.next:\n            return head\n\n        pfast = head\n        pslow = head\n        \n        while pfast.next and pfast.next.next:\n            pfast = pfast.next.next\n            pslow = pslow.next\n        pfast = pslow.next\n        pslow.next = None\n        \n        pnext = pfast.next\n        pfast.next = None\n        while pnext:\n            q = pnext.next\n            pnext.next = pfast\n            pfast = pnext\n            pnext = q\n\n        tail = head\n        while pfast:\n            pnext = pfast.next\n            pfast.next = tail.next\n            tail.next = pfast\n            tail = tail.next.next\n            pfast = pnext\n        return head\n\n"}]},{"id":150,"unique_name":"partition-list","title":"链表划分","description":"<p>给定一个单链表和数值x，划分链表使得所有小于x的节点排在大于等于x的节点之前。</p><p>你应该保留两部分内链表节点原有的相对顺序。</p><p><br></p>","solutions":[{"language":"java","code":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode partition(ListNode head, int x) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        \r\n        ListNode leftDummy = new ListNode(0);\r\n        ListNode rightDummy = new ListNode(0);\r\n        ListNode left = leftDummy, right = rightDummy;\r\n        \r\n        while (head != null) {\r\n            if (head.val < x) {\r\n                left.next = head;\r\n                left = head;\r\n            } else {\r\n                right.next = head;\r\n                right = head;\r\n            }\r\n            head = head.next;\r\n        }\r\n        \r\n        right.next = null;\r\n        left.next = rightDummy.next;\r\n        return leftDummy.next;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of ListNode\r\n * class ListNode {\r\n * public:\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int val) {\r\n *         this->val = val;\r\n *         this->next = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param head: The first node of linked list.\r\n     * @param x: an integer\r\n     * @return: a ListNode \r\n     */\r\n    ListNode *partition(ListNode *head, int x) {\r\n        ListNode *leftDummy = new ListNode(0);\r\n        ListNode *rightDummy = new ListNode(0);\r\n        ListNode *leftTail = leftDummy;\r\n        ListNode *rightTail = rightDummy;\r\n        \r\n        while (head != NULL) {\r\n            if (head->val < x) {\r\n                leftTail->next = head;\r\n                leftTail = head;\r\n            } else {\r\n                rightTail->next = head;\r\n                rightTail = head;\r\n            }\r\n            head = head->next;\r\n        }\r\n        \r\n        leftTail->next = rightDummy->next;\r\n        rightTail->next = NULL;\r\n        \r\n        return leftDummy->next;\r\n    }\r\n};\r\n\r\n\r\n"},{"language":"python","code":"\"\"\"\nDefinition of ListNode\nclass ListNode(object):\n\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param head: The first node of linked list.\n    @param x: an integer\n    @return: a ListNode \n    \"\"\"\n    def partition(self, head, x):\n        # write your code here\n        if head is None:\n            return head\n        aHead, bHead = ListNode(0), ListNode(0)\n        aTail, bTail = aHead, bHead\n        while head is not None:\n            if head.val < x:\n                aTail.next = head\n                aTail = aTail.next\n            else:\n                bTail.next = head\n                bTail = bTail.next\n            head = head.next\n        bTail.next = None\n        aTail.next = bHead.next\n        return aHead.next\n"}]},{"id":156,"unique_name":"reverse-linked-list-ii","title":"翻转链表 II","description":"<p>翻转链表中第m个节点到第n个节点的部分</p>","solutions":[{"language":"java","code":"/**\r\n * Definition for ListNode\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode reverseBetween(ListNode head, int m, int n) {\r\n        if (m >= n || head == null) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        head = dummy;\r\n        \r\n        for (int i = 1; i < m; i++) {\r\n            if (head == null) {\r\n                return null;\r\n            }\r\n            head = head.next;\r\n        }\r\n        \r\n        ListNode premNode = head;\r\n        ListNode mNode = head.next;\r\n        ListNode nNode = mNode, postnNode = mNode.next;\r\n        for (int i = m; i < n; i++) {\r\n            if (postnNode == null) {\r\n                return null;\r\n            }\r\n            ListNode temp = postnNode.next;\r\n            postnNode.next = nNode;\r\n            nNode = postnNode;\r\n            postnNode = temp;\r\n        }\r\n        mNode.next = postnNode;\r\n        premNode.next = nNode;\r\n        \r\n        return dummy.next;\r\n    }\r\n}"},{"language":"cpp","code":"#include \"lintcode.h\"\n\nusing namespace std;\n\n\nclass Solution {\npublic:\n    void reverse(ListNode *head) {\n        ListNode *prev = NULL;\n        while (head != NULL) {\n            ListNode *temp = head->next;\n            head->next = prev;\n            prev = head;\n            head = temp;\n        }\n    }\n\n    ListNode *findkth(ListNode *head, int k) {\n        for (int i = 0; i < k; i++) {\n            if (head == NULL) {\n                return NULL;\n            }\n            head = head->next;\n        }\n        return head;\n    }\n\n    ListNode *reverseBetween(ListNode *head, int m, int n) {\n        ListNode *dummy = new ListNode(-1, head);\n        ListNode *mth_prev = findkth(dummy, m - 1);\n        ListNode *mth = mth_prev->next;\n        ListNode *nth = findkth(dummy, n);\n        ListNode *nth_next = nth->next;\n        nth->next = NULL;\n\n        reverse(mth);\n        mth_prev->next = nth;\n        mth->next = nth_next;\n        return dummy->next;\n    }\n};\n"},{"language":"python","code":"from lintcode import ListNode\n\n\nclass Solution:\n\n    def reverse(self, head):\n        prev = None\n        while head != None:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev\n\n    def findkth(self, head, k):\n        for i in xrange(k):\n            if head is None:\n                return None\n            head = head.next\n        return head\n\n    def reverseBetween(self, head, m, n):\n        dummy = ListNode(-1, head)\n        mth_prev = self.findkth(dummy, m - 1)\n        mth = mth_prev.next\n        nth = self.findkth(dummy, n)\n        nth_next = nth.next\n        nth.next = None\n\n        self.reverse(mth)\n        mth_prev.next = nth\n        mth.next = nth_next\n        return dummy.next\n"}]},{"id":250,"unique_name":"sliding-window-maximum","title":"滑动窗口的最大值","description":"给出一个可能包含重复的整数数组，和一个大小为 *k* 的滑动窗口, 从左到右在数组中滑动这个窗口，找到数组中每个窗口内的最大值。","solutions":[{"language":"java","code":"public class Solution {\r\n    \r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: The maximum number inside the window at each moving.\r\n     */\r\n    void inQueue(Deque<Integer> deque, int num) {\r\n        while (!deque.isEmpty() && deque.peekLast() < num) {\r\n            deque.pollLast();\r\n        }\r\n        deque.offer(num);\r\n    }\r\n    \r\n    void outQueue(Deque<Integer> deque, int num) {\r\n        if (deque.peekFirst() == num) {\r\n            deque.pollFirst();\r\n        }\r\n    }\r\n    \r\n    public ArrayList<Integer> maxSlidingWindow(int[] nums, int k) {\r\n        // write your code here\r\n    \tArrayList<Integer> ans = new ArrayList<Integer>();\r\n        Deque<Integer> deque = new ArrayDeque<Integer>();\r\n        if (nums.length == 0) {\r\n            return ans;\r\n        }\r\n        for (int i = 0; i < k - 1; i++) {\r\n            inQueue(deque, nums[i]);\r\n        }\r\n        \r\n        for(int i = k - 1; i < nums.length; i++) {\r\n            inQueue(deque, nums[i]);\r\n            ans.add(deque.peekFirst());\r\n            outQueue(deque, nums[i - k + 1]);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: The maximum number inside the window at each moving.\r\n     */\r\n    \r\n    void inQueue(deque<int> &Q, int num) {\r\n        while (!Q.empty() && Q.back() < num) {\r\n            Q.pop_back();\r\n        }\r\n        Q.push_back(num);\r\n    }\r\n    \r\n    void outQueue(deque<int> &Q, int num) {\r\n        if (Q.front() == num) {\r\n            Q.pop_front();\r\n        }\r\n    }\r\n    \r\n    vector<int> maxSlidingWindow(vector<int> &nums, int k) {\r\n        deque<int> Q;\r\n        vector<int> result;\r\n        \r\n        for (int i = 0; i < k - 1; i++) {\r\n            inQueue(Q, nums[i]);\r\n        }\r\n        \r\n        for (int i = k - 1; i < nums.size(); i++) {\r\n            inQueue(Q, nums[i]);\r\n            result.push_back(Q.front());\r\n            outQueue(Q, nums[i - k + 1]);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"from collections import deque\r\nclass Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers.\r\n    @return: The maximum number inside the window at each moving.\r\n    \"\"\"\r\n    def maxSlidingWindow(self, nums, k):\r\n        # write your code here\r\n        q = deque()\r\n        result = []\r\n        if len(nums) < k or k == 0:\r\n            return []\r\n\r\n        n = len(nums)\r\n        for i in xrange(n):\r\n            while len(q) and nums[q[-1]] < nums[i]:\r\n                q.pop()\r\n            q.append(i)\r\n\r\n            if i < k - 1:                        \r\n                continue\r\n\r\n            while len(q) and q[0] <= i - k:\r\n                q.popleft()\r\n            \r\n            result.append(nums[q[0]])\r\n\r\n        return result;"}]},{"id":437,"unique_name":"interleaving-positive-and-negative-numbers","title":"交错正负数","description":"给出一个含有正整数和负整数的数组，重新排列成一个正负数交错的数组。\r\n","solutions":[{"language":"java","code":"class Solution {\r\n    /**\r\n     * @param A: An integer array.\r\n     * @return: void\r\n     */\r\n    int[] subfun(int[] A,int [] B, int len) {\r\n        int[] ans = new int[len];\r\n        for(int i = 0; i * 2 + 1 < len; i++) {\r\n            ans[i * 2] = A[i];\r\n            ans[i * 2 + 1] = B[i];\r\n            }\r\n        if(len % 2 == 1)\r\n            ans[len - 1] = A[len / 2];\r\n        return ans;\r\n    }\r\n    public void rerange(int[] A) {\r\n        int[] Ap = new int[A.length];\r\n        int totp = 0;\r\n        int totm = 0;\r\n        int[] Am = new int[A.length];\r\n        int[] tmp = new int[A.length];\r\n        for(int i = 0; i < A.length; i++)\r\n            if(A[i] > 0)\r\n                {\r\n                    Ap[totp] = A[i];\r\n                    totp += 1;\r\n                }\r\n            else\r\n                {\r\n                    Am[totm] = A[i];\r\n                    totm += 1;  \r\n                }   \r\n        if(totp > totm)\r\n            tmp = subfun(Ap, Am, A.length);\r\n        else\r\n            tmp = subfun(Am, Ap, A.length);\r\n        for (int i = 0; i < tmp.length; ++i)\r\n            A[i] = tmp[i];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A: An integer array.\r\n     * @return: void\r\n     */\r\n    vector<int> subfun(vector<int> &A, vector<int> &B) {\r\n        vector<int> ans;\r\n        for(int i = 0; i < B.size(); i++) {\r\n            ans.push_back(A[i]);\r\n            ans.push_back(B[i]);\r\n            }\r\n        if(A.size() > B.size())\r\n            ans.push_back(A[B.size()]);\r\n        return ans;\r\n    }\r\n    void rerange(vector<int> &A) {\r\n        // write your code here\r\n        vector<int> Am, Ap, tmp;\r\n        for(int i = 0; i < A.size(); i++)\r\n            if(A[i] > 0)\r\n                Ap.push_back(A[i]);\r\n            else\r\n                Am.push_back(A[i]);\r\n        if(Ap.size() > Am.size())\r\n            tmp = subfun(Ap, Am);\r\n        else\r\n            tmp = subfun(Am, Ap);\r\n\r\n        for (int i = 0; i < tmp.size(); ++i)\r\n            A[i] = tmp[i];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param A: An integer array.\r\n    @return nothing\r\n    \"\"\"\r\n    def subfun(self, A, B):\r\n        ans = []\r\n        for i in range(len(B)):\r\n            ans.append(A[i])\r\n            ans.append(B[i])\r\n        if(len(A) > len(B)):\r\n            ans.append(A[-1])\r\n        return ans\r\n    def rerange(self, A):\r\n        # write your code here\r\n        Ap = [i for i in A if i > 0]\r\n        Am = [i for i in A if i < 0]\r\n        if(len(Ap) > len(Am)):\r\n            tmp = self.subfun(Ap, Am)\r\n        else:\r\n            tmp = self.subfun(Am, Ap)\r\n        for i in xrange(len(tmp)):\r\n            A[i] = tmp[i];\r\n      "}]},{"id":305,"unique_name":"sort-colors-ii","title":"排颜色 II","description":"给定一个有n个对象（包括k种不同的颜色，并按照1到k进行编号）的数组，将对象进行分类使相同颜色的对象相邻，并按照1,2，...k的顺序进行排序。","solutions":[{"language":"java","code":"// version 1: O(nlogk), the best algorithm based on comparing\nclass Solution {\n    /**\n     * @param colors: A list of integer\n     * @param k: An integer\n     * @return: nothing\n     */\n    public void sortColors2(int[] colors, int k) {\n        if (colors == null || colors.length == 0) {\n            return;\n        }\n        rainbowSort(colors, 0, colors.length - 1, 1, k);\n    }\n    \n    public void rainbowSort(int[] colors,\n                            int left,\n                            int right,\n                            int colorFrom,\n                            int colorTo) {\n        if (colorFrom == colorTo) {\n            return;\n        }\n        \n        if (left >= right) {\n            return;\n        }\n        \n        int colorMid = (colorFrom + colorTo) / 2;\n        int l = left, r = right;\n        while (l <= r) {\n            while (l <= r && colors[l] <= colorMid) {\n                l++;\n            }\n            while (l <= r && colors[r] > colorMid) {\n                r--;\n            }\n            if (l <= r) {\n                int temp = colors[l];\n                colors[l] = colors[r];\n                colors[r] = temp;\n                \n                l++;\n                r--;\n            }\n        }\n        \n        rainbowSort(colors, left, r, colorFrom, colorMid);\n        rainbowSort(colors, l, right, colorMid + 1, colorTo);\n    }\n}\n\n// version 2: O(nk), not efficient, will get Time Limit Exceeded error. But you should try to implement the following algorithm for practicing purpose.\nclass Solution {\n    /**\n     * @param colors: A list of integer\n     * @param k: An integer\n     * @return: nothing\n     */\n    public void sortColors2(int[] colors, int k) {\n        int count = 0;\n        int left = 0;\n        int right = colors.length - 1;\n        while (count < k) {\n            int min = Integer.MAX_VALUE;\n            int max = Integer.MIN_VALUE;\n            \n            for (int i = left; i <= right; i++) {\n                min = Math.min(min, colors[i]);\n                max = Math.max(max, colors[i]);\n            }\n            int cur = left;\n            while(cur <= right) {\n                if (colors[cur] == min) {\n                    swap(left, cur, colors);\n                    cur++;\n                    left++;\n                } else if (colors[cur] > min && colors[cur] < max) {\n                    cur++;\n                } else {\n                    swap(cur, right, colors);\n                    right--;\n                }\n            }\n            count += 2;\n\n        }\n    }\n    \n    void swap(int left, int right, int[] colors) {\n        int tmp = colors[left];\n        colors[left] = colors[right];\n        colors[right] = tmp;\n    }\n}"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param colors: A list of integer\r\n    @param k: An integer\r\n    @return: nothing\r\n    \"\"\"\r\n    def sortColors2(self, colors, k):\r\n        # write your code here\r\n        #for i in xrange(len(colors)):\r\n        i = 0\r\n        n = len(colors)\r\n        while i < n:\r\n            if colors[i] > 0:\r\n                if colors[colors[i]-1] > 0:\r\n                    tmp = colors[i]\r\n                    colors[i] = colors[colors[i]-1]\r\n                    colors[tmp-1] = -1\r\n                    i = i - 1\r\n                else:\r\n                    colors[colors[i]-1] -= 1\r\n                    colors[i] = 0\r\n            i = i + 1 \r\n\r\n        i = len(colors)-1\r\n        k = i\r\n        while i >= 0:\r\n            if colors[i] < 0:\r\n                pos = k + colors[i]\r\n                while k > pos:\r\n                    colors[k] = i+1\r\n                    k -= 1\r\n            i -= 1"},{"language":"javascript","code":"/**\n * @param colors: A list of integer\n * @param k: An integer\n * @return: \n */\nconst sortColors2 = function (colors, k) {\n    if (colors === null || colors.length === 0) {\n            return;\n    }\n    rainbowSort = function(colors, left, right, colorFrom, colorTo) {\n        if (colorFrom === colorTo) {\n            return;\n        }\n        if (left >= right) {\n            return;\n        }\n        var colorMid = Math.floor((colorFrom + colorTo) / 2);\n        var l = left, r = right;\n        var temp;\n        while (l <= r) {\n            while (l <= r && colors[l] <= colorMid) {\n                l++;\n            }\n            while (l <= r && colors[r] > colorMid) {\n                r--;\n            }\n            if (l <= r) {\n                temp = colors[l];\n                colors[l] = colors[r];\n                colors[r] = temp;\n                \n                l++;\n                r--;\n            }\n        }\n        \n        rainbowSort(colors, left, r, colorFrom, colorMid);\n        rainbowSort(colors, l, right, colorMid + 1, colorTo);\n    }\n    rainbowSort(colors, 0, colors.length - 1, 1, k);\n}"}]},{"id":324,"unique_name":"sort-letters-by-case","title":"字符大小写排序","description":"<p><span style=\"line-height: 1.42857143;\">给定一个只包含字母的字符串，按照先小写字母后大写字母的顺序进行排序。</span></p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /** \r\n     *@param chars: The letter array you should sort by Case\r\n     *@return: void\r\n     */\r\n    public void sortLetters(char[] chars) {\r\n        int i = 0, j = chars.length - 1;\r\n\t\tchar tmp ;\r\n\t\twhile ( i <= j) {\r\n\t\t\twhile (i <= j && Character.isLowerCase(chars[i]) ) i++;\r\n\t\t\twhile (i <= j && Character.isUpperCase(chars[j]) ) j--;\r\n\t\t\tif (i <= j) {\r\n\t\t\t\ttmp = chars[i];\r\n\t\t\t\tchars[i] = chars[j];\r\n\t\t\t\tchars[j] = tmp;\r\n\t\t\t\ti++; j--;\r\n\t\t\t}\r\n\t\t}\r\n        //write your code here\r\n\t\treturn ;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isLower(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    void sortLetters(string &letters) {\n        int i = 0, j = letters.size() - 1;\n        while (i <= j) {\n            while (i <= j && isLower(letters[i])) i++;\n            while (i <= j && !isLower(letters[j])) j--;\n            if (i <= j) {\n                char c = letters[i];\n                letters[i] = letters[j];\n                letters[j] = c;\n            }\n        }\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\" \n    @param chars: The letters array you should sort.\n    \"\"\"\n    def sortLetters(self, chars):\n        chars.sort(key=lambda c: c.isupper())\n"}]},{"id":378,"unique_name":"sort-integers-ii","title":"整数排序 II","description":"给一组整数，按照升序排序。使用归并排序，快速排序，堆排序或者任何其他 O(*n* log *n*) 的排序算法。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A an integer array\r\n     * @return void\r\n     */\r\n    public void sortIntegers2(int[] A) {\r\n        quickSort(A, 0, A.length - 1);\r\n    }\r\n    \r\n    private void quickSort(int[] A, int start, int end) {\r\n        if (start >= end) {\r\n            return;\r\n        }\r\n        \r\n        int left = start, right = end;\r\n        // key point 1: pivot is the value, not the index\r\n        int pivot = A[(start + end) / 2];\r\n\r\n        // key point 2: every time you compare left & right, it should be \r\n        // left <= right not left < right\r\n        while (left <= right) {\r\n            while (left <= right && A[left] < pivot) {\r\n                left++;\r\n            }\r\n            while (left <= right && A[right] > pivot) {\r\n                right--;\r\n            }\r\n            if (left <= right) {\r\n                int temp = A[left];\r\n                A[left] = A[right];\r\n                A[right] = temp;\r\n                \r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n        \r\n        quickSort(A, start, right);\r\n        quickSort(A, left, end);\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A an integer array\r\n     * @return void\r\n     */\r\n    void sortIntegers2(vector<int> &A) {\r\n        quickSort(A, 0, A.size() - 1);\r\n    }\r\n    \r\nprivate:\r\n    void quickSort(vector<int> &A, int l, int r) {\r\n        if (l >= r) {\r\n            return;\r\n        }\r\n        \r\n        int i = l, j = r;\r\n        int pivot = A[(l + r) / 2];\r\n        \r\n        while (i <= j) {\r\n            while (i <= j && A[i] < pivot) {\r\n                i++;\r\n            }\r\n            while (i <= j && A[j] > pivot) {\r\n                j--;\r\n            }\r\n            if (i <= j) {\r\n                int temp = A[i];\r\n                A[i] = A[j];\r\n                A[j] = temp;\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        \r\n        quickSort(A, i, r);\r\n        quickSort(A, l, j);\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} A an integer array\r\n    # @return nothing\r\n    def sortIntegers2(self, A):\r\n        # Write your code here\r\n        self.quickSort(A, 0, len(A) - 1)\r\n    \r\n    def quickSort(self, A, start, end):\r\n        if start >= end:\r\n            return\r\n        \r\n        left, right = start, end\r\n        # key point 1: pivot is the value, not the index\r\n        pivot = A[(start + end) / 2];\r\n\r\n        # key point 2: every time you compare left & right, it should be \r\n        # left <= right not left < right\r\n        while left <= right:\r\n            while left <= right and A[left] < pivot:\r\n                left += 1\r\n            \r\n            while left <= right and A[right] > pivot:\r\n                right -= 1\r\n            \r\n            if left <= right:\r\n                A[left], A[right] = A[right], A[left]\r\n                \r\n                left += 1\r\n                right -= 1\r\n        \r\n        self.quickSort(A, start, right)\r\n        self.quickSort(A, left, end)\r\n"}]},{"id":280,"unique_name":"subarray-sum-closest","title":"最接近零的子数组和","description":"给定一个整数数组，找到一个和最接近于零的子数组。返回第一个和最右一个指数。你的代码应该返回满足要求的子数组的起始位置和结束位置","solutions":[{"language":"java","code":"class Pair {\r\n    int sum;\r\n    int index;\r\n    public Pair(int s, int i) {\r\n        sum = s;\r\n        index = i;\r\n    }\r\n}\r\n    \r\npublic class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: A list of integers includes the index of the first number \r\n     *          and the index of the last number\r\n     */\r\n    public int[] subarraySumClosest(int[] nums) {\r\n        int[] res = new int[2];\r\n        if (nums == null || nums.length == 0) {\r\n            return res;\r\n        } \r\n        \r\n        int len = nums.length;\r\n        if(len == 1) {\r\n            res[0] = res[1] = 0;\r\n            return res;\r\n        }\r\n        Pair[] sums = new Pair[len+1];\r\n        int prev = 0;\r\n        sums[0] = new Pair(0, 0);\r\n        for (int i = 1; i <= len; i++) {\r\n            sums[i] = new Pair(prev + nums[i-1], i);\r\n            prev = sums[i].sum;\r\n        }\r\n        Arrays.sort(sums, new Comparator<Pair>() {\r\n           public int compare(Pair a, Pair b) {\r\n               return a.sum - b.sum;\r\n           } \r\n        });\r\n        int ans = Integer.MAX_VALUE;\r\n        for (int i = 1; i <= len; i++) {\r\n            \r\n            if (ans > sums[i].sum - sums[i-1].sum) {\r\n                ans = sums[i].sum - sums[i-1].sum;\r\n                int[] temp = new int[]{sums[i].index - 1, sums[i - 1].index - 1};\r\n                Arrays.sort(temp);\r\n                res[0] = temp[0] + 1;\r\n                res[1] = temp[1];\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n问：为什么需要一个 (0,0) 的初始 Pair?\r\n答：\r\n我们首先需要回顾一下，在 subarray 这节课里，我们讲过一个重要的知识点，叫做 Prefix Sum\r\n比如对于数组 [1,2,3,4]，他的 Prefix Sum 是 [1,3,6,10]\r\n分别表示 前1个数之和，前2个数之和，前3个数之和，前4个数之和\r\n这个时候如果你想要知道 子数组 从下标  1 到下标 2 的这一段的和(2+3)，就用前 3个数之和 减去 前1个数之和 = PrefixSum[2] - PrefixSum[0] = 6 - 1 = 5\r\n你可以看到这里的 前 x 个数，和具体对应的下标之间，存在 +-1 的问题\r\n第 x 个数的下标是 x - 1，反之 下标 x 是第 x + 1 个数\r\n那么问题来了，如果要计算 下标从 0~2 这一段呢？也就是第1个数到第3个数，因为那样会访问到 PrefixSum[-1]\r\n所以我们把 PrefixSum 整体往后面移动一位，把第0位空出来表示前0个数之和，也就是0. => [0,1,3,6,10]\r\n那么此时就用 PrefixSum[3] - PrefixSum[0] ，这样计算就更方便了。\r\n此时，PrefixSum[i] 代表 前i个数之和，也就是 下标区间在 0 ~ i-1 这一段的和\r\n\r\n那么回过头来看看，为什么我们需要一个 (0,0) 的 pair 呢？\r\n因为 这个 0,0 代表的就是前0个数之和为0\r\n一个 n 个数的数组， 变成了 prefix Sum 数组之后，会多一个数出来\r\n*/"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: A list of integers includes the index of the first number \r\n     *          and the index of the last number\r\n     */\r\n    struct node {\r\n        node(int _value, int _pos):value(_value), pos(_pos) {}\r\n        int value, pos;\r\n        bool operator<(const node &o) const{\r\n            return (value < o.value || value == o.value && pos < o.pos);\r\n        }\r\n    };\r\n    vector<int> subarraySumClosest(vector<int> nums){\r\n        // write your code here\r\n        vector<node> s;\r\n        vector<int> results(2);\r\n        s.push_back(node(0,-1));\r\n        int sum = 0, len = nums.size();\r\n        for (int i = 0; i < len ; ++i) {\r\n            sum += nums[i];     \r\n            s.push_back(node(sum, i));\r\n        }\r\n        sort(s.begin(), s.end());\r\n        len = s.size();\r\n        int ans = 0x7fffffff;\r\n        for (int i = 0; i < len-1; ++i)\r\n            if (abs(s[i+1].value - s[i].value) < ans) { \r\n                ans = abs(s[i+1].value - s[i].value);\r\n                results[0] = min(s[i].pos, s[i+1].pos)+1;\r\n                results[1] = max(s[i].pos, s[i+1].pos);\r\n            }\r\n        return results;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Node:\r\n    def __init__(self, _value, _pos):\r\n        self.value = _value\r\n        self.pos = _pos\r\n    def __cmp__(self, other):\r\n        if self.value == other.value:\r\n            return self.pos - other.pos\r\n        return self.value - other.value \r\nclass Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers\r\n    @return: A list of integers includes the index of the first number \r\n             and the index of the last number\r\n    \"\"\"\r\n\r\n        \r\n    def subarraySumClosest(self, nums):\r\n        # write your code here\r\n        s = []\r\n        s.append(Node(0, -1))\r\n        sum = 0\r\n        for x in xrange(len(nums)):\r\n            sum += nums[x]\r\n            s.append(Node(sum, x))\r\n\r\n        s = sorted(s)\r\n        results= [0,0]\r\n        ans = 1000000000000\r\n        for i in xrange(len(s)-1):\r\n            if s[i+1].value - s[i].value < ans or \\\r\n                s[i+1].value - s[i].value == ans and \\\r\n                min(s[i+1].pos, s[i].pos) + 1 < results[0]:\r\n                ans = s[i+1].value - s[i].value\r\n                results[0] = min(s[i+1].pos, s[i].pos) + 1          \r\n                results[1] = max(s[i+1].pos, s[i].pos)\r\n\r\n        return results\r\n"}]},{"id":651,"unique_name":"boggle-game","title":"拼字游戏","description":"给定一个2D矩阵包括 `a-z` 和字典 `dict`，找到矩阵上最大的单词集合，这些单词不能在相同的位置重叠。返回最大集合的 `大小`。","solutions":[{"language":"java","code":"class Trie {\r\n    TrieNode root;\r\n\r\n    Trie() {\r\n        root = new TrieNode('0');\r\n    }\r\n\r\n    public void insert(String word) {\r\n        if(word == null || word.length() == 0) {\r\n            return;\r\n        }\r\n        TrieNode node = root;\r\n        for(int i = 0; i < word.length(); i++) {\r\n            char ch = word.charAt(i);\r\n            if(node.children[ch - 'a'] == null) {\r\n                node.children[ch - 'a'] = new TrieNode(ch);\r\n            }\r\n            node = node.children[ch - 'a'];\r\n        }\r\n        node.isWord = true;\r\n    }\r\n}\r\n\r\nclass TrieNode {\r\n    char value;\r\n    boolean isWord;\r\n    TrieNode[] children;\r\n\r\n    TrieNode(char v) {\r\n        value = v;\r\n        isWord = false;\r\n        children = new TrieNode[26];\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param board a list of lists of character\r\n     * @param words a list of string\r\n     * @return an integer\r\n     */\r\n    public int boggleGame(char[][] board, String[] words) {\r\n        // Write your code here\r\n        Trie trie = new Trie();\r\n        for(String word : words) {\r\n            trie.insert(word);\r\n        }\r\n\r\n        int m = board.length;\r\n        int n = board[0].length;\r\n        List<String> result = new ArrayList<>();\r\n        boolean[][] visited = new boolean[m][n];\r\n        List<String> path = new ArrayList<>();\r\n        findWords(result, board, visited, path, 0, 0, trie.root);\r\n        return result.size();\r\n    }\r\n\r\n    public void findWords(List<String> result, char[][] board, boolean[][] visited, List<String> words, int x, int y, TrieNode root) {\r\n\r\n        int m = board.length;\r\n        int n = board[0].length;\r\n        for (int i = x; i < m; i++) {\r\n            for (int j = y; j < n; j++) {\r\n                List<List<Integer>> nextWordIndexes = new ArrayList<>();\r\n                List<Integer> path = new ArrayList<>();\r\n                getNextWords(nextWordIndexes, board, visited, path, i, j, root);\r\n                for (List<Integer> indexes : nextWordIndexes) {\r\n                    String word = \"\";\r\n                    for (int index : indexes) {\r\n                        int row = index / n;\r\n                        int col = index % n;\r\n                        visited[row][col] = true;\r\n                        word += board[row][col];\r\n                    }\r\n\r\n                    words.add(word);\r\n                    if (words.size() > result.size()) {\r\n                        result.clear();\r\n                        result.addAll(words);\r\n                    }\r\n                    findWords(result, board, visited, words, i, j, root);\r\n                    for (int index : indexes) {\r\n                        int row = index / n;\r\n                        int col = index % n;\r\n                        visited[row][col] = false;\r\n                    }\r\n                    words.remove(words.size() - 1);\r\n                }\r\n            }\r\n            y = 0;\r\n        }\r\n    }\r\n    \r\n    int []dx = {0, 1, 0, -1};\r\n    int []dy = {1, 0, -1, 0};\r\n    private void getNextWords(List<List<Integer>> words, char[][] board,\r\n                              boolean[][] visited, List<Integer> path, int i, int j, TrieNode root) {\r\n        if(i < 0 | i >= board.length || j < 0 || j >= board[0].length\r\n            || visited[i][j] == true || root.children[board[i][j] - 'a'] == null) {\r\n            return;\r\n        }\r\n\r\n        root = root.children[board[i][j] - 'a'];\r\n        if(root.isWord) {\r\n            List<Integer> newPath = new ArrayList<>(path);\r\n            newPath.add(i * board[0].length + j);\r\n            words.add(newPath);\r\n            return;\r\n        }\r\n\r\n        visited[i][j] = true;\r\n        path.add(i * board[0].length + j);\r\n        for (int k = 0; k < 4; k ++) {\r\n            getNextWords(words, board, visited, path, i + dx[k], j + dy[k], root);\r\n        }\r\n        path.remove(path.size() - 1);\r\n        visited[i][j] = false;\r\n    }\r\n}"},{"language":"cpp","code":"class TrieNode {\npublic:\n    // Initialize your data structure here.\n    TrieNode() {\n        next.resize(26);\n        isEnd = false;\n        str = \"\";\n    }\n    \n    vector<TrieNode *> next;\n    bool isEnd;\n    string str;\n};\n\nclass Solution {\npublic:\n    /**\n     * @param board a list of lists of character\n     * @param words a list of string\n     * @return an integer\n     */\n    int boggleGame(vector<vector<char> > &board, vector<string> &words) {\n        // write your code here\n        int m = board.size();\n        if (m == 0) {\n            return 0;\n        }\n        int n = board[0].size();\n        \n        TrieNode* root = new TrieNode();\n        for (string& word : words) {\n            insert(word, root);\n        }\n        \n        maxCount = 0;\n        vector<vector<bool>> visited(m, vector<bool>(n));\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dfs(board, i, j, visited, root, 0);\n            }\n        }\n        return maxCount;\n    }\n    \nprivate:\n    int maxCount;\n    void insert(string word, TrieNode* root) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->next[c - 'a'] == nullptr) {\n                node->next[c - 'a'] = new TrieNode();\n            }\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = true;\n        node->str = word;\n    }\n    \n    void dfs(vector<vector<char> > &board, int x, int y, \n             vector<vector<bool>>& visited,\n             TrieNode* root, int count) {\n                 \n        int m = board.size();\n        int n = board[0].size();\n        for (int i = x; i < m; ++i) {\n            for (int j = y; j < n; ++j) {\n                vector<vector<int>> visitedPaths;\n                vector<int> paths;\n                findNextWord(board, i, j, visited, root, root, paths, visitedPaths, count);\n                for (auto path : visitedPaths) {\n                    for (int pos : path) {\n                        visited[pos / n][pos % n] = true;\n                    }\n                    \n                    dfs(board, i, j, visited, root, count + 1);\n                    \n                    for (int pos : path)\n                    {\n                        visited[pos / n][pos % n] = false;\n                    }\n                }\n    \n            }\n            y = 0;\n        }\n    }\n\n    \n    void findNextWord(vector<vector<char> > &board, int i, int j,\n                      vector<vector<bool>>& visited,\n                      TrieNode* root, TrieNode* currNode,\n                      vector<int>& paths,\n                      vector<vector<int>>& visitedPaths, int count) {\n        char c = board[i][j];\n        if (visited[i][j] || currNode->next[c - 'a'] == nullptr) {\n            return;\n        }\n        \n        currNode = currNode->next[c - 'a'];\n        int m = board.size();\n        int n = board[i].size();\n        paths.push_back(i * n + j);\n        if (currNode->isEnd) {\n            visitedPaths.push_back(paths);\n            maxCount = max(maxCount, count + 1);\n        } else {\n            visited[i][j] = true;\n            if (i > 0) {\n                findNextWord(board, i - 1, j, visited, root, currNode, paths, visitedPaths, count);\n            }\n            if (i < board.size() - 1) {\n                findNextWord(board, i + 1, j, visited, root, currNode, paths, visitedPaths, count);\n            }\n            if (j > 0) {\n                findNextWord(board, i, j - 1, visited, root, currNode, paths, visitedPaths, count);\n            }\n            if (j < board[i].size() - 1) {\n                findNextWord(board, i, j + 1, visited, root, currNode, paths, visitedPaths, count);\n            }\n            visited[i][j] = false;\n        }\n        paths.pop_back();\n    }\n};"},{"language":"python","code":"class TrieNode(object):\n    def __init__(self, value=0):\n        self.value = value\n        self.isWord = False\n        self.children = collections.OrderedDict()\n        \n    @classmethod\n    def insert(cls, root, word):\n        p = root\n        for c in word:\n            child = p.children.get(c)\n            if not child:\n                child = TrieNode(c)\n                p.children[c] = child\n            p = child\n\n        p.isWord = True\n\n\nclass Solution:\n    # @param {char[][]} board a list of lists of char\n    # @param {str[]} words a list of string\n    # @return {int} an integer\n    def boggleGame(self, board, words):\n        # Write your code here\n        self.board = board\n        self.words = words\n        self.m = len(board)\n        self.n = len(board[0])\n        self.results = []\n        self.temp = []\n        self.visited = [[False for _ in xrange(self.n)] for _ in xrange(self.m)]\n        \n        self.root = TrieNode()\n        for word in words:\n            TrieNode.insert(self.root, word)\n        \n        self.dfs(0, 0, self.root)\n                \n        return len(self.results)\n        \n    def dfs(self, x, y, root):\n        for i in xrange(x, self.m):\n            for j in xrange(y, self.n):\n                paths = []\n                temp = []\n                self.getAllPaths(i, j, paths, temp, root)\n                for path in paths:\n                    word = ''\n                    for px, py in path:\n                        word += self.board[px][py]\n                        self.visited[px][py] = True\n                    self.temp.append(word)\n                    \n                    if len(self.temp) > len(self.results):\n                        self.results = self.temp[:]\n                        \n                    self.dfs(i, j, root)\n                    self.temp.pop()\n                    for px, py in path:\n                        self.visited[px][py] = False\n            y = 0\n        \n    def getAllPaths(self, i, j, paths, temp, root):\n        if i < 0 or i >= self.m or j < 0 or j >= self.n or \\\n            self.board[i][j] not in root.children or \\\n            self.visited[i][j] == True:\n            return\n        \n        root = root.children[self.board[i][j]]\n        if root.isWord:\n            temp.append((i,j))\n            paths.append(temp[:])\n            temp.pop()\n            return\n            \n        self.visited[i][j] = True\n        deltas = [(0,1), (0,-1), (1,0), (-1, 0)]\n        for dx, dy in deltas:\n            newx = i + dx\n            newy = j + dy\n            temp.append((i,j))\n            self.getAllPaths(newx, newy, paths, temp, root)\n            temp.pop()\n        self.visited[i][j] = False"}]},{"id":520,"unique_name":"find-the-missing-number-ii","title":"寻找丢失的数 II","description":"给一个由 1 - `n` 的整数随机组成的一个字符串序列，其中丢失了一个整数，请找到它。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @param str a string with number from 1-n\r\n     *            in random order and miss one number\r\n     * @return an integer\r\n     */   \r\n    public boolean flag = false;\r\n    public int ans = 0;\r\n    public int findMissing2(int n, String str) {\r\n        boolean[] happen = new boolean[n + 1];\r\n        dfs(0, n, str, happen);\r\n        return ans;\r\n    }\r\n    \r\n    public void dfs(int i, int n, String s, boolean[] happen) {\r\n        if (i >= s.length() || flag) {\r\n        \tif (!flag)\r\n            for (int k = 1; k <= n; k++) {\r\n                if (!happen[k]) {\r\n                    ans = k;\r\n                }\r\n            }\r\n        \tflag = true;\r\n            return;\r\n        }\r\n        int sum = s.charAt(i) - '0';\r\n        int j = i;\r\n        if (sum == 0) {\r\n            return;\r\n        }\r\n        while (sum <= n) {\r\n            if (!happen[sum]) {\r\n                happen[sum] = true;\r\n                dfs(j+1, n, s, happen);\r\n                happen[sum] = false;\r\n            }\r\n            j++;\r\n            if (j >= s.length()) {\r\n                break;\r\n            }\r\n            sum = sum * 10 + (s.charAt(j) - '0');\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n an integer\r\n     * @param str a string with number from 1-n in \r\n     *            random order and miss one number\r\n     * @return an integer\r\n     */\r\n    int findMissing2(int n, string& str) {\r\n        // Write your code here\r\n        vector<bool> used(n + 1, false);\r\n        return find(n, str, 0, used);\r\n    }\r\n\r\n    int find(int n, string& str, int index, vector<bool>& used) {\r\n\r\n        if (index == str.size()) {\r\n            vector<int> result;\r\n            for (int i = 1; i <= n; ++i)\r\n                if (!used[i])\r\n                    result.push_back(i);\r\n            if (result.size() == 1)\r\n                return result[0];\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        if (str[index] == '0')\r\n            return -1;\r\n\r\n        for (int i = 1; i < 3; ++i) {\r\n            int num = getNumber(str, index, i);\r\n            if (num >= 1 && num <= n && !used[num]) {\r\n                used[num] = true;\r\n                int target = find(n, str, index + i, used);\r\n                if (target != -1)\r\n                    return target;\r\n                used[num] = false;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    int getNumber(string& str, int start, int len) {\r\n        return atoi(str.substr(start, len).c_str());\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n an integer\r\n    # @param {string} str a string with number from 1-n\r\n    #                     in random order and miss one number\r\n    # @return {int} an integer\r\n    def findMissing2(self, n, str):\r\n        # Write your code here\r\n        used = [False for _ in xrange(n + 1)]\r\n        return self.find(n, str, 0, used)\r\n\r\n    def find(self, n, str, index, used):\r\n        \r\n        if index == len(str):\r\n            results = []\r\n            for i in xrange(1, n + 1):\r\n                if not used[i]:\r\n                    results.append(i)\r\n            return results[0] if len(results) ==1 else -1\r\n\r\n        if str[index] == '0':\r\n            return -1\r\n\r\n        for l in xrange(1, 3):\r\n            num = int(str[index : index + l])\r\n            if num >=1 and num <= n and not used[num]:\r\n                used[num] = True\r\n                target = self.find(n, str, index + l, used)\r\n                if target != -1:\r\n                    return target\r\n                used[num] = False\r\n\r\n        return -1"}]},{"id":43,"unique_name":"flatten-binary-tree-to-linked-list","title":"将二叉树拆成链表","description":"将一棵二叉树按照前序遍历拆解成为一个`假链表`。所谓的假链表是说，用二叉树的 *right* 指针，来表示链表中的 *next* 指针。","solutions":[{"language":"java","code":"// Version 1: Traverse\r\npublic class Solution {\r\n    private TreeNode lastNode = null;\r\n\r\n    public void flatten(TreeNode root) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n\r\n        if (lastNode != null) {\r\n            lastNode.left = null;\r\n            lastNode.right = root;\r\n        }\r\n\r\n        lastNode = root;\r\n        TreeNode right = root.right;\r\n        flatten(root.left);\r\n        flatten(right);\r\n    }\r\n}\r\n\r\n// version 2: Divide & Conquer\r\npublic class Solution {\r\n    /**\r\n     * @param root: a TreeNode, the root of the binary tree\r\n     * @return: nothing\r\n     */\r\n    public void flatten(TreeNode root) {\r\n        helper(root);\r\n    }\r\n    \r\n    // flatten root and return the last node\r\n    private TreeNode helper(TreeNode root) {\r\n        if (root == null) {\r\n            return null;\r\n        }\r\n        \r\n        TreeNode leftLast = helper(root.left);\r\n        TreeNode rightLast = helper(root.right);\r\n        \r\n        // connect leftLast to root.right\r\n        if (leftLast != null) {\r\n            leftLast.right = root.right;\r\n            root.right = root.left;\r\n            root.left = null;\r\n        }\r\n        \r\n        if (rightLast != null) {\r\n            return rightLast;\r\n        }\r\n        \r\n        if (leftLast != null) {\r\n            return leftLast;\r\n        }\r\n        \r\n        return root;\r\n    }\r\n}\r\n\r\n// version 3: Non-Recursion\r\n/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: a TreeNode, the root of the binary tree\r\n     * @return: nothing\r\n     */\r\n    public void flatten(TreeNode root) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        \r\n        Stack<TreeNode> stack = new Stack<>();\r\n        stack.push(root);\r\n        \r\n        while (!stack.empty()) {\r\n            TreeNode node = stack.pop();\r\n            if (node.right != null) {\r\n                stack.push(node.right);\r\n            }\r\n            if (node.left != null) {\r\n                stack.push(node.left);\r\n            }\r\n            \r\n            // connect \r\n            node.left = null;\r\n            if (stack.empty()) {\r\n                node.right = null;\r\n            } else {\r\n                node.right = stack.peek();\r\n            }\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: a TreeNode, the root of the binary tree\r\n     * @return: nothing\r\n     */\r\n    void flatten(TreeNode *root) {\r\n        // write your code here\r\n        if (root == NULL) return;  \r\n        while (root) {  \r\n            if (root->left) {  \r\n                TreeNode *pre = root->left;  \r\n                while (pre->right)  \r\n                    pre = pre->right;  \r\n                pre->right = root->right;  \r\n                root->right = root->left;  \r\n                root->left = NULL;  \r\n            }\r\n            root = root->right;\r\n        }  \r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    # @param root: a TreeNode, the root of the binary tree\r\n    # @return: nothing\r\n    def flatten(self, root):\r\n        # write your code here\r\n        if root == None:\r\n            return\r\n        self.flatten(root.left)\r\n        self.flatten(root.right)\r\n        p = root\r\n        if p.left == None:\r\n            return\r\n        p = p.left\r\n        while p.right:\r\n            p = p.right\r\n        p.right = root.right\r\n        root.right = root.left\r\n        root.left = None\r\n"}]},{"id":434,"unique_name":"route-between-two-nodes-in-graph","title":"图中两个点之间的路线","description":"给出一张有向图，设计一个算法判断两个点 `s` 与 `t` 之间是否存在路线。","solutions":[{"language":"java","code":"/**\r\n * Definition for Directed graph.\r\n * class DirectedGraphNode {\r\n *     int label;\r\n *     ArrayList<DirectedGraphNode> neighbors;\r\n *     DirectedGraphNode(int x) { label = x; neighbors = new ArrayList<DirectedGraphNode>(); }\r\n * };\r\n */\r\npublic class Solution {\r\n   /**\r\n     * @param graph: A list of Directed graph node\r\n     * @param s: the starting Directed graph node\r\n     * @param t: the terminal Directed graph node\r\n     * @return: a boolean value\r\n     */\r\n    public boolean hasRoute(ArrayList<DirectedGraphNode> graph,\r\n                                 DirectedGraphNode s, DirectedGraphNode t) {\r\n        if (s == t)\r\n            return true;\r\n\r\n        HashSet<DirectedGraphNode> visited = new HashSet<DirectedGraphNode>();\r\n        Queue<DirectedGraphNode> queue = new LinkedList<DirectedGraphNode>();\r\n        \r\n        queue.offer(s);\r\n        visited.add(s);\r\n        while (!queue.isEmpty()) {\r\n            DirectedGraphNode node = queue.poll();\r\n            for (int i = 0; i < node.neighbors.size(); i++) {\r\n                if (visited.contains(node.neighbors.get(i))) {\r\n                    continue;\r\n                }\r\n                visited.add(node.neighbors.get(i));\r\n                queue.offer(node.neighbors.get(i));\r\n                if (node.neighbors.get(i) == t) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition for Directed graph.\r\n * struct DirectedGraphNode {\r\n *     int label;\r\n *     vector<DirectedGraphNode *> neighbors;\r\n *     DirectedGraphNode(int x) : label(x) {};\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool dfs(DirectedGraphNode* s, map<DirectedGraphNode*, int> &countrd,DirectedGraphNode* t)\r\n    {\r\n        if(s == t)\r\n            return true;\r\n        if(countrd[s] == 0)\r\n            return false;\r\n        countrd[s] = 0;\r\n        for(int j = 0; j < s->neighbors.size(); j++) {\r\n            if(dfs(s->neighbors[j], countrd, t))\r\n                return true;\r\n\t    }\r\n        return false;\r\n    }\r\n    /**\r\n     * @param graph: A list of Directed graph node\r\n     * @param s: the starting Directed graph node\r\n     * @param t: the terminal Directed graph node\r\n     * @return: a boolean value\r\n     */\r\n    bool hasRoute(vector<DirectedGraphNode*> graph, DirectedGraphNode* s, DirectedGraphNode* t) {\r\n        // write your code here\r\n        map<DirectedGraphNode*, int> countrd;\r\n        vector<DirectedGraphNode*> ans;\r\n        for(int i = 0; i < graph.size(); i++)\r\n             countrd[graph[i]] = 1;\r\n        return dfs(s, countrd, t);\r\n    }\r\n};"},{"language":"python","code":"# Definition for a Directed graph node\r\n# class DirectedGraphNode:\r\n#     def __init__(self, x):\r\n#         self.label = x\r\n#         self.neighbors = []\r\n\r\nclass Solution:\r\n    def dfs(self, i, countrd, graph, t):\r\n        if countrd[i] == 1:\r\n            return False\r\n        if i == t:\r\n            return True\r\n        countrd[i] = 1\r\n        for j in i.neighbors:\r\n            if countrd[j] == 0 and self.dfs(j, countrd, graph, t):\r\n                return True\r\n        return False\r\n    \"\"\"\r\n    @param graph: A list of Directed graph node\r\n    @param s: the starting Directed graph node\r\n    @param t: the terminal Directed graph node\r\n    @return: a boolean value\r\n    \"\"\"\r\n\r\n    def hasRoute(self, graph, s, t):\r\n\tcountrd = {}\r\n        for x in graph:\r\n            countrd[x] = 0\r\n        return self.dfs(s, countrd, graph, t)"}]},{"id":174,"unique_name":"topological-sorting","title":"拓扑排序","description":"<p><span style=\"line-height: 1.42857143;\">给定一个有向图，图节点的拓扑排序被定义为：</span><br></p><p><ul><li><span style=\"line-height: 1.42857143;\">对于每条有向边A<span style=\"color: rgb(113, 113, 113); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\">--&gt;</span>&nbsp;B，则A必须排在B之前　　</span><br></li><li><span style=\"line-height: 1.42857143;\">拓扑排序的第一个节点可以是任何在图中没有其他节点指向它的节点　　</span><br></li></ul></p><p>找到给定图的任一拓扑排序</p><p><br></p>","solutions":[{"language":"java","code":"/**\r\n * Definition for Directed graph.\r\n * class DirectedGraphNode {\r\n *     int label;\r\n *     ArrayList<DirectedGraphNode> neighbors;\r\n *     DirectedGraphNode(int x) { label = x; neighbors = new ArrayList<DirectedGraphNode>(); }\r\n * };\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param graph: A list of Directed graph node\r\n     * @return: Any topological order for the given graph.\r\n     */    \r\n    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {\r\n        // write your code here\r\n        ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();\r\n        HashMap<DirectedGraphNode, Integer> map = new HashMap();\r\n        for (DirectedGraphNode node : graph) {\r\n            for (DirectedGraphNode neighbor : node.neighbors) {\r\n                if (map.containsKey(neighbor)) {\r\n                    map.put(neighbor, map.get(neighbor) + 1);\r\n                } else {\r\n                    map.put(neighbor, 1); \r\n                }\r\n            }\r\n        }\r\n        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();\r\n        for (DirectedGraphNode node : graph) {\r\n            if (!map.containsKey(node)) {\r\n                q.offer(node);\r\n                result.add(node);\r\n            }\r\n        }\r\n        while (!q.isEmpty()) {\r\n            DirectedGraphNode node = q.poll();\r\n            for (DirectedGraphNode n : node.neighbors) {\r\n                map.put(n, map.get(n) - 1);\r\n                if (map.get(n) == 0) {\r\n                    result.add(n);\r\n                    q.offer(n);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition for Directed graph.\r\n * struct DirectedGraphNode {\r\n *     int label;\r\n *     vector<DirectedGraphNode *> neighbors;\r\n *     DirectedGraphNode(int x) : label(x) {};\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    void dfs(DirectedGraphNode* i, vector<DirectedGraphNode*> &ans, map<DirectedGraphNode*, int> &countrd,vector<DirectedGraphNode*> graph)         \r\n    {\r\n    \tans.push_back(i);\r\n        countrd[i]--;\r\n        for(int j = 0; j < i->neighbors.size(); j++) {\r\n\t\t        countrd[i->neighbors[j]]--;\r\n                if(countrd[i->neighbors[j]] == 0)\r\n\t\t        dfs(i->neighbors[j], ans, countrd, graph);\r\n\t    }\r\n    }\r\n    /**\r\n     * @param graph: A list of Directed graph node\r\n     * @return: Any topological order for the given graph.\r\n     */\r\n    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {\r\n        // write your code here\r\n        map<DirectedGraphNode*, int> countrd;\r\n        vector<DirectedGraphNode*> ans;\r\n        for(int i = 0; i < graph.size(); i++)\r\n            for(int j = 0; j < graph[i]->neighbors.size(); j++)\r\n                 if (countrd.find(graph[i]->neighbors[j]) == countrd.end())\r\n                    countrd[graph[i]->neighbors[j]] = 1;\r\n                 else\r\n                    countrd[graph[i]->neighbors[j]] += 1;\r\n\r\n        for(int i = 0; i < graph.size(); i++)\r\n            if(countrd[graph[i]] == 0)\r\n                dfs(graph[i], ans, countrd, graph);\r\n        return ans;\r\n    }\r\n};"},{"language":"python","code":"# Definition for a Directed graph node\n# class DirectedGraphNode:\n#     def __init__(self, x):\n#         self.label = x\n#         self.neighbors = []\n\nclass Solution:\n    def dfs(self, i, countrd, ans):\n        ans.append(i)\n        countrd[i] -= 1\n        for j in i.neighbors:\n            countrd[j] = countrd[j] - 1\n            if countrd[j] == 0:\n                self.dfs(j, countrd, ans)\n    \"\"\"\n    @param graph: A list of Directed graph node\n    @return: A list of integer\n    \"\"\"\n    def topSort(self, graph):\n        # write your code here\n        countrd = {}\n        for x in graph:\n            countrd[x] = 0\n\n        for i in graph:\n            for j in i.neighbors:\n                countrd[j] = countrd[j] + 1\n\n        ans = []\n        for i in graph:\n            if countrd[i] == 0:\n                self.dfs(i, countrd, ans)\n        return ans\n"}]},{"id":342,"unique_name":"k-sum-ii","title":"k数和 II","description":"","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A: an integer array.\r\n     * @param k: a positive integer (k <= length(A))\r\n     * @param target: a integer\r\n     * @return an integer\r\n     */    \r\n    List<List<Integer> > ans;\r\n    public void dfs(int A[], int K, int target, int index, List<Integer> tans)\r\n    {\r\n\r\n        if(K == 0 && target == 0) {\r\n            ans.add(new ArrayList<Integer>(tans));\r\n            return ;\r\n        }\r\n        if(K < 0 || target < 0 || index < 0)\r\n            return ;\r\n        dfs(A, K, target, index - 1, tans);\r\n        tans.add(A[index]);\r\n        dfs(A, K  - 1, target - A[index], index - 1, tans);\r\n        tans.remove(tans.size() - 1);\r\n        \r\n    }\r\n    \r\n    public List<List<Integer>> kSumII(int A[], int K, int target) {\r\n        ans = new ArrayList<List<Integer>>();\r\n        List<Integer> tans = new ArrayList<Integer>();\r\n        dfs(A, K, target, A.length - 1, tans);\r\n        return ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int ans[105][1005];\r\n    void append(vector<vector<int> > & A, vector<vector<int> > &B, int C) {\r\n        for(int i = 0; i < B.size(); i++) {\r\n            A.push_back(B[i]);\r\n            A[A.size() - 1].push_back(C);\r\n        }\r\n    }\r\n    vector<vector<int> > anslist[105][1005];\r\n    vector<vector<int> > kSumII(vector<int> A, int k, int target) {\r\n        ans[0][0] = 1;\r\n        anslist[0][0].push_back(vector<int>());\r\n        for(int i = 0; i < A.size(); ++i)\r\n            for(int j = k; j > 0; j--)\r\n                for(int l = target; l >= A[i]; l--) {\r\n                    ans[j][l] += ans[j - 1][l - A[i]];\r\n                    append(anslist[j][l], anslist[j - 1][l - A[i]], A[i]);\r\n                }\r\n        return anslist[k][target];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    def dfs(self, A, k, target, index, onelist):\r\n        \r\n        if(target == 0 and k == 0):\r\n            self.anslist.append(onelist)\r\n            return None\r\n        if(len(A) == index or target < 0 or k < 0):\r\n            return None\r\n        self.dfs(A, k, target, index + 1, onelist)\r\n        otheronelist = [A[index]]\r\n        otheronelist.extend(onelist)\r\n        self.dfs(A, k - 1, target - A[index],  index + 1 , otheronelist)\r\n\r\n    def kSumII(self, A, k, target):\r\n        self.anslist = []\r\n        self.dfs(A, k, target, 0, [])\r\n        return self.anslist\r\n"}]},{"id":24,"unique_name":"palindrome-partitioning","title":"分割回文串","description":"给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。\r\n\r\n返回s所有可能的回文串分割方案。","solutions":[{"language":"java","code":"// version 1: shorter but slower\r\npublic class Solution {\r\n    /**\r\n     * @param s: A string\r\n     * @return: A list of lists of string\r\n     */\r\n    public List<List<String>> partition(String s) {\r\n        List<List<String>> results = new ArrayList<>();\r\n        if (s == null || s.length() == 0) {\r\n            return results;\r\n        }\r\n        \r\n        List<String> partition = new ArrayList<String>();\r\n        helper(s, 0, partition, results);\r\n        \r\n        return results;\r\n    }\r\n    \r\n    private void helper(String s,\r\n                        int startIndex,\r\n                        List<String> partition,\r\n                        List<List<String>> results) {\r\n        if (startIndex == s.length()) {\r\n            results.add(new ArrayList<String>(partition));\r\n            return;\r\n        }\r\n        \r\n        for (int i = startIndex; i < s.length(); i++) {\r\n            String subString = s.substring(startIndex, i + 1);\r\n            if (!isPalindrome(subString)) {\r\n                continue;\r\n            }\r\n            partition.add(subString);\r\n            helper(s, i + 1, partition, results);\r\n            partition.remove(partition.size() - 1);\r\n        }\r\n    }\r\n    \r\n    private boolean isPalindrome(String s) {\r\n        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\r\n            if (s.charAt(i) != s.charAt(j)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// version 2: longer but faster\r\npublic class Solution {\r\n    List<List<String>> results;\r\n    boolean[][] isPalindrome;\r\n    \r\n    /**\r\n     * @param s: A string\r\n     * @return: A list of lists of string\r\n     */\r\n    public List<List<String>> partition(String s) {\r\n        results = new ArrayList<>();\r\n        if (s == null || s.length() == 0) {\r\n            return results;\r\n        }\r\n        \r\n        getIsPalindrome(s);\r\n        \r\n        helper(s, 0, new ArrayList<Integer>());\r\n        \r\n        return results;\r\n    }\r\n    \r\n    private void getIsPalindrome(String s) {\r\n        int n = s.length();\r\n        isPalindrome = new boolean[n][n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            isPalindrome[i][i] = true;\r\n        }\r\n        for (int i = 0; i < n - 1; i++) {\r\n            isPalindrome[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));\r\n        }\r\n        \r\n        for (int i = n - 3; i >= 0; i--) {\r\n            for (int j = i + 2; j < n; j++) {\r\n                isPalindrome[i][j] = isPalindrome[i + 1][j - 1] && s.charAt(i) == s.charAt(j);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void helper(String s,\r\n                        int startIndex,\r\n                        List<Integer> partition) {\r\n        if (startIndex == s.length()) {\r\n            addResult(s, partition);\r\n            return;\r\n        }\r\n        \r\n        for (int i = startIndex; i < s.length(); i++) {\r\n            if (!isPalindrome[startIndex][i]) {\r\n                continue;\r\n            }\r\n            partition.add(i);\r\n            helper(s, i + 1, partition);\r\n            partition.remove(partition.size() - 1);\r\n        }\r\n    }\r\n    \r\n    private void addResult(String s, List<Integer> partition) {\r\n        List<String> result = new ArrayList<>();\r\n        int startIndex = 0;\r\n        for (int i = 0; i < partition.size(); i++) {\r\n            result.add(s.substring(startIndex, partition.get(i) + 1));\r\n            startIndex = partition.get(i) + 1;\r\n        }\r\n        results.add(result);\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param s: A string\r\n     * @return: A list of lists of string\r\n     */\r\n    vector<vector<string>>v;\r\n    vector<string>v1;\r\n    vector<vector<string>> partition(string s) {\r\n        // write your code here\r\n        v.clear();\r\n        if(s.size()==0)return v;\r\n        v1.clear();\r\n        dfs(0,s);\r\n        return v;         \r\n    }\r\n    bool ishui(string s) {\r\n        int i=0,j=s.size()-1;\r\n        while(i<j)\r\n        {\r\n            if(s[i]==s[j])\r\n            {\r\n                i++;j--;\r\n            }\r\n            else return false;\r\n        }\r\n        return true;\r\n    }   \r\n    void dfs(int depth,string s) {\r\n        if(depth==s.size())\r\n        {\r\n            v.push_back(v1);\r\n        }\r\n        if(depth<s.size())\r\n        {\r\n            for(int i=depth;i<s.size();i++)\r\n            {\r\n                if(ishui(s.substr(depth,i-depth+1)))\r\n                {\r\n                    v1.push_back(s.substr(depth,i-depth+1));\r\n                    dfs(i+1,s);\r\n                    v1.pop_back();                   \r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param s, a string\r\n    # @return a list of lists of string\r\n    def isPalindrome(self, s):\r\n        for i in range(len(s)):\r\n            if s[i] != s[len(s)-1-i]: return False\r\n        return True\r\n    \r\n    def dfs(self, s, stringlist):\r\n        if len(s) == 0: Solution.res.append(stringlist)\r\n        for i in range(1, len(s)+1):\r\n            if self.isPalindrome(s[:i]):\r\n                self.dfs(s[i:], stringlist+[s[:i]])\r\n            \r\n    def partition(self, s):\r\n        Solution.res = []\r\n        self.dfs(s, [])\r\n        return Solution.res"}]},{"id":46,"unique_name":"minimum-depth-of-binary-tree","title":"二叉树的最小深度","description":"<p>给定一个二叉树，找出其最小深度。</p><div>二叉树的最小深度为根节点到最近叶子节点的距离。</div>","solutions":[{"language":"java","code":"public class Solution {\r\n    public int minDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        return getMin(root);\r\n    }\r\n\r\n    public int getMin(TreeNode root){\r\n        if (root == null) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n\r\n        if (root.left == null && root.right == null) {\r\n            return 1;\r\n        }\r\n\r\n        return Math.min(getMin(root.left), getMin(root.right)) + 1;\r\n    }\r\n}"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param root: The root of binary tree.\n     * @return: An integer\n     */\n    int ans;\n    int solve_dp(TreeNode *root) {\n        if(root == NULL)\n            return 0;   \n\n        if (root->left == NULL && root->right == NULL)\n            return 1;\n \n        int lf = 0x7fffffff, rt = 0x7fffffff;\n        if(root->left)\n            lf = solve_dp(root->left);\n         \n        if(root->right) \n            rt = solve_dp(root->right);\n\n        return min(lf, rt) + 1;\n    }\n    int minDepth(TreeNode *root) {\n        // write your code here\n        if (!root) return 0;\n        return solve_dp(root);\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param root: The root of binary tree.\n    @return: An integer\n    \"\"\" \n    def minDepth(self, root):\n        # write your code here\n        return self.find(root)\n\n    def find(self, node):\n        if node is None:\n            return 0\n        left, right = 0, 0\n        if node.left != None:\n            left = self.find(node.left)\n        else:\n            return self.find(node.right) + 1\n\n        if node.right != None:\n            right = self.find(node.right)\n        else:\n            return left + 1\n\n        return min(left,right) + 1\n"}]},{"id":28,"unique_name":"word-ladder-ii","title":"单词接龙 II","description":"<p><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">给出两个单词（start和end）和一个字典，找出所有从start到end的最短转换序列</span></p><p><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">比如：</span><br></p><h4 style=\"font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); margin: 0pt; text-indent: 0pt;\"><ol><li><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">每次只能改变一个字母。</span><br></li><li><span style=\"font-family: 宋体; font-size: 10.5pt; color: inherit; line-height: 1.1; text-indent: 0pt;\">变换过程中的中间单词必须在字典中出现。</span></li></ol></h4>","solutions":[{"language":"java","code":"public class Solution {\r\n    public List<List<String>> findLadders(String start, String end,\r\n            Set<String> dict) {\r\n        List<List<String>> ladders = new ArrayList<List<String>>();\r\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\r\n        Map<String, Integer> distance = new HashMap<String, Integer>();\r\n\r\n        dict.add(start);\r\n        dict.add(end);\r\n \r\n        bfs(map, distance, start, end, dict);\r\n        \r\n        List<String> path = new ArrayList<String>();\r\n        \r\n        dfs(ladders, path, end, start, distance, map);\r\n\r\n        return ladders;\r\n    }\r\n\r\n    void dfs(List<List<String>> ladders, List<String> path, String crt,\r\n            String start, Map<String, Integer> distance,\r\n            Map<String, List<String>> map) {\r\n        path.add(crt);\r\n        if (crt.equals(start)) {\r\n            Collections.reverse(path);\r\n            ladders.add(new ArrayList<String>(path));\r\n            Collections.reverse(path);\r\n        } else {\r\n            for (String next : map.get(crt)) {\r\n                if (distance.containsKey(next) && distance.get(crt) == distance.get(next) + 1) { \r\n                    dfs(ladders, path, next, start, distance, map);\r\n                }\r\n            }           \r\n        }\r\n        path.remove(path.size() - 1);\r\n    }\r\n\r\n    void bfs(Map<String, List<String>> map, Map<String, Integer> distance,\r\n            String start, String end, Set<String> dict) {\r\n        Queue<String> q = new LinkedList<String>();\r\n        q.offer(start);\r\n        distance.put(start, 0);\r\n        for (String s : dict) {\r\n            map.put(s, new ArrayList<String>());\r\n        }\r\n        \r\n        while (!q.isEmpty()) {\r\n            String crt = q.poll();\r\n\r\n            List<String> nextList = expand(crt, dict);\r\n            for (String next : nextList) {\r\n                map.get(next).add(crt);\r\n                if (!distance.containsKey(next)) {\r\n                    distance.put(next, distance.get(crt) + 1);\r\n                    q.offer(next);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    List<String> expand(String crt, Set<String> dict) {\r\n        List<String> expansion = new ArrayList<String>();\r\n\r\n        for (int i = 0; i < crt.length(); i++) {\r\n            for (char ch = 'a'; ch <= 'z'; ch++) {\r\n                if (ch != crt.charAt(i)) {\r\n                    String expanded = crt.substring(0, i) + ch\r\n                            + crt.substring(i + 1);\r\n                    if (dict.contains(expanded)) {\r\n                        expansion.add(expanded);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return expansion;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    vector<vector<string> > ans;\r\n    vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {\r\n        dict.insert(end);\r\n        int dsize = dict.size(), len = start.length();\r\n        unordered_map<string, vector<string> > next;\r\n        unordered_map<string, int> vis;\r\n        queue<string> q;\r\n        vector<string> path;\r\n        ans.clear();\r\n        q.push(start);\r\n        vis[start] = 0;\r\n        while (!q.empty()) {\r\n            string s = q.front(); q.pop();\r\n            if (s == end) break;\r\n            int step = vis[s];\r\n            vector<string> snext;\r\n            for (int i = 0; i < len; i++) {\r\n                string news = s;\r\n                for (char c = 'a'; c <= 'z'; c++) {\r\n                    news[i] = c;\r\n                    if (c == s[i] || dict.find(news) == dict.end()) continue;\r\n                    auto it = vis.find(news);\r\n                    if (it == vis.end()) {\r\n                        q.push(news);\r\n                        vis[news] = step + 1;\r\n                    }\r\n                    snext.push_back(news);\r\n                }\r\n            }\r\n            next[s] = snext;\r\n        }\r\n        path.push_back(start);\r\n        dfspath(path, next, vis, start, end);\r\n        return ans;\r\n    }\r\n    void dfspath(vector<string> &path,  unordered_map<string, vector<string> > &next,\r\n                 unordered_map<string, int> &vis, string now, string end){\r\n        if (now == end) ans.push_back(path);\r\n        else {\r\n            auto vec = next[now];\r\n            int visn = vis[now];\r\n            for (int i = 0; i < vec.size(); i++) {\r\n                if (vis[vec[i]] != visn + 1) continue;\r\n                path.push_back(vec[i]);\r\n                dfspath(path, next, vis, vec[i], end);\r\n                path.pop_back();\r\n            }\r\n        }\r\n    }\r\n};"},{"language":"python","code":"# version 1:\r\nPython Version:\r\nclass Solution:\r\n    # @param start, a string\r\n    # @param end, a string\r\n    # @param dict, a set of string\r\n    # @return a list of lists of string\r\n    \r\n    def getEntry(self, word, index):\r\n        return word[:index] + word[index + 1:]\r\n        \r\n    def buildIndexes(self, length, dict):\r\n        indexes = []\r\n        for i in range(length):\r\n            index = {}\r\n            for word in dict:\r\n                entry = self.getEntry(word, i)\r\n                words = index.get(entry, [])\r\n                words.append(word)\r\n                index[entry] = words\r\n            indexes.append(index)\r\n        return indexes\r\n\r\n    def BFS(self, start, end):\r\n        self.distance = {}\r\n        self.distance[start] = 0\r\n        queue = [start]\r\n        while len(queue) != 0:\r\n            head = queue[0]\r\n            del queue[0]\r\n            for word in self.getNextWord(head):\r\n                if word not in self.distance:\r\n                    self.distance[word] = self.distance[head] + 1\r\n                    queue.append(word)\r\n    \r\n    def DFS(self, curt, target, path):\r\n        if curt == target:\r\n            self.results.append(list(path))\r\n            return\r\n        \r\n        for word in self.getNextWord(curt):\r\n            if self.distance.get(word, -2) + 1 == self.distance[curt]:\r\n                path.append(word)\r\n                self.DFS(word, target, path)\r\n                del path[len(path) - 1]\r\n                \r\n    def getNextWord(self, word):\r\n        for i in range(len(word)):\r\n            entry = self.getEntry(word, i)\r\n            if entry in self.indexes[i]:\r\n                for nextWord in self.indexes[i][entry]:\r\n                    if nextWord != word:\r\n                        yield nextWord\r\n                    \r\n    def findLadders(self, start, end, dict):\r\n        if start is None or end is None or len(start) != len(end):\r\n            return []\r\n        if start not in dict or end not in dict:\r\n            return []\r\n            \r\n        self.dict = dict\r\n        self.indexes = self.buildIndexes(len(start), dict)\r\n        self.BFS(end, start)\r\n        \r\n        self.results = []\r\n        if start in self.distance:\r\n            self.DFS(start, end, [start])\r\n        return self.results\r\n \r\n# version 2:\r\nclass Solution(object):\r\n    # @param start, a string\r\n    # @param end, a string\r\n    # @param dict, a set of string\r\n    # @return a list of lists of string\r\n    def findLadders(self, start, end, dict):\r\n        # Write your code here\r\n        dict.add(start)\r\n        dict.add(end)\r\n\r\n        def buildPath(path,word):\r\n            if len(preMap[word]) == 0:\r\n                result.append([word] + path)\r\n                return\r\n            path.insert(0,word)\r\n            for w in preMap[word]:\r\n                buildPath(path,w)\r\n            path.pop(0)\r\n\r\n        length = len(start)\r\n        preMap = {}\r\n        for word in dict:\r\n            preMap[word] = []\r\n        result = []\r\n        cur_level = set()\r\n        cur_level.add(start)\r\n\r\n        while True:\r\n            pre_level = cur_level\r\n            cur_level = set()\r\n            for word in pre_level:\r\n                dict.remove(word)\r\n            for word in pre_level:\r\n                for i in range(length):\r\n                    left = word[:i]\r\n                    right = word[i+1:]\r\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\r\n                        if c != word[i]:\r\n                            nextWord = left + c + right\r\n                            if nextWord in dict:\r\n                                preMap[nextWord].append(word)\r\n                                cur_level.add(nextWord)\r\n            if len(cur_level) == 0:\r\n                return []\r\n            if end in cur_level:\r\n                break\r\n        buildPath([],end)\r\n        return result"}]},{"id":802,"unique_name":"compute-24-game","title":"24点","description":"你有 `4` 张卡片, 每一张上面都有一个 `1` 到 `9` 的数字. 你需要判断是否能用运算符 `*`, `/`, `+`, `-`, `(`, `)` 来计算得到 `24`","solutions":[{"language":"java","code":"class Solution {\n    int[] A = new int[4];\n    double[][] f = new double[16][20000];\n    int[] ftop = new int[16];\n    boolean[] done = new boolean[16];    \n    \n    public void dfs(int mask) {\n        if (done[mask]) return;\n        int i, j, k;\n        double x, y;\n        ftop[mask] = 0;\n        for (i = 0; i < 4; ++i)\n            if (mask == (1 << i)) {\n                ftop[mask] = 1;\n                f[mask][0] = A[i];\n                done[mask] = true;\n                return;\n            }\n        \n        for (i = 1; i < mask; ++i) {\n            if ((i&mask) != i) continue;\n            dfs(i);\n            dfs(mask - i);\n            for (j = 0; j < ftop[i]; ++j) {\n                for (k = 0; k < ftop[mask - i]; ++k) {\n                    x = f[i][j];\n                    y = f[mask - i][k];\n                    f[mask][ftop[mask]++] = x + y;\n                    f[mask][ftop[mask]++] = x - y;\n                    f[mask][ftop[mask]++] = x * y;\n                    if (Math.abs(y) > 1e-5) f[mask][ftop[mask]++] = x / y;\n                }\n            }\n        }\n    \n        done[mask] = true;\n    }\n    \n    public boolean compute24(int[] AA) {\n        int i;\n        for (i = 0; i < 4; ++i) A[i] = AA[i];\n        for (i = 0; i < 16; ++i) done[i] = false;\n        \n        dfs(15);\n        for (i = 0; i < ftop[15]; ++i) \n            if (Math.abs(f[15][i] - 24) < 1e-5) return true;        \n        return false;\n    }\n}"}]},{"id":251,"unique_name":"expression-tree-build","title":"表达树构造","description":"表达树是一个二叉树的结构，用于衡量特定的表达。所有表达树的叶子都有一个数字字符串值。而所有表达树的非叶子都有另一个操作字符串值。\r\n\r\n给定一个表达数组，请构造该表达的表达树，并返回该表达树的根。","solutions":[{"language":"java","code":"// version 1\r\n/**\r\n * Definition of ExpressionTreeNode:\r\n * public class ExpressionTreeNode {\r\n *     public String symbol;\r\n *     public ExpressionTreeNode left, right;\r\n *     public ExpressionTreeNode(String symbol) {\r\n *         this.symbol = symbol;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\n\r\n\r\npublic class Solution {\r\n    class TreeNode {\r\n        int val;\r\n        ExpressionTreeNode eNode;\r\n        public TreeNode(int val, String s) {\r\n            this.val = val;\r\n            eNode = new ExpressionTreeNode(s);\r\n        }\r\n    }\r\n    /**\r\n     * @param expression: A string array\r\n     * @return: The root of expression tree\r\n     */\r\n    public ExpressionTreeNode build(String[] expression) {\r\n        if (expression == null || expression.length == 0) {\r\n            return null;\r\n        }\r\n        Stack<TreeNode> stack = new Stack<TreeNode>();\r\n        int base = 0;\r\n        int val = 0;\r\n\r\n        for (int i = 0; i < expression.length; i++) {\r\n            if (expression[i].equals(\"(\")) {\r\n                base += 10;\r\n                continue;\r\n            }\r\n            if (expression[i].equals(\")\")) {\r\n                base -= 10;\r\n                continue;\r\n            }\r\n            val = getWeight(base, expression[i]);\r\n            TreeNode node = new TreeNode(val, expression[i]);\r\n            while (!stack.isEmpty() && node.val <= stack.peek().val) {\r\n                node.eNode.left = stack.pop().eNode;\r\n            }\r\n            if (!stack.isEmpty()) {\r\n                stack.peek().eNode.right = node.eNode;\r\n            }\r\n            stack.push(node);\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return null;\r\n        }\r\n        TreeNode rst = stack.pop();\r\n        while (!stack.isEmpty()) {\r\n            rst = stack.pop();\r\n        }\r\n        return rst.eNode;\r\n    }\r\n    //Calculate weight for characters\r\n    public int getWeight(int base, String s) {\r\n        if (s.equals(\"+\") || s.equals(\"-\")) {\r\n            return base + 1;\r\n        }\r\n        if (s.equals(\"*\") || s.equals(\"/\")) {\r\n            return base + 2;\r\n        }\r\n        return Integer.MAX_VALUE;\r\n    }\r\n}\r\n\r\n// version 2\r\n/**\r\n * Definition of ExpressionTreeNode:\r\n * public class ExpressionTreeNode {\r\n *     public String symbol;\r\n *     public ExpressionTreeNode left, right;\r\n *     public ExpressionTreeNode(rooting symbol) {\r\n *         this.symbol = symbol;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\nclass TreeNode {\r\n\tpublic int val;\r\n\tpublic String s;\r\n\tpublic ExpressionTreeNode root; \r\n\r\n\tpublic TreeNode(int val, String ss) {\r\n\t\tthis.val = val;\r\n\t\tthis.root = new ExpressionTreeNode(ss);\r\n\t}\r\n\r\n}\r\n\r\npublic class Solution {\r\n\r\n\tint get(String a, Integer base) {\r\n\t\tif (a.equals(\"+\") || a.equals(\"-\"))\r\n\t\t\treturn 1 + base;\r\n\t\tif (a.equals(\"*\") || a.equals(\"/\"))\r\n\t\t\treturn 2 + base;\r\n\r\n\t\treturn Integer.MAX_VALUE;\r\n\t}\r\n\r\n\r\n\r\n\tpublic ExpressionTreeNode build(String[] expression) {\r\n\t\t// write your code here\r\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\r\n\t\tTreeNode root = null;\r\n\t\tint val = 0;\r\n\t\tInteger base = 0;\r\n\t\tfor (int i = 0; i <= expression.length; i++) {\r\n\t\t\tif(i != expression.length)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif (expression[i].equals(\"(\")) {\r\n\t\t\t\t\tbase += 10;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (expression[i].equals(\")\")) {\r\n\t\t\t\t\tbase -= 10;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tval = get(expression[i], base);\r\n\r\n\t\t\t}\r\n\t\t\tTreeNode right = i == expression.length ? new TreeNode(\r\n\t\t\t\t\tInteger.MIN_VALUE, \"\") : new TreeNode(val,\r\n\t\t\t\t\texpression[i]);\r\n\t\t\twhile (!stack.isEmpty()) {\r\n\t\t\t\tif (right.val <= stack.peek().val) {\r\n\t\t\t\t\tTreeNode nodeNow = stack.pop();\r\n\r\n\t\t\t\t\tif (stack.isEmpty()) {\r\n\t\t\t\t\t\tright.root.left = nodeNow.root;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTreeNode left = stack.peek();\r\n\t\t\t\t\t\tif (left.val < right.val) {\r\n\t\t\t\t\t\t\tright.root.left = nodeNow.root;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tleft.root.right = nodeNow.root;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstack.push(right);\r\n\t\t}\r\n\r\n\t\r\n\t\t\r\n\t\treturn stack.peek().root.left;\r\n\t}\r\n\r\n\r\n};\r\n"},{"language":"cpp","code":"/**\r\n * Definition of ExpressionTreeNode:\r\n * class ExpressionTreeNode {\r\n * public:\r\n *     string symbol;\r\n *     ExpressionTreeNode *left, *right;\r\n *     ExpressionTreeNode(string symbol) {\r\n *         this->symbol = symbol;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param expression: A string array\r\n     * @return: The root of expression tree\r\n     */\r\n    int getLevel(string opt) {\r\n        if (opt == \"(\")\r\n            return 0;\r\n        if (opt == \"+\" || opt == \"-\")\r\n            return 1;\r\n        if (opt == \"*\" || opt == \"/\")\r\n            return 2;\r\n\r\n        return 3;\r\n    }\r\n\r\n    bool isOperator(string c) {\r\n        return (c == \"+\" || c == \"-\" || c == \"*\" || c == \"/\");\r\n    }\r\n    \r\n    vector<string> convertToRPN(vector<string> &expression) {\r\n        stack<string> st;\r\n        vector<string> RPN;\r\n        int len = expression.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            string c = expression[i];\r\n            if (c == \"(\")\r\n                st.push(c);\r\n            else if (c == \")\") {\r\n                while (st.top() != \"(\") {\r\n                    RPN.push_back(st.top());\r\n                    st.pop();\r\n                }\r\n                st.pop();\r\n            } else {\r\n                if (!isOperator(c))\r\n                    st.push(c);\r\n                else {\r\n                    while (!st.empty() && getLevel(st.top()) >= getLevel(c)) {\r\n                            RPN.push_back(st.top());\r\n                            st.pop();\r\n                    }\r\n                    st.push(c);\r\n                }\r\n            }\r\n        }\r\n\r\n        while (! st.empty()) {\r\n            RPN.push_back(st.top());\r\n            st.pop();\r\n        }\r\n\r\n        return RPN;\r\n    }\r\n    \r\n    ExpressionTreeNode* build(vector<string> &expression) {\r\n        // write your code here\r\n        vector<string> RPN = convertToRPN(expression);\r\n        int len = RPN.size();\r\n        stack<ExpressionTreeNode *> nodeStack;\r\n        for (int i = 0; i < len; ++i) {\r\n            string s = RPN[i];\r\n            ExpressionTreeNode *pNode = new ExpressionTreeNode(s);\r\n                if (s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\") {\r\n                    ExpressionTreeNode *pRight = nodeStack.top();\r\n                    nodeStack.pop();\r\n                    ExpressionTreeNode *pLeft = nodeStack.top();\r\n                    nodeStack.pop();\r\n\r\n                    pNode->right = pRight;\r\n                    pNode->left = pLeft;\r\n                    nodeStack.push(pNode);\r\n            } else\r\n                nodeStack.push(pNode);\r\n        }       \r\n        if (nodeStack.empty())\r\n            return NULL;\r\n        else\r\n            return nodeStack.top(); \r\n    }\r\n};\r\n"},{"language":"python","code":"\r\n\"\"\"\r\nDefinition of ExpressionTreeNode:\r\nclass ExpressionTreeNode:\r\n    def __init__(self, symbol):\r\n        self.symbol = symbol\r\n        self.left, self.right = None, None\r\n\"\"\"\r\n\r\nclass MyTreeNode:\r\n    def __init__(self, val, s):\r\n        self.left = None\r\n        self.right = None\r\n        self.val = val\r\n        self.exp_node = ExpressionTreeNode(s)\r\n\r\nclass Solution:\r\n    # @param expression: A string list\r\n    # @return: The root of expression tree\r\n    def get_val(self, a, base):\r\n        if a == '+' or a == '-':\r\n            if base == sys.maxint:\r\n                return base\r\n            return 1 + base\r\n        if a == '*' or a == '/':\r\n            if base == sys.maxint:\r\n                return base\r\n            return 2 + base\r\n        return sys.maxint\r\n\r\n    def build(self, expression):\r\n        # write your code here\r\n        root = self.create_tree(expression)\r\n        return self.copy_tree(root)\r\n    \r\n    def copy_tree(self, root):\r\n        if not root:\r\n            return None\r\n        root.exp_node.left = self.copy_tree(root.left)\r\n        root.exp_node.right = self.copy_tree(root.right)\r\n        return root.exp_node\r\n        \r\n    \r\n    def create_tree(self, expression):\r\n        stack = []\r\n        base = 0\r\n        for i in range(len(expression)):\r\n            if i != len(expression):\r\n                if expression[i] == '(':\r\n                    if base != sys.maxint:\r\n                        base += 10\r\n                    continue\r\n                elif expression[i] == ')':\r\n                    if base != sys.maxint:\r\n                        base -= 10\r\n                    continue\r\n                val = self.get_val(expression[i], base)\r\n    \r\n            node = MyTreeNode(val, expression[i])\r\n            while stack and val <= stack[-1].val:\r\n                node.left = stack.pop()\r\n            if stack:\r\n                stack[-1].right = node\r\n            stack.append(node)\r\n        if not stack:\r\n            return None\r\n        return stack[0]"}]},{"id":253,"unique_name":"convert-expression-to-reverse-polish-notation","title":"将表达式转换为逆波兰表达式","description":"给定一个表达式字符串数组，返回该表达式的逆波兰表达式（即去掉括号）。","solutions":[{"language":"java","code":"class TreeNode {\r\n\tpublic int val;\r\n\tpublic String s;\r\n\tpublic TreeNode left, right;\r\n\r\n\tpublic TreeNode(int val, String ss) {\r\n\t\tthis.val = val;\r\n\t\tthis.s = ss;\r\n\t\tthis.left = this.right = null;\r\n\t}\r\n\r\n}\r\n\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param expression: A string array\r\n     * @return: The Reverse Polish notation of this expression\r\n     */\r\n\r\n    int get(String a, Integer base) {\r\n\t\tif (a.equals(\"+\") || a.equals(\"-\"))\r\n\t\t\treturn 1 + base;\r\n\t\tif (a.equals(\"*\") || a.equals(\"/\"))\r\n\t\t\treturn 2 + base;\r\n\r\n\t\treturn Integer.MAX_VALUE;\r\n\t}\r\n\r\n\tvoid dfs(TreeNode root, ArrayList<String> as) {\r\n\t\tif(root==null)\r\n\t\t\treturn;\r\n\t\tif (root.left != null)\r\n\t\t\tdfs(root.left, as);\r\n\t\t\r\n\t\tif (root.right != null)\r\n\t\t\tdfs(root.right, as);\r\n\t\tas.add(root.s);\r\n\t}\r\n\r\n\tpublic ArrayList<String> convertToRPN(String[] expression) {\r\n\t\t// write your code here\r\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\r\n\t\tTreeNode root = null;\r\n\t\tint val = 0;\r\n\t\tInteger base = 0;\r\n\t\tfor (int i = 0; i <= expression.length; i++) {\r\n\t\t\tif(i != expression.length)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif (expression[i].equals(\"(\")) {\r\n\t\t\t\t\tbase += 10;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (expression[i].equals(\")\")) {\r\n\t\t\t\t\tbase -= 10;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tval = get(expression[i], base);\r\n\r\n\t\t\t}\r\n\t\t\tTreeNode right = i == expression.length ? new TreeNode(\r\n\t\t\t\t\tInteger.MIN_VALUE, \"\") : new TreeNode(val,\r\n\t\t\t\t\texpression[i]);\r\n\t\t\twhile (!stack.isEmpty()) {\r\n\t\t\t\tif (right.val <= stack.peek().val) {\r\n\t\t\t\t\tTreeNode nodeNow = stack.pop();\r\n\r\n\t\t\t\t\tif (stack.isEmpty()) {\r\n\t\t\t\t\t\tright.left = nodeNow;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTreeNode left = stack.peek();\r\n\t\t\t\t\t\tif (left.val < right.val) {\r\n\t\t\t\t\t\t\tright.left = nodeNow;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tleft.right = nodeNow;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstack.push(right);\r\n\t\t}\r\n\r\n\t\tArrayList<String> reversepolish = new ArrayList<String>();\r\n\t\tdfs(stack.peek().left, reversepolish);\r\n\t\t\r\n\t\t\r\n\t\treturn reversepolish;\r\n\t}\r\n\r\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param expression: A string array\n     * @return: The Reverse Polish notation of this expression\n     */\n    int getLevel(string opt) {\n        if (opt == \"(\")\n            return 0;\n        if (opt == \"+\" || opt == \"-\")\n            return 1;\n        if (opt == \"*\" || opt == \"/\")\n            return 2;\n\n        return 3;\n    }\n\n    bool isOperator(string c) {\n        return (c == \"+\" || c == \"-\" || c == \"*\" || c == \"/\");\n    }\n\n    vector<string> convertToRPN(vector<string> &expression) {\n        // write your code here\n        stack<string> st;\n        vector<string> RPN;\n        int len = expression.size();\n        for (int i = 0; i < len; ++i) {\n            string c = expression[i];\n            if (c == \"(\")\n                st.push(c);\n            else if (c == \")\") {\n                while (st.top() != \"(\") {\n                    RPN.push_back(st.top());\n                    st.pop();\n                }\n                st.pop();\n            } else {\n                if (!isOperator(c))\n                    st.push(c);\n                else {\n                    while (!st.empty() && getLevel(st.top()) >= getLevel(c)) {\n                            RPN.push_back(st.top());\n                            st.pop();\n                    }\n                    st.push(c);\n                }\n            }\n        }\n\n        while (! st.empty()) {\n            RPN.push_back(st.top());\n            st.pop();\n        }\n\n        return RPN;\n    }\n};"},{"language":"python","code":"class Stack:\n  def __init__(self):\n    self.items = []\n     \n  def isEmpty(self):\n    return len(self.items)==0\n   \n  def push(self, item):\n    self.items.append(item)\n   \n  def pop(self):\n    return self.items.pop() \n   \n  def peek(self):\n    if not self.isEmpty():\n      return self.items[-1]\n     \n  def size(self):\n    return len(self.items)\n\nclass Solution:\n    # @param expression: A string list\n    # @return: The Reverse Polish notation of this expression\n    def getLevel(self, s):\n        if s == \"+\" or s == \"-\":\n            return 1\n        if s == \"*\" or s == \"/\":\n            return 2\n        \n        return 0\n\n    def convertToRPN(self, expression):\n        # write your code here\n        RPN = []\n        cal = Stack()\n        for s in expression:\n            if s == \"(\":\n                cal.push(s)\n            elif s == \")\":\n                while not cal.isEmpty() and cal.peek() != \"(\":\n                    RPN.append(cal.peek())\n                    cal.pop()\n                cal.pop()\n            elif s.isdigit():\n                RPN.append(s)\n            else:\n                if not cal.isEmpty():\n                    if cal.peek() != \"(\":\n                        while self.getLevel(cal.peek()) >= self.getLevel(s):\n                            RPN.append(cal.peek())\n                            cal.pop()\n                            if cal.isEmpty():\n                                break\n                cal.push(s)\n\n        while not cal.isEmpty():\n            RPN.append(cal.peek())\n            cal.pop()\n        \n        return RPN\n                    "}]},{"id":209,"unique_name":"expression-evaluation","title":"表达式求值","description":"给一个用字符串表示的表达式数组，求出这个表达式的值。\r\n","solutions":[{"language":"java","code":"class TreeNode {\r\n\tpublic int val;\r\n\tpublic String s;\r\n\tpublic TreeNode left, right;\r\n\r\n\tpublic TreeNode(int val, String ss) {\r\n\t\tthis.val = val;\r\n\t\tthis.s = ss;\r\n\t\tthis.left = this.right = null;\r\n\t}\r\n\r\n}\r\n\r\npublic class Solution {\r\n\r\n\tint get(String a, Integer base) {\r\n\t\tif (a.equals(\"+\") || a.equals(\"-\"))\r\n\t\t\treturn 1 + base;\r\n\t\tif (a.equals(\"*\") || a.equals(\"/\"))\r\n\t\t\treturn 2 + base;\r\n\r\n\t\treturn Integer.MAX_VALUE;\r\n\t}\r\n\r\n\tvoid dfs(TreeNode root, ArrayList<String> as) {\r\n\t\tif(root==null)\r\n\t\t\treturn;\r\n\t\tif (root.left != null)\r\n\t\t\tdfs(root.left, as);\r\n\t\t\r\n\t\tif (root.right != null)\r\n\t\t\tdfs(root.right, as);\r\n\t\tas.add(root.s);\r\n\t}\r\n\r\n\tpublic int evaluateExpression(String[] expression) {\r\n\t\t// write your code here\r\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\r\n\t\tTreeNode root = null;\r\n\t\tint val = 0;\r\n\t\tInteger base = 0;\r\n\t\tfor (int i = 0; i <= expression.length; i++) {\r\n\t\t\tif(i != expression.length)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif (expression[i].equals(\"(\")) {\r\n\t\t\t\t\tbase += 10;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (expression[i].equals(\")\")) {\r\n\t\t\t\t\tbase -= 10;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tval = get(expression[i], base);\r\n\r\n\t\t\t}\r\n\t\t\tTreeNode right = i == expression.length ? new TreeNode(\r\n\t\t\t\t\tInteger.MIN_VALUE, \"\") : new TreeNode(val,\r\n\t\t\t\t\texpression[i]);\r\n\t\t\twhile (!stack.isEmpty()) {\r\n\t\t\t\tif (right.val <= stack.peek().val) {\r\n\t\t\t\t\tTreeNode nodeNow = stack.pop();\r\n\r\n\t\t\t\t\tif (stack.isEmpty()) {\r\n\t\t\t\t\t\tright.left = nodeNow;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTreeNode left = stack.peek();\r\n\t\t\t\t\t\tif (left.val < right.val) {\r\n\t\t\t\t\t\t\tright.left = nodeNow;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tleft.right = nodeNow;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstack.push(right);\r\n\t\t}\r\n\r\n\t\tArrayList<String> reversepolish = new ArrayList<String>();\r\n\t\tdfs(stack.peek().left, reversepolish);\r\n\t\tString[] str = new String[reversepolish.size()];\r\n\t\treversepolish.toArray(str);\r\n\t\t//System.out.println(as);\r\n\t\t\r\n\t\treturn evalreversepolish(str);\r\n\t}\r\n\r\n\tint evalreversepolish(String[] tokens) {\r\n\t\tint returnValue = 0;\r\n\t\tString operators = \"+-*/\";\r\n\r\n\t\tStack<String> stack = new Stack<String>();\r\n\r\n\t\tfor (String ss : tokens) {\r\n\t\t\tif (!operators.contains(ss)) {\r\n\t\t\t\tstack.push(ss);\r\n\t\t\t} else {\r\n\t\t\t\tint a = Integer.valueOf(stack.pop());\r\n\t\t\t\tint b = Integer.valueOf(stack.pop());\r\n\t\t\t\tif (ss.equals(\"+\")) {\r\n\t\t\t\t\tstack.push(String.valueOf(a + b));\r\n\t\t\t\t} else if (ss.equals(\"-\")) {\r\n\t\t\t\t\tstack.push(String.valueOf(b - a));\r\n\t\t\t\t} else if (ss.equals(\"*\")) {\r\n\t\t\t\t\tstack.push(String.valueOf(a * b));\r\n\t\t\t\t} else if (ss.equals(\"/\")) {\r\n\t\t\t\t\tstack.push(String.valueOf(b / a));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(stack.isEmpty())\r\n\t\t\treturnValue = 0;\r\n\t\telse \r\n\t\t\treturnValue = Integer.valueOf(stack.pop());\r\n\r\n\t\treturn returnValue;\r\n\t}\r\n};"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param expression: a vector of strings;\n     * @return: an integer\n     */\n    int evaluateExpression(vector<string> &expression) {\n        // write your code here\n        if (expression.size()==0) return 0;\n        vector<string> stack;\n        vector<int> suffixExpression;\n        for (int i=0; i<expression.size(); ++i)\n            if (isDigit(expression[i])) suffixExpression.push_back(alterDigit(expression[i]));\n            else pushInto(suffixExpression, stack, expression[i]);\n        while (stack.size()>0) {\n            calc(suffixExpression, stack.back());\n            stack.pop_back();\n        }\n        if (suffixExpression.size()>0) return suffixExpression[0];\n        else return 0;\n    }\n\nprivate:\n    bool isDigit(string &str) {\n        if (str.length()>1) return true;\n        if (str[0]>='0' && str[0]<='9') return true;\n        else return false;\n    }\n    \n    int alterDigit(string &str) {\n        int a = 0;\n        for (int i=0; i<str.length(); ++i) a = a*10+str[i]-48;\n        return a;\n    }\n\n    void pushInto(vector<int> &suffixExpression, vector<string> &stack, string &str) {\n        if (str==\")\") {\n            while (stack.back()!=\"(\") {\n                calc(suffixExpression, stack.back());\n                stack.pop_back();\n            }\n            stack.pop_back();\n        }\n        else {\n            while (!stack.empty() && cmp(stack.back(), str)) {\n                calc(suffixExpression, stack.back());\n                stack.pop_back();\n            }\n            stack.push_back(str);\n        }\n    }\n\n    void calc(vector<int> &suffixExpression, string &str) {\n        int b = suffixExpression.back();\n        suffixExpression.pop_back();\n        int a = suffixExpression.back();\n        suffixExpression.pop_back();\n        if (str==\"+\") suffixExpression.push_back(a+b);\n        else\n            if (str==\"-\") suffixExpression.push_back(a-b);\n            else \n                if (str==\"*\") suffixExpression.push_back(a*b);\n                else suffixExpression.push_back(a/b);\n    }\n\n    bool cmp(string &stra, string &strb) {\n        int a, b;\n        if (stra==\"+\" || stra==\"-\") a = 1;\n        else \n            if (stra==\"(\") a = 0;\n            else a = 2;\n        if (strb==\"+\" || strb==\"-\") b = 1;\n        else\n            if (strb==\"(\") b = 3;\n            else b = 2;\n        if (a<b) return false;\n        else return true;\n    }\n};\n"},{"language":"python","code":"class Solution:\r\n    # @param expression: a list of strings;\r\n    # @return: an integer\r\n    def getBlocks(self, delims, expression):\r\n        paren, lastIndex = 0, 0\r\n        blocks = []\r\n        lastOperator = None\r\n        for index, e in enumerate(expression):\r\n            if e == '(':\r\n                paren += 1\r\n            elif e == ')':\r\n                paren -= 1\r\n            elif e in delims and paren == 0:\r\n                blocks.append((lastOperator, expression[lastIndex: index]))\r\n                lastIndex = index + 1\r\n                lastOperator = e\r\n        blocks.append((lastOperator, expression[lastIndex: len(expression)]))\r\n        return blocks\r\n        \r\n    def evaluateExpression(self, expression):\r\n        if len(expression) == 0:\r\n            return 0\r\n        if len(expression) == 1:\r\n            return int(expression[0])\r\n            \r\n        blocks = self.getBlocks(['+', '-'], expression)\r\n        if len(blocks) == 1:\r\n            blocks = self.getBlocks(['*', '/'], expression)\r\n            if len(blocks) == 1:  # must be ( ... )\r\n                return self.evaluateExpression(expression[1:-1])\r\n        \r\n        sum = 0\r\n        for opt, exp in blocks:\r\n            val = self.evaluateExpression(exp)\r\n            if opt is None:\r\n                sum = val\r\n            elif opt == '+':\r\n                sum += val\r\n            elif opt == '-':\r\n                sum -= val\r\n            elif opt == '*':\r\n                sum *= val\r\n            elif opt == '/':\r\n                sum /= val\r\n        return sum\r\n"}]},{"id":424,"unique_name":"mock-hanoi-tower-by-stacks","title":"用栈模拟汉诺塔问题","description":"在经典的汉诺塔问题中，有 3 个塔和 N 个可用来堆砌成塔的不同大小的盘子。要求盘子必须按照从小到大的顺序从上往下堆 （如，任意一个盘子，其必须堆在比它大的盘子上面）。同时，你必须满足以下限制条件：\r\n\r\n(1) 每次只能移动一个盘子。\r\n(2) 每个盘子从堆的顶部被移动后，只能置放于下一个堆中。\r\n(3) 每个盘子只能放在比它大的盘子上面。\r\n\r\n请写一段程序，实现将第一个堆的盘子移动到最后一个堆中。\r\n\r\n","solutions":[{"language":"java","code":"public class Tower {\r\n    private Stack<Integer> disks;\r\n    // create three towers (i from 0 to 2)\r\n    public Tower(int i) {\r\n        disks = new Stack<Integer>();\r\n    }\r\n\t\r\n    // Add a disk into this tower\r\n    public void add(int d) {\r\n        if (!disks.isEmpty() && disks.peek() <= d) {\r\n            System.out.println(\"Error placing disk \" + d);\r\n        } else {\r\n            disks.push(d);\r\n        }\r\n    }\r\n\t\r\n    // @param t a tower\r\n    // Move the top disk of this tower to the top of t.\r\n    public void moveTopTo(Tower t) {\r\n        // Write your code here\r\n        int top = disks.pop();\r\n        t.add(top);\r\n    }\r\n\t\r\n    // @param n an integer\r\n    // @param destination a tower\r\n    // @param buffer a tower\r\n    // Move n Disks from this tower to destination by buffer tower\r\n    public void moveDisks(int n, Tower destination, Tower buffer) {\r\n        // Write your code here\r\n        if (n > 0) {\t\r\n            moveDisks(n - 1, buffer, destination);\r\n            moveTopTo(destination);\r\n            buffer.moveDisks(n - 1, destination, this);\r\n        }\r\n    }\r\n\r\n    public Stack<Integer> getDisks() {\r\n        return disks;\r\n    }\r\n}\r\n/**\r\n * Your Tower object will be instantiated and called as such:\r\n * Tower[] towers = new Tower[3];\t\r\n * for (int i = 0; i < 3; i++) towers[i] = new Tower(i);\r\n * for (int i = n - 1; i >= 0; i--) towers[0].add(i);\t\r\n * towers[0].moveDisks(n, towers[2], towers[1]);\r\n * print towers[0], towers[1], towers[2]\r\n*/\r\n"},{"language":"cpp","code":"class Tower {\r\npublic:\r\n    // create three towers (i from 0 to 2)\r\n    Tower(int i) {}\r\n\t\r\n    // Add a disk into this tower\r\n    void add(int d) {\r\n        if (!disks.empty() && disks.top() <= d) {\r\n            printf(\"Error placing disk %d\", d);\r\n        } else {\r\n            disks.push(d);\r\n        }\r\n    }\r\n\t\r\n    // @param t a tower\r\n    // Move the top disk of this tower to the top of t.\r\n    void moveTopTo(Tower &t) {\r\n        // Write your code here\r\n        int top = disks.top();\r\n        disks.pop();\r\n        t.add(top);\r\n    }\r\n\t\r\n    // @param n an integer\r\n    // @param destination a tower\r\n    // @param buffer a tower\r\n    // Move n Disks from this tower to destination by buffer tower\r\n    void moveDisks(int n, Tower &destination, Tower &buffer) {\r\n        // Write your code here\r\n        if (n > 0) {\r\n            moveDisks(n - 1, buffer, destination);\r\n            moveTopTo(destination);\r\n            buffer.moveDisks(n - 1, destination, *this);\r\n        }\r\n    }\r\n\r\n    stack<int> getDisks() {\r\n        return disks;\r\n    }\r\n\r\nprivate:\r\n    stack<int> disks;\r\n};\r\n/**\r\n * Your Tower object will be instantiated and called as such:\r\n * vector<Tower> towers;\r\n * for (int i = 0; i < 3; i++) towers.push_back(Tower(i));\r\n * for (int i = n - 1; i >= 0; i--) towers[0].add(i);\r\n * towers[0].moveDisks(n, towers[2], towers[1]);\r\n * print towers[0], towers[1], towers[2]\r\n*/\r\n"},{"language":"python","code":"class Tower(object):\r\n    # create three towers (i from 0 to 2)\r\n    def __init__(self, i):\r\n        self.disks = []\r\n\t\r\n    # Add a disk into this tower\r\n    def add(self, d):\r\n        if len(self.disks) > 0 and self.disks[-1] <= d:\r\n            print \"Error placing disk %s\" % d\r\n        else:\r\n            self.disks.append(d);\r\n\t\r\n    # @param {Tower} t a tower\r\n    # Move the top disk of this tower to the top of t.\r\n    def move_top_to(self, t):\r\n        # Write your code here\r\n        t.add(self.disks.pop())\r\n\t\r\n    # @param {int} n an integer\r\n    # @param {Tower} destination a tower\r\n    # @param {Tower} buffer a tower\r\n    # Move n Disks from this tower to destination by buffer tower\r\n    def move_disks(self, n, destination, buffer):\r\n        # Write your code here\r\n        if n > 0:\r\n            self.move_disks(n - 1, buffer, destination)\r\n            self.move_top_to(destination)\r\n            buffer.move_disks(n - 1, destination, self)\r\n\r\n    def get_disks(self):\r\n        return self.disks\r\n\r\n\"\"\"\r\nYour Tower object will be instantiated and called as such:\r\ntowers = [Tower(0), Tower(1), Tower(2)]\r\nfor i in xrange(n - 1, -1, -1): towers[0].add(i)\r\ntowers[0].move_disks(n, towers[2], towers[1])\r\nprint towers[0], towers[1], towers[2]\r\n\"\"\"\r\n"}]},{"id":61,"unique_name":"simplify-path","title":"简化路径","description":"给定一个文档(Unix-style)的完全路径，请进行路径简化。","solutions":[{"language":"java","code":"public class Solution {\r\n    public String simplifyPath(String path) {\r\n        String result = \"/\";\r\n        String[] stubs = path.split(\"/+\");\r\n        ArrayList<String> paths = new ArrayList<String>();\r\n        for (String s : stubs){\r\n            if(s.equals(\"..\")){\r\n                if(paths.size() > 0){\r\n                    paths.remove(paths.size() - 1);\r\n                }\r\n            }\r\n            else if (!s.equals(\".\") && !s.equals(\"\")){\r\n                paths.add(s);\r\n            }\r\n        }\r\n        for (String s : paths){\r\n            result += s + \"/\";\r\n        }\r\n        if (result.length() > 1)\r\n            result = result.substring(0, result.length() - 1);\r\n        return result;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    string simplifyPath(string const& path) {\n        vector<string> dirs; // 当做栈\n\n        for (auto i = path.begin(); i != path.end();) {\n            ++i;\n\n            auto j = find(i, path.end(), '/');\n            auto dir = string(i, j);\n\n            if (!dir.empty() && dir != \".\") {// 当有连续 '///'时，dir 为空\n                if (dir == \"..\") {\n                    if (!dirs.empty())\n                        dirs.pop_back();\n                } else\n                    dirs.push_back(dir);\n            }\n\n            i = j;\n        }\n\n        stringstream out;\n        if (dirs.empty()) {\n            out << \"/\";\n        } else {\n            for (auto dir : dirs)\n                out << '/' << dir;\n        }\n\n        return out.str();\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param path, a string\n    # @return a string\n    def simplifyPath(self, path):\n        stack = []\n        i = 0\n        res = ''\n        while i < len(path):\n            end = i+1\n            while end < len(path) and path[end] != \"/\":\n                end += 1\n            sub=path[i+1:end]\n            if len(sub) > 0:\n                if sub == \"..\":\n                    if stack != []: stack.pop()\n                elif sub != \".\":\n                    stack.append(sub)\n            i = end\n        if stack == []: return \"/\"\n        for i in stack:\n            res += \"/\"+i\n        return res\n"}]},{"id":147,"unique_name":"remove-node-in-binary-search-tree","title":"删除二叉查找树的节点","description":"<p>给定一棵具有不同节点值的二叉查找树，删除树中与给定值相同的节点。如果树中没有相同值的节点，就不做任何处理。你应该保证处理之后的树仍是<span style=\"line-height: 1.42857143;\">二叉查找树。</span></p>","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of the binary search tree.\r\n     * @param value: Remove the node with given value.\r\n     * @return: The root of the binary search tree after removal.\r\n     */\r\n    public TreeNode removeNode(TreeNode root, int value) {\r\n        TreeNode dummy = new TreeNode(0);\r\n        dummy.left = root;\r\n        \r\n        TreeNode parent = findNode(dummy, root, value);\r\n        TreeNode node;\r\n        if (parent.left != null && parent.left.val == value) {\r\n            node = parent.left;\r\n        } else if (parent.right != null && parent.right.val == value) {\r\n            node = parent.right;\r\n        } else {\r\n            return dummy.left;\r\n        }\r\n        \r\n        deleteNode(parent, node);\r\n        \r\n        return dummy.left;\r\n    }\r\n    \r\n    private TreeNode findNode(TreeNode parent, TreeNode node, int value) {\r\n        if (node == null) {\r\n            return parent;\r\n        }\r\n        \r\n        if (node.val == value) {\r\n            return parent;\r\n        }\r\n        if (value < node.val) {\r\n            return findNode(node, node.left, value);\r\n        } else {\r\n            return findNode(node, node.right, value);\r\n        }\r\n    }\r\n    \r\n    private void deleteNode(TreeNode parent, TreeNode node) {\r\n        if (node.right == null) {\r\n            if (parent.left == node) {\r\n                parent.left = node.left;\r\n            } else {\r\n                parent.right = node.left;\r\n            }\r\n        } else {\r\n            TreeNode temp = node.right;\r\n            TreeNode father = node;\r\n            \r\n            while (temp.left != null) {\r\n                father = temp;\r\n                temp = temp.left;\r\n            }\r\n            \r\n            if (father.left == temp) {\r\n                father.left = temp.right;\r\n            } else {\r\n                father.right = temp.right;\r\n            }\r\n            \r\n            if (parent.left == node) {\r\n                parent.left = temp;\r\n            } else {\r\n                parent.right = temp;\r\n            }\r\n            \r\n            temp.left = node.left;\r\n            temp.right = node.right;\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: The root of the binary search tree.\r\n     * @param value: Remove the node with given value.\r\n     * @return: The root of the binary search tree after removal.\r\n     */\r\n    TreeNode* removeNode(TreeNode* root, int value) {\r\n        // write your code here\r\n        if (root == NULL)\r\n            return NULL;\r\n        TreeNode * head = new TreeNode();\r\n        head->left = root;\r\n        TreeNode * tmp = root, *father = head;\r\n\r\n        while (tmp != NULL) {\r\n            if (tmp->val == value)\r\n                break;\r\n            father = tmp;\r\n            if (tmp->val > value)\r\n                tmp = tmp->left;\r\n            else\r\n                tmp = tmp->right;\r\n        }\r\n        if (tmp == NULL)\r\n            return head->left;\r\n\r\n        if (tmp->right == NULL) {\r\n            if (father->left == tmp)\r\n                father->left = tmp->left;\r\n            else\r\n                father->right = tmp->left;\r\n        } else \r\n        if (tmp->right->left == NULL) {\r\n            if (father->left == tmp)\r\n                father->left = tmp->right;\r\n            else\r\n                father->right = tmp->right;\r\n\r\n            tmp->right->left = tmp->left;\r\n            \r\n        } else {\r\n            father = tmp->right;\r\n            TreeNode * cur = tmp->right->left;\r\n            while (cur->left != NULL) {\r\n                father = cur;\r\n                cur = cur->left;\r\n            }\r\n            tmp->val = cur->val;\r\n            father->left = cur->right;\r\n        }\r\n        return head->left;\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of the binary search tree.\r\n    @param value: Remove the node with given value.\r\n    @return: The root of the binary search tree after removal.\r\n    \"\"\"    \r\n    ans = []\r\n    def inorder(self, root, value):\r\n        if root is None:\r\n            return\r\n\r\n        self.inorder(root.left, value)\r\n        if root.val != value:\r\n            self.ans.append(root.val)\r\n        self.inorder(root.right, value)\r\n    \r\n    def build(self, l, r):\r\n        if l == r:\r\n            node = TreeNode(self.ans[l])\r\n            return node\r\n\r\n        if l > r:\r\n            return None\r\n\r\n        mid = (l+r) / 2\r\n        node = TreeNode(self.ans[mid])\r\n        node.left = self.build(l, mid-1)\r\n        node.right = self.build(mid+1, r)\r\n        return node\r\n    def removeNode(self, root, value):\r\n        # write your code here\r\n        self.inorder(root, value)\r\n        return self.build(0, len(self.ans)-1)\r\n        \r\n\r\n"}]},{"id":214,"unique_name":"insert-node-in-a-binary-search-tree","title":"在二叉查找树中插入节点","description":"给定一棵二叉查找树和一个新的树节点，将节点插入到树中。\r\n\r\n你需要保证该树仍然是一棵二叉查找树。","solutions":[{"language":"java","code":"/**\n * Definition of TreeNode:\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left, right;\n *     public TreeNode(int val) {\n *         this.val = val;\n *         this.left = this.right = null;\n *     }\n * }\n */\npublic class Solution {\n    /**\n     * @param root: The root of the binary search tree.\n     * @param node: insert this node into the binary search tree\n     * @return: The root of the new binary search tree.\n     */\n    public TreeNode insertNode(TreeNode root, TreeNode node) {\n        if (root == null) {\n            return node;\n        }\n        if (root.val > node.val) {\n            root.left = insertNode(root.left, node);\n        } else {\n            root.right = insertNode(root.right, node);\n        }\n        return root;\n    }\n}\n"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param root: The root of the binary search tree.\n     * @param node: insert this node into the binary search tree\n     * @return: The root of the new binary search tree.\n     */\n    TreeNode* insertNode(TreeNode* root, TreeNode* node) {\n        if (root == NULL) {\n            return node;\n        }\n        if (node->val < root->val) {\n            root->left = insertNode(root->left, node);\n            return root;\n        }\n        root->right = insertNode(root->right, node);\n        return root;\n    }\n};\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param root: The root of the binary search tree.\r\n    @param node: insert this node into the binary search tree.\r\n    @return: The root of the new binary search tree.\r\n    \"\"\"\r\n    def insertNode(self, root, node):\r\n        if root is None:\r\n            return node\r\n            \r\n        curt = root\r\n        while curt != node:\r\n            if node.val < curt.val:\r\n                if curt.left is None:\r\n                    curt.left = node\r\n                curt = curt.left\r\n            else:\r\n                if curt.right is None:\r\n                    curt.right = node\r\n                curt = curt.right\r\n        return root\r\n"}]},{"id":153,"unique_name":"search-range-in-binary-search-tree","title":"二叉查找树中搜索区间","description":"给定两个值 k1 和 k2（k1 < k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 <= x <= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    private ArrayList<Integer> results;\r\n    /**\r\n     * @param root: The root of the binary search tree.\r\n     * @param k1 and k2: range k1 to k2.\r\n     * @return: Return all keys that k1<=key<=k2 in increasing order.\r\n     */\r\n    public ArrayList<Integer> searchRange(TreeNode root, int k1, int k2) {\r\n        results = new ArrayList<Integer>();\r\n        helper(root, k1, k2);\r\n        return results;\r\n    }\r\n    \r\n    private void helper(TreeNode root, int k1, int k2) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        if (root.val > k1) {\r\n            helper(root.left, k1, k2);\r\n        }\r\n        if (root.val >= k1 && root.val <= k2) {\r\n            results.add(root.val);\r\n        }\r\n        if (root.val < k2) {\r\n            helper(root.right, k1, k2);\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param root: The root of the binary search tree.\n     * @param k1 and k2: range k1 to k2.\n     * @return: Return all keys that k1<=key<=k2 in increasing order.\n     */\n    vector<int> ans;\n    void  dfs(TreeNode* node, int k1, int k2) {\n       \n        if (node->left && node->val>=k1)\n            dfs(node->left, k1, k2);\n         if (node->val >= k1 && node->val <= k2)\n            ans.push_back(node->val);\n        if (node->right && node->val<=k2)\n            dfs(node->right, k1, k2);\n    }\n    vector<int> searchRange(TreeNode* root, int k1, int k2) {\n        // write your code here\n        if (root==NULL)\n            return ans;\n        dfs(root, k1, k2);\n        return ans;\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\nclass Solution:\n    \"\"\"\n    @param root: The root of the binary search tree.\n    @param k1 and k2: range k1 to k2.\n    @return: Return all keys that k1<=key<=k2 in increasing order.\n    \"\"\"     \n    def searchRange(self, root, k1, k2):\n        # write your code here\n        ans = []\n        if root is None:\n            return ans\n        queue = [root]\n        index = 0\n        while index < len(queue):\n            if queue[index] is not None:\n                if queue[index].val >= k1 and \\\n                    queue[index].val <= k2:\n                    ans.append(queue[index].val)\n\n                queue.append(queue[index].left)\n                queue.append(queue[index].right)\n\n            index += 1\n        return sorted(ans)\n"}]},{"id":286,"unique_name":"shortest-palindrome","title":"转换成回文串","description":"给一个字符串 `S`, 你可以通过在前面添加字符将其转换为回文串.找到并返回用这种方式转换的最短回文串.","solutions":[{"language":"java","code":"public class Solution {\r\n\r\n    public String shortestPalindrome(String s) {\r\n\r\n        int j = 0;\r\n\r\n        for (int i = s.length() - 1; i >= 0; i--) {//找到第一个使他不回文的位置\r\n\r\n           if (s.charAt(i) == s.charAt(j)) { \r\n\r\n               j += 1; \r\n\r\n           }\r\n\r\n        }\r\n\r\n        if (j == s.length()) {  //本身是回文\r\n\r\n            return s; \r\n\r\n        }\r\n\r\n        String suffix = s.substring(j); // 后缀不能够匹配的字符串\r\n\r\n        String prefix = new StringBuilder(suffix).reverse().toString(); // 前面补充prefix让他和suffix回文匹配\r\n\r\n        String mid = shortestPalindrome(s.substring(0, j)); //递归调用找 [0,j]要最少可以补充多少个字符让他回文\r\n\r\n        String ans = prefix + mid  + suffix;\r\n\r\n        return  ans;\r\n\r\n    }\r\n\r\n}"}]},{"id":306,"unique_name":"space-replacement","title":"空格替换","description":"设计一种方法，将一个字符串中的所有空格替换成 `%20` 。你可以假设该字符串有足够的空间来加入新的字符，且你得到的是“真实的”字符长度。\r\n\r\n你的程序还需要返回被替换后的字符串的长度。","solutions":[{"language":"java","code":"class Solution {\r\npublic:\r\n    int replaceBlank(char string[], int length) {\r\n        if(0==length) return 0;\r\n        int num = 0;\r\n        for(int i=0;i<length;i++){\r\n            if(string[i] == ' ') num++;\r\n        }\r\n        \r\n        int newLen = length + num*2;\r\n        string[newLen] = 0;\r\n        int j = 1;\r\n        for(int i=length-1;i>=0;i--){\r\n            if(string[i] != ' '){\r\n                string[newLen - j] = string[i];\r\n                j++;\r\n            }\r\n            else{\r\n                string[newLen - j] = '0';\r\n                j++;\r\n                string[newLen - j] = '2';\r\n                j++;\r\n                string[newLen - j] = '%';\r\n                j++; \r\n            }\r\n        }\r\n        return newLen;\r\n    }\r\n};  \r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param string: An array of Char\n     * @param length: The true length of the string\n     * @return: The true length of new string\n     */\n    int replaceBlank(char string[], int length) {\n        // Write your code here\n        if(string == NULL && length <= 0)\n            return 0;\n\n        /*originalLength 为字符串string的实际长度*/\n        int originalLength = 0;\n        int numberOfBlank = 0;\n        int i = 0;\n        while(string[i] != '\\0')\n        {\n            ++ originalLength;\n    \n            if(string[i] == ' ')\n                ++ numberOfBlank;\n    \n            ++ i;\n        }\n\n        /*newLength 为把空格替换成'%20'之后的长度*/\n        int newLength = originalLength + numberOfBlank * 2;\n\n        int indexOfOriginal = originalLength;\n        int indexOfNew = newLength;\n        while(indexOfOriginal >= 0 && indexOfNew > indexOfOriginal)\n        {\n            if(string[indexOfOriginal] == ' ')\n            {\n                string[indexOfNew --] = '0';\n                string[indexOfNew --] = '2';\n                string[indexOfNew --] = '%';\n            }\n            else\n            {\n                string[indexOfNew --] = string[indexOfOriginal];\n            }\n    \n            -- indexOfOriginal;\n        }\n        return newLength;\n    }\n};  \n"},{"language":"python","code":"class Solution:\n    # @param {char[]} string: An array of Char\n    # @param {int} length: The true length of the string\n    # @return {int} The true length of new string\n    def replaceBlank(self, string, length):\n        if string is None:\n            return length\n            \n        spaces = 0\n        for c in string:\n            if c == ' ':\n                spaces += 1\n        \n        L = length + spaces * 2\n        index = L - 1\n        for i in range(length - 1, -1, -1):\n            if string[i] == ' ':\n                string[index] = '0'\n                string[index - 1] = '2'\n                string[index - 2] = '%'\n                index -= 3\n            else:\n                string[index] = string[i]\n                index -= 1\n        return L"}]},{"id":406,"unique_name":"longest-words","title":"最长单词","description":"给一个词典，找出其中所有最长的单词。","solutions":[{"language":"java","code":"class Solution {\n    /**\n     * @param dictionary: an array of strings\n     * @return: an arraylist of strings\n     */\n    ArrayList<String> longestWords(String[] dictionary) {\n        // write your code here\n        int maxLen = 0;\n        ArrayList<String> ans = new ArrayList<String>();\n        for (int i=0; i<dictionary.length; ++i) \n            if (dictionary[i].length()>maxLen) maxLen = dictionary[i].length();\n        for (int i=0; i<dictionary.length; ++i)\n            if (dictionary[i].length()==maxLen) ans.add(dictionary[i]);\n        return ans;\n    }\n};\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param dictionary: a vector of strings\n     * @return: a vector of strings\n     */\n    vector<string> longestWords(vector<string> &dictionary) {\n        // write your code here\n        int maxLen = 0;\n        vector<string> ans;\n        for (int i=0; i<dictionary.size(); ++i) \n            if (dictionary[i].size()>maxLen) maxLen = dictionary[i].size();\n        for (int i=0; i<dictionary.size(); ++i)\n            if (dictionary[i].size()==maxLen) ans.push_back(dictionary[i]);\n        return ans;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param dictionary: a list of strings\n    # @return: a list of strings\n    def longestWords(self, dictionary):\n        maxLength = max(len(w) for w in dictionary)\n        return [w for w in dictionary if len(w) == maxLength]\n"}]},{"id":124,"unique_name":"longest-palindromic-substring","title":"最长回文子串","description":"给出一个字符串（假设长度最长为1000），求出它的最长回文子串，你可以假定只有一个满足条件的最长回文串。","solutions":[{"language":"java","code":"public class Solution {\r\n    public String longestPalindrome(String s) {\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        \r\n        int length = s.length();    \r\n        int max = 0;\r\n        String result = \"\";\r\n        for(int i = 1; i <= 2 * length - 1; i++){\r\n            int count = 1;\r\n            while(i - count >= 0 && i + count <= 2 * length  && get(s, i - count) == get(s, i + count)){\r\n                count++;\r\n            }\r\n            count--; // there will be one extra count for the outbound #\r\n            if(count > max) {\r\n                result = s.substring((i - count) / 2, (i + count) / 2);\r\n                max = count;\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    private char get(String s, int i) {\r\n        if(i % 2 == 0)\r\n            return '#';\r\n        else \r\n            return s.charAt(i / 2);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n    题意为求最长回文子串， 直接枚举子串首尾位置再判断是否会问，时间复杂度为O(N^3)，\r\n    换个思路，枚举回文串的对称中心位置，向两侧扫描检测最长回文长度时间复杂度为O(N^2)\r\n    对于最长回文子串问题有对应O(N)算法--Manacher算法\r\n    笔者觉得面试中应当不会有这么高的要求，有兴趣可以自行了解该算法\r\n    */    \r\n    string longestPalindrome(string s) {\r\n        string str = \"\", ans = \"\";\r\n        int len = s.length();\r\n        int maxl = -1, cnt;\r\n        for (int i = 0; i < len; i++) {\r\n            str += '#';\r\n            str += s[i];\r\n        }\r\n        str += '#';\r\n        // 将原字符串扩展成#a#b#的形式可以直接枚举长度，不用考虑回文串长度的奇偶性\r\n        for (int i = 1; i < 2 * len; i++) {\r\n            cnt = 0;\r\n            while ((i - cnt >= 0) && (i + cnt <= 2 * len) && (str[i - cnt] == str[i + cnt]))\r\n                cnt++;\r\n            cnt--;\r\n            if (cnt > maxl) {\r\n                maxl = cnt;\r\n                ans = s.substr((i - cnt) / 2, (i + cnt) / 2 - (i - cnt) / 2);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    # Python O(N^2)常数比较大的话会TLE\r\n    def longestPalindrome(self, s):\r\n        ansl, ansr, maxx = 0, 1, 0\r\n        length = len(s)\r\n        for i in range(1, length * 2):\r\n            if i & 1 :\r\n                left = i / 2\r\n                right = left\r\n            else :\r\n                left = i / 2 - 1\r\n                right = left + 1\r\n            while (left >= 0) and (right < length) and (s[left] == s[right]):\r\n                left -= 1\r\n                right += 1\r\n            left += 1\r\n            right -= 1\r\n            if right - left > maxx:\r\n                maxx = right - left\r\n                ansl = left\r\n                ansr = right\r\n        return s[ansl: ansr + 1]"}]},{"id":179,"unique_name":"binary-representation","title":"二进制表示","description":"给定一个数将其转换为二进制（均用字符串表示），如果这个数的小数部分不能在 32 个字符之内来精确地表示，则返回 `\"ERROR\"`。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     *@param n: Given a decimal number that is passed in as a string\r\n     *@return: A string\r\n     */\r\n     \r\n    private String parseInteger(String str) {\r\n        int n = Integer.parseInt(str);\r\n        if (str.equals(\"\") || str.equals(\"0\")) {\r\n            return \"0\";\r\n        }\r\n        String binary = \"\";\r\n        while (n != 0) {\r\n            binary = Integer.toString(n % 2) + binary;\r\n            n = n / 2;\r\n        }\r\n        return binary;\r\n    }\r\n    \r\n    private String parseFloat(String str) {\r\n        double d = Double.parseDouble(\"0.\" + str);\r\n        String binary = \"\";\r\n        HashSet<Double> set = new HashSet<Double>();\r\n        while (d > 0) {\r\n            if (binary.length() > 32 || set.contains(d)) {\r\n                return \"ERROR\";\r\n            }\r\n            set.add(d);\r\n            d = d * 2;\r\n            if (d >= 1) {\r\n                binary = binary + \"1\";\r\n                d = d - 1;\r\n            } else {\r\n                binary = binary + \"0\";\r\n            }\r\n        }\r\n        return binary;\r\n    }\r\n    \r\n    public String binaryRepresentation(String n) {\r\n        if (n.indexOf('.') == -1) {\r\n            return parseInteger(n);\r\n        }\r\n        String[] params = n.split(\"\\\\.\");\r\n        String flt = parseFloat(params[1]);\r\n        if (flt == \"ERROR\") {\r\n            return flt;\r\n        }\r\n        if (flt.equals(\"0\") || flt.equals(\"\")) {\r\n            return parseInteger(params[0]);\r\n        }\r\n        return parseInteger(params[0]) + \".\" + flt;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <strstream>\nclass Solution {\npublic:\n    /**\n     *@param n: Given a decimal number that is passed in as a string\n     *@return: A string\n     */\n    string itoa(int n) {\n        strstream ss;\n        string s;\n        ss << n;\n        ss >> s;\n        return s;\n    }\n    string binaryRepresentation(string n) {\n        // wirte your code here\n        int intPart = atoi(n.substr(0, n.find(\".\")).c_str());\n        double decPart = atof(n.substr(n.find(\".\"),n.size() - n.find(\".\")).c_str());\n        string int_string = \"\";\n        while (intPart > 0) {\n            int r = intPart % 2;\n            intPart >>= 1;\n            int_string = itoa(r) + int_string;\n        }\n        if (int_string.size() == 0)\n            int_string = \"0\";\n        if (n.substr(n.find(\".\"), n.size() - n.find(\".\")) == \".0\")\n            return int_string;\n        string dec_string = \"\";\n        while (decPart > 0) {\n            if (dec_string.size() > 32) return \"ERROR\";\n            if (decPart == 1) { \n                dec_string += itoa(1);\n                break;\t    \t\n            }\n\t\t\n            double r = decPart * 2;\n            if (r >= 1) {\t\t\n                dec_string += \"1\";\t\t\t\n                decPart = r - 1;\n            } else {\t\t\t\n                dec_string += \"0\";\n                decPart = r;\n            }\n\t\n        }\n        return int_string + \".\" + dec_string;\n    }\n};\n\n"},{"language":"python","code":"from decimal import *\n\nclass Solution:\n    #@param n: Given a decimal number that is passed in as a string\n    #@return: A string\n    def binaryRepresentation(self, num):\n        (a, b) = num.split('.')\n        a = '{:b}'.format(int(a))\n        b = self.frac_to_binary(b)\n        if b is None:\n            return 'ERROR'\n        elif b == '':\n            return a\n        else:\n            return a + '.' + b\n    \n    def frac_to_binary(self, num):\n        if int(num) == 0:\n            return ''\n        if int(num) % 10 != 5:\n            return None\n        \n        res = ''\n        num = Decimal('0.' + str(num))\n        while num:\n            num *= 2\n            if num >= 1:\n                res += '1'\n                num -= 1\n            else:\n                res += '0'\n            num = num.normalize()    \n            if num and str(num)[-1] != '5':\n                return None\n                \n        return res\n"}]},{"id":188,"unique_name":"two-strings-are-anagrams","title":"两个字符串是变位词","description":"写出一个函数 `anagram(s, t)` 判断两个字符串是否可以通过改变字母的顺序变成一样的字符串。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param s: The first string\r\n     * @param b: The second string\r\n     * @return true or false\r\n     */\r\n    public boolean anagram(String s, String t) {\r\n        if (s.length() != t.length()) {\r\n           return false;\r\n        }\r\n        \r\n        int[] count = new int[256];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            count[(int) s.charAt(i)]++;\r\n        }\r\n        for (int i = 0; i < t.length(); i++) {\r\n            count[(int) t.charAt(i)]--;\r\n            if (count[(int) t.charAt(i)] < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param s: The first string\n     * @param b: The second string\n     * @return true or false\n     */\n    bool anagram(string s, string t) {\n        // write your code here\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        return s == t;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param s: The first string\n    @param b: The second string\n    @return true or false\n    \"\"\"\n    def anagram(self, s, t):\n        # write your code here\n        ss = [i for i in s]\n        tt = [i for i in t]\n        ss.sort()\n        tt.sort()\n        return \"\".join(ss) == \"\".join(tt)\n"}]},{"id":444,"unique_name":"compare-strings","title":"比较字符串","description":"比较两个字符串A和B，确定A中是否包含B中所有的字符。字符串A和B中的字符都是 **大写字母**","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param A : A string includes Upper Case letters\n     * @param B : A string includes Upper Case letter\n     * @return :  if string A contains all of the characters in B return true else return false\n     */\n    public boolean compareStrings(String A, String B) {\n        int[] counts = new int[26];\n        for (int i = 0; i < 26; i++) {\n            counts[i] = 0;\n        }\n        for (int i = 0; i < A.length(); i++) {\n            counts[A.charAt(i) - 'A'] ++;\n        }\n        for (int i = 0; i < B.length(); i++) {\n            counts[B.charAt(i) - 'A'] --;\n            if (counts[B.charAt(i) - 'A'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"},{"language":"cpp","code":"#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    /**\n     * @param A: A string includes Upper Case letters\n     * @param B: A string includes Upper Case letter\n     * @return:  if string A contains all of the characters in B return true \n     *           else return false\n     */\n    bool compareStrings(string A, string B) {\n        int count[26];\n        for (int i = 0; i < 26; i++) {\n            count[i] = 0;\n        }\n        for (int i = 0; i < A.length(); i++) {\n            count[A[i] - 'A'] ++;\n        }\n        for (int i = 0; i < B.length(); i++) {\n            count[B[i] - 'A'] --;\n            if (count[B[i] - 'A'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param A : A string includes Upper Case letters\n    @param B : A string includes Upper Case letters\n    @return :  if string A contains all of the characters in B return True else return False\n    \"\"\"\n    def compareStrings(self, A, B):\n        # write your code here\n        if len(B) == 0:\n            return True\n        if len(A) == 0:\n            return False\n        trackTable = [0 for _ in range(26)]\n        for i in A:\n            trackTable[ord(i) - 65] += 1\n        for i in B:\n            if trackTable[ord(i) - 65] == 0:\n                return False\n            else:\n                trackTable[ord(i) -65] -= 1\n        return True\n"}]},{"id":224,"unique_name":"rotate-string","title":"旋转字符串","description":"给定一个字符串和一个偏移量，根据偏移量旋转字符串(从左向右旋转)","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param str: an array of char\r\n     * @param offset: an integer\r\n     * @return: nothing\r\n     */\r\n    public void rotateString(char[] str, int offset) {\r\n        // write your code here\r\n        if (str == null || str.length == 0)\r\n            return;\r\n            \r\n        offset = offset % str.length;\r\n        reverse(str, 0, str.length - offset - 1);\r\n        reverse(str, str.length - offset, str.length - 1);\r\n        reverse(str, 0, str.length - 1);\r\n    }\r\n    \r\n    private void reverse(char[] str, int start, int end) {\r\n        for (int i = start, j = end; i < j; i++, j--) {\r\n            char temp = str[i];\r\n            str[i] = str[j];\r\n            str[j] = temp;\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param str: a string\r\n     * @param offset: an integer\r\n     * @return: nothing\r\n     */\r\n    void rotateString(string &str,int offset){\r\n        //wirte your code here\r\n        if (str.size() == 0)\r\n            return;\r\n            \r\n        offset = offset % str.size();\r\n        str = str.substr(str.size() - offset, offset) +\r\n                str.substr(0, str.size() - offset);\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param s: a list of char\r\n    # @param offset: an integer \r\n    # @return: nothing\r\n    def rotateString(self, s, offset):\r\n\t    # write you code here\r\n        if len(s) > 0:\r\n            offset = offset % len(s)\r\n            \r\n        temp = (s + s)[len(s) - offset : 2 * len(s) - offset]\r\n\r\n        for i in xrange(len(temp)):\r\n            s[i] = temp[i]"}]},{"id":1,"unique_name":"length-of-last-word","title":"最后一个单词的长度","description":"给定一个字符串， 包含大小写字母、空格`' '`，请返回其最后一个单词的长度。\r\n\r\n如果不存在最后一个单词，请返回 `0` 。","solutions":[{"language":"java","code":"public class Solution {\r\n    public int lengthOfLastWord(String s) {\r\n        int length = 0;\r\n        char[] chars = s.toCharArray();\r\n        for (int i = s.length() - 1; i >= 0; i--) {\r\n            if (length == 0) {\r\n                if (chars[i] == ' ') {\r\n                    continue;\r\n                } else {\r\n                    length++;\r\n                }\r\n            } else {\r\n                if (chars[i] == ' ') {\r\n                    break;\r\n                } else {\r\n                    length++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return length;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    \r\n    /*\r\n     * @param s: A string\r\n     * @return: the length of last word\r\n     */\r\n    int lengthOfLastWord(string s) {\r\n        // write your code here\r\n        int length = 0;\r\n        for (int i = s.length()-1; i >= 0; i--) {\r\n            if (length == 0) {\r\n                if (s[i] == ' ') {\r\n                    continue;\r\n                } else {\r\n                    length++;\r\n                }\r\n            } else {\r\n                if (s[i] == ' ') {\r\n                    break;\r\n                } else {\r\n                    length++;\r\n                }\r\n            }\r\n        }\r\n        return length;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {string} s A string\r\n    # @return {int} the length of last word\r\n    def lengthOfLastWord(self, s):\r\n        return len(s.strip().split(' ')[-1])\r\n"}]},{"id":117,"unique_name":"integer-to-roman","title":"整数转罗马数字","description":"给定一个整数，将其转换成罗马数字。\r\n\r\n返回的结果要求在1-3999的范围内。","solutions":[{"language":"java","code":"public class Solution {\r\n\tpublic String intToRoman(int num) {\r\n\t\tif(num <= 0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t    int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\r\n\t    String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\r\n\t    StringBuilder res = new StringBuilder();\r\n\t    int digit=0;\r\n\t    while (num > 0) {\r\n\t        int times = num / nums[digit];\r\n\t        num -= nums[digit] * times;\r\n\t        for ( ; times > 0; times--) {\r\n\t            res.append(symbols[digit]);\r\n\t        }\r\n\t        digit++;\r\n\t    }\r\n\t    return res.toString();\r\n\t}\r\n}\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    /**\r\n     * @param n The integer\r\n     * @return Roman representation\r\n     */\r\n    public String intToRoman(int n) {\r\n        // Write your code here\r\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\r\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\r\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\r\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\r\n        return M[n / 1000] + C[(n / 100) % 10] + X[(n / 10) % 10] + I[n % 10];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n  /**\r\n   * @param n The integer\r\n   * @return Roman representation\r\n   */\r\n  string intToRoman(int n) {\r\n    // Write your code here\r\n    string ans;\r\n    string Roman[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\r\n    int value[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\r\n    for (int i = 0; i < 13; i++) { \r\n      while (n >= value[i]) {\r\n        n -= value[i];\r\n        ans += Roman[i];\r\n      }\r\n    } \r\n    return ans;\r\n  }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param {integer} num\r\n    # @return {string}\r\n    def parse(self, digit, index):\r\n        NUMS = {\r\n            1: 'I',\r\n            2: 'II',\r\n            3: 'III',\r\n            4: 'IV',\r\n            5: 'V',\r\n            6: 'VI',\r\n            7: 'VII',\r\n            8: 'VIII',\r\n            9: 'IX',\r\n        }\r\n        ROMAN = {\r\n            'I': ['I', 'X', 'C', 'M'],\r\n            'V': ['V', 'L', 'D', '?'],\r\n            'X': ['X', 'C', 'M', '?']\r\n        }\r\n        \r\n        s = NUMS[digit]\r\n        return s.replace('X', ROMAN['X'][index]).replace('I', ROMAN['I'][index]).replace('V', ROMAN['V'][index])\r\n        \r\n    def intToRoman(self, num):\r\n        s = ''\r\n        index = 0\r\n        while num != 0:\r\n            digit = num % 10\r\n            if digit != 0:\r\n                s = self.parse(digit, index) + s\r\n            num = num / 10\r\n            index += 1\r\n        return s\r\n            \r\n            "}]},{"id":159,"unique_name":"longest-common-substring","title":"最长公共子串","description":"<p>给出两个字符串，找到最长公共子串，并返回其长度。</p><p><br></p>","solutions":[{"language":"java","code":"// 严格的说，这个算法是递推，而不是动态规划，但是可以用动态规划的四要素去分析换个解答。\r\n// 为什么不是动态规划？因为最暴力的方式也就是 O(n^3) 可以找到A所有的Substring然后看看在不在B里。\r\npublic class Solution {\r\n    /**\r\n     * @param A, B: Two string.\r\n     * @return: the length of the longest common substring.\r\n     */\r\n    public int longestCommonSubstring(String A, String B) {\r\n        // state: f[i][j] is the length of the longest lcs\r\n        // ended with A[i - 1] & B[j - 1] in A[0..i-1] & B[0..j-1]\r\n        int n = A.length();\r\n        int m = B.length();\r\n        int[][] f = new int[n + 1][m + 1];\r\n        \r\n        // initialize: f[i][j] is 0 by default\r\n        \r\n        // function: f[i][j] = f[i - 1][j - 1] + 1 or 0\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                if (A.charAt(i - 1) == B.charAt(j - 1)) {\r\n                    f[i][j] = f[i - 1][j - 1] + 1;\r\n                } else {\r\n                    f[i][j] = 0;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // answer: max{f[i][j]}\r\n        int max = 0;\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= m; j++) {\r\n                max = Math.max(max, f[i][j]);\r\n            }\r\n        }\r\n        \r\n        return max;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param A, B: Two string.\r\n     * @return: the length of the longest common substring.\r\n     */\r\n    int longestCommonSubstring(string &A, string &B) {\r\n        // write your code here\r\n        int maxlen = 0;\r\n        int xlen = A.size();\r\n        int ylen = B.size();\r\n        for(int i = 0; i < xlen; ++i)\r\n\t    {\r\n\t\t    for(int j = 0; j < ylen; ++j)\r\n\t\t    {\r\n\t\t\t    int len = 0;\r\n                while (i + len < xlen && j + len < ylen && \r\n                    A[i + len] == B[j + len])\r\n                        len ++;\r\n\t\t\t    if(len > maxlen)\r\n\t\t\t\t    maxlen = len;\r\n\t\t    }\r\n\t    }\r\n        return maxlen;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\r\n    # @param A, B: Two string.\r\n    # @return: the length of the longest common substring.\r\n    def longestCommonSubstring(self, A, B):\r\n        # write your code here\r\n        ans = 0\r\n        for i in xrange(len(A)):\r\n            for j in xrange(len(B)):\r\n                l = 0\r\n                while i + l < len(A) and j + l < len(B) \\\r\n                    and A[i + l] == B[j + l]:\r\n                    l += 1\r\n                if l > ans:\r\n                    ans = l\r\n        return ans\r\n        \r\n                        \r\n                \r\n"}]},{"id":115,"unique_name":"longest-common-prefix","title":"最长公共前缀","description":"<p>给k个字符串，求出他们的最长公共前缀(LCP)</p>","solutions":[{"language":"java","code":"\r\npublic class Solution {\r\n    \r\n    // 1. Method 1, start from the first one, compare prefix with next string, until end;\r\n    // 2. Method 2, start from the first char, compare it with all string, and then the second char\r\n    // I am using method 1 here\r\n    public String longestCommonPrefix(String[] strs) {\r\n        if (strs == null || strs.length == 0) {\r\n            return \"\";\r\n        }\r\n        String prefix = strs[0];\r\n        for(int i = 1; i < strs.length; i++) {\r\n            int j = 0;\r\n            while( j < strs[i].length() && j < prefix.length() && strs[i].charAt(j) == prefix.charAt(j)) {\r\n                j++;\r\n            }\r\n            if( j == 0) {\r\n                return \"\";\r\n\t    }\r\n            prefix = prefix.substring(0, j);\r\n        }\r\n        return prefix;\r\n    }\r\n\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:    \r\n    /**\r\n     * @param strs: A list of strings\r\n     * @return: The longest common prefix\r\n     */\r\n    string longestCommonPrefix(vector<string> &strs) {\r\n        if (strs.size() == 0) {\r\n            return \"\";\r\n        }\r\n        \r\n        string prefix = \"\";\r\n        for (int i = 0; i < strs[0].length(); i++) {\r\n            for (int j = 1; j < strs.size(); j++) {\r\n                if (strs[j][i] != strs[0][i]) {\r\n                    return prefix;\r\n                }\r\n            }\r\n            prefix += strs[0][i];\r\n        }\r\n        \r\n        return prefix;\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param strs: A list of strings\r\n    # @return: The longest common prefix\r\n    def longestCommonPrefix(self, strs):\r\n        # write your code here\r\n        if len(strs) <= 1:\r\n            return strs[0] if len(strs) == 1 else \"\"\r\n        end, minl = 0, min([len(s) for s in strs])\r\n        while end < minl:\r\n            for i in range(1, len(strs)):\r\n                if strs[i][end] != strs[i-1][end]:\r\n                    return strs[0][:end]\r\n            end = end + 1\r\n        return strs[0][:end]\r\n"}]},{"id":4,"unique_name":"reverse-words-in-a-string","title":"翻转字符串","description":"<span style=\"line-height: 1.42857143;\">给定一个字符串，逐个翻转字符串中的每个单词。</span>","solutions":[{"language":"java","code":"public class Solution {\r\n    public String reverseWords(String s) {\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n\r\n        String[] array = s.split(\" \");\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        for (int i = array.length - 1; i >= 0; --i) {\r\n            if (!array[i].equals(\"\")) {\r\n                sb.append(array[i]).append(\" \");\r\n            }\r\n        }\r\n\r\n        //remove the last \" \"\r\n        return sb.length() == 0 ? \"\" : sb.substring(0, sb.length() - 1);\r\n    }\r\n}"},{"language":"cpp","code":"#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\n    /**\n     * @param s : A string\n     * @return : A string\n     */\npublic:\n    string reverseWords(string s) {\n        string ss;\n        int i = s.length()-1;\n        while(i>=0)\n        {\n            while(i>=0&&s[i] == ' ')\n            {\n                i --;\n            }\n            if(i<0) break;\n            if(ss.length()!=0)\n                ss.push_back(' ');\n            string temp ;\n            for(;i>=0&&s[i]!=' ';i--)\n                temp.push_back(s[i]);\n            reverse(temp.begin(),temp.end());\n            ss.append(temp);\n        }\n        s=ss;\n        return s;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param s : A string\n    # @return : A string\n    def reverseWords(self, s):\n        return ' '.join(reversed(s.strip().split()))\n"}]},{"id":716,"unique_name":"rotate-words","title":"循环单词","description":"","solutions":[{"language":"java","code":"public class Solution {\n    /*\n     * @param words: A list of words\n     * @return: Return how many different rotate words\n     */\n    public int countRotateWords(List<String> words) {\n        // Write your code here\n        if (words == null || words.size() == 0) {\n            return 0;\n        }\n        \n        Set<String> set = new HashSet<>();\n        for (String word: words) {\n            boolean exist = false;\n            for (int i = 0; i < word.length(); i++) {\n                String cur = word.substring(i, word.length()) + \n                             word.substring(0, i);\n                if (set.contains(cur)) {\n                    exist = true;\n                    break;\n                }\n            }\n            if (exist == false) {\n                set.add(word);\n            }\n        }\n        return set.size();\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param words: A list of words\n     * @return: Return how many different rotate words\n     */\n  int countRotateWords(vector<string> words)\n  {\n\t\t// Write your code here\n\n\n\t\tint size = words.size();\n\t\tif (words.size() == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\twords[i] = change_word_to_smallest(words[i]);\n\t\t}\n\t\tsort(words.begin(), words.end());\n\t\tvector<string> vec;\n\t\tvec.push_back(words[0]);\n\t\tfor (int i = 1; i < size; i++)\n\t\t{\n\t\t\tif (find(vec.begin(), vec.end(), words[i]) != vec.end())\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec.push_back(words[i]);\n\t\t\t}\n\t\t}\n\t\treturn vec.size();\n\t}\n\tstring change_word_to_smallest(const string &a)\n\t{\n\t\tint size = a.size();\n\t\tvector<string>vec;\n\t\tint offset = size;\n\t\twhile (offset--)\n\t\t{\n\t\t\tvec.push_back(a.substr(size - offset, offset) + a.substr(0, size - offset));\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\treturn *vec.begin();\n\t}\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: words: A list of words\n    @return: Return how many different rotate words\n    \"\"\"\n    def countRotateWords(self, words):\n        # Write your code here\n        count = 0\n        dict = set()\n        exist = False\n        \n        if not words:\n            return 0\n\n        for word in words:\n            for i in range(len(word)):\n                new_word = word[i:] + word[0:i]\n                if new_word in dict:\n                    exist = True\n                    break\n            \n            if False == exist:\n                dict.add(word)\n                count += 1\n            exist = False\n\n        return count"}]},{"id":512,"unique_name":"build-post-office","title":"邮局的建立","description":"给出一个二维的网格，每一个格子上用 `1` 表示房子，`0` 表示空。要求在网格中，找到一个空地建立邮局，使得邮局到所有的房子的距离和最小。返回所有房子到邮局的最小距离和，如果不可能建邮局则返回`-1`。","solutions":[{"language":"java","code":"// 方法一 \r\npublic class Solution {\r\n    /**\r\n     * @param grid a 2D grid\r\n     * @return an integer\r\n     */\r\n    public int shortestDistance(int[][] grid) {\r\n        // Write your code here\r\n        int n = grid.length;\r\n        if (n == 0)\r\n            return -1;\r\n\r\n        int m = grid[0].length;\r\n        if (m == 0)\r\n            return -1;\r\n\r\n        List<Integer> sumx = new ArrayList<Integer>();\r\n        List<Integer> sumy = new ArrayList<Integer>();\r\n        List<Integer> x = new ArrayList<Integer>();\r\n        List<Integer> y = new ArrayList<Integer>();\r\n\r\n        int result = Integer.MAX_VALUE;\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = 0; j < m; ++j)\r\n                if (grid[i][j] == 1) {\r\n                    x.add(i);\r\n                    y.add(j);\r\n                }\r\n        \r\n        Collections.sort(x);\r\n        Collections.sort(y);\r\n\r\n        int total = x.size();\r\n\r\n        sumx.add(0);\r\n        sumy.add(0);\r\n        for (int i = 1; i <= total; ++i) {\r\n            sumx.add(sumx.get(i-1) + x.get(i-1));\r\n            sumy.add(sumy.get(i-1) + y.get(i-1));\r\n        }\r\n\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = 0; j < m; ++j)\r\n                if (grid[i][j] == 0) {\r\n                    int cost_x = get_cost(x, sumx, i, total);\r\n                    int cost_y = get_cost(y, sumy, j, total);\r\n                    if (cost_x + cost_y < result)\r\n                        result = cost_x + cost_y;\r\n                }\r\n\r\n        return result;\r\n    }\r\n\r\n    public int get_cost(List<Integer> x, List<Integer> sum, int pos, int n) {\r\n        if (n == 0)\r\n            return 0;\r\n        if (x.get(0) > pos)\r\n            return sum.get(n) - pos * n;\r\n\r\n        int l = 0, r = n - 1;\r\n        while (l + 1 < r) {\r\n            int mid = l + (r - l) / 2;\r\n            if (x.get(mid) <= pos)\r\n                l = mid;\r\n            else\r\n                r = mid - 1;\r\n        }\r\n        \r\n        int index = 0;\r\n        if (x.get(r) <= pos)\r\n            index = r;\r\n        else\r\n            index = l;\r\n        return sum.get(n) - sum.get(index + 1) - pos * (n - index - 1) + \r\n               (index + 1) * pos - sum.get(index + 1);\r\n    }\r\n}\r\n\r\n// 方法二\r\npublic class Solution {\r\n    /**\r\n     * @param grid a 2D grid\r\n     * @return an integer\r\n     */\r\n    public int shortestDistance(int[][] grid) {\r\n        // Write your code here\r\n        int row = grid.length, column = grid[0].length;\r\n        if(row == 0 || column == 0 || !haveZero(grid,row,column)) {\r\n        \treturn -1;\r\n        }\r\n\r\n        int[] rowSum = new int[row];\r\n        int[] columnSum = new int[column]; \r\n        for(int i = 0; i < row; i++)\r\n        \tfor(int j = 0; j < column; j++)\r\n        \t\tif(grid[i][j] == 1) {\r\n        \t\t\trowSum[i]++;\r\n        \t\t\tcolumnSum[j]++;\r\n        \t\t}\r\n\r\n        int[] ansRow = new int[row];\r\n        int[] ansColumn = new int[column];\r\n        getSumDistance(rowSum,row,ansRow);\r\n        getSumDistance(columnSum,column,ansColumn);\r\n\r\n        int ans = Integer.MAX_VALUE;\r\n        for(int i = 0; i < row; i++)\r\n        \tfor(int j = 0; j < column; j++)\r\n        \t\tif(grid[i][j] == 0 && ans > ansRow[i] + ansColumn[j]) {\r\n        \t\t\tans = ansRow[i] + ansColumn[j];\r\n        \t\t}\r\n        return ans;\r\n    }\r\n\r\n    void getSumDistance(int[] a,int n,int[] ans) {\r\n    \tint[] prefixSum1 = new int[n];\r\n    \tint[] prefixSum2 = new int[n];\r\n    \t/*\r\n    \t第一阶段，处理前缀。\r\n    \tprefixSum1记录数组 a 的前缀和，即:prefixSum1[i]=a[0]+a[1]+..+a[i].\r\n    \tprefixSum2记录数组 prefixSum1 前缀和，prefixSum2即为前 i 个点到第 i 个点的代价和。\r\n    \t*/\r\n    \tprefixSum1[0] = a[0];\r\n    \tfor(int i = 1; i < n; i++) {\r\n    \t\tprefixSum1[i] = prefixSum1[i - 1] + a[i];\r\n    \t}\r\n    \tprefixSum2[0] = 0;\r\n    \tfor(int i = 1; i < n; i++) {\r\n    \t\tprefixSum2[i] = prefixSum2[i - 1] + prefixSum1[i - 1];\r\n     \t}\r\n\r\n     \tfor(int i = 0; i < n; i++) {\r\n     \t\tans[i] = prefixSum2[i];\r\n     \t}\r\n\r\n    \t/*\r\n    \t第二阶段，处理后缀。\r\n    \tprefixSum1记录数组 a 的后缀和，即:prefixSum1[i]=a[n-1]+a[n-2]+..+a[i].\r\n    \tprefixSum2记录数组 prefixSum1 的后缀和，prefixSum2即为 i 之后的点到第 i 个点的代价和。\r\n    \t*/\r\n    \tprefixSum1[n - 1] = a[n - 1];\r\n    \tfor(int i = n - 2; i >= 0; i--) {\r\n    \t\tprefixSum1[i] = prefixSum1[i + 1] + a[i];\r\n    \t}\r\n    \tprefixSum2[n - 1] =0;\r\n    \tfor(int i = n - 2; i >= 0; i--) {\r\n    \t\tprefixSum2[i] = prefixSum2[i + 1] + prefixSum1[i + 1];\r\n     \t}\r\n\r\n     \tfor(int i = 0; i < n; i++) {\r\n     \t\tans[i] += prefixSum2[i];\r\n     \t}\r\n\r\n     \t/*\r\n     \tans[i] 即为a数组中所有点到第 i 点的代价和\r\n     \t*/\r\n    }\r\n\r\n    boolean haveZero(int[][] grid, int row, int column) {\r\n    \tfor(int i = 0; i < row; i++) {\r\n    \t\tfor(int j = 0; j < column; j++){\r\n    \t\t\tif(grid[i][j] == 0) {\r\n    \t\t\t\treturn true;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t}\r\n    \treturn false;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"//  方法一见java\r\n\r\n//  方法二\r\n// Time Complexity O(n * m)  n和m分别是矩阵的行和列\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param grid a 2D grid\r\n     * @return an integer\r\n     */\r\n    int shortestDistance(vector<vector<int>>& grid) {\r\n        // Write your code here\r\n        int row = grid.size(), column = grid[0].size();\r\n        if(row == 0 || column == 0 || !haveZero(grid, row, column)) {\r\n            return -1;\r\n        }\r\n\r\n        vector<int> rowSum(row);\r\n        vector<int> columnSum(column);\r\n        for(int i = 0; i < row; i++)\r\n            for(int j = 0; j < column; j++)\r\n                if (grid[i][j] == 1) {\r\n                    rowSum[i]++;\r\n                    columnSum[j]++;\r\n                }\r\n\r\n        vector<int> costRow(row);\r\n        vector<int> costColumn(column);\r\n        getSumDistance(rowSum,row,costRow);\r\n        getSumDistance(columnSum,column,costColumn);\r\n\r\n        int cost = INT_MAX;\r\n        for(int i = 0; i < row; i++)\r\n            for(int j = 0; j < column; j++)\r\n                if(grid[i][j] == 0 && cost > costRow[i] + costColumn[j]) {\r\n                    cost = costRow[i] + costColumn[j];\r\n                }\r\n        return cost;\r\n    }\r\n\r\n    void getSumDistance(vector<int>& a, int n, vector<int>& cost) {\r\n        vector<int> prefixSum1(n);\r\n        vector<int> prefixSum2(n);\r\n    \t/*\r\n    \t第一阶段，处理前缀。\r\n    \tprefixSum1记录数组 a 的前缀和，即:prefixSum1[i]=a[0]+a[1]+..+a[i].\r\n    \tprefixSum2记录数组 prefixSum1 前缀和，prefixSum2即为前 i 个点到第 i 个点的代价和。\r\n    \t*/\r\n    \tprefixSum1[0] = a[0];\r\n    \tfor(int i = 1; i < n; i++) {\r\n    \t\tprefixSum1[i] = prefixSum1[i - 1] + a[i];\r\n    \t}\r\n    \tprefixSum2[0] = 0;\r\n    \tfor(int i = 1; i < n; i++) {\r\n    \t\tprefixSum2[i] = prefixSum2[i - 1] + prefixSum1[i - 1];\r\n     \t}\r\n\r\n     \tfor(int i = 0; i < n; i++) {\r\n     \t\tcost[i] = prefixSum2[i];\r\n     \t}\r\n\r\n    \t/*\r\n    \t第二阶段，处理后缀。\r\n    \tprefixSum1记录数组 a 的后缀和，即:prefixSum1[i]=a[n-1]+a[n-2]+..+a[i].\r\n    \tprefixSum2记录数组 prefixSum1 的后缀和，prefixSum2即为 i 之后的点到第 i 个点的代价和。\r\n    \t*/\r\n    \tprefixSum1[n - 1] = a[n - 1];\r\n    \tfor(int i = n - 2; i >= 0; i--) {\r\n    \t\tprefixSum1[i] = prefixSum1[i + 1] + a[i];\r\n    \t}\r\n    \tprefixSum2[n - 1] = 0;\r\n    \tfor(int i = n - 2; i >= 0; i--) {\r\n    \t\tprefixSum2[i] = prefixSum2[i + 1] + prefixSum1[i + 1];\r\n     \t}\r\n\r\n     \tfor(int i = 0; i < n; i++) {\r\n     \t\tcost[i] += prefixSum2[i];\r\n     \t}\r\n\r\n     \t/*\r\n     \tcost[i] 即为a数组中所有点到第 i 点的代价和\r\n     \t*/\r\n    }\r\n\r\n    bool haveZero(vector<vector<int>>& grid, int row, int column) {\r\n        for (int i = 0; i < row; i++) {\r\n            for (int j = 0; j < column; j++) {\r\n                if (grid[i][j] == 0) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};"}]},{"id":379,"unique_name":"sort-integers","title":"整数排序","description":"给一组整数，按照升序排序，使用选择排序，冒泡排序，插入排序或者任何 O(n<sup>2</sup>) 的排序算法。\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param A an integer array\r\n     * @return void\r\n     */\r\n    public void sortIntegers(int[] A) {\r\n        // Write your code here\r\n        int n = A.length;\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = i+1; j < n; ++j)\r\n                if (A[j] < A[i]) {\r\n                    int t = A[j];\r\n                    A[j] = A[i];\r\n                    A[i] = t;\r\n                }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A an integer array\r\n     * @return void\r\n     */\r\n    void sortIntegers(vector<int>& A) {\r\n        // Write your code here\r\n        sort(A.begin(), A.end());\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int[]} A an integer array\r\n    # @return nothing\r\n    def sortIntegers(self, A):\r\n        # Write your code here\r\n        A.sort()"}]},{"id":292,"unique_name":"nuts-bolts-problem","title":"Nuts 和 Bolts 的问题","description":"给定一组 n 个不同大小的 nuts 和 n 个不同大小的 bolts。nuts 和 bolts 一一匹配。 不允许将 nut 之间互相比较，也不允许将 bolt 之间互相比较。也就是说，只许将 nut 与 bolt 进行比较， 或将 bolt 与 nut 进行比较。请比较 nut 与 bolt 的大小。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nuts: an array of integers\r\n     * @param bolts: an array of integers\r\n     * @param compare: a instance of Comparator\r\n     * @return: nothing\r\n     */\r\n    public void sortNutsAndBolts(String[] nuts, String[] bolts, NBComparator compare) {\r\n        if (nuts == null || bolts == null) return;\r\n        if (nuts.length != bolts.length) return;\r\n\r\n        qsort(nuts, bolts, compare, 0, nuts.length - 1);\r\n    }\r\n\r\n    private void qsort(String[] nuts, String[] bolts, NBComparator compare, \r\n                       int l, int u) {\r\n        if (l >= u) return;\r\n        // find the partition index for nuts with bolts[l]\r\n        int part_inx = partition(nuts, bolts[l], compare, l, u);\r\n        // partition bolts with nuts[part_inx]\r\n        partition(bolts, nuts[part_inx], compare, l, u);\r\n        // qsort recursively\r\n        qsort(nuts, bolts, compare, l, part_inx - 1);\r\n        qsort(nuts, bolts, compare, part_inx + 1, u);\r\n    }\r\n    \r\n    private int partition(String[] str, String pivot, NBComparator compare, \r\n                          int l, int u) {\r\n        for (int i = l; i <= u; i++) {\r\n            if (compare.cmp(str[i], pivot) == 0 || \r\n                compare.cmp(pivot, str[i]) == 0) {\r\n                swap(str, i, l);\r\n                break;\r\n            }\r\n        }\r\n        String now = str[l];\r\n        int left = l; \r\n        int right = u;\r\n        while (left < right) {\r\n            while (left < right && \r\n            (compare.cmp(str[right], pivot) == -1 || \r\n            compare.cmp(pivot, str[right]) == 1)) {\r\n                right--;\r\n            }\r\n            str[left] = str[right];\r\n            \r\n            while (left < right && \r\n            (compare.cmp(str[left], pivot) == 1 || \r\n            compare.cmp(pivot, str[left]) == -1)) {\r\n                left++;\r\n            }\r\n            str[right] = str[left];\r\n        }\r\n        str[left] = now;\r\n\r\n        return left;\r\n    }\r\n\r\n    private void swap(String[] str, int l, int r) {\r\n        String temp = str[l];\r\n        str[l] = str[r];\r\n        str[r] = temp;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * class Comparator {\r\n *     public:\r\n *      int cmp(string a, string b);\r\n * };\r\n * You can use compare.cmp(a, b) to compare nuts \"a\" and bolts \"b\",\r\n * if \"a\" is bigger than \"b\", it will return 1, else if they are equal,\r\n * it will return 0, else if \"a\" is smaller than \"b\", it will return -1.\r\n * When \"a\" is not a nut or \"b\" is not a bolt, it will return 2, which is not valid.\r\n*/\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nuts: a vector of integers\r\n     * @param bolts: a vector of integers\r\n     * @param compare: a instance of Comparator\r\n     * @return: nothing\r\n     */\r\n    void sortNutsAndBolts(vector<string> &nuts, vector<string> &bolts, Comparator compare) {\r\n        // write your code here\r\n        quickSort(nuts, bolts, 0, nuts.size()-1, compare);\r\n    }\r\n    \r\nprivate:\r\n    void quickSort(vector<string> &a, vector<string> &b, int l, int r, Comparator compare) {\r\n        int mark, count=0;\r\n        for (int i=l; i<=r; ++i) {\r\n            int t = compare.cmp(a[l], b[i]);\r\n            if (t==0) mark = i;\r\n            else \r\n                if (t==1) ++count;\r\n        }\r\n        swap(a[l], a[l+count]);\r\n        swap(b[mark],b[l+count]);\r\n        mark = l+count;\r\n        int i = l, j = r;\r\n        while (i<mark && j>mark) {\r\n            while (i<mark && compare.cmp(a[i], b[mark])==-1) ++i;\r\n            while (j>mark && compare.cmp(a[j], b[mark])==1) --j;\r\n            if (i<j) swap(a[i++], a[j--]);\r\n        }\r\n        i = l; j = r;\r\n        while (i<mark && j>mark) {\r\n            while (i<mark && compare.cmp(a[mark], b[i])==1) ++i;\r\n            while (j>mark && compare.cmp(a[mark], b[j])==-1) --j;\r\n            if (i<j) swap(b[i++], b[j--]);\r\n        }\r\n        if (l<mark) quickSort(a, b, l, mark-1, compare);\r\n        if (r>mark) quickSort(a, b, mark+1, r, compare);\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param nuts: a list of integers\r\n    # @param bolts: a list of integers\r\n    # @param compare: a instance of Comparator\r\n    # @return: nothing\r\n    def sortNutsAndBolts(self, nuts, bolts, compare):\r\n        if nuts == [] or bolts == [] or compare is None:\r\n            return \r\n        self.compare = compare\r\n        self.quickSort(nuts, bolts, 0, len(nuts) - 1)\r\n        \r\n    def quickSort(self, nuts, bolts, left, right):\r\n        if left >= right:\r\n            return \r\n        split_nut_pos = self.partition(nuts, bolts[left], left, right)\r\n        split_bolt_pos = self.partition(bolts, nuts[split_nut_pos], left, right)\r\n        self.quickSort(nuts, bolts, left, split_nut_pos - 1)\r\n        self.quickSort(nuts, bolts, split_nut_pos + 1, right)\r\n        \r\n    def partition(self, items, pivot, left, right):\r\n        if items == [] or pivot == None:\r\n            return\r\n        \r\n        for i in range(left, right + 1):\r\n            if self.compare.cmp(pivot, items[i]) == 0 \\\r\n                or self.compare.cmp(items[i], pivot) == 0:\r\n                items[left], items[i] = items[i], items[left]\r\n                break\r\n        \r\n        pivot_partner = items[left]\r\n        while left < right:\r\n            while left < right and \\\r\n                (self.compare.cmp(pivot, items[right]) == -1 \\\r\n                or self.compare.cmp(items[right], pivot) == 1):\r\n                right -= 1\r\n            items[left] = items[right]\r\n            \r\n            while left < right and \\\r\n                (self.compare.cmp(pivot, items[left]) == 1 \\\r\n                or self.compare.cmp(items[left], pivot) == -1):\r\n                left += 1\r\n            items[right] = items[left]\r\n            \r\n        items[left] = pivot_partner\r\n        return left"}]},{"id":203,"unique_name":"largest-number","title":"最大数","description":"给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。","solutions":[{"language":"java","code":"class NumbersComparator implements Comparator<String> {\r\n\t@Override\r\n\tpublic int compare(String s1, String s2) {\r\n\t\treturn (s2 + s1).compareTo(s1 + s2);\r\n\t}\r\n}\r\n\r\npublic class Solution {\r\n    \r\n    public String largestNumber(int[] nums) {\r\n        String[] strs = new String[nums.length];\r\n        for (int i = 0; i < nums.length; i++) {\r\n            strs[i] = Integer.toString(nums[i]);\r\n        }\r\n        Arrays.sort(strs, new NumbersComparator());\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < strs.length; i++) {\r\n            sb.append(strs[i]);\r\n        }\r\n        String result = sb.toString();\r\n        int index = 0;\r\n        while (index < result.length() && result.charAt(index) == '0') {\r\n            index++;\r\n        }\r\n        if (index == result.length()) {\r\n            return \"0\";\r\n        }\r\n        return result.substring(index);\r\n    }\r\n}"},{"language":"cpp","code":"#include <sstream>\nbool cmp(const string s1, const string s2) {\n    return (s1 + s2) > (s2 + s1);\n}\nclass Solution {\npublic:\n    /**\n     *@param num: A list of non negative integers\n     *@return: A string\n     */\n    string largestNumber(vector<int> &num) {\n        // write your code here\n        vector<string> s_num(num.size());\n        stringstream stream;\n        for (int i = 0; i < num.size(); ++i) {\n            stream << num[i];\n            stream >> s_num[i];\n            stream.clear();\n        }\n        sort(s_num.begin(), s_num.end(), cmp);\n        string tmp_res;\n        for (int i = 0; i < s_num.size(); ++i) {\n            tmp_res += s_num[i];\n        }\n        string res;\n        bool flag = false;\n        for (int i = 0; i < tmp_res.size(); ++i) {\n            if (tmp_res[i] != '0') {\n                res.push_back(tmp_res[i]);\n                flag = true;\n            } else if (flag) {\n                res.push_back(tmp_res[i]);\n            }\n        }\n        if (!flag) res.push_back('0');\n        return res;\n    }\n};\n"},{"language":"python","code":"class Solution:\t\n    # @param num: A list of non negative integers\n    # @return: A string\n    def largestNumber(self, num):\n        nums = sorted(num, cmp=lambda x, y: 1 if str(x) + str(y) < str(y) + str(x) else -1)\n        largest = ''.join([str(x) for x in nums])\n        i, length = 0, len(largest)\n        while i + 1 < length:\n            if largest[i] != '0':\n                break\n            i += 1\n        return largest[i:]\n"}]},{"id":312,"unique_name":"kth-largest-element","title":"第k大元素","description":"在数组中找到第k大的元素\r\n","solutions":[{"language":"java","code":"class Solution {\n    /*\n     * @param k : description of k\n     * @param nums : array of nums\n     * @return: description of return\n     */\n    public int kthLargestElement(int k, int[] nums) {\n        return quickSelect(nums, 0, nums.length - 1, k);\n    }\n    \n    private int quickSelect(int[] nums, int start, int end, int k) {\n        int left = start, right = end;\n        int pivot = nums[(start + end) / 2];\n        \n        while (left <= right) {\n            while (left <= right && nums[left] > pivot) {\n                left++;\n            }\n            while (left <= right && nums[right] < pivot) {\n                right--;\n            }\n            \n            if (left <= right) {\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] = temp;\n                \n                left++;\n                right--;\n            }\n        }\n        \n        if (start + k - 1 <= right) {\n            return quickSelect(nums, start, right, k);\n        }\n        \n        if (start + k - 1 >= left) {\n            return quickSelect(nums, left, end, k - (left - start));\n        }\n        \n        return nums[right + 1];\n    }\n};"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n     * param k : description of k\r\n     * param nums : description of array and index 0 ~ n-1\r\n     * return: description of return\r\n     */\r\n    int kthLargestElement(int k, vector<int> nums){\r\n        return helper(nums, 0, nums.size() - 1, nums.size() - k + 1);\r\n    }\r\n    \r\n    int helper(vector<int> &nums, int left, int right, int k) {\r\n        if (left == right) {\r\n            return nums[left];\r\n        }\r\n        \r\n        int i = left, j = right;\r\n        int pivot = nums[(i + j) / 2];\r\n        while (i <= j) {\r\n            while (i <= j && nums[i] < pivot) {\r\n                i++;\r\n            }\r\n            while (i <= j && nums[j] > pivot) {\r\n                j--;\r\n            }\r\n            if (i <= j) {\r\n                swap(nums[i], nums[j]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n\r\n\r\n        if (left + k - 1 <= j) {\r\n            return helper(nums, left, j, k);\r\n        }\r\n        \r\n        if (left + k - 1 < i) {\r\n            return nums[left + k - 1];\r\n        }\r\n\r\n        return helper(nums, i, right, k - (i - left));\r\n    }\r\n};"},{"language":"python","code":"class Solution:\n    # @param k & A a integer and an array\n    # @return ans a integer\n    def kthLargestElement(self, k, A):\n        n = len(A)\n        k -= 1\n        \n        def partitionHelper(s, e):\n            p, q = s + 1, e\n            while p <= q:\n                if (A[p]>A[s]):\n                    p += 1\n                else:\n                    A[p], A[q] = A[q], A[p]\n                    q -= 1\n        \n            A[s], A[q] = A[q], A[s]\n            \n            m = q\n            if m == k:\n                return A[m]\n            elif m < k:\n                return partitionHelper(m + 1, e)\n            else:\n                return partitionHelper(s, m - 1)\n\n        return partitionHelper(0, n-1)"}]},{"id":621,"unique_name":"kth-smallest-numbers-in-unsorted-array","title":"无序数组K小元素","description":"找到一个无序数组中最小的K个数","solutions":[{"language":"java","code":"class Solution {\r\n    /*\r\n     * @param k an integer\r\n     * @param nums an integer array\r\n     * @return kth smallest element\r\n     */\r\n    public int kthSmallest(int k, int[] nums) {\r\n        // write your code here\r\n        return quickSelect(nums, 0, nums.length - 1, k - 1);\r\n    }\r\n\r\n    public int quickSelect(int[] A, int start, int end , int k) {\r\n\r\n        if (start == end)\r\n            return A[start];\r\n        \r\n        int left = start, right = end;\r\n        int pivot = A[(start + end) / 2];\r\n\r\n        while (left <= right) {\r\n            while (left <= right && A[left] < pivot) {\r\n                left++;\r\n            }\r\n\r\n            while (left <= right && A[right] > pivot) {\r\n                right--;\r\n            }\r\n            if (left <= right) {\r\n                int temp = A[left];\r\n                A[left] = A[right];\r\n                A[right] = temp;\r\n                \r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n\r\n        if (right >= k && start <= right)\r\n            return quickSelect(A, start, right, k);\r\n        else if (left <= k && left <= end)\r\n            return quickSelect(A, left, end, k);\r\n        else\r\n            return A[k];\r\n    }\r\n};"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n     * @param k an integer\r\n     * @param nums an integer array\r\n     * @return kth smallest element\r\n     */\r\n    int kthSmallest(int k, vector<int> nums) {\r\n        // write your code here\r\n        return quickSelect(nums, 0, nums.size() - 1, k - 1);\r\n    }\r\n\r\n    int quickSelect(vector<int>& A, int start, int end , int k) {\r\n\r\n        if (start == end)\r\n            return A[start];\r\n        \r\n        int left = start, right = end;\r\n\r\n        int pivot = A[(start + end) / 2];\r\n\r\n        while (left <= right) {\r\n            while (left <= right && A[left] < pivot) {\r\n                left++;\r\n            }\r\n\r\n            while (left <= right && A[right] > pivot) {\r\n                right--;\r\n            }\r\n            if (left <= right) {\r\n                int temp = A[left];\r\n                A[left] = A[right];\r\n                A[right] = temp;\r\n                \r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n        if (right >= k && start <= right)\r\n            return quickSelect(A, start, right, k);\r\n        else if (left <= k && left <= end)\r\n            return quickSelect(A, left, end, k);\r\n        else\r\n            return A[k];\r\n    }\r\n};"}]},{"id":413,"unique_name":"fibonacci","title":"斐波纳契数列","description":"查找斐波纳契数列中第 N 个数。\r\n\r\n所谓的斐波纳契数列是指：\r\n\r\n- 前2个数是 0 和 1 。\r\n- 第 *i* 个数是第 *i*-1 个数和第*i*-2 个数的和。\r\n\r\n斐波纳契数列的前10个数字是：\r\n\r\n`0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...`","solutions":[{"language":"java","code":"class Solution {\n    /**\n     * @param n: an integer\n     * @return an integer f(n)\n     */\n    public int fibonacci(int n) {\n        int a = 0;\n        int b = 1;\n        for (int i = 0; i < n - 1; i++) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return a;\n    }\n}\n\n//递归版本，会超时\npublic class Solution {\n    /*\n     * @param : an integer\n     * @return: an ineger f(n)\n     */\n    public int fibonacci(int n) {\n        // write your code here\n        if (n == 1) {\n            return 0;\n        }\n        \n        if (n == 2) {\n            return 1;\n        }\n        \n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n};"},{"language":"cpp","code":"class Solution{\npublic:\n    int fibonacci(int n) {\n       int a, b;\n       a = 0;\n       b = 1;\n       for(int i = 1; i < n; i++) {\n           int c = a + b;\n           a = b;\n           b = c;\n       }\n       return a;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    def fibonacci(self, n):\n        a = 0\n        b = 1\n        for i in range(n - 1):\n            a, b = b, a + b\n        return a\n"},{"language":"javascript","code":"const fibonacci = function (n) {\n    var i, a, b, c;\n    a = 0;\n    b = 1;\n    for (i = 0; i < n - 1; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return a;\n}"}]},{"id":449,"unique_name":"fizz-buzz","title":"Fizz Buzz 问题","description":"给你一个整数*n*. 从 *1* 到 *n* 按照下面的规则打印每个数：\r\n\r\n- 如果这个数被3整除，打印`fizz`.\r\n- 如果这个数被5整除，打印`buzz`.\r\n- 如果这个数能同时被`3`和`5`整除，打印`fizz buzz`.","solutions":[{"language":"java","code":"class Solution {\n    /**\n     * param n: As description.\n     * return: A list of strings.\n     */\n    public ArrayList<String> fizzBuzz(int n) {\n        ArrayList<String> results = new ArrayList<String>();\n        for (int i = 1; i <= n; ++i) {\n            if (i % 3 == 0 && i % 5 == 0) {\n                results.add(\"fizz buzz\");\n            } else if (i % 3 == 0) {\n                results.add(\"fizz\");\n            } else if (i % 5 == 0) {\n                results.add(\"buzz\");\n            } else  {\n                results.add(i + \"\");\n            }\n        }\n        return results;\n    }\n}\n\n\nclass Solution {\n    /**\n     * param n: As description.\n     * return: A list of strings.\n     */\n    public ArrayList<String> fizzBuzz(int n) {\n        ArrayList<String> results = new ArrayList<String>();\n        int i = 1;\n        int p3 = 1, p5 = 1;\n        \n        while (i <= n) {\n          while (i < p3 * 3 && i < p5 * 5) {\n            results.add(i + \"\");\n            i++;\n          }\n        \n          if (i <= n && p3 * 3 == p5 * 5) {\n            results.add(\"fizz buzz\");\n            p3++;\n            p5++;\n            i++;\n            continue;\n          }\n        \n          while (i <= n && p3 * 3 <= i) {\n            results.add(\"fizz\");\n            p3++;\n            i++;\n          }\n        \n          while (i <= n && p5 * 5 <= i) {\n            results.add(\"buzz\");\n            p5++;\n            i++;\n          }\n        }\n        \n        return results;\n    }\n}"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * param n: As description.\n     * return: A list of strings.\n     */\n    vector<string> fizzBuzz(int n) {\n        vector<string> results;\n        for (int i = 1; i <= n; i++) {\n            if (i % 15 == 0) {\n                results.push_back(\"fizz buzz\");\n            } else if (i % 5 == 0) {\n                results.push_back(\"buzz\");\n            } else if (i % 3 == 0) {\n                results.push_back(\"fizz\");\n            } else {\n                results.push_back(to_string(i));\n            }\n        }\n        return results;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param n: An integer as description\n    @return: A list of strings.\n    For example, if n = 7, your code should return\n        [\"1\", \"2\", \"fizz\", \"4\", \"buzz\", \"fizz\", \"7\"]\n    \"\"\"\n    def fizzBuzz(self, n):\n        results = []\n        for i in range(1, n+1):\n            if i % 15 == 0:\n                results.append(\"fizz buzz\")\n            elif i % 5 == 0:\n                results.append(\"buzz\")\n            elif i % 3 == 0:\n                results.append(\"fizz\")\n            else:\n                results.append(str(i))\n        return results\n\n"}]},{"id":450,"unique_name":"digit-counts","title":"统计数字","description":"<p>计算数字k在0到n中的出现的次数，k可能是0~9的一个值</p>","solutions":[{"language":"java","code":"class Solution {\n    /*\n     * param k : As description.\n     * param n : As description.\n     * return: An integer denote the count of digit k in 1..n\n     */\n    public int digitCounts(int k, int n) {\n        // write your code here\n        int cnt = 0;\n        for (int i = k; i <= n; i++) {\n            cnt += singleCount(i, k);\n        }\n        return cnt;\n    }\n    \n    public int singleCount(int i, int k) {\n        if (i == 0 && k == 0)\n            return 1;\n        int cnt = 0;\n        while (i > 0) {\n            if (i % 10 == k) {\n                cnt++;\n            }\n            i = i / 10;\n        }\n        return cnt;\n    }\n};\n\n"},{"language":"cpp","code":"class Solution {\r\n public:\r\n    // param k : description of k\r\n    // param n : description of n\r\n    // return ans a integer\r\n    int digitCounts(int k, int n) {\r\n        int count = 0;\r\n        if (k == 0) {\r\n            count = 1;\r\n        }\r\n        for (int i = 1; i <= n; i++) {\r\n            int number = i;\r\n            while (number > 0) {\r\n                if (number % 10 == k) {\r\n                    count += 1;\r\n                } \r\n                number /= 10;\r\n            }\r\n        }\r\n        \r\n        return count;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"class Solution:\n    # @param k & n  two integer\n    # @return ans a integer\n    def digitCounts(self, k, n):\n        assert(n >= 0 and 0 <= k <= 9)\n        count = 0\n        for i in range(n + 1):\n            j = i\n            while True:\n                if j % 10 == k:\n                    count += 1\n                j /= 10\n                if j == 0:\n                    break\n        return count\n\t\t\n"},{"language":"javascript","code":"const digitCounts = function (k, n) {\n    var i, ans, t;\n    ans = 0;\n    for (i = 0; i <= n; i++) {\n        t = i;\n        do {\n            if (t % 10 === k) {\n                ans++;\n            }\n            t = Math.floor(t / 10);\n        } while (t !== 0);\n    }\n    return ans;\n}"}]},{"id":715,"unique_name":"check-sum-of-square-numbers","title":"判断是否为平方数之和","description":"给一个整数 `c`, 你需要判断是否存在两个整数 `a` 和 `b` 使得 `a^2 + b^2 = c`.","solutions":[{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: : the given number\n    @return: whether whether there're two integers\n    \"\"\"\n\n    def checkSumOfSquareNumbers(self, num):\n        import math\n        if num < 0:\n            return False\n        if num == 0:\n            return True\n        root = int(math.sqrt(num))\n        for i in range(0,root+1):\n            j = math.sqrt(num - i*i)\n            if j == int(j):\n                return True\n        return False"}]},{"id":314,"unique_name":"add-digits","title":"各位相加","description":"给出一个非负整数 `num`，反复的将所有位上的数字相加，直到得到一个一位的整数。","solutions":[{"language":"java","code":"#### 参考程序 - Java\r\n\r\n\r\n\r\n\tpublic class Solution {\r\n\r\n\t\tpublic int addDigits(int num) {\r\n\r\n\t\t\tif (num == 0) {\r\n\r\n\t\t\t    return 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tint ans = 0;\r\n\r\n\t\t\tfor (; num != 0; ) {\r\n\r\n\t\t\t    int digit = num % 10;\r\n\r\n\t\t\t    ans = (ans * 10 + digit) % 9;\r\n\r\n\t\t\t    num /= 10;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn ans == 0 ? 9 : ans;\r\n\r\n\t\t}\r\n\r\n\t}\r\n"},{"language":"cpp","code":"#### 参考程序 - C++\r\n\r\n\tclass Solution {\r\n\tpublic:\r\n\t\tint addDigits(int num) {\r\n\t\t\tif (num == 0) {\r\n\t\t\t    return 0;\r\n\t\t\t}\r\n\t\t\tint ans = 0;\r\n\t\t\tfor (; num; ) {\r\n\t\t\t    int digit = num % 10;\r\n\t\t\t    ans = (ans * 10 + digit) % 9;\r\n\t\t\t    num /= 10;\r\n\t\t\t}\r\n\t\t\treturn ans == 0 ? 9 : ans;\r\n\t\t}\r\n\t};"},{"language":"javascript","code":"const addDigits = function (num) {\n    var res;\n    if (num === 0) {\n        return 0;\n    }\n    res = num % 9;\n    if (res === 0) {\n        return 9;\n    }\n    return res;\n}"}]},{"id":308,"unique_name":"ugly-number","title":"丑数","description":"写一个程序来检测一个整数是不是`丑数`。\r\n\r\n丑数的定义是，只包含质因子 `2, 3, 5` 的正整数。比如 6, 8 就是丑数，但是 14 不是丑数以为他包含了质因子 7。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param num an integer\r\n     * @return true if num is an ugly number or false\r\n     */\r\n    public boolean isUgly(int num) {\r\n        if (num <= 0) return false;  \r\n        if (num == 1) return true;  \r\n          \r\n        while (num >= 2 && num % 2 == 0) num /= 2;  \r\n        while (num >= 3 && num % 3 == 0) num /= 3;  \r\n        while (num >= 5 && num % 5 == 0) num /= 5;  \r\n          \r\n        return num == 1;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param num an integer\r\n     * @return true if num is an ugly number or false\r\n     */\r\n    bool isUgly(int num) {\r\n        if (num <= 0) return false;  \r\n        if (num == 1) return true;  \r\n          \r\n        while (num >= 2 && num % 2 == 0) num /= 2;  \r\n        while (num >= 3 && num % 3 == 0) num /= 3;  \r\n        while (num >= 5 && num % 5 == 0) num /= 5;  \r\n          \r\n        return num == 1;  \r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} num an integer\r\n    # @return {boolean} true if num is an ugly number or false\r\n    def isUgly(self, num):\r\n        if num <= 0:\r\n            return False\r\n        if num == 1:\r\n            return True  \r\n          \r\n        while num >= 2 and num % 2 == 0:\r\n            num /= 2;  \r\n        while num >= 3 and num % 3 == 0:\r\n            num /= 3;  \r\n        while num >= 5 and num % 5 == 0:\r\n            num /= 5;  \r\n          \r\n        return num == 1"}]},{"id":293,"unique_name":"trailing-zeros","title":"尾部的零","description":"<p>设计一个算法，计算出n阶乘中尾部零的个数</p>","solutions":[{"language":"java","code":"class Solution {\r\n    /*\r\n     * param n: As desciption\r\n     * return: An integer, denote the number of trailing zeros in n!\r\n     */\r\n    public long trailingZeros(long n) {\r\n        long sum = 0;\r\n        while (n != 0) {\r\n            sum += n / 5;\r\n            n /= 5;\r\n        }\r\n        return sum;\r\n    }\r\n};\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    // param n : description of n\n    // return: description of return \n    long long trailingZeros(long long n) {\n        long long sum = 0;\n        while (n != 0) {\n            sum += n / 5;\n            n /= 5;\n        }\n        return sum;\n    }\n};\n\n"},{"language":"python","code":"class Solution:\n    # @param n a integer\n    # @return ans a integer\n    def trailingZeros(self, n):\n        sum = 0\n        while n != 0:\n            n /= 5\n            sum+= n\n        return sum\n"},{"language":"javascript","code":"/**\n * @param n: A long integer\n * @return: An integer, denote the number of trailing zeros in n!\n */\nconst trailingZeros = function (n) {\n    var sum = 0;\n    while (n !== 0) {\n        sum += Math.floor(n / 5);\n        n = Math.floor(n / 5);\n    }\n    return sum;\n}"}]},{"id":433,"unique_name":"flip-bits","title":"将整数A转换为B","description":"如果要将整数A转换为B，需要改变多少个bit位？","solutions":[{"language":"java","code":"class Solution {\n    /**\n     *@param a, b: Two integer\n     *return: An integer\n     */\n    public static int bitSwapRequired(int a, int b) {\n        // write your code here\n        int count = 0;  \n        for (int c = a ^ b; c != 0; c = c >>> 1) {\n            count += c & 1;\n        }\n        return count;\n    }\n};\n\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     *@param a, b: Two integer\n     *return: An integer\n     */\n    int bitSwapRequired(int a, int b) {\n        // write your code here\n        int count = 0;  \n        for (unsigned int c = a ^ b; c != 0; c = c >> 1) {\n            count += c & 1;\n        }\n        return count;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param a, b: Two integer\n    return: An integer\n    \"\"\"\n    def bitSwapRequired(self, a, b):\n        # write your code here\n        c = a ^ b\n        cnt = 0   \n        for i in xrange(32):\n            if c & (1 << i) != 0:\n                cnt += 1\n        return cnt\n"},{"language":"javascript","code":"/**\n * @param a: An integer\n * @param b: An integer\n * @return: An integer\n */\nconst bitSwapRequired = function (a, b) {\n    var count = 0, c;\n    for (c = a ^ b; c !== 0; c = c >>> 1) {\n        count += c & 1;\n    }\n    return count;\n}"}]},{"id":184,"unique_name":"update-bits","title":"更新二进制位","description":"<p>给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）</p>","solutions":[{"language":"java","code":"class Solution {\n    /**\n     *@param n, m: Two integer\n     *@param i, j: Two bit positions\n     *return: An integer\n     */\n    public int updateBits(int n, int m, int i, int j) {\n        // write your code here\n        int max = ~0; /* All 1’s */\n        // 1’s through position j, then 0’s\n        if (j == 31)\n            j = max;\n        else\n            j = (1 << (j + 1)) - 1;\n        int left = max - j;\n        // 1’s after position i\n\t    int right = ((1 << i) - 1);\n\t    // 1’s, with 0s between i and j\n        int mask = left | right;\n        // Clear i through j, then put m in there\n        return ((n & mask) | (m << i));\n    }\n}\n\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     *@param n, m: Two integer\r\n     *@param i, j: Two bit positions\r\n     *return: An integer\r\n     */\r\n    int updateBits(int n, int m, int i, int j) {\r\n        int mask;\r\n        if (j < 31) {\r\n            mask = ~((1 << (j + 1)) - (1 << i));\r\n        } else {\r\n            mask = (1 << i) - 1;\r\n        }\r\n        return (m << i) + (mask & n);\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\n    #@param n, m: Two integer\n    #@param i, j: Two bit positions\n    #return: An integer\n    def updateBits(self, n, m, i, j):\n        # write your code here\n        a = list()\n        for k in xrange(32):\n            a.append(n % 2)\n            n /= 2\n\n        for k in xrange(i, j + 1):\n            a[k] = m % 2\n            m /= 2\n\n        n = 0\n        for k in xrange(31):\n            if a[k] == 1:\n                n |= (1 << k)\n        if a[31] == 1:\n            n -= 1 << 31\n        return n\n"},{"language":"javascript","code":"/**\n * @param n: An integer\n * @param m: An integer\n * @param i: A bit position\n * @param j: A bit position\n * @return: An integer\n */\nconst updateBits = function (n, m, i, j) {\n    var mask;\n    if (j < 31) {\n        mask = ~((1 << (j + 1)) - (1 << i));\n    } else {\n        mask = (1 << i) - 1;\n    }\n    return (m << i) + (mask & n);\n}"}]},{"id":438,"unique_name":"o1-check-power-of-2","title":"O(1)时间检测2的幂次","description":"用 O(*1*) 时间检测整数 *n* 是否是 *2* 的幂次。","solutions":[{"language":"java","code":"class Solution {\n    /*\n     * @param n: An integer\n     * @return: True or false\n     */\n    public boolean checkPowerOf2(int n) {\n        if (n <= 0) {\n            return false;\n        }\n        return (n & (n-1)) == 0;\n    }\n};\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param n: An integer\n     * @return: True or false\n     */\n    bool checkPowerOf2(int n) {\n        // write your code here\n        if (n==0)\n            return false;\n        while (n % 2 == 0)\n            n /=2 ;\n        return n == 1;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param n: An integer\n    @return: True or false\n    \"\"\"\n    def checkPowerOf2(self, n):\n        # write your code here\n        ans = 1\n        for i in xrange(31):\n            if ans == n:\n                return True\n            ans = ans << 1\n \n        return False\n"}]},{"id":178,"unique_name":"a-b-problem","title":"A + B 问题","description":"给出两个整数a和b, 求他们的和, 但不能使用 `+` 等数学运算符。","solutions":[{"language":"java","code":"class Solution {\r\n    /*\r\n     * param a: The first integer\r\n     * param b: The second integer\r\n     * return: The sum of a and b\r\n     */\r\n    public int aplusb(int a, int b) {\r\n        // 主要利用异或运算来完成 \r\n        // 异或运算有一个别名叫做：不进位加法\r\n        // 那么a ^ b就是a和b相加之后，该进位的地方不进位的结果\r\n        // 然后下面考虑哪些地方要进位，自然是a和b里都是1的地方\r\n        // a & b就是a和b里都是1的那些位置，a & b << 1 就是进位\r\n        // 之后的结果。所以：a + b = (a ^ b) + (a & b << 1)\r\n        // 令a' = a ^ b, b' = (a & b) << 1\r\n        // 可以知道，这个过程是在模拟加法的运算过程，进位不可能\r\n        // 一直持续，所以b最终会变为0。因此重复做上述操作就可以\r\n        // 求得a + b的值。\r\n        while (b != 0) {\r\n            int _a = a ^ b;\r\n            int _b = (a & b) << 1;\r\n            a = _a;\r\n            b = _b;\r\n        }\r\n        return a;\r\n    }\r\n};\r\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /*\n     * @param a: The first integer\n     * @param b: The second integer\n     * @return: The sum of a and b\n     */\n    int aplusb(int a, int b) {\n        // write your code here, try to do it without arithmetic operators.\n        return a + b;\n    }\n};\n"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param a: The first integer\n    @param b: The second integer\n    @return:  The sum of a and b\n    \"\"\"\n    def aplusb(self, a, b):\n        return a + b\n        # write your code here, try to do it without arithmetic operators.\n"}]},{"id":522,"unique_name":"climbing-stairs-ii","title":"爬楼梯 II","description":"一个小孩爬一个 n 层台阶的楼梯。他可以每次跳 1 步， 2 步 或者 3 步。实现一个方法来统计总共有多少种不同的方式爬到最顶层的台阶。\r\n","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n an integer\r\n     * @return an integer\r\n     */\r\n    public int climbStairs2(int n) {\r\n        int[] f = new int[n+1];\r\n        f[0] = 1;\r\n        for (int i = 0; i <= n; i++) \r\n            for (int j = 1; j <= 3; j++) {\r\n                if (i >= j) {\r\n                    f[i] += f[i-j];\r\n                }\r\n            }\r\n        return f[n];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param n an integer\r\n     * @return an integer\r\n     */\r\n    int climbStairs2(int n) {\r\n        // Write your code here\r\n        if(n <= 1)\r\n            return 1;\r\n\r\n        int* step = new int[n + 1];\r\n        step[0] = 1;\r\n        step[1] = 1; \r\n        step[2] = 2;\r\n\r\n        for(int i = 3; i <= n; i++) {\r\n            step[i] = step[i - 1] + step[i-2] + step[i - 3];\r\n        } \r\n        return step[n];\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param {int} n a integer\r\n    @return {int} a integer\r\n    \"\"\"\r\n    def climbStairs2(self, n):\r\n        # write your code here\r\n        if n <= 1:\r\n            return 1\r\n            \r\n        if n == 2:\r\n            return 2\r\n\r\n        a, b, c = 1, 1, 2\r\n        for i in xrange(3, n + 1):\r\n            a, b, c = b, c, a + b + c\r\n\r\n        return c\r\n"}]},{"id":122,"unique_name":"reverse-integer","title":"反转整数","description":"将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param n the integer to be reversed\r\n     * @return the reversed integer\r\n     */\r\n    public int reverseInteger(int n) {\r\n        int reversed_n = 0;\r\n        \r\n        while (n != 0) {\r\n            int temp = reversed_n * 10 + n % 10;\r\n            n = n / 10;\r\n            if (temp / 10 != reversed_n) {\r\n                reversed_n = 0;\r\n                break;\r\n            }\r\n            reversed_n = temp;\r\n        }\r\n        return reversed_n;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int reverseInteger(int x) {\r\n         // Write your code here\r\n        int rst = 0;\r\n        \r\n        while(x != 0){\r\n            int next_rst = rst * 10 + x % 10;\r\n            x = x / 10;\r\n            if(next_rst/10 != rst) {\r\n                rst  = 0;\r\n                break;\r\n            }\r\n            rst = next_rst;\r\n        }\r\n        return rst;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {int} n the integer to be reversed\r\n    # @return {int} the reversed integer\r\n    def reverseInteger(self, n):\r\n        if n == 0:\r\n            return 0\r\n            \r\n        neg = 1\r\n        if n < 0:\r\n            neg, n = -1, -n\r\n        \r\n        reverse = 0\r\n        while n > 0:\r\n            reverse = reverse * 10 + n % 10\r\n            n = n / 10\r\n        \r\n        reverse = reverse * neg\r\n        if reverse < -(1 << 31) or reverse > (1 << 31) - 1:\r\n            return 0\r\n        return reverse"},{"language":"javascript","code":"const reverseInteger = function (n) {\n    var res, temp;\n    res = 0;\n    while (n !== 0) {\n        temp = res * 10 + n % 10;\n        n = parseInt(n / 10);\n        if (parseInt(temp / 10) != res) {\n            res = 0;\n            break;\n        }\n        res = temp;\n    }\n    if (res < -2147483648 || res > 2147483647) {\n        return 0;\n    }\n    return res;\n}"}]},{"id":405,"unique_name":"segment-tree-build-ii","title":"线段树的构造 II","description":"线段树是一棵二叉树，他的每个节点包含了两个额外的属性`start`和`end`用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:\r\n\r\n- 根节点的 _start_ 和 _end_ 由 `build` 方法所给出。\r\n- 对于节点 A 的左儿子，有 `start=A.left, end=(A.left + A.right) / 2`。\r\n- 对于节点 A 的右儿子，有 `start=(A.left + A.right) / 2 + 1, end=A.right`。\r\n- 如果 _start_ 等于 _end_, 那么该节点是叶子节点，不再有左右儿子。\r\n\r\n对于给定数组设计一个`build`方法，构造出线段树","solutions":[{"language":"java","code":"/**\n * Definition of SegmentTreeNode:\n * public class SegmentTreeNode {\n *     public int start, end, max;\n *     public SegmentTreeNode left, right;\n *     public SegmentTreeNode(int start, int end, int max) {\n *         this.start = start;\n *         this.end = end;\n *         this.max = max\n *         this.left = this.right = null;\n *     }\n * }\n */\npublic class Solution {\n    /**\n     *@param A: a list of integer\n     *@return: The root of Segment Tree\n     */\n    public SegmentTreeNode build(int[] A) {\n        // write your code here\n        return buildTree(0, A.length - 1, A);\n    }\n\n    public SegmentTreeNode buildTree(int start, int end, int[] A) {\n        if (start > end)\n            return null;\n\n        if (start == end) {\n            return new SegmentTreeNode(start, end, A[start]);\n        }\n        SegmentTreeNode node = new SegmentTreeNode(start, end, A[start]);\n        int mid = (start + end) / 2;\n        node.left = this.buildTree(start, mid, A);\n        node.right = this.buildTree(mid + 1, end, A);\n        if (node.left != null && node.left.max > node.max)\n            node.max = node.left.max;\n        if (node.right != null && node.right.max > node.max)\n            node.max = node.right.max;\n        return node;\n    }\n}"},{"language":"cpp","code":"/**\n * Definition of SegmentTreeNode:\n * class SegmentTreeNode {\n * public:\n *     int start, end, max;\n *     SegmentTreeNode *left, *right;\n *     SegmentTreeNode(int start, int end, int max) {\n *         this->start = start;\n *         this->end = end;\n *         this->max = max;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     *@param A: a list of integer\n     *@return: The root of Segment Tree\n     */\n    SegmentTreeNode * build(vector<int>& A) {\n        // write your code here\n        return buildTree(0, A.size()-1, A);\n    }\n\n    SegmentTreeNode * buildTree(int start, int end, vector<int>& A) {\n        if (start > end)\n            return NULL;\n\n        SegmentTreeNode * node = new SegmentTreeNode(start, end, A[start]);\n        if (start == end)\n            return node;\n        int mid = (start + end) / 2;\n        node->left = buildTree(start, mid, A);\n        node->right = buildTree(mid+1, end, A);\n        if (node->left && node->left->max > node->max)\n            node->max = node->left->max;\n        if (node->right && node->right->max > node->max)\n            node->max = node->right->max;\n        return node;\n    }\n};"},{"language":"python","code":"\"\"\"\nDefinition of SegmentTreeNode:\nclass SegmentTreeNode:\n    def __init__(self, start, end, max):\n        self.start, self.end, self.max = start, end, max\n        self.left, self.right = None, None\n\"\"\"\n\nclass Solution:\t\n    # @oaram A: a list of integer\n    # @return: The root of Segment Tree\n    def build(self, A):\n        # write your code here\n        return self.buildTree(0, len(A)-1, A)\n\n    def buildTree(self, start, end, A):\n        if start > end:\n            return None\n\n        node = SegmentTreeNode(start, end, A[start])\n        if start == end:\n            return node\n\n        mid = (start + end) / 2\n        node.left = self.buildTree(start, mid, A)\n        node.right = self.buildTree(mid + 1, end, A)\n        if node.left is not None and node.left.max > node.max:\n            node.max = node.left.max\n        if node.right is not None and node.right.max > node.max:\n            node.max = node.right.max\n        return node\n"}]},{"id":240,"unique_name":"count-of-smaller-number-before-itself","title":"统计前面比自己小的数的个数","description":"给定一个整数数组（下标由 0 到 n-1， n 表示数组的规模，取值范围由 0 到10000）。对于数组中的每个 `ai` 元素，请计算 `ai` 前的数中比它小的元素的数量。","solutions":[{"language":"java","code":"public class Solution {\r\n   /**\r\n     * @param A: An integer array\r\n     * @return: Count the number of element before this element 'ai' is \r\n     *          smaller than it and return count number array\r\n     */ \r\n    class SegmentTreeNode {\r\n        public int start, end;\r\n        public int count;\r\n        public SegmentTreeNode left, right;\r\n        public SegmentTreeNode(int start, int end, int count) {\r\n              this.start = start;\r\n              this.end = end;\r\n              this.count = count;\r\n              this.left = this.right = null;\r\n        }\r\n    }\r\n    SegmentTreeNode root;\r\n    public SegmentTreeNode build(int start, int end) {\r\n        // write your code here\r\n        if(start > end) {  // check core case\r\n            return null;\r\n        }\r\n        \r\n        SegmentTreeNode root = new SegmentTreeNode(start, end, 0);\r\n        \r\n        if(start != end) {\r\n            int mid = (start + end) / 2;\r\n            root.left = build(start, mid);\r\n            root.right = build(mid+1, end);\r\n        } else {\r\n            root.count =  0;\r\n        }\r\n        return root;\r\n    }\r\n    public int querySegmentTree(SegmentTreeNode root, int start, int end) {\r\n        // write your code here\r\n        if(start == root.start && root.end == end) { // 相等 \r\n            return root.count;\r\n        }\r\n        \r\n        \r\n        int mid = (root.start + root.end)/2;\r\n        int leftcount = 0, rightcount = 0;\r\n        // 左子区\r\n        if(start <= mid) {\r\n            if( mid < end) { // 分裂 \r\n                leftcount =  querySegmentTree(root.left, start, mid);\r\n            } else { // 包含 \r\n                leftcount = querySegmentTree(root.left, start, end);\r\n            }\r\n        }\r\n        // 右子区\r\n        if(mid < end) { // 分裂 3\r\n            if(start <= mid) {\r\n                rightcount = querySegmentTree(root.right, mid+1, end);\r\n            } else { //  包含 \r\n                rightcount = querySegmentTree(root.right, start, end);\r\n            } \r\n        }  \r\n        // else 就是不相交\r\n        return leftcount + rightcount;\r\n    }\r\n    public void modifySegmentTree(SegmentTreeNode root, int index, int value) {\r\n        // write your code here\r\n        if(root.start == index && root.end == index) { // 查找到\r\n            root.count += value;\r\n            return;\r\n        }\r\n        \r\n        // 查询\r\n        int mid = (root.start + root.end) / 2;\r\n        if(root.start <= index && index <=mid) {\r\n            modifySegmentTree(root.left, index, value);\r\n        }\r\n        \r\n        if(mid < index && index <= root.end) {\r\n            modifySegmentTree(root.right, index, value);\r\n        }\r\n        //更新\r\n        root.count = root.left.count + root.right.count;\r\n    }\r\n    public ArrayList<Integer> countOfSmallerNumberII(int[] A) {\r\n        // write your code here\r\n        root = build(0, 10000);\r\n        ArrayList<Integer> ans = new ArrayList<Integer>();\r\n        int res;\r\n        for(int i = 0; i < A.length; i++) {\r\n            res = 0;\r\n            if(A[i] > 0) {\r\n                res = querySegmentTree(root, 0, A[i]-1);\r\n            }\r\n            modifySegmentTree(root, A[i], 1);\r\n            ans.add(res);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n   /**\r\n     * @param A: An integer array\r\n     * @return: Count the number of element before this element 'ai' is \r\n     *          smaller than it and return count number array\r\n     */\r\n    int c[20000];\r\n    int lowbit(int x) {\r\n        return x&(-x);    \r\n    }\r\n    int sum(int n) {\r\n        if (n <= 0)\r\n            return 0;\r\n        int sum=0;\r\n        while(n>0) {\r\n            sum += c[n];\r\n            n -= lowbit(n);\r\n        }    \r\n        return sum;\r\n    }\r\n    \r\n    void change(int i,int x, int n) {\r\n        while (i <= n) {\r\n          c[i] += x;\r\n          i += lowbit(i);\r\n        }\r\n    }\r\n    \r\n    vector<int> countOfSmallerNumberII(vector<int> &A) {\r\n        // write your code here\r\n        vector<int> result;\r\n        int len = A.size();\r\n        int maxValue = 10000 + 1;\r\n        for (int i = 0; i < len; ++i) {\r\n            result.push_back(sum(A[i]));\r\n            change(A[i] + 1, 1, maxValue);\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\n\r\n// Segment Tree Version\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param A: An integer array\r\n     * @return: The number of element in the array that\r\n     *          are smaller that the given integer\r\n     */\r\n    class SegmentTreeNode {\r\n        public:\r\n            int start, end, count;\r\n            SegmentTreeNode *left, *right;\r\n            SegmentTreeNode(int start, int end, int count) {\r\n                this->start = start;\r\n                this->end = end;\r\n                this->count = count;\r\n                this->left = this->right = NULL;\r\n        }\r\n    };\r\n    \r\n    vector<int> countOfSmallerNumberII(vector<int> &A) {\r\n        vector<int> result;\r\n        SegmentTreeNode *root = build(0, 10000);\r\n        for (const auto& num : A) {\r\n            result.push_back(query(root, num - 1));\r\n            insert(root, num);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    SegmentTreeNode *build(int start, int end) {\r\n        if (start > end) {\r\n            return nullptr;\r\n        }\r\n        SegmentTreeNode *root = new SegmentTreeNode(start, end, 0);\r\n        if (start == end) {\r\n            root->count = 0;\r\n            return root;\r\n        }\r\n        int mid = start + (end - start) / 2;\r\n        root->left = build(start, mid);\r\n        root->right = build(mid + 1, end);\r\n        return root;\r\n    }\r\n\r\n    int query(SegmentTreeNode *root, int q) {\r\n        if (root == nullptr || root->start > q) {\r\n            return 0;\r\n        }\r\n        if (root->end <= q) {\r\n            return root->count;\r\n        }\r\n        return query(root->left, q) + query(root->right, q);\r\n    }\r\n    \r\n    void insert(SegmentTreeNode *root, int p) {\r\n        if (root == nullptr || root->start == root->end) {\r\n            root->count +=1;\r\n            return;\r\n        }\r\n    \r\n        if (root->left != nullptr && root->left->end >= p) {\r\n            insert(root->left, p);\r\n        }\r\n        \r\n        if (root->right != nullptr && root->right->start <= p) {\r\n            insert(root->right, p);\r\n        }\r\n\r\n        root->count += 1;\r\n    }\r\n};"},{"language":"python","code":"class SegTree:\r\n    \r\n    def __init__(self, start, end):\r\n        self.start = start\r\n        self.end = end\r\n        self.left = None\r\n        self.right = None\r\n        self.count = 0\r\n        if start != end:\r\n            self.left = SegTree(start, (start + end) / 2)\r\n            self.right = SegTree((start + end) / 2 + 1, end)\r\n    \r\n    def sum(self, start, end):\r\n        if start <= self.start and end >= self.end:\r\n            return self.count\r\n        \r\n        if self.start == self.end:\r\n            return 0\r\n        \r\n        if end <= self.left.end:\r\n            return self.left.sum(start, end)\r\n        \r\n        if start >= self.right.start:\r\n            return self.right.sum(start, end)\r\n        \r\n        return (self.left.sum(start, self.left.end) + \r\n                self.right.sum(self.right.start, end))\r\n    \r\n    def inc(self, index):\r\n        if self.start == self.end:\r\n            self.count += 1\r\n            return\r\n        \r\n        if index <= self.left.end:\r\n            self.left.inc(index)\r\n        else:\r\n            self.right.inc(index)\r\n        \r\n        self.count = self.left.count + self.right.count\r\n\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    @param A: A list of integer\r\n    @return: Count the number of element before this element 'ai' is \r\n             smaller than it and return count number list\r\n    \"\"\"\r\n    def countOfSmallerNumberII(self, A):\r\n        if len(A) == 0:\r\n            return []\r\n            \r\n        root = SegTree(0, max(A))\r\n        \r\n        results = []\r\n        for a in A:\r\n            results.append(root.sum(0, a - 1))\r\n            root.inc(a)\r\n        return results\r\n"}]},{"id":210,"unique_name":"count-of-smaller-number","title":"统计比给定整数小的数的个数","description":"给定一个整数数组 （下标由 0 到 n-1，其中 n 表示数组的规模，数值范围由 0 到 10000），以及一个 查询列表。对于每一个查询，将会给你一个整数，请你返回该数组中小于给定整数的元素的数量。","solutions":[{"language":"java","code":"public class Solution {\r\n   /**\r\n     * @param A: An integer array\r\n     * @return: The number of element in the array that \r\n     *          are smaller that the given integer\r\n     */\r\n    class SegmentTreeNode {\r\n        public int start, end;\r\n        public int count;\r\n        public SegmentTreeNode left, right;\r\n        public SegmentTreeNode(int start, int end, int count) {\r\n              this.start = start;\r\n              this.end = end;\r\n              this.count = count;\r\n              this.left = this.right = null;\r\n        }\r\n    }\r\n    SegmentTreeNode root;\r\n    public SegmentTreeNode build(int start, int end) {\r\n        // write your code here\r\n        if(start > end) {  // check core case\r\n            return null;\r\n        }\r\n        \r\n        SegmentTreeNode root = new SegmentTreeNode(start, end, 0);\r\n        \r\n        if(start != end) {\r\n            int mid = (start + end) / 2;\r\n            root.left = build(start, mid);\r\n            root.right = build(mid+1, end);\r\n        } else {\r\n            root.count =  0;\r\n        }\r\n        return root;\r\n    }\r\n    public int querySegmentTree(SegmentTreeNode root, int start, int end) {\r\n        // write your code here\r\n        if(start == root.start && root.end == end) { // 相等 \r\n            return root.count;\r\n        }\r\n        \r\n        \r\n        int mid = (root.start + root.end)/2;\r\n        int leftcount = 0, rightcount = 0;\r\n        // 左子区\r\n        if(start <= mid) {\r\n            if( mid < end) { // 分裂 \r\n                leftcount =  querySegmentTree(root.left, start, mid);\r\n            } else { // 包含 \r\n                leftcount = querySegmentTree(root.left, start, end);\r\n            }\r\n        }\r\n        // 右子区\r\n        if(mid < end) { // 分裂 3\r\n            if(start <= mid) {\r\n                rightcount = querySegmentTree(root.right, mid+1, end);\r\n            } else { //  包含 \r\n                rightcount = querySegmentTree(root.right, start, end);\r\n            } \r\n        }  \r\n        // else 就是不相交\r\n        return leftcount + rightcount;\r\n    }\r\n    public void modifySegmentTree(SegmentTreeNode root, int index, int value) {\r\n        // write your code here\r\n        if(root.start == index && root.end == index) { // 查找到\r\n            root.count += value;\r\n            return;\r\n        }\r\n        \r\n        // 查询\r\n        int mid = (root.start + root.end) / 2;\r\n        if(root.start <= index && index <=mid) {\r\n            modifySegmentTree(root.left, index, value);\r\n        }\r\n        \r\n        if(mid < index && index <= root.end) {\r\n            modifySegmentTree(root.right, index, value);\r\n        }\r\n        //更新\r\n        root.count = root.left.count + root.right.count;\r\n    }\r\n    public ArrayList<Integer> countOfSmallerNumber(int[] A, int[] queries) {\r\n        // write your code here\r\n        root = build(0, 10000);\r\n        ArrayList<Integer> ans = new ArrayList<Integer>();\r\n        int res;\r\n        for(int i = 0; i < A.length; i++) {\r\n            modifySegmentTree(root, A[i], 1);\r\n        }\r\n        for(int i = 0; i < queries.length; i++) {\r\n            res = 0;\r\n            if(queries[i] > 0)\r\n                res = querySegmentTree(root, 0, queries[i] - 1);\r\n            ans.add(res);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"// Binary Search Version\r\nclass Solution {\r\npublic:\r\n   /**\r\n     * @param A: An integer array\r\n     * @return: The number of element in the array that \r\n     *          are smaller that the given integer\r\n     */\r\n    int find(vector<int> &array, int val) {\r\n        int l = 0;\r\n        int r = array.size() - 1;\r\n        int ans = -1;\r\n        while(l <= r) {\r\n            int mid = (l + r) >> 1;\r\n            if(array[mid] < val) {\r\n                l = mid + 1;\r\n                ans = mid;\r\n            }\r\n            else\r\n                r = mid - 1;\r\n        }\r\n        return ans + 1;\r\n    }\r\n    \r\n    vector<int> countOfSmallerNumber(vector<int> &A, vector<int> &queries) {\r\n        // write your code here\r\n        vector<int> result;\r\n        sort(A.begin(), A.end());\r\n        int qlen = queries.size();\r\n        for(int i = 0; i < qlen; ++i)\r\n            result.push_back(find(A, queries[i]));\r\n        \r\n        return result;\r\n    }\r\n};\r\n\r\n\r\n// Segment Tree Version\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param A: An integer array\r\n     * @return: The number of element in the array that\r\n     *          are smaller that the given integer\r\n     */\r\n    class SegmentTreeNode {\r\n        public:\r\n            int start, end, count;\r\n            SegmentTreeNode *left, *right;\r\n            SegmentTreeNode(int start, int end, int count) {\r\n                this->start = start;\r\n                this->end = end;\r\n                this->count = count;\r\n                this->left = this->right = NULL;\r\n        }\r\n    };\r\n    \r\n    vector<int> countOfSmallerNumber(vector<int> &A, vector<int> &queries) {\r\n        vector<int> result;\r\n        SegmentTreeNode *root = build(0, 10000);\r\n        for (const auto& num : A) {\r\n            insert(root, num);\r\n        }\r\n        for (const auto& q : queries) {\r\n            result.push_back(query(root, q - 1));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    SegmentTreeNode *build(int start, int end) {\r\n        if (start > end) {\r\n            return nullptr;\r\n        }\r\n        SegmentTreeNode *root = new SegmentTreeNode(start, end, 0);\r\n        if (start == end) {\r\n            root->count = 0;\r\n            return root;\r\n        }\r\n        int mid = start + (end - start) / 2;\r\n        root->left = build(start, mid);\r\n        root->right = build(mid + 1, end);\r\n        return root;\r\n    }\r\n\r\n    int query(SegmentTreeNode *root, int q) {\r\n        if (root == nullptr || root->start > q) {\r\n            return 0;\r\n        }\r\n        if (root->end <= q) {\r\n            return root->count;\r\n        }\r\n        return query(root->left, q) + query(root->right, q);\r\n    }\r\n    \r\n    void insert(SegmentTreeNode *root, int p) {\r\n        if (root == nullptr || root->start == root->end) {\r\n            root->count +=1;\r\n            return;\r\n        }\r\n    \r\n        if (root->left != nullptr && root->left->end >= p) {\r\n            insert(root->left, p);\r\n        }\r\n        \r\n        if (root->right != nullptr && root->right->start <= p) {\r\n            insert(root->right, p);\r\n        }\r\n\r\n        root->count += 1;\r\n    }\r\n};\r\n\r\n"},{"language":"python","code":"// Binary search version\r\nclass Solution:\r\n    \"\"\"\r\n    @param A: A list of integer\r\n    @return: The number of element in the array that \r\n             are smaller that the given integer\r\n    \"\"\"\r\n    def countOfSmallerNumber(self, A, queries):\r\n        A = sorted(A)\r\n        \r\n        results = []\r\n        for q in queries:\r\n            results.append(self.countSmaller(A, q))\r\n        return results\r\n\r\n    def countSmaller(self, A, q):\r\n        # find the first number in A >= q\r\n        if len(A) == 0 or A[-1] < q:\r\n            return len(A)\r\n            \r\n        start, end = 0, len(A) - 1\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            if A[mid] < q:\r\n                start = mid\r\n            else:\r\n                end = mid\r\n        if A[start] >= q:\r\n            return start\r\n        if A[end] >= q:\r\n            return end\r\n        return end + 1\r\n\r\n// Segment Tree Version\r\nclass Solution:\r\n    class SegmentTreeNode:\r\n        def __init__(self, start, end, count):\r\n            self.start, self.end, self.count = start, end, count\r\n            self.left, self.right = None, None\r\n        \r\n    \"\"\"\r\n    @param A: A list of integer\r\n    @return: The number of element in the array that \r\n             are smaller that the given integer\r\n    \"\"\"\r\n    def countOfSmallerNumber(self, A, queries):\r\n        # write your code here\r\n        \r\n        # build segmeng tree\r\n        root = self.build(0, 10000)\r\n        result = []\r\n        \r\n        # modify count value for each\r\n        for num in A:\r\n            self.modify(root, num, 1)\r\n        \r\n        for i in queries:\r\n            count = 0\r\n            if i > 0:\r\n                count = self.query(root, 0, i - 1)\r\n            result.append(count)\r\n        \r\n        return result\r\n    \r\n    def build(self, start, end):\r\n        if start >= end:\r\n            return SegmentTreeNode(start, end, 0)\r\n        root = SegmentTreeNode(start, end, 0)\r\n        mid = start + (end - start) / 2\r\n        root.left = self.build(start, mid)\r\n        root.right = self.build(mid + 1, end)\r\n        return root\r\n    \r\n    def modify(self, root, index, value):\r\n        if root.start == index and root.end == index:\r\n            root.count += value\r\n            return\r\n        # query\r\n        mid = root.start + (root.end - root.start) / 2\r\n        if index <= mid:\r\n            self.modify(root.left, index, value)\r\n        \r\n        if mid < index:\r\n            self.modify(root.right, index, value)\r\n        root.count = root.left.count + root.right.count\r\n    \r\n    def query(self, root, start, end):\r\n        if start == root.start and end == root.end:\r\n            return root.count\r\n        \r\n        mid = root.start + (root.end - root.start) / 2\r\n        if end <= mid:\r\n            return self.query(root.left, start, end)\r\n        \r\n        if start > mid:\r\n            return self.query(root.right, start, end)\r\n            \r\n        return self.query(root.left, start, mid) + \\\r\n            self.query(root.right, mid + 1, end)"}]},{"id":239,"unique_name":"segment-tree-query-ii","title":"线段树查询 II","description":"对于一个数组，我们可以对其建立一棵 `线段树`, 每个结点存储一个额外的值 `count` 来代表这个结点所指代的数组区间内的元素个数. (数组中并不一定每个位置上都有元素)\r\n\r\n实现一个 `query` 的方法，该方法接受三个参数 `root`, `start` 和 `end`, 分别代表线段树的根节点和需要查询的区间，找到数组中在区间[*start*, *end*]内的元素个数。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     *@param root, start, end: The root of segment tree and \r\n     *                         an segment / interval\r\n     *@return: The count number in the interval [start, end]\r\n     */\r\n    public int query(SegmentTreeNode root, int start, int end) {\r\n        // write your code here\r\n        if(start > end || root==null)\r\n            return 0;\r\n        if(start <= root.start && root.end <= end) { // 相等 \r\n            return root.count;\r\n        }\r\n        \r\n        int mid = (root.start + root.end)/2;\r\n        int leftsum = 0, rightsum = 0;\r\n        // 左子区\r\n        if(start <= mid) {\r\n            if( mid < end) { // 分裂 \r\n                leftsum =  query(root.left, start, mid);\r\n            } else { // 包含 \r\n                leftsum = query(root.left, start, end);\r\n            }\r\n        }\r\n        // 右子区\r\n        if(mid < end) { // 分裂 3\r\n            if(start <= mid) {\r\n                rightsum = query(root.right, mid+1, end);\r\n            } else { //  包含 \r\n                rightsum = query(root.right, start, end);\r\n            } \r\n        }  \r\n        // else 就是不相交\r\n        return leftsum + rightsum;\r\n    }\r\n}"},{"language":"cpp","code":"/**\n * Definition of SegmentTreeNode:\n * class SegmentTreeNode {\n * public:\n *     int start, end, count;\n *     SegmentTreeNode *left, *right;\n *     SegmentTreeNode(int start, int end, int count) {\n *         this->start = start;\n *         this->end = end;\n *         this->count = count;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     *@param root, start, end: The root of segment tree and \n     *                         an segment / interval\n     *@return: The count number in the interval [start, end] \n     */\n    int query(SegmentTreeNode *root, int start, int end) {\n        // write your code here\n        if (root == NULL)\n            return 0;\n\n        if (root->end < start || root->start > end)\n            return 0;\n  \n        if (root->start >= start && root->end <= end)\n            return root->count;\n\n        return query(root->left, start, end) + query(root->right, start, end);\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of SegmentTreeNode:\nclass SegmentTreeNode:\n    def __init__(self, start, end, count):\n        this.start, this.end, this.count = start, end, count\n        this.left, this.right = None, None\n\"\"\"\n\nclass Solution:\t\n    # @param root, start, end: The root of segment tree and \n    #                          an segment / interval\n    # @return: The count number in the interval [start, end] \n    def query(self, root, start, end):\n        # write your code here\n        if root is None:\n            return 0\n\n        if root.start > end or root.end < start:\n            return 0\n    \n        if start <= root.start and root.end <= end:\n            return root.count\n        \n        return self.query(root.left, start, end) + \\\n                   self.query(root.right, start, end)"}]},{"id":238,"unique_name":"interval-sum-ii","title":"区间求和 II","description":"在类的构造函数中给一个整数数组, 实现两个方法 `query(start, end)` 和 `modify(index, value)`:\r\n\r\n- 对于 query(*start*, *end*), 返回数组中下标 *start* 到 *end* 的 **和**。\r\n- 对于 modify(*index*, *value*), 修改数组中下标为 *index* 上的数为 *value*.","solutions":[{"language":"java","code":"public class Solution {\r\n    /* you may need to use some attributes here */\r\n    \r\n     class SegmentTreeNode {\r\n        public int start, end;\r\n        public int sum;\r\n        public SegmentTreeNode left, right;\r\n        public SegmentTreeNode(int start, int end, int sum) {\r\n              this.start = start;\r\n              this.end = end;\r\n              this.sum = sum;\r\n              this.left = this.right = null;\r\n        }\r\n    }\r\n    SegmentTreeNode root;\r\n    public SegmentTreeNode build(int start, int end, int[] A) {\r\n        // write your code here\r\n        if(start > end) {  // check core case\r\n            return null;\r\n        }\r\n        \r\n        SegmentTreeNode root = new SegmentTreeNode(start, end, 0);\r\n        \r\n        if(start != end) {\r\n            int mid = (start + end) / 2;\r\n            root.left = build(start, mid, A);\r\n            root.right = build(mid+1, end, A);\r\n            \r\n            root.sum = root.left.sum + root.right.sum;\r\n        } else {\r\n            root.sum =  A[start];\r\n            \r\n        }\r\n        return root;\r\n    }\r\n    public int querySegmentTree(SegmentTreeNode root, int start, int end) {\r\n        // write your code here\r\n        if(start == root.start && root.end == end) { // 相等 \r\n            return root.sum;\r\n        }\r\n        \r\n        \r\n        int mid = (root.start + root.end)/2;\r\n        int leftsum = 0, rightsum = 0;\r\n        // 左子区\r\n        if(start <= mid) {\r\n            if( mid < end) { // 分裂 \r\n                leftsum =  querySegmentTree(root.left, start, mid);\r\n            } else { // 包含 \r\n                leftsum = querySegmentTree(root.left, start, end);\r\n            }\r\n        }\r\n        // 右子区\r\n        if(mid < end) { // 分裂 3\r\n            if(start <= mid) {\r\n                rightsum = querySegmentTree(root.right, mid+1, end);\r\n            } else { //  包含 \r\n                rightsum = querySegmentTree(root.right, start, end);\r\n            } \r\n        }  \r\n        // else 就是不相交\r\n        return leftsum + rightsum;\r\n    }\r\n    public void modifySegmentTree(SegmentTreeNode root, int index, int value) {\r\n        // write your code here\r\n        if(root.start == index && root.end == index) { // 查找到\r\n            root.sum = value;\r\n            return;\r\n        }\r\n        \r\n        // 查询\r\n        int mid = (root.start + root.end) / 2;\r\n        if(root.start <= index && index <=mid) {\r\n            modifySegmentTree(root.left, index, value);\r\n        }\r\n        \r\n        if(mid < index && index <= root.end) {\r\n            modifySegmentTree(root.right, index, value);\r\n        }\r\n        //更新\r\n        root.sum = root.left.sum + root.right.sum;\r\n    }\r\n    /**\r\n     * @param A: An integer array\r\n     */\r\n    public Solution(int[] A) {\r\n        // write your code here\r\n        root = build(0, A.length-1, A);\r\n    }\r\n    \r\n    /**\r\n     * @param start, end: Indices\r\n     * @return: The sum from start to end\r\n     */\r\n    public long query(int start, int end) {\r\n        // write your code here\r\n        return querySegmentTree(root, start ,end);\r\n    }\r\n    \r\n    /**\r\n     * @param index, value: modify A[index] to value.\r\n     */\r\n    public void modify(int index, int value) {\r\n        // write your code here\r\n        modifySegmentTree(root, index, value);\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"class SegmentTree{\npublic:\n    int start, end;\n    long long sum;\n    SegmentTree* left, *right;\n    SegmentTree(int start, int end, long long sum = 0): start(start),end(end),sum(sum){};\n    \n    static SegmentTree* build(int start, int end, vector<int> &A) {\n        if (start > end) return nullptr;\n        SegmentTree* head = new SegmentTree(start, end, A[start]);\n        if (start == end) return head;\n        int mid = (start + end) /2;\n        head->left = build(start, mid, A);\n        head->right = build(mid+1, end, A);\n        \n        head->sum = 0;\n        if (head->left)\n            head->sum += head->left->sum;\n        if (head->right)\n            head->sum += head->right->sum;\n        return head;\n    }\n    \n    static long long query(SegmentTree* head, int start, int end) {\n        if (start > head->end || end < head->start) return 0;\n        if (start <= head->start && end >= head->end) {\n            return head->sum;\n        }\n        int l = query(head->left, start, end);\n        int r = query(head->right, start, end);\n        return l + r;\n    }\n    \n    static void modify(SegmentTree* head, int index, int value) {\n        if (head->start == head->end) {\n            head->sum = value;\n            return;\n        }\n        int mid = (head->start + head->end) /2;\n        if (index > mid) {\n            modify(head->right, index, value);\n        }\n        else if(index <= mid) {\n            modify(head->left, index, value);\n        }\n        \n        head->sum = 0;\n        if (head->left)\n            head->sum += head->left->sum;\n        if (head->right)\n            head->sum += head->right->sum;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    /* you may need to use some attributes here */\n    SegmentTree* head;\n\n    /**\n     * @param A: An integer vector\n     */\n    Solution(vector<int> A) {\n        // write your code here\n        head = SegmentTree:: build(0, A.size()-1, A);\n    }\n    \n    /**\n     * @param start, end: Indices\n     * @return: The sum from start to end\n     */\n    long long query(int start, int end) {\n        // write your code here\n        long long res = SegmentTree::query(head, start, end);\n        return res;\n    }\n    \n    /**\n     * @param index, value: modify A[index] to value.\n     */\n    void modify(int index, int value) {\n        // write your code here\n        SegmentTree::modify(head, index, value);\n    }\n};"},{"language":"python","code":"class SegmentTree(object):\r\n\r\n    def __init__(self, start, end, sum=0):\r\n        self.start = start\r\n        self.end = end\r\n        self.sum = sum\r\n        self.left, self.right = None, None \r\n\r\n    @classmethod\r\n    def build(cls, start, end, a):\r\n        if start > end:\r\n            return None\r\n\t\t\r\n        if start == end:\r\n            return SegmentTree(start, end, a[start])\r\n\r\n        node = SegmentTree(start, end, a[start])\r\n\r\n        mid = (start + end) / 2\r\n        node.left = cls.build(start, mid, a)\r\n        node.right = cls.build(mid + 1, end, a)\r\n        node.sum = node.left.sum + node.right.sum\r\n        return node\r\n\r\n    @classmethod\r\n    def modify(cls, root, index, value):\r\n        if root is None:\r\n            return\r\n\r\n        if root.start == root.end:\r\n            root.sum = value\r\n            return\r\n    \r\n        if root.left.end >= index:\r\n            cls.modify(root.left, index, value)\r\n        else:\r\n            cls.modify(root.right, index, value)\r\n        \r\n        root.sum = root.left.sum + root.right.sum\r\n\r\n    @classmethod\r\n    def query(cls, root, start, end):\r\n        if root.start > end or root.end < start:\r\n            return 0\r\n    \r\n        if start <= root.start and root.end <= end:\r\n            return root.sum\r\n        \r\n        return cls.query(root.left, start, end) +  \\\r\n               cls.query(root.right, start, end)\r\n\r\n\r\nclass Solution:\t\r\n    # @param A: An integer list\r\n    def __init__(self, A):\r\n        # write your code here\r\n        self.root = SegmentTree.build(0, len(A)-1, A)\r\n    \r\n\r\n    # @param start, end: Indices\r\n    # @return: The sum from start to end\r\n    def query(self, start, end):\r\n        # write your code here\r\n        return SegmentTree.query(self.root, start, end)\r\n    \r\n\r\n    # @param index, value: modify A[index] to value.\r\n    def modify(self, index, value):\r\n        # write your code here\r\n        SegmentTree.modify(self.root, index, value)"}]},{"id":237,"unique_name":"interval-sum","title":"区间求和  I","description":"给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 `[start, end]` 。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的总和，并返回在结果列表中。 ","solutions":[{"language":"java","code":"/**\n * Definition of Interval:\n * public classs Interval {\n *     int start, end;\n *     Interval(int start, int end) {\n *         this.start = start;\n *         this.end = end;\n *     }\n */\npublic class Solution {\n    /**\n     *@param A, queries: Given an integer array and an query list\n     *@return: The result list\n     */\n     class SegmentTreeNode {\n        public int start, end;\n        public Long sum;\n        public SegmentTreeNode left, right;\n        public SegmentTreeNode(int start, int end, Long sum) {\n              this.start = start;\n              this.end = end;\n              this.sum = sum;\n              this.left = this.right = null;\n        }\n    }\n    public SegmentTreeNode build(int start, int end, int[] A) {\n        // write your code here\n        if(start > end) {  // check core case\n            return null;\n        }\n        \n        SegmentTreeNode root = new SegmentTreeNode(start, end, 0L);\n        \n        if(start != end) {\n            int mid = (start + end) / 2;\n            root.left = build(start, mid, A);\n            root.right = build(mid+1, end, A);\n            \n            root.sum = root.left.sum + root.right.sum;\n        } else {\n            root.sum =  Long.valueOf(A[start]);\n            \n        }\n        return root;\n    }\n    public Long query(SegmentTreeNode root, int start, int end) {\n        // write your code here\n        if(start == root.start && root.end == end) { // 相等 \n            return root.sum;\n        }\n        \n        \n        int mid = (root.start + root.end)/2;\n        Long leftsum = 0L, rightsum = 0L;\n        // 左子区\n        if(start <= mid) {\n            if( mid < end) { // 分裂 \n                leftsum =  query(root.left, start, mid);\n            } else { // 包含 \n                leftsum = query(root.left, start, end);\n            }\n        }\n        // 右子区\n        if(mid < end) { // 分裂 3\n            if(start <= mid) {\n                rightsum = query(root.right, mid+1, end);\n            } else { //  包含 \n                rightsum = query(root.right, start, end);\n            } \n        }  \n        // else 就是不相交\n        return leftsum + rightsum;\n    }\n    public ArrayList<Long> intervalSum(int[] A, \n                                       ArrayList<Interval> queries) {\n        // write your code here\n        SegmentTreeNode root = build(0, A.length - 1, A);\n        ArrayList ans = new ArrayList<Long>();\n        for(Interval in : queries) {\n            ans.add(query(root, in.start, in.end));\n        }\n        return ans;\n    }\n}\n\n\n *     Interval(int start, int end) {\n *         this.start = start;\n *         this.end = end;\n *     }\n */\n\npublic class Solution {\n    /**\n     *@param A, queries: Given an integer array and an query list\n     *@return: The result list\n     */\n    public class SegmentTreeNode {\n        public int start, end, min;\n        public SegmentTreeNode left, right;\n        public SegmentTreeNode(int start, int end, int min) {\n              this.start = start;\n              this.end = end;\n              this.min = min;\n              this.left = this.right = null;\n        }\n    }\n    public SegmentTreeNode build(int start, int end, int[] A) {\n        // write your code here\n        if(start > end) {  // check core case\n            return null;\n        }\n       \n        SegmentTreeNode root = new SegmentTreeNode(start, end, Integer.MAX_VALUE);\n       \n        if(start != end) {\n            int mid = (start + end) / 2;\n            root.left = build(start, mid, A);\n            root.right = build(mid+1, end, A);\n           \n            root.min = Math.min(root.left.min, root.right.min);\n        } else {\n            root.min = A[start];\n        }\n        return root;\n    }\n    public int query(SegmentTreeNode root, int start, int end) {\n        // write your code here\n        if(start == root.start && root.end == end) { // equal\n            return root.min;\n        }\n       \n       \n        int mid = (root.start + root.end)/2;\n        int leftmin = Integer.MAX_VALUE, rightmin = Integer.MAX_VALUE;\n        // left\n        if(start <= mid) {\n            if( mid < end) { // split\n                leftmin =  query(root.left, start, mid);\n            } else { //  contain\n                leftmin = query(root.left, start, end);\n            }\n        }\n        // right\n        if(mid < end) { // split\n            if(start <= mid) {\n                rightmin = query(root.right, mid+1, end);\n            } else { //  contain\n                rightmin = query(root.right, start, end);\n            }\n        }\n        return Math.min(leftmin, rightmin);\n    }\n   \n    public List<Integer> intervalMinNumber(int[] A,\n                                           List<Interval> queries) {\n        // write your code here\n        SegmentTreeNode root = build(0, A.length - 1, A);\n        List<Integer> ans = new ArrayList<Integer>();\n        for(Interval in : queries) {\n            ans.add(query(root, in.start, in.end));\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"/**\n * Definition of Interval:\n * classs Interval {\n *     int start, end;\n *     Interval(int start, int end) {\n *         this->start = start;\n *         this->end = end;\n *     }\n */\nclass SegmentTree {\npublic:\n    SegmentTree *left, *right;\n    int start, end;\n    long long sum;\n    SegmentTree(int start, int end, int sum=0): left(NULL), right(NULL), start(start), end(end), sum(sum) {};\n    \n    static SegmentTree *build(int start, int end, vector<int> &a) {\n        if (start > end)\n            return NULL;\n\n        SegmentTree * node = new SegmentTree(start, end, a[start]);\n        if (start == end) \n            return node;\n\n        int mid = (start + end) / 2;\n        node->left = build(start, mid, a);\n        node->right = build(mid+1, end, a);\n        node->sum = node->left->sum + node->right->sum;\n\n        return node;\n    }\n\n    static long long query(SegmentTree *root, int start, int end) {\n        if (start <= root->start &&  root->end <= end) {\n            return root->sum;\n        }\n        \n        if (root->left->end >= end) {\n            return query(root->left, start, end);\n        }\n        if (root->right->start <= start) {\n            return query(root->right, start, end);\n        }\n        \n        long long leftsum = query(root->left, start, root->left->end);\n        long long rightsum = query(root->right, root->right->start, end);\n        return leftsum + rightsum;\n    }\n};\n\n\nclass Solution { \npublic:\n    /**\n     *@param A, queries: Given an integer array and an query list\n     *@return: The result list\n     */\n    vector<long long> intervalSum(vector<int> &A, vector<Interval> &queries) {\n        // write your code here\n        SegmentTree * root = SegmentTree::build(0, A.size()-1, A);\n        vector<long long> result;\n\n        int len = queries.size();\n        for (int i = 0; i < len; ++i)\n            result.push_back(SegmentTree::query(root, queries[i].start, queries[i].end));\n\n        return result;\n    }\n};"},{"language":"python","code":"\"\"\"\nDefinition of Interval.\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass SegmentTree(object):\n\n    def __init__(self, start, end, sum=0):\n        self.start = start\n        self.end = end\n        self.sum = sum\n        self.left, self.right = None, None \n\n    @classmethod\n    def build(cls, start, end, a):\n        if start > end:\n            return None\n\t\t\n        if start == end:\n            return SegmentTree(start, end, a[start])\n\n        node = SegmentTree(start, end, a[start])\n\n        mid = (start + end) / 2\n        node.left = cls.build(start, mid, a)\n        node.right = cls.build(mid + 1, end, a)\n        node.sum = node.left.sum + node.right.sum\n        return node\n\n    @classmethod\n    def query(self, root, start, end):\n        if root.start > end or root.end < start:\n            return 0\n    \n        if start <= root.start and root.end <= end:\n            return root.sum\n        \n        return self.query(root.left, start, end) +  \\\n               self.query(root.right, start, end)\n\n\nclass Solution:\t\n    \"\"\"\n    @param A, queries: Given an integer array and an Interval list\n                       The ith query is [queries[i-1].start, queries[i-1].end]\n    @return: The result list\n    \"\"\"\n    def intervalSum(self, A, queries):\n        # write your code here\n        root = SegmentTree.build(0, len(A)-1, A)\n        result = []\n        for query in queries:\n            result.append(SegmentTree.query(root, query.start, query.end))\n\n        return result"}]},{"id":222,"unique_name":"interval-minimum-number","title":"区间最小数","description":"给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 `[start, end]`。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的最小值，并返回在结果列表中。 ","solutions":[{"language":"java","code":"/**\n * Definition of Interval:\n * public classs Interval {\n *     int start, end;\n *     Interval(int start, int end) {\n *         this.start = start;\n *         this.end = end;\n *     }\n */\nclass SegmentTreeNode {\n    public int start, end, min;\n    public SegmentTreeNode left, right;\n    public SegmentTreeNode(int start, int end, int min) {\n          this.start = start;\n          this.end = end;\n          this.min = min;\n          this.left = this.right = null;\n    }\n}\npublic class Solution {\n    /**\n     *@param A, queries: Given an integer array and an query list\n     *@return: The result list\n     */\n    public SegmentTreeNode build(int start, int end, int[] A) {\n        // write your code here\n        if(start > end) {  // check core case\n            return null;\n        }\n        \n        SegmentTreeNode root = new SegmentTreeNode(start, end, Integer.MAX_VALUE);\n        \n        if(start != end) {\n            int mid = (start + end) / 2;\n            root.left = build(start, mid, A);\n            root.right = build(mid+1, end, A);\n            \n            root.min = Math.min(root.left.min, root.right.min);\n        } else {\n            root.min = A[start];\n        }\n        return root;\n    }\n    public int query(SegmentTreeNode root, int start, int end) {\n        // write your code here\n        if(start == root.start && root.end == end) { // 相等 \n            return root.min;\n        }\n        \n        \n        int mid = (root.start + root.end)/2;\n        int leftmin = Integer.MAX_VALUE, rightmin = Integer.MAX_VALUE;\n        // 左子区\n        if(start <= mid) {\n            if( mid < end) { // 分裂 \n                leftmin =  query(root.left, start, mid);\n            } else { // 包含 \n                leftmin = query(root.left, start, end);\n            }\n        }\n        // 右子区\n        if(mid < end) { // 分裂 3\n            if(start <= mid) {\n                rightmin = query(root.right, mid+1, end);\n            } else { //  包含 \n                rightmin = query(root.right, start, end);\n            } \n        }  \n        // else 就是不相交\n        return Math.min(leftmin, rightmin);\n    }\n    \n    public List<Integer> intervalMinNumber(int[] A, \n                                           List<Interval> queries) {\n        // write your code here\n        SegmentTreeNode root = build(0, A.length - 1, A);\n        List<Integer> ans = new ArrayList<Integer>();\n        for(Interval in : queries) {\n            ans.add(query(root, in.start, in.end));\n        }\n        return ans;\n    }\n}"},{"language":"cpp","code":"/**\r\n * Definition of Interval:\r\n * classs Interval {\r\n *     int start, end;\r\n *     Interval(int start, int end) {\r\n *         this->start = start;\r\n *         this->end = end;\r\n *     }\r\n */\r\nclass SegmentTree {\r\npublic:\r\n    SegmentTree *left, *right;\r\n    int start, end, min;\r\n    SegmentTree(int start, int end, int min=0): left(NULL), right(NULL), start(start), end(end), min(min) {};\r\n    \r\n    static SegmentTree *build(int start, int end, vector<int> &a) {\r\n        if (start > end)\r\n            return NULL;\r\n\r\n        SegmentTree * node = new SegmentTree(start, end, a[start]);\r\n        if (start == end) \r\n            return node;\r\n\r\n        int mid = (start + end) / 2;\r\n        node->left = build(start, mid, a);\r\n        node->right = build(mid+1, end, a);\r\n        node->min = node->left->min < node->right->min ? \r\n                node->left->min:node->right->min;\r\n\r\n        return node;\r\n    }\r\n\r\n    static int query(SegmentTree *root, int start, int end) {\r\n        if (start <= root->start &&  root->end <= end) {\r\n            return root->min;\r\n        }\r\n        \r\n        if (root->left->end >= end) {\r\n            return query(root->left, start, end);\r\n        }\r\n        if (root->right->start <= start) {\r\n            return query(root->right, start, end);\r\n        }\r\n        \r\n        int leftmin = query(root->left, start, root->left->end);\r\n        int rightmin = query(root->right, root->right->start, end);\r\n        return leftmin < rightmin ? leftmin : rightmin;\r\n    }\r\n};\r\n\r\n\r\nclass Solution { \r\npublic:\r\n    /**\r\n     *@param A, queries: Given an integer array and an query list\r\n     *@return: The result list\r\n     */\r\n    vector<int> intervalMinNumber(vector<int> &A, vector<Interval> &queries) {\r\n        // write your code here\r\n        SegmentTree * root = SegmentTree::build(0, A.size()-1, A);\r\n        vector<int> result;\r\n\r\n        int len = queries.size();\r\n        for (int i = 0; i < len; ++i)\r\n            result.push_back(SegmentTree::query(root, queries[i].start, queries[i].end));\r\n\r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of Interval.\r\nclass Interval(object):\r\n    def __init__(self, start, end):\r\n        self.start = start\r\n        self.end = end\r\n\"\"\"\r\n\r\nclass SegmentTree(object):\r\n\r\n    def __init__(self, start, end, min=0):\r\n        self.start = start\r\n        self.end = end\r\n        self.min = min\r\n        self.left, self.right = None, None \r\n\r\n    @classmethod\r\n    def build(cls, start, end, a):\r\n        if start > end:\r\n            return None\r\n\t\t\r\n        if start == end:\r\n            return SegmentTree(start, end, a[start])\r\n\r\n        node = SegmentTree(start, end, a[start])\r\n\r\n        mid = (start + end) / 2\r\n        node.left = cls.build(start, mid, a)\r\n        node.right = cls.build(mid + 1, end, a)\r\n        node.min = min(node.left.min, node.right.min)\r\n        return node\r\n\r\n    @classmethod\r\n    def query(self, root, start, end):\r\n        if root.start > end or root.end < start:\r\n            return 0x7fffff\r\n    \r\n        if start <= root.start and root.end <= end:\r\n            return root.min\r\n        \r\n        return min(self.query(root.left, start, end), \\\r\n                   self.query(root.right, start, end))\r\n\r\n\r\nclass Solution:\t\r\n    \"\"\"\r\n    @param A, queries: Given an integer array and an Interval list\r\n                       The ith query is [queries[i-1].start, queries[i-1].end]\r\n    @return: The result list\r\n    \"\"\"\r\n    def intervalMinNumber(self, A, queries):\r\n        # write your code here\r\n        root = SegmentTree.build(0, len(A)-1, A)\r\n        result = []\r\n        for query in queries:\r\n            result.append(SegmentTree.query(root, query.start, query.end))\r\n\r\n        return result"}]},{"id":227,"unique_name":"segment-tree-modify","title":"线段树的修改","description":"对于一棵 **最大线段树**, 每个节点包含一个额外的 `max` 属性，用于存储该节点所代表区间的最大值。\n\n设计一个 `modify` 的方法，接受三个参数 `root`、 `index` 和 `value`。该方法将 _root_ 为根的线段树中 [_start_, _end_] = [_index_, _index_] 的节点修改为了新的 _value_ ，并确保在修改后，线段树的每个节点的 _max_ 属性仍然具有正确的值。","solutions":[{"language":"java","code":"/**\r\n * Definition of SegmentTreeNode:\r\n * public class SegmentTreeNode {\r\n *     public int start, end, max;\r\n *     public SegmentTreeNode left, right;\r\n *     public SegmentTreeNode(int start, int end, int max) {\r\n *         this.start = start;\r\n *         this.end = end;\r\n *         this.max = max\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     *@param root, index, value: The root of segment tree and \r\n     *@ change the node's value with [index, index] to the new given value\r\n     *@return: void\r\n     */\r\n    public void modify(SegmentTreeNode root, int index, int value) {\r\n        // write your code here\r\n        if(root.start == index && root.end == index) { // 查找到\r\n            root.max = value;\r\n            return;\r\n        }\r\n        \r\n        // 查询\r\n        int mid = (root.start + root.end) / 2;\r\n        if(root.start <= index && index <=mid) {\r\n            modify(root.left, index, value);\r\n        }\r\n        \r\n        if(mid < index && index <= root.end) {\r\n            modify(root.right, index, value);\r\n        }\r\n        //更新\r\n        root.max = Math.max(root.left.max, root.right.max);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of SegmentTreeNode:\n * class SegmentTreeNode {\n * public:\n *     int start, end, max;\n *     SegmentTreeNode *left, *right;\n *     SegmentTreeNode(int start, int end, int max) {\n *         this->start = start;\n *         this->end = end;\n *         this->max = max;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     *@param root, index, value: The root of segment tree and \n     *@ change the node's value with [index, index] to the new given value\n     *@return: void\n     */\n    void modify(SegmentTreeNode *root, int index, int value) {\n        // write your code here\n        if (root==NULL)\n            return;\n\n        if (root->start==root->end) {\n            root->max = value;\n            return;\n        }\n\n        if (index <= root->left->end)\n            modify(root->left, index, value);\n        else\n            modify(root->right, index, value);\n        \n        root->max = root->left->max > root->right->max ?\n                    root->left->max : root->right->max;\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of SegmentTreeNode:\nclass SegmentTreeNode:\n    def __init__(self, start, end, max):\n        this.start, this.end, this.max = start, end, max\n        this.left, this.right = None, None\n\"\"\"\n\nclass Solution:\t\n    \"\"\"\n    @param root, index, value: The root of segment tree and \n    @ change the node's value with [index, index] to the new given value\n    @return: nothing\n    \"\"\"\n    def modify(self, root, index, value):\n        # write your code here\n        if root is None:\n            return\n\n        if root.start == root.end:\n            root.max = value\n            return\n    \n        if root.left.end >= index:\n            self.modify(root.left, index, value)\n        else:\n            self.modify(root.right, index, value)\n        \n        root.max = max(root.left.max, root.right.max)\n"}]},{"id":226,"unique_name":"segment-tree-query","title":"线段树的查询","description":"对于一个有n个数的整数数组，在对应的线段树中, 根节点所代表的区间为0-n-1, 每个节点有一个额外的属性`max`，值为该节点所代表的数组区间start到end内的最大值。\r\n\r\n为SegmentTree设计一个 `query` 的方法，接受3个参数`root`, `start`和`end`，线段树root所代表的数组中子区间[start, end]内的最大值。","solutions":[{"language":"java","code":"/**\r\n * Definition of SegmentTreeNode:\r\n * public class SegmentTreeNode {\r\n *     public int start, end, max;\r\n *     public SegmentTreeNode left, right;\r\n *     public SegmentTreeNode(int start, int end, int max) {\r\n *         this.start = start;\r\n *         this.end = end;\r\n *         this.max = max\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     *@param root, start, end: The root of segment tree and \r\n     *                         an segment / interval\r\n     *@return: The maximum number in the interval [start, end]\r\n     */\r\n    public int query(SegmentTreeNode root, int start, int end) {\r\n        // write your code here\r\n        if(start == root.start && root.end == end) { // 相等 \r\n            return root.max;\r\n        }\r\n        \r\n        \r\n        int mid = (root.start + root.end)/2;\r\n        int leftmax = Integer.MIN_VALUE, rightmax = Integer.MIN_VALUE;\r\n        // 左子区\r\n        if(start <= mid) {\r\n            if( mid < end) { // 分裂 \r\n                leftmax =  query(root.left, start, mid);\r\n            } else { // 包含 \r\n                leftmax = query(root.left, start, end);\r\n            }\r\n            // leftmax = query(root.left, start, Math.min(mid,end));\r\n        }\r\n        // 右子区\r\n        if(mid < end) { // 分裂 3\r\n            if(start <= mid) {\r\n                rightmax = query(root.right, mid+1, end);\r\n            } else { //  包含 \r\n                rightmax = query(root.right, start, end);\r\n            }\r\n            //rightmax = query(root.right, Math.max(mid+1,start), end);\r\n        }  \r\n        // else 就是不相交\r\n        return Math.max(leftmax, rightmax);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of SegmentTreeNode:\n * class SegmentTreeNode {\n * public:\n *     int start, end, max;\n *     SegmentTreeNode *left, *right;\n *     SegmentTreeNode(int start, int end, int max) {\n *         this->start = start;\n *         this->end = end;\n *         this->max = max;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     *@param root, start, end: The root of segment tree and \n     *                         an segment / interval\n     *@return: The maximum number in the interval [start, end]\n     */\n    int query(SegmentTreeNode *root, int start, int end) {\n        // write your code here\n        if (root->end < start || root->start > end)\n            return -0x7ffffff;\n  \n        if (root->start >= start && root->end <= end)\n            return root->max;\n\n        int l = query(root->left, start, end);\n        int r = query(root->right, start, end);\n        return l > r ? l : r;\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of SegmentTreeNode:\nclass SegmentTreeNode:\n    def __init__(self, start, end, max):\n        this.start, this.end, this.max = start, end, max\n        this.left, this.right = None, None\n\"\"\"\n\nclass Solution:\t\n    # @param root, start, end: The root of segment tree and \n    #                          an segment / interval\n    # @return: The maximum number in the interval [start, end]\n    def query(self, root, start, end):\n        # write your code here\n        if root.start > end or root.end < start:\n            return -0x7fffff\n    \n        if start <= root.start and root.end <= end:\n            return root.max\n        \n        return max(self.query(root.left, start, end), \\\n                   self.query(root.right, start, end))\n"}]},{"id":225,"unique_name":"segment-tree-build","title":"线段树的构造","description":"线段树是一棵二叉树，他的每个节点包含了两个额外的属性`start`和`end`用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:\r\n\r\n- 根节点的 _start_ 和 _end_ 由 `build` 方法所给出。\r\n- 对于节点 A 的左儿子，有 `start=A.left, end=(A.left + A.right) / 2`。\r\n- 对于节点 A 的右儿子，有 `start=(A.left + A.right) / 2 + 1, end=A.right`。\r\n- 如果 _start_ 等于 _end_, 那么该节点是叶子节点，不再有左右儿子。\r\n\r\n实现一个 `build` 方法，接受 _start_ 和 _end_ 作为参数, 然后构造一个代表区间 `[start, end]` 的线段树，返回这棵线段树的根。","solutions":[{"language":"java","code":"/**\r\n * Definition of SegmentTreeNode:\r\n * public class SegmentTreeNode {\r\n *     public int start, end;\r\n *     public SegmentTreeNode left, right;\r\n *     public SegmentTreeNode(int start, int end) {\r\n *         this.start = start, this.end = end;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     *@param start, end: Denote an segment / interval\r\n     *@return: The root of Segment Tree\r\n     */\r\n    public SegmentTreeNode build(int start, int end) {\r\n        // write your code here\r\n        if(start > end) {  // check core case\r\n            return null;\r\n        }\r\n       \r\n        SegmentTreeNode root = new SegmentTreeNode(start, end);\r\n       \r\n        if(start != end) {\r\n            int mid = (start + end) / 2;\r\n            root.left = build(start, mid);\r\n            root.right = build(mid+1, end);\r\n           \r\n            // root.max = Math.max(root.left.max, root.right.max);\r\n        }\r\n        return root;\r\n    }\r\n}\r\n\r\n"},{"language":"cpp","code":"/**\n * Definition of SegmentTreeNode:\n * class SegmentTreeNode {\n * public:\n *     int l, r;\n *     SegmentTreeNode *left, *right;\n *     SegmentTreeNode(int l, int r) {\n *         this->l = l, this->r = r;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     *@param l, r: Denote an segment / interval\n     *@return: The root of Segment Tree\n     */\n    SegmentTreeNode * building(int l, int r) {\n        // write your code here\n        SegmentTreeNode * node = new SegmentTreeNode(l, r);\n        if (l == r)\n            return node;\n        int mid = (l + r) / 2;\n        node->left = building(l, mid);\n        node->right = building(mid+1, r);\n        return node;\n    }\n};\n"},{"language":"python","code":"\"\"\"\nDefinition of SegmentTreeNode:\nclass SegmentTreeNode:\n    def __init__(self, start, end):\n        this.start, this.end = start, end\n        this.left, this.right = None, None\n\"\"\"\n\nclass Solution:\t\n    # @param start, end: Denote an segment / interval\n    # @return: The root of Segment Tree\n    def build(self, start, end):\n        if start > end:\n            return None\n        root = SegmentTreeNode(start, end)\n        if start == end:\n            return root\n        root.left = self.build(start, (start + end) / 2)\n        root.right = self.build((start + end) / 2 + 1, end)\n        return root"}]},{"id":192,"unique_name":"wood-cut","title":"木材加工","description":"有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 `k`。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。","solutions":[{"language":"java","code":"public class Solution {\r\n    /** \r\n     *@param L: Given n pieces of wood with length L[i]\r\n     *@param k: An integer\r\n     *return: The maximum length of the small pieces.\r\n     */\r\n    public int woodCut(int[] L, int k) {\r\n        int max = 0;\r\n        for (int i = 0; i < L.length; i++) {\r\n            max = Math.max(max, L[i]);\r\n        }\r\n        \r\n        // find the largest length that can cut more than k pieces of wood.\r\n        int start = 1, end = max;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (count(L, mid) >= k) {\r\n                start = mid;\r\n            } else {\r\n                end = mid;\r\n            }\r\n        }\r\n        \r\n        if (count(L, end) >= k) {\r\n            return end;\r\n        }\r\n        if (count(L, start) >= k) {\r\n            return start;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    private int count(int[] L, int length) {\r\n        int sum = 0;\r\n        for (int i = 0; i < L.length; i++) {\r\n            sum += L[i] / length;\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /** \r\n     *@param L: Given n pieces of wood with length L[i]\r\n     *@param k: An integer\r\n     *return: The maximum length of the small pieces.\r\n     */\r\n    bool  ok(vector<int> L, int mid, int k) {\r\n        if (!mid) { \r\n            return false;\r\n        }\r\n        int cnt = 0;\r\n        int n = L.size();\r\n        for (int i = 0; i < n; ++i){\r\n            cnt += L[i] / mid;\r\n        }\r\n        return cnt >= k;\r\n    }\r\n    int woodCut(vector<int> L, int k) {\r\n        // write your code here\r\n        int l =1, r = 0;\r\n        int n = L.size();\r\n        for (int i = 0; i < n; ++i){\r\n            r = max(r, L[i]);\r\n        }\r\n        int ans = 0;\r\n        while (l <= r) {\r\n            int mid = l + (r - l) / 2;\r\n            if (ok(L, mid, k)) {\r\n                l = mid + 1; \r\n                ans = mid;\r\n            } else{\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param L: Given n pieces of wood with length L[i]\r\n    @param k: An integer\r\n    return: The maximum length of the small pieces.\r\n    \"\"\"\r\n    def woodCut(self, L, k):\r\n        if sum(L) < k:\r\n            return 0\r\n            \r\n        maxLen = max(L)\r\n        start, end = 1, maxLen\r\n        while start + 1 < end:\r\n            mid = (start + end) / 2\r\n            pieces = sum([l / mid for l in L])\r\n            if pieces >= k:\r\n                start = mid\r\n            else:\r\n                end = mid\r\n                \r\n        if sum([l / end for l in L]) >= k:\r\n            return end\r\n        return start\r\n"},{"language":"javascript","code":"/**\n * @param L: Given n pieces of wood with length L[i]\n * @param k: An integer\n * @return: The maximum length of the small pieces\n */\nconst woodCut = function (L, k) {\n    count = function(L, length) {\n        var sum = 0;\n        var i;\n        for (i = 0; i < L.length; i++) {\n            sum += Math.floor(L[i] / length);\n        }\n        return sum;\n    }\n    var max = 0;\n    var i;\n    var start, end, mid;\n    for (i = 0; i < L.length; i++) {\n        max = Math.max(max, L[i]);\n    }\n    start = 1;\n    end = max;\n    while (start + 1 < end) {\n        mid = start + Math.floor((end - start) / 2);\n        if (count(L, mid) >= k) {\n            start = mid;\n        } else {\n            end = mid;\n        }\n    }\n    if (count(L, end) >= k) {\n        return end;\n    }\n    if (count(L, start) >= k) {\n        return start;\n    }\n    return 0;\n}"}]},{"id":169,"unique_name":"find-minimum-in-rotated-sorted-array-ii","title":"寻找旋转排序数组中的最小值 II","description":"<p>假设一个旋转排序的数组其起始位置是未知的（比如<span style=\"font-weight: 700;\"><font color=\"#e76363\">0 1 2 4 5 6 7</font></span>&nbsp;可能变成是<font color=\"#e76363\"><span style=\"font-weight: 700;\">4 5 6 7 0 1 2</span></font>）。</p><p>你需要找到其中最小的元素。</p><p>数组中可能存在重复的元素。</p>","solutions":[{"language":"java","code":"// version 1: just for loop is enough\r\npublic class Solution {\r\n    public int findMin(int[] num) {\r\n        //  这道题目在面试中不会让写完整的程序\r\n        //  只需要知道最坏情况下 [1,1,1....,1] 里有一个0\r\n        //  这种情况使得时间复杂度必须是 O(n)\r\n        //  因此写一个for循环就好了。\r\n        //  如果你觉得，不是每个情况都是最坏情况，你想用二分法解决不是最坏情况的情况，那你就写一个二分吧。\r\n        //  反正面试考的不是你在这个题上会不会用二分法。这个题的考点是你想不想得到最坏情况。\r\n        int min = num[0];\r\n        for (int i = 1; i < num.length; i++) {\r\n            if (num[i] < min)\r\n                min = num[i];\r\n        }\r\n        return min;\r\n    }\r\n}\r\n\r\n// version 2: use *fake* binary-search\r\npublic class Solution {\r\n    /**\r\n     * @param num: a rotated sorted array\r\n     * @return: the minimum number in the array\r\n     */\r\n    public int findMin(int[] nums) {\r\n        if (nums == null || nums.length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        int start = 0, end = nums.length - 1;\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (nums[mid] == nums[end]) {\r\n                // if mid equals to end, that means it's fine to remove end\r\n                // the smallest element won't be removed\r\n                end--;\r\n            } else if (nums[mid] < nums[end]) {\r\n                end = mid;\r\n                // of course you can merge == & <\r\n            } else {\r\n                start = mid;\r\n                // or start = mid + 1\r\n            }\r\n        }\r\n        \r\n        if (nums[start] <= nums[end]) {\r\n            return nums[start];\r\n        }\r\n        return nums[end];\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param num: the rotated sorted array\r\n     * @return: the minimum number in the array\r\n     */\r\n    int findMin(vector<int> &num) {\r\n        // write your code here\r\n         int lo = 0;\r\n        int hi = num.size()-1;\r\n        while(lo<hi){\r\n            int mid = lo + (hi - lo)/2;\r\n            if(num[mid]>num[hi]){\r\n                lo = mid+1;\r\n            }else if(num[mid]<num[hi]){\r\n                hi = mid;\r\n            }else{\r\n                hi--;\r\n            }\r\n        }\r\n        return num[lo];\r\n        \r\n       /* \r\n        int st = 0;\r\n        int ed = num.size()-1;\r\n        while(st<ed){\r\n            int mid = st+(ed-st)/2;\r\n            if(num[mid] > num[ed]){\r\n                st = mid+1;\r\n            }else if(mid[mid] < num[ed]){\r\n                ed = mid;\r\n            }else {\r\n                ed--;\r\n            }\r\n        }\r\n        return num[st];\r\n        */\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param num: a rotated sorted array\r\n    # @return: the minimum number in the array\r\n    def findMin(self, num):\r\n        # write your code here\r\n        min = num[0]\r\n        start, end = 0, len(num) - 1\r\n        while start<end:\r\n            mid = (start+end)/2\r\n            if num[mid]>num[end]:\r\n                start = mid+1\r\n            elif num[mid]<num[end]:\r\n                end = mid\r\n            else:\r\n                end = end - 1\r\n        return num[start]\r\n"},{"language":"javascript","code":"/**\n * @param nums: a rotated sorted array\n * @return: the minimum number in the array\n */\nconst findMin = function (nums) {\n    if (nums === null || nums.length === 0) {\n        return -1;\n    }\n    var start = 0, end = nums.length - 1;\n    var mid;\n    while (start + 1 < end) {\n        mid = start + Math.floor((end - start) / 2);\n        if (nums[mid] == nums[end]) {\n            end--;\n        } else if (nums[mid] < nums[end]) {\n            end = mid;\n        } else {\n            start = mid;\n        }\n    }\n    if (nums[start] <= nums[end]) {\n        return nums[start];\n    }\n    return nums[end];\n}"}]},{"id":168,"unique_name":"find-minimum-in-rotated-sorted-array","title":"寻找旋转排序数组中的最小值","description":"<p>假设一个旋转排序的数组其起始位置是未知的（比如<b><font color=\"#e76363\">0 1 2 4 5 6 7</font></b> 可能变成是<font color=\"#e76363\"><b>4 5 6 7 0 1 2</b></font>）。</p><p>你需要找到其中最小的元素。</p><p>你可以假设数组中不存在重复的元素。</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: a rotated sorted array\r\n     * @return: the minimum number in the array\r\n     */\r\n    public int findMin(int[] nums) {\r\n        if (nums == null || nums.length == 0) {\r\n            return -1;\r\n        }\r\n        \r\n        int start = 0, end = nums.length - 1;\r\n        int target = nums[nums.length - 1];\r\n        \r\n        // find the first element <= target\r\n        while (start + 1 < end) {\r\n            int mid = start + (end - start) / 2;\r\n            if (nums[mid] <= target) {\r\n                end = mid;\r\n            } else {\r\n                start = mid;\r\n            }\r\n        }\r\n        if (nums[start] <= target) {\r\n            return nums[start];\r\n        } else {\r\n            return nums[end];\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: a rotated sorted array\r\n     * @return: the minimum number in the array\r\n     */\r\n    int findMin(vector<int> &nums) {\r\n        // write your code here\r\n        int left = 0, right = nums.size() - 1;\r\n        while (nums[left] > nums[right]) {\r\n            int mid = (left + right) / 2;\r\n\r\n            if (nums[mid] >= nums[left] && nums[mid] > nums[right])\r\n                left = mid+1;\r\n            else\r\n                right = mid;\r\n        }\r\n\r\n        return nums[left];\r\n    }\r\n};"},{"language":"python","code":"class Solution:\n    \"\"\"\n    @param: nums: a rotated sorted array\n    @return: the minimum number in the array\n    \"\"\"\n    def findMin(self, nums):\n        # write your code here\n        len_t = len(nums)\n        if len_t == 0:\n            return -1\n        start, end = 0, len_t - 1\n        \n        while start + 1 < end:\n            mid = start + (end - start)/2\n            if nums[mid] > nums[end]:\n                start = mid\n            else:\n                end = mid\n        return min(nums[start],nums[end])"}]},{"id":101,"unique_name":"divide-two-integers","title":"两个整数相除","description":"将两个整数相除，要求不使用乘法、除法和 mod 运算符。\r\n\r\n如果溢出，返回 `2147483647` 。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param dividend the dividend\r\n     * @param divisor the divisor\r\n     * @return the result\r\n     */\r\n    public int divide(int dividend, int divisor) {\r\n        if (divisor == 0) {\r\n             return dividend >= 0? Integer.MAX_VALUE : Integer.MIN_VALUE;\r\n        }\r\n        \r\n        if (dividend == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n        \r\n        boolean isNegative = (dividend < 0 && divisor > 0) || \r\n                             (dividend > 0 && divisor < 0);\r\n                             \r\n        long a = Math.abs((long)dividend);\r\n        long b = Math.abs((long)divisor);\r\n        int result = 0;\r\n        while(a >= b){\r\n            int shift = 0;\r\n            while(a >= (b << shift)){\r\n                shift++;\r\n            }\r\n            a -= b << (shift - 1);\r\n            result += 1 << (shift - 1);\r\n        }\r\n        return isNegative? -result: result;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    int divide(int dividend, int divisor) {\r\n        long long a = dividend >= 0 ? dividend : -(long long) dividend;\r\n        long long b = divisor >= 0 ? divisor : -(long long) divisor;\r\n        long long result = 0, shift = 31;\r\n        while (shift >= 0) {\r\n            if (a >= b << shift) {\r\n                a -= b << shift;\r\n                result += 1LL << shift;\r\n            }\r\n            shift--;\r\n        }\r\n        result = ((dividend ^ divisor) >> 31) ? (-result) : (result);\r\n        if (result > INT32_MAX) return INT32_MAX;\r\n        else return result;\r\n    }\r\n};"},{"language":"python","code":"class Solution(object):\r\n    def divide(self, dividend, divisor):\r\n        INT_MAX = 2147483647\r\n        if divisor == 0:\r\n            return INT_MAX\r\n        neg = dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0\r\n        a, b = abs(dividend), abs(divisor)\r\n        ans, shift = 0, 31\r\n        while shift >= 0:\r\n            if a >= b << shift:\r\n                a -= b << shift\r\n                ans += 1 << shift\r\n            shift -= 1\r\n        if neg:\r\n            ans = - ans\r\n        if ans > INT_MAX:\r\n            return INT_MAX\r\n        return ans"}]},{"id":396,"unique_name":"pass-interview","title":"通过面试","description":"给出面试者的性别和面试成绩，判断求职者是否通过面试。\r\n\r\n* 如果面试者是男性，那么面试成绩必须大于等于4分。\r\n* 如果面试者是女性，那么面试成绩必须大于等于3分。\r\n\r\n参数sex是boolean类型，sex为true时，代表求职者是女性，因为女人永远都是对的。相反sex为false时，代表求职者为男性，因为男人永远都是错的。","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param sex the sex of a candidate\n     * @param score the interview score of a candidate\n     * @return a boolean\n     */\n    public boolean passInterview(boolean sex, double score) {\n        if (sex) {\n            return score >= 3;\n        }\n        return score >= 4;\n    }\n}\n"},{"language":"cpp","code":"class Solution {\npublic:\n    /**\n     * @param sex the sex of a candidate\n     * @param score the interview score of a candidate\n     * @return a boolean\n     */\n    bool passInterview(bool sex, double score) {\n        // Write your code here\n        return (sex && score >= 3 || !sex && score >=4);\n    }\n};\n"},{"language":"python","code":"class Solution:\n    # @param {boolean} sex the sex of a candidate\n    # @param {double} score the interview score of a candidate\n    # @return {boolean} a boolean\n    def passInterview(self, sex, score):\n        # Write your code here\n        return sex and score >= 3 or not sex and score >=4\n"}]},{"id":613,"unique_name":"binary-tree-maximum-node","title":"二叉树的最大节点","description":"在二叉树中寻找值最大的节点并返回。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the max ndoe\r\n     */\r\n    public TreeNode maxNode(TreeNode root) {\r\n        // Write your code here\r\n        if (root == null)\r\n            return root;\r\n\r\n        TreeNode left = maxNode(root.left);\r\n        TreeNode right = maxNode(root.right);\r\n        return max(root, max(left, right));\r\n    }\r\n\r\n    TreeNode max(TreeNode a, TreeNode b) {\r\n        if (a == null)\r\n            return b;\r\n        if (b == null)\r\n            return a;\r\n        if (a.val > b.val) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param root the root of binary tree\r\n     * @return the max node\r\n     */\r\n    TreeNode* maxNode(TreeNode* root) {\r\n        // Write your code here\r\n        if (root == NULL)\r\n            return root;\r\n\r\n        TreeNode* left = maxNode(root->left);\r\n        TreeNode* right = maxNode(root->right);\r\n        return max(root, max(left, right));\r\n    }\r\n\r\n    TreeNode* max(TreeNode* a, TreeNode* b) {\r\n        if (a == NULL)\r\n            return b;\r\n        if (b == NULL)\r\n            return a;\r\n        if (a->val > b->val) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {TreeNode} root the root of binary tree\r\n    # @return {TreeNode} the max node\r\n    def maxNode(self, root):\r\n        # Write your code here\r\n        if root is None:\r\n            return root\r\n\r\n        left = self.maxNode(root.left)\r\n        right = self.maxNode(root.right)\r\n        return self.max(root, self.max(left, right))\r\n\r\n    def max(self, a, b):\r\n        if a is None:\r\n            return b\r\n        if b is None:\r\n            return a\r\n        if a.val > b.val:\r\n            return a\r\n        return b"}]},{"id":375,"unique_name":"identical-binary-tree","title":"等价二叉树","description":"检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param a, b, the root of binary trees.\r\n     * @return true if they are identical, or false.\r\n     */\r\n    public boolean isIdentical(TreeNode a, TreeNode b) {\r\n        // Write your code here\r\n        if (a == null && b == null)\r\n            return true;\r\n        if (a != null && b != null) {\r\n            return a.val == b.val && isIdentical(a.left, b.left)\r\n                    && isIdentical(a.right, b.right);\r\n        }\r\n        return false;\r\n    }\r\n}"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @aaram a, b, the root of binary trees.\r\n     * @return true if they are identical, or false.\r\n     */\r\n    bool isIdentical(TreeNode* a, TreeNode* b) {\r\n        // Write your code here\r\n        if(!a && !b)\r\n            return true;\r\n        else if(!a && b)\r\n            return false;\r\n        else if(a && !b)\r\n            return false;\r\n        else {\r\n            if(a->val != b->val)\r\n                return false;\r\n            else\r\n                return isIdentical(a->left, b->left) && isIdentical(a->right, b->right);\r\n        }\r\n    }\r\n};"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param a, b, the root of binary trees.\r\n    @return true if they are identical, or false.\r\n    \"\"\"\r\n    def isIdentical(self, a, b):\r\n        # Write your code here\r\n        if a == None and b == None: return True\r\n        if a and b and a.val == b.val:\r\n            return self.isIdentical(a.left, b.left) and \\\r\n                    self.isIdentical(a.right, b.right)\r\n        return False"}]},{"id":223,"unique_name":"invert-binary-tree","title":"翻转二叉树","description":"翻转一棵二叉树","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: a TreeNode, the root of the binary tree\r\n     * @return: nothing\r\n     */\r\n    public void invertBinaryTree(TreeNode root) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        TreeNode temp = root.left;\r\n        root.left = root.right;\r\n        root.right = temp;\r\n        \r\n        invertBinaryTree(root.left);\r\n        invertBinaryTree(root.right);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\nclass Solution {\npublic:\n    /**\n     * @param root: a TreeNode, the root of the binary tree\n     * @return: nothing\n     */\n    void invertBinaryTree(TreeNode *root) {\n        // write your code here\n        dfs(root);\n    }\nprivate:\n    void dfs(TreeNode *node) {\n        TreeNode *left = node->left, *right = node->right;\n        node->left = right; node->right = left;\n        if (left!=NULL) dfs(left);\n        if (right!=NULL) dfs(right);\n    }\n};"},{"language":"python","code":"\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\nclass Solution:\n    # @param root: a TreeNode, the root of the binary tree\n    # @return: nothing\n    def invertBinaryTree(self, root):\n        # write your code here\n        self.dfs(root)\n    def dfs(self, node):\n        left = node.left\n        right = node.right\n        node.left = right\n        node.right = left\n        if (left!=None): self.dfs(left)\n        if (right!=None): self.dfs(right)\n"}]},{"id":505,"unique_name":"clone-binary-tree","title":"克隆二叉树","description":"深度复制一个二叉树。\r\n\r\n给定一个二叉树，返回一个他的 **克隆品** 。","solutions":[{"language":"java","code":"/**\r\n * Definition of TreeNode:\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left, right;\r\n *     public TreeNode(int val) {\r\n *         this.val = val;\r\n *         this.left = this.right = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    /**\r\n     * @param root: The root of binary tree\r\n     * @return root of new tree\r\n     */\r\n    public TreeNode cloneTree(TreeNode root) {\r\n        // Write your code here\r\n        if (root == null)\r\n            return null;\r\n        TreeNode clone_root = new TreeNode(root.val);\r\n        clone_root.left = cloneTree(root.left);\r\n        clone_root.right = cloneTree(root.right);\r\n        return clone_root;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"/**\r\n * Definition of TreeNode:\r\n * class TreeNode {\r\n * public:\r\n *     int val;\r\n *     TreeNode *left, *right;\r\n *     TreeNode(int val) {\r\n *         this->val = val;\r\n *         this->left = this->right = NULL;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param root: The root of binary tree\r\n     * @return root of new tree\r\n     */\r\n    TreeNode* cloneTree(TreeNode *root) {\r\n        // Write your code here\r\n        if (root == NULL)\r\n            return NULL;\r\n\r\n\r\n        TreeNode* clone_root = new TreeNode(root->val);\r\n        clone_root->left = cloneTree(root->left);\r\n        clone_root->right = cloneTree(root->right);\r\n        \r\n        return clone_root;\r\n    }\r\n};\r\n"},{"language":"python","code":"\"\"\"\r\nDefinition of TreeNode:\r\nclass TreeNode:\r\n    def __init__(self, val):\r\n        this.val = val\r\n        this.left, this.right = None, None\r\n\"\"\"\r\nclass Solution:\r\n    \"\"\"\r\n    @param {TreeNode} root: The root of binary tree\r\n    @return {TreeNode} root of new tree\r\n    \"\"\"\r\n    def cloneTree(self, root):\r\n        # Write your code here\r\n        if root is None:\r\n            return None\r\n        clone_root = TreeNode(root.val)\r\n        clone_root.left = self.cloneTree(root.left)\r\n        clone_root.right = self.cloneTree(root.right)\r\n        return clone_root\r\n"}]},{"id":52,"unique_name":"construct-binary-tree-from-preorder-and-inorder-traversal","title":"前序遍历和中序遍历树构造二叉树","description":"根据前序遍历和中序遍历树构造二叉树.","solutions":[{"language":"java","code":"public class Solution {\r\n    private int findPosition(int[] arr, int start, int end, int key) {\r\n        int i;\r\n        for (i = start; i <= end; i++) {\r\n            if (arr[i] == key) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private TreeNode myBuildTree(int[] inorder, int instart, int inend,\r\n            int[] preorder, int prestart, int preend) {\r\n        if (instart > inend) {\r\n            return null;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(preorder[prestart]);\r\n        int position = findPosition(inorder, instart, inend, preorder[prestart]);\r\n\r\n        root.left = myBuildTree(inorder, instart, position - 1,\r\n                preorder, prestart + 1, prestart + position - instart);\r\n        root.right = myBuildTree(inorder, position + 1, inend,\r\n                preorder, position - inend + preend + 1, preend);\r\n        return root;\r\n    }\r\n\r\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\r\n        if (inorder.length != preorder.length) {\r\n            return null;\r\n        }\r\n        return myBuildTree(inorder, 0, inorder.length - 1, preorder, 0, preorder.length - 1);\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <vector>\n#include \"lintcode.h\"\n#include <algorithm>\nusing namespace std;\n\n/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\n \n\nclass Solution {\n    /**\n     *@param preorder : A list of integers that preorder traversal of a tree\n     *@param inorder : A list of integers that inorder traversal of a tree\n     *@return : Root of a tree\n     */\npublic:\n    typedef vector<int>::iterator Iter;\n    TreeNode *buildTreeRecur(Iter istart, Iter iend, Iter pstart, Iter pend)\n    {\n        if(istart == iend)return NULL;\n        int rootval = *pstart;\n        Iter iterroot = find(istart, iend, rootval);\n        TreeNode *res = new TreeNode(rootval);\n        res->left = buildTreeRecur(istart, iterroot, pstart+1, pstart+1+(iterroot-istart));\n        res->right = buildTreeRecur(iterroot+1, iend, pstart+1+(iterroot-istart), pend);\n        return res;\n    }\n    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n        // write your code here\n        return buildTreeRecur(inorder.begin(), inorder.end(), preorder.begin(), preorder.end());\n    }\n};\n"},{"language":"python","code":"from lintcode import TreeNode\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    @param preorder : A list of integers that preorder traversal of a tree\n    @param inorder : A list of integers that inorder traversal of a tree\n    @return : Root of a tree\n    \"\"\"\n    def buildTree(self, preorder, inorder):\n        # write your code here\n        if not inorder: return None # inorder is empty\n        root = TreeNode(preorder[0])\n        rootPos = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : 1 + rootPos], inorder[ : rootPos])\n        root.right = self.buildTree(preorder[rootPos + 1 : ], inorder[rootPos + 1 : ])\n        return root"}]},{"id":51,"unique_name":"construct-binary-tree-from-inorder-and-postorder-traversal","title":"中序遍历和后序遍历树构造二叉树","description":"<p>根据中序遍历和后序遍历树构造二叉树</p>","solutions":[{"language":"java","code":"public class Solution {\r\n    private int findPosition(int[] arr, int start, int end, int key) {\r\n        int i;\r\n        for (i = start; i <= end; i++) {\r\n            if (arr[i] == key) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private TreeNode myBuildTree(int[] inorder, int instart, int inend,\r\n            int[] postorder, int poststart, int postend) {\r\n        if (instart > inend) {\r\n            return null;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(postorder[postend]);\r\n        int position = findPosition(inorder, instart, inend, postorder[postend]);\r\n\r\n        root.left = myBuildTree(inorder, instart, position - 1,\r\n                postorder, poststart, poststart + position - instart - 1);\r\n        root.right = myBuildTree(inorder, position + 1, inend,\r\n                postorder, poststart + position - instart, postend - 1);\r\n        return root;\r\n    }\r\n\r\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\r\n        if (inorder.length != postorder.length) {\r\n            return null;\r\n        }\r\n        return myBuildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\r\n    }\r\n}"},{"language":"cpp","code":"#include <vector>\n#include \"lintcode.h\"\n#include <algorithm>\nusing namespace std;\n\n/**\n * Definition of TreeNode:\n * class TreeNode {\n * public:\n *     int val;\n *     TreeNode *left, *right;\n *     TreeNode(int val) {\n *         this->val = val;\n *         this->left = this->right = NULL;\n *     }\n * }\n */\n \n\nclass Solution {\n    /**\n     *@param inorder : A list of integers that inorder traversal of a tree\n     *@param postorder : A list of integers that postorder traversal of a tree\n     *@return : Root of a tree\n     */\npublic:\n    typedef vector<int>::iterator Iter;\n    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n        // write your code here\n        if (inorder.size() == 0)\n            return NULL;\n        return buildTreeRecur(inorder.begin(), inorder.end(), postorder.begin(), \n        postorder.end());\n    }\n    TreeNode *buildTreeRecur(Iter istart, Iter iend, Iter pstart, Iter pend)\n    {\n        if(istart == iend)return NULL;\n        int rootval = *(pend-1);\n        Iter iterroot = find(istart, iend, rootval);\n        TreeNode *res = new TreeNode(rootval);\n        res->left = buildTreeRecur(istart, iterroot, pstart, pstart+(iterroot-istart));\n        res->right = buildTreeRecur(iterroot+1, iend, pstart+(iterroot-istart), pend-1);\n        return res;\n    }\n};\n"},{"language":"python","code":"from lintcode import TreeNode\n\"\"\"\nDefinition of TreeNode:\nclass TreeNode:\n    def __init__(self, val):\n        this.val = val\n        this.left, this.right = None, None\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    @param inorder : A list of integers that inorder traversal of a tree\n    @param postorder : A list of integers that postorder traversal of a tree\n    @return : Root of a tree\n    \"\"\"\n    def buildTree(self, inorder, postorder):\n        if not inorder: return None # inorder is empty\n        root = TreeNode(postorder[-1])\n        rootPos = inorder.index(postorder[-1])\n        root.left = self.buildTree(inorder[ : rootPos], postorder[ : rootPos])\n        root.right = self.buildTree(inorder[rootPos + 1 : ], postorder[rootPos : -1])\n        return root"}]},{"id":212,"unique_name":"sliding-window-median","title":"滑动窗口的中位数","description":"给定一个包含 n 个整数的数组，和一个大小为 *k* 的滑动窗口,从左到右在数组中滑动这个窗口，找到数组中每个窗口内的中位数。(如果数组个数是偶数，则在该窗口排序数字后，返回第 N/2 个数字。)","solutions":[{"language":"java","code":"// TreeMap Version\r\nimport java.util.*;\r\n\r\n\r\npublic class Solution {\r\n\t/**\r\n\t * @param nums\r\n\t *            : A list of integers.\r\n\t * @return: The median of the element inside the window at each moving.\r\n\t */\r\n\tpublic  ArrayList<Integer> medianSlidingWindow(int[] nums, int k) {\r\n\t    int n = nums.length;\r\n        TreeSet<Node> minheap = new TreeSet<Node>();\r\n        TreeSet<Node> maxheap = new TreeSet<Node>();\r\n        ArrayList<Integer> result = new ArrayList<Integer> ();\r\n        \r\n        if (k == 0)\r\n            return result;\r\n        \r\n        int half = (k+1)/2;\r\n        for(int i=0; i<k-1; i++) {\r\n            add(minheap, maxheap, half, new Node(i, nums[i]));\r\n        }\r\n        for(int i=k-1; i<n; i++) {\r\n            add(minheap, maxheap, half, new Node(i, nums[i]));\r\n            result.add(minheap.last().val);\r\n            remove(minheap,maxheap, new Node(i-k+1, nums[i-k+1]));\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    void add(TreeSet<Node>minheap, TreeSet<Node> maxheap, int size, Node node) {\r\n        if (minheap.size()<size) {\r\n            minheap.add(node);\r\n        }\r\n        else {\r\n            maxheap.add(node);\r\n        }\r\n        if (minheap.size()==size) {\r\n            if (maxheap.size()>0 && minheap.last().val>maxheap.first().val) {\r\n                Node s = minheap.last();\r\n                Node b = maxheap.first();\r\n                minheap.remove(s);\r\n                maxheap.remove(b);\r\n                minheap.add(b);\r\n                maxheap.add(s);\r\n            }\r\n        }\r\n    }\r\n    \r\n    void remove(TreeSet<Node>minheap, TreeSet<Node> maxheap, Node node) {\r\n        if (minheap.contains(node)) {\r\n            minheap.remove(node);\r\n        }\r\n        else {\r\n            maxheap.remove(node);\r\n        }\r\n    }\r\n}\r\n\r\nclass Node implements Comparable<Node>{\r\n    int id;\r\n    int val;\r\n    Node(int id, int val) {\r\n        this.id = id;\r\n        this.val = val;\r\n    }\r\n    public int compareTo(Node other) {\r\n        Node a =(Node)other;\r\n        if (this.val == a.val) {\r\n            return this.id - a.id;\r\n        }\r\n        return this.val - a.val;\r\n    }\r\n}\r\n\r\n\r\n// Normal heap Version\r\npublic class Solution {\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: The median of the element inside the window at each moving.\r\n     */\r\n    public ArrayList<Integer> medianSlidingWindow(int[] nums, int k) {\r\n        // write your code here\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        int size = nums.length;\r\n        if (size == 0 || size < k) {\r\n            return result;\r\n        }\r\n\r\n        PriorityQueue<Integer> minPQ = new PriorityQueue<Integer>();\r\n        PriorityQueue<Integer> maxPQ = new PriorityQueue<Integer>(11, Collections.reverseOrder());\r\n\r\n        int median = nums[0];\r\n        int j = 0;\r\n        if (k == 1) {\r\n            result.add(median);\r\n        }\r\n\r\n        for (int i = 1; i < size; i++) {\r\n            if (nums[i] > median) {\r\n                minPQ.offer(nums[i]);\r\n            } else {\r\n                maxPQ.offer(nums[i]);\r\n            }\r\n\r\n            if (i > k - 1) {\r\n                if (nums[j] > median) {\r\n                    minPQ.remove(nums[j]);\r\n                } else if (nums[j] < median) {\r\n                    maxPQ.remove(nums[j]);\r\n                } else {\r\n                    median = Integer.MIN_VALUE;\r\n                }\r\n                j++;\r\n            }\r\n\r\n            if (median == Integer.MIN_VALUE) {\r\n                median = minPQ.size() > maxPQ.size() ? minPQ.poll() : maxPQ.poll();\r\n            } else {\r\n                while (minPQ.size() >= maxPQ.size() + 2) {\r\n                    maxPQ.offer(median);\r\n                    median = minPQ.poll();\r\n                }\r\n                while (maxPQ.size() >= minPQ.size() + 1) {\r\n                    minPQ.offer(median);\r\n                    median = maxPQ.poll();\r\n                }\r\n            }\r\n            if (i >= k - 1) {\r\n                result.add(median);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// Hash Heap Version\r\nimport java.util.*;\r\n\r\nclass HashHeap {\r\n    ArrayList<Integer> heap;\r\n    String mode;\r\n    int size_t;\r\n    HashMap<Integer, Node> hash;\r\n\r\n    class Node {\r\n        public Integer id;\r\n        public Integer num;\r\n\r\n        Node(Node now) {\r\n            id = now.id;\r\n            num = now.num;\r\n        }\r\n\r\n        Node(Integer first, Integer second) {\r\n            this.id = first;\r\n            this.num = second;\r\n        }\r\n    }\r\n\r\n    public HashHeap(String mod) {\r\n        // TODO Auto-generated constructor stub\r\n        heap = new ArrayList<Integer>();\r\n        mode = mod;\r\n        hash = new HashMap<Integer, Node>();\r\n        size_t = 0;\r\n    }\r\n\r\n    int peak() {\r\n        return heap.get(0);\r\n    }\r\n\r\n    int size() {\r\n        return size_t;\r\n    }\r\n\r\n    Boolean empty() {\r\n        return (heap.size() == 0);\r\n    }\r\n\r\n    int parent(int id) {\r\n        if (id == 0) {\r\n            return -1;\r\n        }\r\n        return (id - 1) / 2;\r\n    }\r\n\r\n    int lson(int id) {\r\n        return id * 2 + 1;\r\n    }\r\n\r\n    int rson(int id) {\r\n        return id * 2 + 2;\r\n    }\r\n\r\n    boolean comparesmall(int a, int b) {\r\n        if (a <= b) {\r\n            if (mode == \"min\")\r\n                return true;\r\n            else\r\n                return false;\r\n        } else {\r\n            if (mode == \"min\")\r\n                return false;\r\n            else\r\n                return true;\r\n        }\r\n\r\n    }\r\n\r\n    void swap(int idA, int idB) {\r\n        int valA = heap.get(idA);\r\n        int valB = heap.get(idB);\r\n\r\n        int numA = hash.get(valA).num;\r\n        int numB = hash.get(valB).num;\r\n        hash.put(valB, new Node(idA, numB));\r\n        hash.put(valA, new Node(idB, numA));\r\n        heap.set(idA, valB);\r\n        heap.set(idB, valA);\r\n    }\r\n\r\n    Integer poll() {\r\n        size_t--;\r\n        Integer now = heap.get(0);\r\n        Node hashnow = hash.get(now);\r\n        if (hashnow.num == 1) {\r\n            swap(0, heap.size() - 1);\r\n            hash.remove(now);\r\n            heap.remove(heap.size() - 1);\r\n            if (heap.size() > 0) {\r\n                siftdown(0);\r\n            }\r\n        } else {\r\n            hash.put(now, new Node(0, hashnow.num - 1));\r\n        }\r\n        return now;\r\n    }\r\n\r\n    void add(int now) {\r\n        size_t++;\r\n        if (hash.containsKey(now)) {\r\n            Node hashnow = hash.get(now);\r\n            hash.put(now, new Node(hashnow.id, hashnow.num + 1));\r\n\r\n        } else {\r\n            heap.add(now);\r\n            hash.put(now, new Node(heap.size() - 1, 1));\r\n        }\r\n\r\n        siftup(heap.size() - 1);\r\n    }\r\n\r\n    void delete(int now) {\r\n        size_t--;\r\n        ;\r\n        Node hashnow = hash.get(now);\r\n        int id = hashnow.id;\r\n        int num = hashnow.num; \r\n        if (hashnow.num == 1) {\r\n\r\n            swap(id, heap.size() - 1);\r\n            hash.remove(now);\r\n            heap.remove(heap.size() - 1);\r\n            if (heap.size() > id) {\r\n                siftup(id);\r\n                siftdown(id);\r\n            }\r\n        } else {\r\n            hash.put(now, new Node(id, num - 1));\r\n        }\r\n    }\r\n\r\n    void siftup(int id) {\r\n        while (parent(id) > -1) {\r\n            int parentId = parent(id);\r\n            if (comparesmall(heap.get(parentId), heap.get(id)) == true) {\r\n                break;\r\n            } else {\r\n                swap(id, parentId);\r\n            }\r\n            id = parentId;\r\n        }\r\n    }\r\n\r\n    void siftdown(int id) {\r\n        while (lson(id) < heap.size()) {\r\n            int leftId = lson(id);\r\n            int rightId = rson(id);\r\n            int son;\r\n            if (rightId >= heap.size() || (comparesmall(heap.get(leftId), heap.get(rightId)) == true)) {\r\n                son = leftId;\r\n            } else {\r\n                son = rightId;\r\n            }\r\n            if (comparesmall(heap.get(id), heap.get(son)) == true) {\r\n                break;\r\n            } else {\r\n                swap(id, son);\r\n            }\r\n            id = son;\r\n        }\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param nums\r\n     *            : A list of integers.\r\n     * @return: The median of the element inside the window at each moving.\r\n     */\r\n    public ArrayList<Integer> medianSlidingWindow(int[] nums, int k) {\r\n        // write your code here\r\n\r\n        ArrayList<Integer> ans = new ArrayList<Integer>();\r\n        if (nums.length == 0)\r\n            return ans;\r\n        int median = nums[0];\r\n        HashHeap minheap = new HashHeap(\"min\");\r\n        HashHeap maxheap = new HashHeap(\"max\");\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (i != 0) {\r\n                if (nums[i] > median) {\r\n                    minheap.add(nums[i]);\r\n                } else {\r\n                    maxheap.add(nums[i]);\r\n                }\r\n            }\r\n\r\n            if (i >= k) {\r\n                if (median == nums[i - k]) {\r\n                    if (maxheap.size() > 0) {\r\n                        median = maxheap.poll();\r\n                    } else if (minheap.size() > 0) {\r\n                        median = minheap.poll();\r\n                    } \r\n\r\n                } else if (median < nums[i - k]) {\r\n                    minheap.delete(nums[i - k]);\r\n                } else {\r\n                    maxheap.delete(nums[i - k]);\r\n                }\r\n            }\r\n\r\n            while (maxheap.size() > minheap.size()) {\r\n                minheap.add(median);\r\n                median = maxheap.poll();\r\n            }\r\n            while (minheap.size() > maxheap.size() + 1) {\r\n                maxheap.add(median);\r\n                median = minheap.poll();\r\n            }\r\n\r\n            if (i + 1 >= k) {\r\n                ans.add(median);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param nums: A list of integers.\r\n     * @return: The median of the element inside the window at each moving\r\n     */\r\n    vector<int> medianSlidingWindow(vector<int> &nums, int k) {\r\n        // write your code here\r\n        vector<int> result;\r\n        int n = nums.size();\r\n        if (n == 0)\r\n            return result;\r\n\r\n        multiset<int> max, min;\r\n        for (int i = 0; i < k; ++i)\r\n            max.insert(nums[i]);\r\n\r\n        for (int i = 0; i < k/2; ++i) {\r\n            min.insert(*max.rbegin());\r\n            max.erase(max.lower_bound(*max.rbegin()));\r\n        }\r\n\r\n        for (int i = k; i < n; ++i) {\r\n            result.push_back(*max.rbegin());\r\n            if (max.find(nums[i-k]) != max.end()) {\r\n                max.erase(max.find(nums[i-k]));\r\n                max.insert(nums[i]);\r\n            } else {\r\n                min.erase(min.find(nums[i-k]));\r\n                min.insert(nums[i]);\r\n            }\r\n            if (max.size() > 0 && min.size() > 0 && *max.rbegin() > *min.begin()) {\r\n                int tmp = *max.rbegin();\r\n                max.erase(max.lower_bound(*max.rbegin()));\r\n                max.insert(*min.begin());\r\n                min.erase(min.begin());\r\n                min.insert(tmp);\r\n            }\r\n        }\r\n        result.push_back(*max.rbegin());\r\n\r\n        return result;\r\n    }\r\n};\r\n"},{"language":"python","code":"class node:\r\n\r\n    def __init__(self, id, number):\r\n        self.id = id\r\n        self.num = number\r\n\r\nclass HashHeap:\r\n    def __init__(self):\r\n        self.map = {}\r\n        self.hashmaxheap = [0]\r\n        self.map[0] = node(0, 1)\r\n        self.currentSize = 0\r\n\r\n    def put(self, data):\r\n        if data in self.map:\r\n            existData = self.map[data]\r\n            self.map[data] = node(existData.id, existData.num + 1)\r\n            self.currentSize += 1\r\n            return \r\n        else:\r\n            self.hashmaxheap.append(data)\r\n            self.map[data] = node(len(self.hashmaxheap) - 1, 1)\r\n            self.currentSize += 1\r\n            self.siftUp(len(self.hashmaxheap) - 1)\r\n\r\n    def peek(self):\r\n        return self.hashmaxheap[1]\r\n\r\n    def get(self):\r\n        res = self.hashmaxheap[1]\r\n        if self.map[res].num == 1:\r\n            if self.map[res].id == len(self.hashmaxheap) - 1:\r\n                del self.map[res]\r\n                self.hashmaxheap.pop()\r\n                self.currentSize -= 1\r\n                return res\r\n            del self.map[res]\r\n            self.hashmaxheap[1] = self.hashmaxheap[-1]\r\n            self.map[self.hashmaxheap[1]] = node(1, self.map[self.hashmaxheap[1]].num)\r\n            self.hashmaxheap.pop()\r\n            self.siftDown(1)\r\n        else:\r\n            self.map[res] = node(1, self.map[res].num - 1)\r\n        self.currentSize -= 1\r\n        return res\r\n\r\n    def delete(self, data):\r\n        existData = self.map[data]\r\n        if existData.num == 1:\r\n            del self.map[data]\r\n            if existData.id == len(self.hashmaxheap) - 1:\r\n                self.hashmaxheap.pop()\r\n                self.currentSize -= 1\r\n                return\r\n            self.hashmaxheap[existData.id] = self.hashmaxheap[-1]\r\n            self.map[self.hashmaxheap[-1]] = node(existData.id, self.map[self.hashmaxheap[-1]].num)\r\n            self.hashmaxheap.pop()\r\n            self.siftUp(existData.id)\r\n            self.siftDown(existData.id)\r\n        else:\r\n            self.map[data] = node(existData.id, existData.num - 1)\r\n        self.currentSize -= 1\r\n\r\n    def siftUp(self, index):\r\n        while index // 2 > 0:\r\n            if self.hashmaxheap[index] < self.hashmaxheap[index // 2]:\r\n                break\r\n            else:\r\n                numA = self.map[self.hashmaxheap[index]].num\r\n                numB = self.map[self.hashmaxheap[index // 2]].num\r\n                self.map[self.hashmaxheap[index]] = node(index // 2, numA)\r\n                self.map[self.hashmaxheap[index // 2]] = node(index, numB)\r\n                self.hashmaxheap[index], self.hashmaxheap[index // 2] = self.hashmaxheap[index // 2], self.hashmaxheap[index] \r\n            index = index // 2\r\n\r\n    def siftDown(self, index):\r\n        if index > (len(self.hashmaxheap) - 1) // 2:\r\n            return\r\n        if (index * 2 + 1) > (len(self.hashmaxheap) - 1) or self.hashmaxheap[index * 2] > self.hashmaxheap[index * 2 + 1]:\r\n            maxChild = index * 2\r\n        else:\r\n            maxChild = index * 2 + 1\r\n        if self.hashmaxheap[index] > self.hashmaxheap[maxChild]:\r\n            return\r\n        else:\r\n            numA = self.map[self.hashmaxheap[index]].num\r\n            numB = self.map[self.hashmaxheap[maxChild]].num\r\n            self.map[self.hashmaxheap[index]] = node(maxChild, numA)\r\n            self.map[self.hashmaxheap[maxChild]] = node(index, numB)\r\n            self.hashmaxheap[index], self.hashmaxheap[maxChild] = self.hashmaxheap[maxChild], self.hashmaxheap[index] \r\n        self.siftDown(index * 2)\r\n        self.siftDown(index * 2 + 1)\r\n\r\n    def size(self):\r\n        return self.currentSize\r\n\r\n    def isEmpty(self):\r\n        return self.currentSize == 0\r\n\r\nclass Solution:\r\n    \"\"\"\r\n    @param nums: A list of integers.\r\n    @return: The median of element inside the window at each moving.\r\n    \"\"\"\r\n    def medianSlidingWindow(self, nums, k):\r\n        res = []\r\n        if not nums:\r\n            return res\r\n\r\n        median = nums[0]\r\n        minHeap = HashHeap()\r\n        maxHeap = HashHeap()\r\n        for i in range(len(nums)):\r\n            if i != 0:\r\n                if nums[i] > median:\r\n                    minHeap.put(- nums[i])\r\n                else:\r\n                    maxHeap.put(nums[i])\r\n            if i >= k:\r\n                if median == nums[i - k]:\r\n                    if not maxHeap.isEmpty():\r\n                        median = maxHeap.get()\r\n                    elif not minHeap.isEmpty():\r\n                        median = - minHeap.get()\r\n                elif median < nums[i - k]:\r\n                    minHeap.delete(- nums[i - k])\r\n                else:\r\n                    maxHeap.delete(nums[i - k])\r\n\r\n            while maxHeap.size() > minHeap.size():\r\n                minHeap.put(- median)\r\n                median = maxHeap.get()\r\n\r\n            while minHeap.size() > maxHeap.size() + 1:\r\n                maxHeap.put(median)\r\n                median = - minHeap.get()\r\n\r\n            if i + 1 >= k:\r\n                res.append(median)\r\n\r\n        return res"}]},{"id":176,"unique_name":"word-search-ii","title":"单词搜索 II","description":"<p>给出一个由小写字母组成的矩阵和一个字典。找出所有同时在字典和矩阵中出现的单词。一个单词可以从矩阵中的任意位置开始，可以向左/右/上/下四个相邻方向移动。</p>","solutions":[{"language":"java","code":"public class Solution {\n    /**\n     * @param board: A list of lists of character\n     * @param words: A list of string\n     * @return: A list of string\n     */\n         \n    class TrieNode {\n        String s;\n         boolean isString;\n         HashMap<Character, TrieNode> subtree;\n         public TrieNode() {\n            // TODO Auto-generated constructor stub\n             isString = false;\n             subtree = new HashMap<Character, TrieNode>();\n             s = \"\";\n         }\n    };\n\n\n    class TrieTree{\n        TrieNode root ;\n        public TrieTree(TrieNode TrieNode) {\n            root = TrieNode;\n        }\n        public void insert(String s) {\n            TrieNode now = root;\n            for (int i = 0; i < s.length(); i++) {\n                if (!now.subtree.containsKey(s.charAt(i))) {\n                    now.subtree.put(s.charAt(i), new TrieNode());\n                }\n                now  =  now.subtree.get(s.charAt(i));\n            }\n            now.s = s;\n            now.isString  = true;\n        }\n        public boolean find(String s){\n            TrieNode now = root;\n            for (int i = 0; i < s.length(); i++) {\n                if (!now.subtree.containsKey(s.charAt(i))) {\n                    return false;\n                }\n                now  =  now.subtree.get(s.charAt(i));\n            }\n            return now.isString ;\n        }\n    };\n\n    public int []dx = {1, 0, -1, 0};\n    public int []dy = {0, 1, 0, -1};\n    \n    public void search(char[][] board, int x, int y, TrieNode root, List<String> ans) {    \n        if(root.isString == true)\n        {\n            if(!ans.contains(root.s)){\n                ans.add(root.s);\n            }\n        }\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y]==0 || root == null)\n            return ;\n        if(root.subtree.containsKey(board[x][y])){\n            for(int i = 0; i < 4; i++){\n                char now = board[x][y];\n                board[x][y] = 0;\n                search(board, x+dx[i], y+dy[i], root.subtree.get(now), ans);\n                board[x][y] = now;\n            }\n        }\n        \n    }\n    \n    public List<String> wordSearchII(char[][] board, List<String> words) {\n        List<String> ans = new ArrayList<String>();\n        \n        TrieTree tree = new TrieTree(new TrieNode());\n        for(String word : words){\n            tree.insert(word);\n        }\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[i].length; j++){\n                search(board, i, j, tree.root, ans);\n            }\n        }\n        return ans;\n        // write your code here\n        \n    }\n    \n}"},{"language":"cpp","code":"struct Node {\r\n    Node * ch[26];\r\n    string str;\r\n    Node() {\r\n        for (int i = 0; i < 26; ++i)\r\n            ch[i] = NULL;\r\n            str = \"\";\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    vector<string> results;\r\n    Node * root;\r\n    void insert(Node* p, string s) {\r\n        int len = s.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            if (p->ch[s[i]-'a'] == NULL)\r\n                p->ch[s[i]-'a'] = new Node();\r\n            p = p->ch[s[i]-'a'];\r\n        }   \r\n        p->str = s;\r\n    }\r\n    void search(vector<vector<char> > &board, vector<vector<bool> > &mask, Node* p, int x, int y) {\r\n        if (p->str != \"\") {\r\n            results.push_back(p->str);\r\n            p->str = \"\";\r\n        }\r\n\r\n        mask[x][y] = false;\r\n        if (y + 1 < board[0].size() && mask[x][y+1] && p->ch[board[x][y+1]-'a'] != NULL) {\r\n           search(board,mask, p->ch[board[x][y+1]-'a'], x, y+1);\r\n        }\r\n\r\n        if (x + 1 < board.size() && mask[x+1][y] && p->ch[board[x+1][y]-'a'] != NULL) {\r\n           search(board,mask, p->ch[board[x+1][y]-'a'], x+1, y);\r\n        }\r\n\r\n        if (y - 1 >= 0 && mask[x][y-1] && p->ch[board[x][y-1]-'a'] != NULL) {\r\n           search(board,mask, p->ch[board[x][y-1]-'a'], x, y-1);\r\n        }\r\n\r\n        if (x - 1 >= 0 && mask[x-1][y] && p->ch[board[x-1][y]-'a'] != NULL) {\r\n           search(board,mask, p->ch[board[x-1][y]-'a'], x-1, y);\r\n        }\r\n        mask[x][y] = true;\r\n    }\r\n    /**\r\n     * @param board: A list of lists of character\r\n     * @param words: A list of string\r\n     * @return: A list of string\r\n     */\r\n    vector<string> wordSearchII(vector<vector<char> > &board, vector<string> &words) {\r\n        // write your code here\r\n        root = new Node();\r\n        int len = words.size();\r\n        for (int i = 0; i < len; ++i) { \r\n            insert(root, words[i]);\r\n        }\r\n        vector<vector<bool> > mask(board.size(), vector<bool>(board[0].size(), true));\r\n        if (board.size() < 1) return results;\r\n        for (int i = 0; i <board.size(); ++i) {\r\n            for (int j = 0; j < board[0].size(); ++j) {\r\n               if (root->ch[board[i][j]-'a'] != NULL) {\r\n                    search(board, mask, root->ch[board[i][j]-'a'], i, j);\r\n                }\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n};"},{"language":"python","code":"class Trie:\r\n    \r\n    def __init__(self):\r\n        self.children = {}\r\n        self.flag = False\r\n        self.hasWord = False\r\n    \r\n    def put(self, key):\r\n        if key == '':\r\n            self.flag = True\r\n            self.hasWord = True\r\n            return\r\n        \r\n        if key[0] not in self.children:\r\n            self.children[key[0]] = Trie()\r\n        self.children[key[0]].put(key[1:])\r\n        self.hasWord = True\r\n    \r\n    def pop(self, key):\r\n        if key == '':\r\n            self.flag = False\r\n            self.hasWord = False\r\n            return\r\n        if key[0] not in self.children:\r\n            return\r\n        self.children[key[0]].pop(key[1:])\r\n        self.hasWord = any([child.hasWord for child in self.children.values()])\r\n        \r\n    def has(self, key):\r\n        if key == '':\r\n            return self.flag\r\n        \r\n        if not self.hasWord:\r\n            return False\r\n        if key[0] not in self.children:\r\n            return False\r\n        return self.children[key[0]].has(key[1:])\r\n\r\n\r\nclass Solution:\r\n    DIRECT_X = [1, 0, 0, -1]\r\n    DIRECT_Y = [0, 1, -1, 0]\r\n    # @param board, a list of lists of 1 length string\r\n    # @param words: A list of string\r\n    # @return: A list of string\r\n    def wordSearchII(self, board, words):\r\n        trie = Trie()\r\n        for word in words:\r\n            trie.put(word)\r\n        \r\n        self.results = {}\r\n        for r in range(len(board)):\r\n            for c in range(len(board[0])):\r\n                self.search(trie, trie, board, r, c, [])\r\n        return self.results.keys()\r\n                \r\n    def search(self, root, trie, board, x, y, chars):\r\n        char = board[x][y]\r\n        if char not in trie.children:\r\n            return\r\n        chars.append(char)\r\n        trie = trie.children[char]\r\n        if trie.flag:\r\n            self.results[''.join(chars)] = True\r\n            root.pop(''.join(chars))\r\n        \r\n        board[x][y] = '.'\r\n        for i in range(4):\r\n            r = x + self.DIRECT_X[i]\r\n            c = y + self.DIRECT_Y[i]\r\n            if r < 0 or r == len(board) or c < 0 or c == len(board[0]):\r\n                continue\r\n            self.search(root, trie, board, r, c, chars)\r\n        board[x][y] = char\r\n        chars.pop()\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        "}]},{"id":175,"unique_name":"heapify","title":"堆化","description":"给出一个整数数组，堆化操作就是把它变成一个最小堆数组。\r\n\r\n对于堆数组A，A[0]是堆的根，并对于每个A[i]，A [i * 2 + 1]是A[i]的左儿子并且A[i * 2 + 2]是A[i]的右儿子。\r\n","solutions":[{"language":"java","code":"// Version Linpz\r\npublic class Solution {\r\n    /**\r\n     * @param A: Given an integer array\r\n     * @return: void\r\n     */\r\n    private void siftdown(int[] A, int k) {\r\n        while (k * 2 + 1 < A.length) {\r\n            int son = k * 2 + 1;\r\n            if (k * 2 + 2 < A.length && A[son] > A[k * 2 + 2])\r\n                son = k * 2 + 2;\r\n            if (A[son] >= A[k])\r\n                break;\r\n            \r\n            int temp = A[son];\r\n            A[son] = A[k];\r\n            A[k] = temp;\r\n            k = son;\r\n        }\r\n    }\r\n    \r\n    public void heapify(int[] A) {\r\n        for (int i = (A.length - 1) / 2; i >= 0; i--) {\r\n            siftdown(A, i);\r\n        }\r\n    }\r\n}\r\n\r\n// Version 1: this cost O(n)\r\npublic class Solution {\r\n    /**\r\n     * @param A: Given an integer array\r\n     * @return: void\r\n     */\r\n    private void siftdown(int[] A, int k) {\r\n        while (k < A.length) {\r\n            int smallest = k;\r\n            if (k * 2 + 1 < A.length && A[k * 2 + 1] < A[smallest]) {\r\n                smallest = k * 2 + 1;\r\n            }\r\n            if (k * 2 + 2 < A.length && A[k * 2 + 2] < A[smallest]) {\r\n                smallest = k * 2 + 2;\r\n            }\r\n            if (smallest == k) {\r\n                break;\r\n            }\r\n            int temp = A[smallest];\r\n            A[smallest] = A[k];\r\n            A[k] = temp;\r\n            \r\n            k = smallest;\r\n        }\r\n    }\r\n    \r\n    public void heapify(int[] A) {\r\n        for (int i = A.length / 2; i >= 0; i--) {\r\n            siftdown(A, i);\r\n        } // for\r\n    }\r\n}\r\n\r\n\r\n// Version 2: This cost O(nlogn)\r\npublic class Solution {\r\n    /**\r\n     * @param A: Given an integer array\r\n     * @return: void\r\n     */\r\n    private void siftup(int[] A, int k) {\r\n        while (k != 0) {\r\n            int father = (k - 1) / 2;\r\n            if (A[k] > A[father]) {\r\n                break;\r\n            }\r\n            int temp = A[k];\r\n            A[k] = A[father];\r\n            A[father] = temp;\r\n            \r\n            k = father;\r\n        }\r\n    }\r\n    \r\n    public void heapify(int[] A) {\r\n        for (int i = 0; i < A.length; i++) {\r\n            siftup(A, i);\r\n        }\r\n    }\r\n}"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param A: Given an integer array\r\n     * @return: void\r\n     */\r\n    void min_heapify(vector<int> &A, int i, int len){  \r\n        int l = 2 * i + 1;  \r\n        int r = 2 * i + 2;  \r\n        int largest = i;  \r\n        if( l < len)\r\n            if(A[l] < A[i])  \r\n                largest = l;\r\n\r\n        if( r < len )   \r\n            if( A[r] < A[largest])  \r\n                largest = r;\r\n\r\n        if(largest != i) {\r\n            swap(A[i], A[largest]);  \r\n            min_heapify(A, largest, len);  \r\n        }  \r\n    }    \r\n    void heapify(vector<int> &A) {\r\n        // write your code here\r\n        int len = A.size();\r\n        for(int i = len / 2; i >= 0;i--)\r\n            min_heapify(A, i, len);\r\n    }\r\n};\r\n"},{"language":"python","code":"import heapq\r\nclass Solution:\r\n    # @param A: Given an integer array\r\n    # @return: void\r\n    def heapify(self, A):\r\n        # write your code here\r\n        heapq.heapify(A)\r\n        \r\n"}]},{"id":445,"unique_name":"previous-permutation","title":"上一个排列","description":"给定一个整数数组来表示排列，找出其上一个排列。","solutions":[{"language":"java","code":"import java.util.ArrayList;\n\npublic class Solution {\n    /**\n     * @param nums: A list of integers\n     * @return: A list of integers that's previous permuation\n     */\n    public void swapItem(ArrayList<Integer> nums, int i, int j) {\n\t\tInteger tmp = nums.get(i);\n\t\tnums.set(i, nums.get(j));\n\t\tnums.set(j, tmp);\n\t}\n\tpublic void swapList(ArrayList<Integer> nums, int i, int j) {\n\t\twhile ( i < j) {\n\t\t\tswapItem(nums, i, j);\n\t\t\ti ++; j --;\n\t\t}\n\t}\n    public ArrayList<Integer> previousPermuation(ArrayList<Integer> nums) {\n\t\tint len = nums.size();\n\t\tif ( len <= 1)\n\t\t\treturn nums;\n\t\tint i = len - 1;\n\t\twhile ( i > 0 && nums.get(i) >= nums.get(i-1) )\n\t\t\ti --;\n\t\tswapList(nums, i, len - 1);     \n\t\tif ( i != 0) {\n\t\t\tint j = i;\n\t\t\twhile ( nums.get(j) >= nums.get(i-1) ) j++;\n\t\t\tswapItem(nums, j, i-1);\n\t\t}\n\t\t\n\t\treturn nums;\n    }\n}\n\n"},{"language":"cpp","code":"#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    /**\n     * @param nums: An array of integers\n     * @return: An array of integers that's previous permuation\n     */\n    vector<int> previousPermuation(vector<int> &nums) {\n        int i = nums.size() - 2;  \n        while (i >= 0 && nums[i] <= nums[i + 1]) {  \n            i--;  \n        }  \n        if (i < 0) {  \n            reverse(nums.begin(), nums.end() - 1);  \n        }  \n        else {  \n            int j = i + 2;  \n            while (j < nums.size() && nums[j] < nums[i]) {  \n                j++;  \n            }  \n            j--;  \n              \n            nums[i] ^= nums[j];  \n            nums[j] ^= nums[i];  \n            nums[i] ^= nums[j];  \n              \n            reverse(nums.begin() + i + 1, nums.end() - 1);  \n        }  \n        return nums;\n    }\n    private:  \n    void reverse(vector<int>::iterator i1, vector<int>::iterator i2) {  \n        while (i1 < i2) {  \n            *i1 ^= *i2;  \n            *i2 ^= *i1;  \n            *i1 ^= *i2;  \n       \n            i1++;  \n            i2--;  \n        }  \n    }  \n};\n"},{"language":"python","code":"class Solution:\n    # @param num :  a list of integer\n    # @return : a list of integer\n    def previousPermuation(self, num):\n        # write your code here\n        for i in range(len(num)-2, -1, -1):\n            if num[i] > num[i+1]:\n                break\n        else:\n            num.reverse()\n            return num\n        for j in range(len(num)-1, i, -1):\n            if num[j] < num[i]:\n                num[i], num[j] = num[j], num[i]\n                break\n        for j in range(0, (len(num) - i)//2):\n            num[i+j+1], num[len(num)-j-1] = num[len(num)-j-1], num[i+j+1]\n        return num\n\n\n"}]},{"id":99,"unique_name":"next-permutation","title":"下一个排列","description":"给定一个整数数组来表示排列，找出其之后的一个排列。","solutions":[{"language":"java","code":"public class Solution {\r\n    /**\r\n     * @param nums: A list of integers\r\n     * @return: A list of integers that's next permuation\r\n     */\r\n    public void swapItem(int[] nums, int i, int j) {\r\n\t\tint temp = nums[i];\r\n\t\tnums[i] = nums[j];\r\n\t\tnums[j] = temp;\r\n\t}\r\n\tpublic void swapList(int[] nums, int i, int j) {\r\n\t\twhile (i < j) {\r\n\t\t\tswapItem(nums, i, j);\r\n\t\t\ti ++; j --;\r\n\t\t}\r\n\t}\r\n    public int[] nextPermutation(int[] nums) {\r\n\t\tint len = nums.length;\r\n\t\tif ( len <= 1)\r\n\t\t\treturn nums;\r\n\t\tint i = len - 1;\r\n\t\twhile (i > 0 && nums[i] <= nums[i - 1])\r\n\t\t\ti --;\r\n\t\tswapList(nums, i, len - 1);\r\n\t\tif (i != 0) {\r\n\t\t\tint j = i;\r\n\t\t\twhile (nums[j] <= nums[i - 1]) j++;\r\n\t\t\tswapItem(nums, j, i-1);\r\n\t\t}\r\n\t\treturn nums;\r\n    }\r\n}\r\n\r\n// version 2\r\npublic class Solution {\r\n    /**\r\n     * @param num: an array of integers\r\n     * @return: return nothing (void), do not return anything, modify num in-place instead\r\n     */\r\n     \r\n    public void reverse(int[] num, int start, int end) {\r\n        for (int i = start, j = end; i < j; i++, j--) {\r\n            int temp = num[i];\r\n            num[i] = num[j];\r\n            num[j] = temp;\r\n        }\r\n    }\r\n    \r\n    public int[] nextPermutation(int[] num) {\r\n        // find the last increase index\r\n        int index = -1;\r\n        for (int i = num.length - 2; i >= 0; i--) {\r\n            if (num[i] < num[i + 1]) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        if (index == -1) {\r\n            reverse(num, 0, num.length - 1);\r\n            return num;\r\n        }\r\n        \r\n        // find the first bigger one\r\n        int biggerIndex = index + 1;\r\n        for (int i = num.length - 1; i > index; i--) {\r\n            if (num[i] > num[index]) {\r\n                biggerIndex = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // swap them to make the permutation bigger\r\n        int temp = num[index];\r\n        num[index] = num[biggerIndex];\r\n        num[biggerIndex] = temp;\r\n        \r\n        // reverse the last part\r\n        reverse(num, index + 1, num.length - 1);\r\n        return num;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param nums: An array of integers\r\n     * @return: An array of integers that's next permuation\r\n     */\r\n    vector<int> nextPermutation(vector<int> &nums) {\r\n        int i = nums.size() - 2;  \r\n        while (i >= 0 && nums[i] >= nums[i + 1]) {  \r\n            i--;  \r\n        }  \r\n        if (i < 0) {  \r\n            reverse(nums.begin(), nums.end() - 1);  \r\n        }  \r\n        else {  \r\n            int j = i + 2;  \r\n            while (j < nums.size() && nums[j] > nums[i]) {  \r\n                j++;  \r\n            }  \r\n            j--;  \r\n              \r\n            nums[i] ^= nums[j];  \r\n            nums[j] ^= nums[i];  \r\n            nums[i] ^= nums[j];  \r\n              \r\n            reverse(nums.begin() + i + 1, nums.end() - 1);  \r\n        }  \r\n        return nums;\r\n    }\r\n    private:  \r\n    void reverse(vector<int>::iterator i1, vector<int>::iterator i2) {  \r\n        while (i1 < i2) {  \r\n            *i1 ^= *i2;  \r\n            *i2 ^= *i1;  \r\n            *i1 ^= *i2;  \r\n       \r\n            i1++;  \r\n            i2--;  \r\n        }  \r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    # @param num :  a list of integer\r\n    # @return : a list of integer\r\n    def nextPermutation(self, num):\r\n        # write your code here\r\n        for i in range(len(num)-2, -1, -1):\r\n            if num[i] < num[i+1]:\r\n                break\r\n        else:\r\n            num.reverse()\r\n            return num\r\n        for j in range(len(num)-1, i, -1):\r\n            if num[j] > num[i]:\r\n                num[i], num[j] = num[j], num[i]\r\n                break\r\n        for j in range(0, (len(num) - i)//2):\r\n            num[i+j+1], num[len(num)-j-1] = num[len(num)-j-1], num[i+j+1]\r\n        return num\r\n"},{"language":"javascript","code":"/**\n * @param nums: A list of integers\n * @return: A list of integers\n */\nconst nextPermutation = function (nums) {\n    reverse = function(i1, i2) {\n        var temp;\n        while (i1 < i2) {\n            temp = nums[i1];\n            nums[i1] = nums[i2];\n            nums[i2] = temp;\n            i1++;\n            i2--;\n        }\n    }\n    var n = nums.length;\n    var i, j;\n    var temp;\n    i = n - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n    if (i < 0) {\n        nums.reverse();\n    } else {\n        j = i + 2;\n        while (j < n && nums[j] > nums[i]) {\n            j ++;\n        }\n        j--;\n        temp = nums[j];\n        nums[j] = nums[i];\n        nums[i] = temp;\n        reverse(i + 1, n - 1);\n    }\n    return nums;\n}"}]},{"id":25,"unique_name":"surrounded-regions","title":"被围绕的区域","description":"给一个二维的矩阵，包含 `'X'` 和 `'O'`, 找到所有被 'X' 围绕的区域，并用 'X' 填充满。\r\n","solutions":[{"language":"java","code":"version 1:\r\npublic class Solution {\r\n    static final int[] directionX = {+1, -1, 0, 0};\r\n    static final int[] directionY = {0, 0, +1, -1};\r\n    \r\n    static final char FREE = 'F';\r\n    static final char TRAVELED = 'T';\r\n    \r\n    public void solve(char[][] board) {\r\n        if (board.length == 0) {\r\n            return;\r\n        }\r\n        \r\n        int row = board.length;\r\n        int col = board[0].length;\r\n        \r\n        for (int i = 0; i < row; i++) {\r\n            bfs(board, i, 0);\r\n            bfs(board, i, col - 1);\r\n        }\r\n        \r\n        for (int j = 1; j < col - 1; j++) {\r\n            bfs(board, 0, j);\r\n            bfs(board, row - 1, j);\r\n        }\r\n        \r\n        for (int i = 0; i < row; i++) {\r\n            for (int j = 0; j < col; j++) {\r\n                switch(board[i][j]) {\r\n                    case 'O': \r\n                        board[i][j] = 'X';\r\n                        break;\r\n                    case 'F':\r\n                        board[i][j] = 'O';\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void bfs(char[][] board, int i, int j) {\r\n        if (board[i][j] != 'O') {\r\n            return;\r\n        }\r\n        \r\n        Queue<Node> queue = new LinkedList<Node>();\r\n        queue.offer(new Node(i, j));\r\n        \r\n        while (!queue.isEmpty()) {\r\n            Node crt = queue.poll();\r\n            board[crt.x][crt.y] = FREE;\r\n            \r\n            for (Node node : expand(board, crt)) {\r\n                queue.offer(node);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private List<Node> expand(char[][] board, Node node) {\r\n        List<Node> expansion = new ArrayList<Node>();\r\n        \r\n        for (int i = 0; i < directionX.length; i++) {\r\n            int x = node.x + directionX[i];\r\n            int y = node.y + directionY[i];\r\n            \r\n            // check validity\r\n            if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == 'O') {\r\n                board[x][y] = TRAVELED;\r\n                expansion.add(new Node(x, y));\r\n            }\r\n        }\r\n        \r\n        return expansion;\r\n    }\r\n    \r\n    static class Node {\r\n        int x;\r\n        int y;\r\n        \r\n        Node(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nversion 2:\r\n\r\npublic class Solution {\r\n    private static Queue<Integer> queue = null;\r\n    private static int rows = 0;\r\n    private static int cols = 0;\r\n\r\n    public void surroundedRegions(char[][] board) {\r\n        if (board.length == 0 || board[0].length == 0) return;\r\n        queue = new LinkedList<Integer>();\r\n        rows = board.length;\r\n        cols = board[0].length;\r\n\r\n        for (int i = 0; i < rows; i++) { // **important**\r\n            enqueue(i, 0, board);\r\n            enqueue(i, cols - 1, board);\r\n        }\r\n\r\n        for (int j = 1; j < cols - 1; j++) { // **important**\r\n            enqueue(0, j, board);\r\n            enqueue(rows - 1, j, board);\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            int cur = queue.poll();\r\n            int x = cur / cols,\r\n                y = cur % cols;\r\n\r\n            if (board[x][y] == 'O') {\r\n                board[x][y] = 'D';\r\n            }\r\n\r\n            enqueue(x - 1, y, board);\r\n            enqueue(x + 1, y, board);\r\n            enqueue(x, y - 1, board);\r\n            enqueue(x, y + 1, board);\r\n        }\r\n\r\n        for (int i = 0; i < rows; i++) {\r\n            for (int j = 0; j < cols; j++) {\r\n                if (board[i][j] == 'D') board[i][j] = 'O';\r\n                else if (board[i][j] == 'O') board[i][j] = 'X';\r\n            }\r\n        }\r\n\r\n        queue = null;\r\n        board = null;\r\n        rows = 0;\r\n        cols = 0;\r\n    }\r\n\r\n    public void enqueue(int x, int y, char[][] board) {\r\n        if (x >= 0 && x < rows && y >= 0 && y < cols && board[x][y] == 'O'){  \r\n            queue.offer(x * cols + y);\r\n        }\r\n    }\r\n}\r\n\r\n// version: 高频题班\r\npublic class Solution {\r\n    int n, m;\r\n\r\n    public void surroundedRegions(char[][] board) {\r\n        // Write your code here\r\n        n = board.length;\r\n        if (n == 0) {\r\n            return;\r\n        }\r\n        m = board[0].length;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            bfs(board, i, 0);\r\n            bfs(board, i, m - 1);\r\n        }\r\n        for (int j = 0; j < m; j++) {\r\n            bfs(board, 0, j);\r\n            bfs(board, n - 1, j);\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                if (board[i][j] == 'W') {\r\n                    board[i][j] = 'O';\r\n                } else {\r\n                    board[i][j] = 'X';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void bfs(char[][] board, int sx, int sy) {\r\n        if (board[sx][sy] != 'O') {\r\n            return;\r\n        }\r\n        int[] dx = {0, 1, 0, -1};\r\n        int[] dy = {1, 0, -1, 0};\r\n\r\n        Queue<Integer> qx = new LinkedList<>();\r\n        Queue<Integer> qy = new LinkedList<>();\r\n        qx.offer(sx);\r\n        qy.offer(sy);\r\n        board[sx][sy] = 'W';                          // 'W' ->  Water\r\n        while (!qx.isEmpty()) {\r\n            int cx = qx.poll();\r\n            int cy = qy.poll();\r\n\r\n            for (int i = 0; i < 4; i++) {\r\n                int nx = cx + dx[i];\r\n                int ny = cy + dy[i];\r\n                if (0 <= nx && nx < n && 0 <= ny && ny < m\r\n                        && board[nx][ny] == 'O') {\r\n                    board[nx][ny] = 'W';              // 'W' ->  Water\r\n                    qx.offer(nx);\r\n                    qy.offer(ny);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /**\r\n     * @param board a 2D board containing 'X' and 'O'\r\n     * @return void\r\n     */\r\n    void surroundedRegions(vector<vector<char>>& board) {\r\n        int m=board.size();\r\n\t\tif (m==0)\r\n\t\t\treturn;\r\n\t\tint n=board[0].size();\r\n\t\tint i,j;\r\n\t\tfor(i=0;i<m;i++)\r\n\t\t{\r\n\t\t\tif (board[i][0]=='O')\r\n\t\t\t\tprocess(i,0,board);\r\n\t\t\tif (board[i][n-1]=='O')\r\n\t\t\t\tprocess(i,n-1,board);\r\n\t\t}\r\n\t\tfor(j=0;j<n;j++)\r\n\t\t{\r\n\t\t\tif (board[0][j]=='O')\r\n\t\t\t\tprocess(0,j,board);\r\n\t\t\tif (board[m-1][j]=='O')\r\n\t\t\t\tprocess(m-1,j,board);\r\n\t\t}\r\n\t\tfor(i=0;i<m;i++)\r\n\t\t\tfor(j=0;j<n;j++)\r\n\t\t\t{\r\n\t\t\t\tif(board[i][j]=='O')\r\n\t\t\t\t\tboard[i][j]='X';\r\n\t\t\t\telse if (board[i][j]=='E')\r\n\t\t\t\t\tboard[i][j]='O';\r\n\t\t\t}\r\n    }\r\n    void process(int i,int j,vector<vector<char> >& board)\r\n\t{\r\n\t\tint m=board.size();\r\n\t\tint n=board[0].size();\r\n\r\n\t\ttypedef pair<int,int> point;\r\n\t\tqueue<point> Q;\r\n\t\tQ.push(point(i,j));\r\n\t\tboard[i][j]='E';\r\n\t\twhile(!Q.empty())\r\n\t\t{\r\n\t\t\tpoint tmp=Q.front();\r\n\t\t\tQ.pop();\r\n\t\t\t\r\n\t\t\tint x=tmp.first,y=tmp.second;\r\n\r\n\t\t\t//extending\r\n\t\t\tif (x!=0&&board[x-1][y]=='O')\r\n\t\t\t{\r\n\t\t\t\tQ.push(point(x-1,y));\r\n\t\t\t\tboard[x-1][y]='E';   //extended;\r\n\t\t\t}\r\n\t\t\tif (x!=m-1&&board[x+1][y]=='O')\r\n\t\t\t{\r\n\t\t\t\tQ.push(point(x+1,y));\r\n\t\t\t\tboard[x+1][y]='E';   //extended;\r\n\t\t\t}\r\n\t\t\tif (y!=0&&board[x][y-1]=='O')\r\n\t\t\t{\r\n\t\t\t\tQ.push(point(x,y-1));\r\n\t\t\t\tboard[x][y-1]='E';   //extended;\r\n\t\t\t}\r\n\t\t\tif (y!=n-1&&board[x][y+1]=='O')\r\n\t\t\t{\r\n\t\t\t\tQ.push(point(x,y+1));\r\n\t\t\t\tboard[x][y+1]='E';   //extended;\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n};"},{"language":"python","code":"class Solution:\r\n    # @param {list[list[str]]} board a 2D board containing 'X' and 'O'\r\n    # @return nothing \r\n    def surroundedRegions(self, board):\r\n        def fill(x, y):\r\n            if x < 0 or x > m-1 or y < 0 or y > n-1 or board[x][y] != 'O':\r\n                return\r\n            queue.append((x,y))\r\n            board[x][y] = 'D'\r\n\r\n        def bfs(x, y):\r\n            if board[x][y]=='O':\r\n                queue.append((x,y))\r\n                fill(x,y)\r\n\r\n            while queue:\r\n                curr = queue.pop(0)\r\n                i, j = curr[0], curr[1]\r\n                fill(i+1, j)\r\n                fill(i-1, j)\r\n                fill(i, j+1)\r\n                fill(i, j-1)\r\n\r\n        if len(board) == 0:\r\n            return\r\n        m, n , queue = len(board), len(board[0]), []\r\n        for i in range(n):\r\n            bfs(0, i)\r\n            bfs(m-1, i)\r\n\r\n        for j in range(1, m-1):\r\n            bfs(j, 0)\r\n            bfs(j, n-1)\r\n\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if board[i][j] == 'D':\r\n                    board[i][j] = 'O'\r\n                elif board[i][j] == 'O':\r\n                    board[i][j] = 'X'\r\n\r\n\r\n\r\n// version: 高频题班\r\n\r\nclass Solution:\r\n    # @param {list[list[str]]} board a 2D board containing 'X' and 'O'\r\n    # @return nothing \r\n    def surroundedRegions(self, board):\r\n        # Write your code here\r\n        if not any(board):\r\n            return\r\n\r\n        n, m = len(board), len(board[0])\r\n        q = [ij for k in range(max(n,m)) for ij in ((0, k), (n-1, k), (k, 0), (k, m-1))]\r\n        while q:\r\n            i, j = q.pop()\r\n            if 0 <= i < n and 0 <= j < m and board[i][j] == 'O':\r\n                board[i][j] = 'W'\r\n                q += (i, j-1), (i, j+1), (i-1, j), (i+1, j)\r\n\r\n        board[:] = [['XO'[c == 'W'] for c in row] for row in board]\r\n\r\n\r\n\r\n\r\n\r\n"}]},{"id":307,"unique_name":"add-and-search-word","title":"单词的添加与查找","description":"设计一个包含下面两个操作的数据结构：`addWord(word)`, `search(word)`\r\n\r\n`addWord(word)`会在数据结构中添加一个单词。而`search(word)`则支持普通的单词查询或是只包含`.`和`a-z`的简易正则表达式的查询。\r\n\r\n一个 `.` 可以代表一个任何的字母。","solutions":[{"language":"java","code":"// Version1 use Array\r\nclass TrieNode {\r\n\r\n    public TrieNode[] children;\r\n    public boolean hasWord;\r\n    \r\n    public TrieNode() {\r\n        children = new TrieNode[26];\r\n        for (int i = 0; i < 26; ++i)\r\n            children[i] = null;\r\n        hasWord = false;\r\n    }\r\n}\r\n\r\n\r\npublic class WordDictionary {\r\n    private TrieNode root;\r\n \r\n    public WordDictionary(){\r\n        root = new TrieNode();\r\n    }\r\n \r\n    // Adds a word into the data structure.\r\n    public void addWord(String word) {\r\n        // Write your code here\r\n        TrieNode now = root;\r\n        for(int i = 0; i < word.length(); i++) {\r\n            Character c = word.charAt(i);\r\n            if (now.children[c - 'a'] == null) {\r\n                now.children[c - 'a'] = new TrieNode();\r\n            }\r\n            now = now.children[c - 'a'];\r\n        }\r\n        now.hasWord = true;\r\n    }\r\n    \r\n    boolean find(String word, int index, TrieNode now) {\r\n        if(index == word.length()) {\r\n            return now.hasWord;\r\n        }\r\n        \r\n        Character c = word.charAt(index);\r\n        if (c == '.') {\r\n            for(int i = 0; i < 26; ++i) \r\n            if (now.children[i] != null) {\r\n                if (find(word, index+1, now.children[i]))\r\n                    return true;\r\n            }\r\n            return false;\r\n        } else if (now.children[c - 'a'] != null) {\r\n            return find(word, index+1, now.children[c - 'a']);  \r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    // Returns if the word is in the data structure. A word could\r\n    // contain the dot character '.' to represent any one letter.\r\n    public boolean search(String word) {\r\n        // Write your code here\r\n        return find(word, 0, root);\r\n    }\r\n}\r\n\r\n// Your WordDictionary object will be instantiated and called as such:\r\n// WordDictionary wordDictionary = new WordDictionary();\r\n// wordDictionary.addWord(\"word\");\r\n// wordDictionary.search(\"pattern\");\r\n\r\n\r\n\r\n// Version 2 use HashMap and dfs\r\nclass TrieNode {\r\n    // Initialize your data structure here.\r\n    public HashMap<Character, TrieNode> children;\r\n    public boolean hasWord;\r\n    \r\n    // Initialize your data structure here.\r\n    public TrieNode() {\r\n        children = new HashMap<Character, TrieNode>();\r\n        hasWord = false;\r\n    }\r\n}\r\n\r\n\r\npublic class WordDictionary {\r\n    private TrieNode root;\r\n \r\n    public WordDictionary(){\r\n        root = new TrieNode();\r\n    }\r\n \r\n    // Adds a word into the data structure.\r\n    public void addWord(String word) {\r\n        // Write your code here\r\n        TrieNode now = root;\r\n        for(int i = 0; i < word.length(); i++) {\r\n            Character c = word.charAt(i);\r\n            if (!now.children.containsKey(c)) {\r\n                now.children.put(c, new TrieNode());\r\n            }\r\n            now = now.children.get(c);\r\n        }\r\n        now.hasWord = true;\r\n    }\r\n    \r\n    boolean find(String word, int index, TrieNode now) {\r\n        if(index == word.length()){\r\n            if(now.children.size()==0) \r\n                return true; \r\n            else\r\n                return false;\r\n        }\r\n        \r\n        Character c = word.charAt(index);\r\n        if (now.children.containsKey(c)) {\r\n            if(index == word.length()-1 && now.children.get(c).hasWord){\r\n                return true;\r\n            }\r\n            return find(word, index+1, now.children.get(c)) ;  \r\n        }else if(c == '.'){\r\n            boolean result = false;\r\n            for(Map.Entry<Character, TrieNode> child: now.children.entrySet()){\r\n                if(index == word.length()-1 && child.getValue().hasWord){\r\n                    return true;\r\n                } \r\n \r\n                //if any path is true, set result to be true; \r\n                if(find(word, index+1, child.getValue()) ){\r\n                    result = true;\r\n                }\r\n            }\r\n \r\n            return result;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    // Returns if the word is in the data structure. A word could\r\n    // contain the dot character '.' to represent any one letter.\r\n    public boolean search(String word) {\r\n        // Write your code here\r\n        return find(word, 0, root);\r\n    }\r\n}\r\n\r\n// Your WordDictionary object will be instantiated and called as such:\r\n// WordDictionary wordDictionary = new WordDictionary();\r\n// wordDictionary.addWord(\"word\");\r\n// wordDictionary.search(\"pattern\");\r\n\r\n//version 3: use HashMap and bfs\r\nclass TrieNode{\r\n    public Map<Character,TrieNode> children;\r\n    public boolean hasWord;\r\n    public TrieNode(){\r\n        children=new HashMap<>();\r\n        hasWord=false;\r\n    }\r\n}\r\n\r\npublic class WordDictionary {\r\n    TrieNode root;\r\n    public WordDictionary(){\r\n        root=new TrieNode();\r\n    }\r\n\r\n    // Adds a word into the data structure.\r\n    public void addWord(String word) {\r\n        // Write your code here\r\n        TrieNode cur=root;\r\n        for(int i=0;i<word.length();++i){\r\n            char c=word.charAt(i);\r\n            TrieNode nextNode=cur.children.get(c);\r\n            if(nextNode==null){\r\n                nextNode=new TrieNode();\r\n                cur.children.put(c,nextNode);\r\n            }\r\n            cur=nextNode;\r\n        }\r\n        cur.hasWord=true;\r\n    }\r\n\r\n    // Returns if the word is in the data structure. A word could\r\n    // contain the dot character '.' to represent any one letter.\r\n    public boolean search(String word) {\r\n        // Write your code here\r\n        Queue<TrieNode> nexts=new LinkedList<>();\r\n        nexts.add(root);\r\n        int index=0;\r\n        while(!nexts.isEmpty()){\r\n            int size=nexts.size();\r\n            char c=word.charAt(index);\r\n            boolean flag=false;\r\n            for(int i=0;i<size;++i){\r\n                TrieNode cur=nexts.poll();\r\n                if(c=='.'){\r\n                    for(TrieNode tempNode:cur.children.values()){\r\n                        nexts.add(tempNode);\r\n                        flag|=tempNode.hasWord;\r\n                    }\r\n                } else if(cur.children.containsKey(c)){\r\n                    TrieNode nextNode=cur.children.get(c);\r\n                    flag|=nextNode.hasWord;\r\n                    nexts.add(nextNode);\r\n                }\r\n            }\r\n            index++;\r\n            if(index>=word.length()) return flag;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// Your WordDictionary object will be instantiated and called as such:\r\n// WordDictionary wordDictionary = new WordDictionary();\r\n// wordDictionary.addWord(\"word\");\r\n// wordDictionary.search(\"pattern\");"},{"language":"cpp","code":"class TrieNode\r\n{\r\npublic:\r\n    bool isEnd;\r\n    TrieNode *children[26];\r\n    TrieNode() : isEnd(false)\r\n    {\r\n        for (int i = 0; i < 26; i++)\r\n        {\r\n            children[i] = NULL;\r\n        }\r\n    }\r\n};\r\n\r\nclass WordDictionary {\r\npublic:\r\n    WordDictionary()\r\n    {\r\n        root = new TrieNode();\r\n    }\r\n    \r\n    // Adds a word into the data structure.\r\n    void addWord(string word) {\r\n        // Write your code here\r\n        TrieNode *cur = root;\r\n        for (int i = 0; i < word.length(); i++)\r\n        {\r\n            int index = word[i] - 'a';\r\n            if (cur->children[index] == NULL)\r\n            {\r\n                cur->children[index] = new TrieNode();\r\n            }\r\n\r\n            cur = cur->children[index];\r\n        }\r\n\r\n        cur->isEnd = true; \r\n    }\r\n\r\n    // Returns if the word is in the data structure. A word could\r\n    // contain the dot character '.' to represent any one letter.\r\n    bool search(string word) {\r\n        // Write your code here\r\n        int n = word.length();\r\n        return search(word, n, 0, root);\r\n    }\r\n    \r\n    bool search(string &word, int n, int pos, TrieNode *cur) {\r\n        if (cur == NULL)\r\n        {\r\n            return false;\r\n        }\r\n        if (pos == n)\r\n        {\r\n            return cur->isEnd;\r\n        }\r\n\r\n        if (word[pos] == '.')\r\n        {\r\n            for (int i = 0; i < 26; i++)\r\n            {\r\n                if (cur->children[i])\r\n                {\r\n                    if (search(word, n, pos+1, cur->children[i]))\r\n                    {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            int index = word[pos] - 'a';\r\n            if (cur->children[index])\r\n            {\r\n                return search(word, n, pos+1, cur->children[index]);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\nprivate:\r\n    TrieNode *root;\r\n};\r\n\r\n// Your WordDictionary object will be instantiated and called as such:\r\n// WordDictionary wordDictionary;\r\n// wordDictionary.addWord(\"word\");\r\n// wordDictionary.search(\"pattern\");"},{"language":"python","code":"class TrieNode:  \r\n    def __init__(self):  \r\n        self.leaf = False  \r\n        self.children = [None] * 26  \r\n  \r\nclass Trie:  \r\n    def __init__(self):  \r\n        self.root = TrieNode()  \r\n        self.size = 0  \r\n  \r\n    def insert(self, s):  \r\n        if len(s) == 0:  \r\n            return  \r\n        p = self.root  \r\n        i = 0  \r\n        while i < len(s):  \r\n            if p.children[ord(s[i])-ord('a')] is None:  \r\n                new_node = TrieNode()  \r\n                p.children[ord(s[i])-ord('a')] = new_node  \r\n            p = p.children[ord(s[i])-ord('a')]  \r\n            i += 1  \r\n        p.leaf = True  \r\n        self.size += 1  \r\n  \r\n    def search(self, s):  \r\n        if len(s) == 0:  \r\n            return False  \r\n         \r\n        return self.searchRe(s, self.root, 0)\r\n        \r\n    def searchRe(self, s, p, i):\r\n        if len(s) == i:\r\n            if p.leaf:\r\n                return True\r\n            return False\r\n            \r\n        result = False\r\n        if s[i] == '.':\r\n            for j in range(0, 26):\r\n                if p.children[j] != None:\r\n                    if self.searchRe(s, p.children[j], i+1):\r\n                        result = True\r\n        else:\r\n            if p.children[ord(s[i]) - ord('a')] != None:\r\n                if self.searchRe(s, p.children[ord(s[i]) - ord('a')], i+1):\r\n                    result = True\r\n        return result\r\n\r\nclass WordDictionary:\r\n    # initialize your data structure here.\r\n    def __init__(self):\r\n        # Write your code here\r\n        self.trie = Trie()\r\n\r\n    # @param {string} word\r\n    # @return {void}\r\n    # Adds a word into the data structure.\r\n    def addWord(self, word):\r\n        # Write your code here\r\n        self.trie.insert(word)\r\n\r\n    # @param {string} word\r\n    # @return {boolean}\r\n    # Returns if the word is in the data structure. A word could\r\n    # contain the dot character '.' to represent any one letter.\r\n    def search(self, word):\r\n        # Write your code here\r\n        return self.trie.search(word)\r\n\r\n# Your WordDictionary object will be instantiated and called as such:\r\n# wordDictionary = WordDictionary()\r\n# wordDictionary.addWord(\"word\")\r\n# wordDictionary.search(\"pattern\")\r\n"}]},{"id":487,"unique_name":"kth-largest-in-n-arrays","title":"N数组第K大元素","description":"在N个数组中找到第K大元素","solutions":[{"language":"java","code":"import java.util.Comparator;  \r\nimport java.util.PriorityQueue;  \r\nimport java.util.Queue; \r\n\r\nclass Node {\r\n    public int value, from_id, index;\r\n    public Node(int _v, int _id, int _i) {\r\n        this.value = _v;\r\n        this.from_id = _id;\r\n        this.index = _i;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param arrays a list of array\r\n     * @param k an integer\r\n     * @return an integer, K-th largest element in N arrays\r\n     */\r\n    public int KthInArrays(int[][] arrays, int k) {\r\n        // Write your code here\r\n        Queue<Node> queue =  new PriorityQueue<Node>(k, new Comparator<Node>() {  \r\n                public int compare(Node o1, Node o2) {  \r\n                    if (o1.value > o2.value)\r\n                        return -1;\r\n                    else if (o1.value < o2.value)\r\n                        return 1;\r\n                    else\r\n                        return 0;\r\n                }\r\n            }); \r\n\r\n        int n = arrays.length;\r\n        int i;\r\n        for (i = 0; i < n; ++i) {\r\n            Arrays.sort(arrays[i]);\r\n            \r\n            if (arrays[i].length > 0) {\r\n                int from_id = i;\r\n                int index = arrays[i].length - 1;\r\n                int value = arrays[i][index];\r\n                queue.add(new Node(value, from_id, index));\r\n            }\r\n        }\r\n\r\n        for (i  = 0; i < k; ++i) {\r\n            Node temp = queue.poll();\r\n            int from_id = temp.from_id;\r\n            int index = temp.index;\r\n            int value = temp.value;\r\n            \r\n            if (i == k - 1)\r\n                return value;\r\n            \r\n            if (index > 0) {\r\n                index --;\r\n                value = arrays[from_id][index];\r\n                queue.add(new Node(value, from_id, index));\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n}\r\n"},{"language":"cpp","code":"struct Node {\r\n    int value;\r\n    int from_id;\r\n    int index;\r\n    Node(int _v, int _id, int _i):\r\n        value(_v), from_id(_id), index(_i) {}\r\n\r\n    bool operator < (const Node & obj) const {\r\n        return value < obj.value;\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param arrays a list of array\r\n     * @param k an integer\r\n     * @return an integer, K-th largest element in N arrays\r\n     */\r\n    int KthInArrays(vector<vector<int>>& arrays, int k) {\r\n        // Write your code here\r\n        priority_queue<Node> queue;\r\n\r\n        int n = arrays.size();\r\n        for (int i = 0; i < n; ++i) {\r\n            sort(arrays[i].begin(), arrays[i].end());\r\n\r\n            if (arrays[i].size() > 0) {\r\n                int from_id = i;\r\n                int index = arrays[i].size() - 1;\r\n                int value = arrays[i][index];\r\n                queue.push(Node(value, from_id, index));\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < k; ++i) {\r\n            Node temp = queue.top();\r\n            queue.pop();\r\n            int value = temp.value;\r\n            int from_id = temp.from_id;\r\n            int index = temp.index;\r\n            \r\n            if (i == k - 1)\r\n                return value;\r\n\r\n            if (index > 0) {\r\n                index --;\r\n                value = arrays[from_id][index];\r\n                queue.push(Node(value, from_id, index));\r\n            }\r\n        }\r\n    }\r\n};\r\n"},{"language":"python","code":"class Node:\r\n    \r\n    def __init__(self, _v, _id, _i):\r\n        self.value = _v\r\n        self.from_id = _id\r\n        self.index = _i\r\n\r\n    def __cmp__(self, obj):\r\n        return cmp(obj.value, self.value)\r\n\r\nimport heapq\r\n\r\nclass Solution:\r\n    # @param {int[][]} arrays a list of array\r\n    # @param {int} k an integer\r\n    # @return {int} an integer, K-th largest element in N arrays\r\n    def KthInArrays(self, arrays, k):\r\n        # Write your code here\r\n        queue = []\r\n        heapq.heapify(queue) \r\n        n = len(arrays)\r\n        for i, array in enumerate(arrays):\r\n            from_id = i\r\n            index = len(array) - 1\r\n            array.sort()\r\n            if index >= 0:\r\n                value = arrays[i][index]\r\n                heapq.heappush(queue, Node(value, from_id, index))\r\n\r\n        for i in xrange(k):\r\n            node = heapq.heappop(queue)\r\n            value = node.value\r\n            from_id = node.from_id\r\n            index = node.index\r\n\r\n            if i == k-1:\r\n                return value\r\n\r\n            if index:\r\n                index -= 1\r\n                value = arrays[from_id][index]\r\n                heapq.heappush(queue, Node(value, from_id, index))\r\n"}]},{"id":578,"unique_name":"zombie-in-matrix","title":"僵尸矩阵","description":"给一个二维网格，每一个格子都有一个值，`2` 代表墙，`1` 代表僵尸，`0` 代表人类(数字 0, 1, 2)。僵尸每天可以将上下左右最接近的人类感染成僵尸，但不能穿墙。将所有人类感染为僵尸需要多久，如果不能感染所有人则返回 `-1`。","solutions":[{"language":"java","code":"class Coordinate {\r\n    int x, y;\r\n    public Coordinate(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    public int PEOPLE = 0;\r\n    public int ZOMBIE = 1;\r\n    public int WALL = 2;\r\n    \r\n    public int[] deltaX = {1, 0, 0, -1};\r\n    public int[] deltaY = {0, 1, -1, 0};\r\n     \r\n    /**\r\n     * @param grid a 2D integer grid\r\n     * @return an integer\r\n     */\r\n    public int zombie(int[][] grid) {\r\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        int n = grid.length;\r\n        int m = grid[0].length;\r\n        \r\n        // initialize the queue & count people\r\n        int people = 0;\r\n        Queue<Coordinate> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < m; j++) {\r\n                if (grid[i][j] == PEOPLE) {\r\n                    people++;\r\n                } else if (grid[i][j] == ZOMBIE) {\r\n                    queue.offer(new Coordinate(i, j));\r\n                }\r\n            }\r\n        }\r\n        \r\n        // corner case\r\n        if (people == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        // bfs\r\n        int days = 0;\r\n        while (!queue.isEmpty()) {\r\n            days++;\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                Coordinate zb = queue.poll();\r\n                for (int direction = 0; direction < 4; direction++) {\r\n                    Coordinate adj = new Coordinate(\r\n                        zb.x + deltaX[direction],\r\n                        zb.y + deltaY[direction]\r\n                    );\r\n                    \r\n                    if (!isPeople(adj, grid)) {\r\n                        continue;\r\n                    }\r\n                    \r\n                    grid[adj.x][adj.y] = ZOMBIE;\r\n                    people--;\r\n                    if (people == 0) {\r\n                        return days;\r\n                    }\r\n                    queue.offer(adj);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n    \r\n    private boolean isPeople(Coordinate coor, int[][] grid) {\r\n        int n = grid.length;\r\n        int m = grid[0].length;\r\n        \r\n        if (coor.x < 0 || coor.x >= n) {\r\n            return false;\r\n        }\r\n        if (coor.y < 0 || coor.y >= m) {\r\n            return false;\r\n        }\r\n        return (grid[coor.x][coor.y] == PEOPLE);\r\n    }\r\n}"},{"language":"cpp","code":"// version 1\r\nclass Position {\r\npublic:\r\n    int x, y;\r\n    Position(int _x, int _y):x(_x), y(_y) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param grid  a 2D integer grid\r\n     * @return an integer\r\n     */\r\n    int zombie(vector<vector<int>>& grid) {\r\n        // Write your code here\r\n        queue<Position> q;\r\n        int n = grid.size();\r\n        if (n == 0)\r\n            return 0;\r\n        int m = grid[0].size();\r\n        if (m == 0)\r\n            return 0;\r\n\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = 0; j < m; ++j)\r\n                if (grid[i][j] == 1)\r\n                    q.push(Position(i, j));\r\n\r\n        int d[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n        int days = 0;\r\n        while (!q.empty()) {\r\n            days ++;\r\n            int size = q.size();\r\n            for (int i = 0; i < size; i++) {\r\n                Position head = q.front();\r\n                q.pop();\r\n                for (int k = 0; k < 4; ++k) {\r\n                    int x = head.x + d[k][0];\r\n                    int y = head.y + d[k][1];\r\n                    if (x >= 0 && x < n && y >=0 && y < m && grid[x][y] == 0) {\r\n                        grid[x][y] = 1;\r\n                        q.push(Position(x, y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; ++i)\r\n            for (int j = 0; j < m; ++j)\r\n                if (grid[i][j] == 0)\r\n                    return -1;\r\n\r\n        return days - 1;\r\n    }\r\n};\r\n\r\n// version 2\r\nclass Solution {\r\npublic:\r\n    /**\r\n     * @param grid  a 2D integer grid\r\n     * @return an integer\r\n     */\r\n    \r\n    struct tnode {\r\n        int x, y;\r\n        int step;\r\n    };\r\n    int dx[4] = {-1, 1, 0, 0};\r\n    int dy[4] = {0, 0, -1, 1};\r\n    \r\n    int zombie(vector<vector<int> >& grid) {\r\n        // Write your code here\r\n        \r\n        int sum_zombie = 0, sum_wall = 0;\r\n        int n = grid.size(), m = grid[0].size();\r\n        queue<tnode> qzombie;\r\n        while(!qzombie.empty()) {\r\n            qzombie.pop();\r\n        }\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < m; ++j) {\r\n                if (grid[i][j] == 1) {\r\n                    tnode p = {i, j, 0};\r\n                    qzombie.push(p);\r\n                    sum_zombie++;\r\n                }\r\n                if(grid[i][j] == 2) {\r\n                    sum_wall++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        int step;\r\n        while(!qzombie.empty()) {\r\n            tnode p = qzombie.front();\r\n            qzombie.pop();\r\n            \r\n            for (int i = 0; i < 4; ++i) {\r\n                int x = p.x + dx[i];\r\n                if (x < 0 || x >= n) {\r\n                    continue;\r\n                }\r\n                \r\n                int y = p.y + dy[i]; \r\n                if (y < 0 || y >= m) {\r\n                    continue;\r\n                }\r\n                \r\n                if (grid[x][y] == 0) {\r\n                    grid[x][y] = 1;\r\n                    tnode new_zombie = {x, y, p.step+1};\r\n                    sum_zombie++;\r\n                    qzombie.push(new_zombie);\r\n                }\r\n            }\r\n            \r\n            if(qzombie.empty()) {\r\n                step = p.step;\r\n            }\r\n        }\r\n        \r\n        if(sum_wall + sum_zombie != n *m) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return step;\r\n        }\r\n    }\r\n};"},{"language":"python","code":"// version 1\r\nclass Solution:\r\n    # @param {int[][]} grid  a 2D integer grid\r\n    # @return {int} an integer\r\n    def zombie(self, grid):\r\n        # Write your code here\r\n        n = len(grid)\r\n        if n == 0:\r\n            return 0\r\n\r\n        m = len(grid[0])\r\n        if m == 0:\r\n            return 0\r\n\r\n        q = []\r\n        for i in xrange(n):\r\n            for j in xrange(m):\r\n                if grid[i][j] == 1:\r\n                    q.append((i, j))\r\n\r\n        d = [[0, -1], [0, 1], [-1, 0], [1, 0]]\r\n        days = 0\r\n        while q:\r\n            days += 1\r\n            new_q = []\r\n            for node in q:\r\n                for k in xrange(4):\r\n                    x = node[0] + d[k][0]\r\n                    y = node[1] + d[k][1]\r\n                    if x >= 0 and x < n and y >= 0 and y < m and grid[x][y] == 0:\r\n                        grid[x][y] = 1\r\n                        new_q.append((x, y))\r\n            q = new_q\r\n\r\n        for i in xrange(n):\r\n            for j in xrange(m):\r\n                if grid[i][j] == 0:\r\n                    return -1\r\n\r\n        return days - 1\r\n        \r\n\r\n// verison 2\r\nclass Solution:\r\n    # @param {int[][]} grid  a 2D integer grid\r\n    # @return {int} an integer\r\n\r\n    def zombie(self, grid):\r\n        # Write your code here\r\n        sum_zombie = 0\r\n        sum_wall = 0\r\n        n = len(grid)\r\n        m = len(grid[0])\r\n        qzombie = []\r\n        dx = [0,0,-1,1]\r\n        dy = [1,-1,0,0]\r\n\r\n        for i in xrange(n):\r\n            for j in xrange(m):\r\n                if grid[i][j] == 1:\r\n                    qzombie.append([i,j,0])\r\n                    sum_zombie += 1\r\n                elif grid[i][j] == 2:\r\n                    sum_wall += 1\r\n\r\n        step = 0\r\n        while qzombie:\r\n            p = qzombie.pop(0)\r\n            for i in xrange(4):\r\n                x = p[0] + dx[i]\r\n                y = p[1] + dy[i]\r\n                if x < 0 or x >= n or y < 0 or y >= m:\r\n                    continue\r\n                if grid[x][y] == 0:\r\n                    grid[x][y] = 1\r\n                    qzombie.append([x,y,p[2]+1])\r\n                    sum_zombie += 1\r\n            if not qzombie:\r\n                step = p[2]\r\n        if sum_zombie + sum_wall != n * m:\r\n            return -1\r\n        else:\r\n            return step"}]},{"id":760,"unique_name":"portal","title":"传送门","description":"Chell是Valve Corporation开发的Portal视频游戏系列中的主角。\n一天，她掉进了一个迷宫。迷宫可以看作是一个大小为`n x m`二维字符数组。它有`4`种房间。`'S'`代表Chell从哪开始（只有一个起点）。`'E'`代表迷宫的出口（当chell抵达时，她将离开迷宫，**该题目可能会有多个出口**）。`'*'`代表这个房间Chell可以经过。`'#'`代表一堵墙，Chell不能经过墙。\n她可以每次上下左右移动到达一个房间，花费一分钟时间，但是不能到达墙。\n现在，你能告诉我她最少需要多少时间离开这个迷宫吗？\n如果她不能离开，返回`-1`\n","solutions":[{"language":"java","code":"class Solution {\n    class  node {\n        int x, y, step;\n    }\n    public int Portal(char[][] Maze) {\n        //\n        int dx[] = {-1,1,0,0};\n        int dy[] = {0,0,-1,1};\n        int n = Maze.length;\n        int m = Maze[0].length;\n        int sx = 0, sy = 0;\n        int step[][] = new int[201][201];\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                step[i][j] = 99999;\n                step[i][j] = 99999;\n                if(Maze[i][j] == 'S') {\n                    sx = i;\n                    sy = j;\n                    step[sx][sy] = 0;\n                }\n            }\n        }\n        node Start = new node();\n        Start.x = sx;Start.y = sy;Start.step = 0;\n        Queue<node> queue = new LinkedList<node>();\n        queue.offer(Start);\n        while(!queue.isEmpty()) {\n            node head = queue.poll();\n            for (int i = 0; i < 4; i++) {\n                node New = new node();\n                New.x = head.x + dx[i];\n                New.y = head.y + dy[i];\n                New.step = head.step + 1;\n                if(New.x < 0 || New.x >= n || New.y < 0 || New.y >= m || Maze[New.x][New.y] == '#') {\n                    continue;\n                }\n                if (step[New.x][New.y] <= New.step) {\n                    continue;\n                }\n                step[New.x][New.y] = New.step;\n                if (Maze[New.x][New.y] == 'E')\n                    return New.step;\n                queue.offer(New);\n            }\n        }\n        return -1;\n    }\n};"},{"language":"cpp","code":"class Solution {\npublic:\n    struct node {\n        int x, y, step;\n    };\n    int Portal(vector<vector<char>>& Maze) {\n        int dx[5]={-1,1,0,0};\n        int dy[5]={0,0,-1,1};\n        int n = Maze.size();\n        int m = Maze[0].size();\n        int sx, sy, ex, ey;\n        int step[201][201];\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                step[i][j] = INT_MAX;\n                step[i][j] = INT_MAX;\n                if(Maze[i][j] == 'S') {\n                    sx = i;\n                    sy = j;\n                    step[sx][sy] = 0;\n                }\n            }\n        }\n        node Start;\n        Start.x = sx;Start.y = sy;Start.step = 0;\n        queue<node>nodequeue;\n        nodequeue.push(Start);\n        while(!nodequeue.empty()) {\n            node head = nodequeue.front();\n            nodequeue.pop();\n            node New = head;\n            for (int i = 0; i < 4; i++) {\n                New.x = head.x + dx[i];\n                New.y = head.y + dy[i];\n                New.step = head.step + 1;\n                if(New.x < 0 || New.x >= n || New.y < 0 || New.y >= m || Maze[New.x][New.y] == '#') {\n                    continue;\n                }\n                if (step[New.x][New.y] <= New.step) {\n                    continue;\n                }\n                step[New.x][New.y] = New.step;\n                if (Maze[New.x][New.y] == 'E')\n                    return New.step;\n                nodequeue.push(New);\n            }\n        }\n        return -1;\n    }\n};"},{"language":"python","code":"class Solution:\n    class Point:\n    \tdef __init__(self, a=0, b=0):\n        \tself.x = a\n        \tself.y = b\n    def Portal(self, grid):\n        n = len(grid)\n        m = len(grid[0])\n        import sys\n        record = [[sys.maxint for _ in xrange(m)] for i in xrange(n)]\n        for i in range(0,n):\n            for j in range(0,m):\n                if (grid[i][j] == 'S'):\n                    source = Point(i,j)\n        record[source.x][source.y] = 0\n\n        import Queue\n        q = Queue.Queue(maxsize = n * m)\n        q.put(source)\n\n        d = [(0,1),(0,-1),(-1,0),(1,0)]\n        while not q.empty():\n            head = q.get()\n            for dx, dy in d:\n                x, y = head.x + dx, head.y + dy\n                if x >=0 and x < n and y >= 0 and y < m and  grid[x][y] != '#' and \\\n                    record[head.x][head.y] + 1 < record[x][y]:\n                    record[x][y] = record[head.x][head.y] + 1\n                    if(grid[x][y] == 'E'):\n                        return record[x][y]\n                    q.put(Point(x, y))\n\n        return -1"}]},{"id":208,"unique_name":"fast-power","title":"快速幂","description":"<p>计算<b style=\"color: rgb(113, 113, 113); font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;\"><font color=\"#e76363\"><i>a<span style=\"position: relative; font-size: 12px; line-height: 0; vertical-align: baseline; top: -0.5em;\">n</span>&nbsp;% b</i></font></b><span style=\"line-height: 1.42857143;\">，</span><span style=\"line-height: 1.42857143;\">其中a，b和n都是32位的整数。</span></p>","solutions":[{"language":"java","code":"class Solution {\r\n    /*\r\n     * @param a, b, n: 32bit integers\r\n     * @return: An integer\r\n     */\r\n    public int fastPower(int a, int b, int n) {\r\n        if (n == 1) {\r\n            return a % b;\r\n        }\r\n        if (n == 0) {\r\n            return 1 % b;\r\n        }\r\n        \r\n        long product = fastPower(a, b, n / 2);\r\n        product = (product * product) % b;\r\n        if (n % 2 == 1) {\r\n            product = (product * a) % b;\r\n        }\r\n        return (int) product;\r\n    }\r\n};\r\n"},{"language":"cpp","code":"class Solution {\r\npublic:\r\n    /*\r\n     * @param a, b, n: 32bit integers\r\n     * @return: An integer\r\n     */\r\n    int fastPower(int a, int b, int n) {\r\n        if (n == 0) {\r\n            return 1 % b;\r\n        }\r\n        if (n == 1) {\r\n            return a % b;\r\n        }\r\n        long long temp = fastPower(a, b, n / 2);\r\n        if (n % 2 == 0) {\r\n            return (temp * temp) % b;\r\n        } else {\r\n            return ((temp * temp) % b * a) % b;\r\n        }\r\n    }\r\n};\r\n"},{"language":"python","code":"class Solution:\r\n    \"\"\"\r\n    @param a, b, n: 32bit integers\r\n    @return: An integer\r\n    \"\"\"\r\n    def fastPower(self, a, b, n):\r\n        # write your code here\r\n        ans = 1\r\n        while n > 0:\r\n            if n % 2==1:\r\n                ans = ans * a % b\r\n            a = a * a % b\r\n            n = n / 2\r\n        return ans % b\r\n"}]}]